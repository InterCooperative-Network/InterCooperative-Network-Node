===== START OF crates/icn_api/Cargo.toml =====
[package]
name = "icn_api"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_core = { path = "../icn_core" }
icn_blockchain = { path = "../icn_blockchain" }
icn_consensus = { path = "../icn_consensus" }
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
log = "0.4"
thiserror = "1.0"

[dev-dependencies]
tokio-test = "0.4"
===== END OF crates/icn_api/Cargo.toml =====

===== START OF crates/icn_api/src/lib.rs =====
use icn_blockchain::{Blockchain, Transaction};
use icn_governance::DemocraticSystem;
use icn_governance::democracy::ProposalStatus as DemocracyProposalStatus;
use icn_core::Error;

use serde::{Deserialize, Serialize};
use tokio::sync::RwLock;
use std::sync::Arc;
use chrono::{DateTime, Utc, Duration};

#[derive(Serialize, Deserialize)]
pub struct ApiResponse<T> {
    pub success: bool,
    pub data: Option<T>,
    pub error: Option<String>,
}

pub struct ApiLayer {
    blockchain: Arc<RwLock<Blockchain>>,
    governance: Arc<RwLock<DemocraticSystem>>,
}

impl ApiLayer {
    pub fn new(
        blockchain: Arc<RwLock<Blockchain>>,
        governance: Arc<RwLock<DemocraticSystem>>,
    ) -> Self {
        Self {
            blockchain,
            governance,
        }
    }

    pub async fn get_blockchain_info(&self) -> ApiResponse<BlockchainInfo> {
        let blockchain = self.blockchain.read().await;
        let info = BlockchainInfo {
            block_count: blockchain.chain.len(),
            last_block_hash: blockchain.chain.last().map(|b| b.hash.clone()),
        };
        ApiResponse {
            success: true,
            data: Some(info),
            error: None,
        }
    }

    pub async fn submit_transaction(&self, transaction: Transaction) -> ApiResponse<String> {
        let mut blockchain = self.blockchain.write().await;
        match blockchain.add_transaction(transaction) {
            Ok(()) => ApiResponse {
                success: true,
                data: Some("Transaction submitted successfully".to_string()),
                error: None,
            },
            Err(e) => ApiResponse {
                success: false,
                data: None,
                error: Some(e.to_string()),
            },
        }
    }

    pub async fn get_balance(&self, address: &str) -> ApiResponse<f64> {
        let blockchain = self.blockchain.read().await;
        let balance = blockchain.get_balance(address);
        ApiResponse {
            success: true,
            data: Some(balance),
            error: None,
        }
    }

    pub async fn create_proposal(&self, proposal: Proposal) -> ApiResponse<String> {
        let mut governance = self.governance.write().await;
        match governance.create_proposal(
            proposal.title,
            proposal.description,
            proposal.proposer,
            proposal.voting_period,
            proposal.proposal_type,
            proposal.category,
            proposal.required_quorum,
            proposal.execution_timestamp,
        ) {
            Ok(id) => ApiResponse {
                success: true,
                data: Some(id),
                error: None,
            },
            Err(e) => ApiResponse {
                success: false,
                data: None,
                error: Some(e.to_string()),
            },
        }
    }

    pub async fn vote_on_proposal(&self, vote: Vote) -> ApiResponse<String> {
        let mut governance = self.governance.write().await;
        match governance.vote(vote.voter, vote.proposal_id, vote.in_favor, vote.weight) {
            Ok(()) => ApiResponse {
                success: true,
                data: Some("Vote recorded successfully".to_string()),
                error: None,
            },
            Err(e) => ApiResponse {
                success: false,
                data: None,
                error: Some(e.to_string()),
            },
        }
    }

    pub async fn get_proposal_status(&self, proposal_id: &str) -> ApiResponse<ProposalStatus> {
        let governance = self.governance.read().await;
        match governance.get_proposal(proposal_id) {
            Some(proposal) => ApiResponse {
                success: true,
                data: Some(ProposalStatus::from(proposal.status.clone())),
                error: None,
            },
            None => ApiResponse {
                success: false,
                data: None,
                error: Some("Proposal not found".to_string()),
            },
        }
    }
}

#[derive(Serialize, Deserialize)]
pub struct BlockchainInfo {
    pub block_count: usize,
    pub last_block_hash: Option<String>,
}

#[derive(Serialize, Deserialize)]
pub struct Proposal {
    pub title: String,
    pub description: String,
    pub proposer: String,
    #[serde(with = "duration_serde")]
    pub voting_period: Duration,
    pub proposal_type: icn_governance::democracy::ProposalType,
    pub category: icn_governance::democracy::ProposalCategory,
    pub required_quorum: f64,
    pub execution_timestamp: Option<DateTime<Utc>>,
}

#[derive(Serialize, Deserialize)]
pub struct Vote {
    pub voter: String,
    pub proposal_id: String,
    pub in_favor: bool,
    pub weight: f64,
}

#[derive(Serialize, Deserialize, Clone)]
pub enum ProposalStatus {
    Active,
    Passed,
    Rejected,
    Implemented,
}

impl From<DemocracyProposalStatus> for ProposalStatus {
    fn from(status: DemocracyProposalStatus) -> Self {
        match status {
            DemocracyProposalStatus::Active => ProposalStatus::Active,
            DemocracyProposalStatus::Passed => ProposalStatus::Passed,
            DemocracyProposalStatus::Rejected => ProposalStatus::Rejected,
            DemocracyProposalStatus::Implemented => ProposalStatus::Implemented,
        }
    }
}

mod duration_serde {
    use chrono::Duration;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};

    pub fn serialize<S>(duration: &Duration, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_i64(duration.num_seconds())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Duration, D::Error>
    where
        D: Deserializer<'de>,
    {
        let seconds = i64::deserialize(deserializer)?;
        Ok(Duration::seconds(seconds))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_currency::CurrencyType;

    // Helper function to create a mock ApiLayer for testing
    async fn create_mock_api_layer() -> ApiLayer {
        let blockchain = Arc::new(RwLock::new(Blockchain::new()));
        let governance = Arc::new(RwLock::new(DemocraticSystem::new()));

        ApiLayer::new(blockchain, governance)
    }

    #[tokio::test]
    async fn test_get_blockchain_info() {
        let api = create_mock_api_layer().await;
        let info = api.get_blockchain_info().await;
        assert!(info.success);
        assert_eq!(info.data.unwrap().block_count, 1); // Genesis block
    }

    #[tokio::test]
    async fn test_submit_transaction() {
        let api = create_mock_api_layer().await;
        let transaction = Transaction::new("Alice".to_string(), "Bob".to_string(), 100.0, CurrencyType::BasicNeeds, 1000);
        let result = api.submit_transaction(transaction).await;
        assert!(result.success);
    }

    #[tokio::test]
    async fn test_get_balance() {
        let api = create_mock_api_layer().await;
        let balance = api.get_balance("Alice").await;
        assert!(balance.success);
        assert_eq!(balance.data.unwrap(), 0.0); // Initial balance
    }
}===== END OF crates/icn_api/src/lib.rs =====

===== START OF crates/icn_blockchain/Cargo.toml =====
[package]
name = "icn_blockchain"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
icn_consensus = { path = "../icn_consensus" }
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
log = "0.4"
thiserror = "1.0"
chrono = { version = "0.4", features = ["serde"] }

[dev-dependencies]
tokio-test = "0.4"
===== END OF crates/icn_blockchain/Cargo.toml =====

===== START OF crates/icn_blockchain/src/asset_tokenization.rs =====
use serde::{Serialize, Deserialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};
use icn_core::error::{Error, Result};

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct AssetToken {
    pub id: String,
    pub name: String,
    pub description: String,
    pub owner: String,
    pub created_at: DateTime<Utc>,
    pub last_transferred: DateTime<Utc>,
    pub metadata: serde_json::Value,
}

impl AssetToken {
    pub fn new(name: String, description: String, owner: String, metadata: serde_json::Value) -> Self {
        let now = Utc::now();
        AssetToken {
            id: Uuid::new_v4().to_string(),
            name,
            description,
            owner,
            created_at: now,
            last_transferred: now,
            metadata,
        }
    }

    pub fn transfer(&mut self, new_owner: String) {
        self.owner = new_owner;
        self.last_transferred = Utc::now();
    }
}

pub struct AssetRegistry {
    tokens: Vec<AssetToken>,
}

impl AssetRegistry {
    pub fn new() -> Self {
        AssetRegistry {
            tokens: Vec::new(),
        }
    }

    pub fn create_token(&mut self, name: String, description: String, owner: String, metadata: serde_json::Value) -> AssetToken {
        let token = AssetToken::new(name, description, owner, metadata);
        self.tokens.push(token.clone());
        token
    }

    pub fn transfer_token(&mut self, token_id: &str, new_owner: String) -> Result<()> {
        if let Some(token) = self.tokens.iter_mut().find(|t| t.id == token_id) {
            token.transfer(new_owner);
            Ok(())
        } else {
            Err(Error::BlockchainError("Token not found".to_string()))
        }
    }

    pub fn get_token(&self, token_id: &str) -> Option<&AssetToken> {
        self.tokens.iter().find(|t| t.id == token_id)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_asset_tokenization() {
        let mut registry = AssetRegistry::new();
        
        let metadata = serde_json::json!({
            "type": "Real Estate",
            "location": "123 Main St, Anytown, USA",
            "square_feet": 2000
        });
        
        let token = registry.create_token(
            "Main Street Property".to_string(),
            "A beautiful property on Main Street".to_string(),
            "Alice".to_string(),
            metadata
        );
        
        assert_eq!(token.owner, "Alice");
        
        registry.transfer_token(&token.id, "Bob".to_string()).unwrap();
        
        let updated_token = registry.get_token(&token.id).unwrap();
        assert_eq!(updated_token.owner, "Bob");
    }
}===== END OF crates/icn_blockchain/src/asset_tokenization.rs =====

===== START OF crates/icn_blockchain/src/blockchain.rs =====
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use crate::currency::CurrencyType;
use crate::consensus::PoCConsensus;
use crate::error::{Error, Result};

pub mod block;
pub mod transaction;

pub use block::Block;
pub use transaction::Transaction;

#[derive(Serialize, Deserialize)]
pub struct Blockchain {
    pub chain: Vec<Block>,
    pub pending_transactions: Vec<Transaction>,
    pub asset_tokens: HashMap<String, CurrencyType>,
    pub bonds: HashMap<String, CurrencyType>,
    pub consensus: PoCConsensus,
}

impl Blockchain {
    pub fn new() -> Self {
        let mut blockchain = Blockchain {
            chain: vec![],
            pending_transactions: vec![],
            asset_tokens: HashMap::new(),
            bonds: HashMap::new(),
            consensus: PoCConsensus::new(0.5, 0.66),
        };
        
        let genesis_block = Block::new(0, vec![], String::new());
        blockchain.chain.push(genesis_block);
        
        blockchain
    }

    pub fn add_transaction(&mut self, transaction: Transaction) -> Result<()> {
        // Add validation logic here if needed
        self.pending_transactions.push(transaction);
        Ok(())
    }

    pub fn create_block(&mut self, author: String) -> Result<()> {
        let previous_block = self.chain.last().ok_or(Error::BlockchainError("No previous block found".to_string()))?;
        let new_block = Block::new(
            self.chain.len() as u64,
            self.pending_transactions.clone(),
            previous_block.hash.clone(),
        );
        
        self.chain.push(new_block);
        self.pending_transactions.clear();
        Ok(())
    }

    pub fn get_latest_block(&self) -> Option<&Block> {
        self.chain.last()
    }

    pub fn get_balance(&self, address: &str) -> f64 {
        let mut balance = 0.0;
        for block in &self.chain {
            for transaction in &block.transactions {
                if transaction.from == address {
                    balance -= transaction.amount;
                }
                if transaction.to == address {
                    balance += transaction.amount;
                }
            }
        }
        balance
    }

    pub fn validate_chain(&self) -> Result<()> {
        for i in 1..self.chain.len() {
            let previous_block = &self.chain[i - 1];
            let current_block = &self.chain[i];

            if current_block.previous_hash != previous_block.hash {
                return Err(Error::BlockchainError("Invalid previous hash".to_string()));
            }

            if current_block.hash != current_block.calculate_hash() {
                return Err(Error::BlockchainError("Invalid block hash".to_string()));
            }
        }
        Ok(())
    }

    pub fn get_asset_token(&self, asset_id: &str) -> Option<&CurrencyType> {
        self.asset_tokens.get(asset_id)
    }

    pub fn get_bond(&self, bond_id: &str) -> Option<&CurrencyType> {
        self.bonds.get(bond_id)
    }

    pub fn add_asset_token(&mut self, asset_id: String, currency_type: CurrencyType) -> Result<()> {
        if self.asset_tokens.contains_key(&asset_id) {
            return Err(Error::BlockchainError("Asset token already exists".to_string()));
        }
        self.asset_tokens.insert(asset_id, currency_type);
        Ok(())
    }

    pub fn add_bond(&mut self, bond_id: String, currency_type: CurrencyType) -> Result<()> {
        if self.bonds.contains_key(&bond_id) {
            return Err(Error::BlockchainError("Bond already exists".to_string()));
        }
        self.bonds.insert(bond_id, currency_type);
        Ok(())
    }

    pub fn execute_smart_contracts(&mut self) -> Result<()> {
        // Implement smart contract execution logic here
        Ok(())
    }

    pub fn transfer_asset_token(&mut self, asset_id: &str, new_owner: &str) -> Result<()> {
        // Implement asset token transfer logic here
        Ok(())
    }

    pub fn transfer_bond(&mut self, bond_id: &str, new_owner: &str) -> Result<()> {
        // Implement bond transfer logic here
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_blockchain_creation() {
        let blockchain = Blockchain::new();
        assert_eq!(blockchain.chain.len(), 1);
        assert_eq!(blockchain.chain[0].index, 0);
    }

    #[test]
    fn test_add_transaction_and_create_block() {
        let mut blockchain = Blockchain::new();
        let transaction = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            100.0,
            CurrencyType::BasicNeeds,
            1000,
        );

        assert!(blockchain.add_transaction(transaction).is_ok());
        assert_eq!(blockchain.pending_transactions.len(), 1);

        assert!(blockchain.create_block("Miner1".to_string()).is_ok());
        assert_eq!(blockchain.chain.len(), 2);
        assert!(blockchain.pending_transactions.is_empty());
    }

    #[test]
    fn test_get_balance() {
        let mut blockchain = Blockchain::new();
        let transaction1 = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            100.0,
            CurrencyType::BasicNeeds,
            1000,
        );
        let transaction2 = Transaction::new(
            "Bob".to_string(),
            "Alice".to_string(),
            50.0,
            CurrencyType::BasicNeeds,
            1000,
        );

        blockchain.add_transaction(transaction1).unwrap();
        blockchain.add_transaction(transaction2).unwrap();
        blockchain.create_block("Miner1".to_string()).unwrap();

        assert_eq!(blockchain.get_balance("Alice"), -50.0);
        assert_eq!(blockchain.get_balance("Bob"), 50.0);
    }

    #[test]
    fn test_validate_chain() {
        let mut blockchain = Blockchain::new();
        let transaction = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            100.0,
            CurrencyType::BasicNeeds,
            1000,
        );

        blockchain.add_transaction(transaction).unwrap();
        blockchain.create_block("Miner1".to_string()).unwrap();

        assert!(blockchain.validate_chain().is_ok());

        // Tamper with a block
        blockchain.chain[1].hash = "tampered_hash".to_string();
        assert!(blockchain.validate_chain().is_err());
    }

    #[test]
    fn test_asset_tokens_and_bonds() {
        let mut blockchain = Blockchain::new();
        
        assert!(blockchain.add_asset_token("ASSET1".to_string(), CurrencyType::AssetToken("ASSET1".to_string())).is_ok());
        assert!(blockchain.add_bond("BOND1".to_string(), CurrencyType::Bond("BOND1".to_string())).is_ok());

        assert!(blockchain.get_asset_token("ASSET1").is_some());
        assert!(blockchain.get_bond("BOND1").is_some());
        assert!(blockchain.get_asset_token("NONEXISTENT").is_none());
        assert!(blockchain.get_bond("NONEXISTENT").is_none());
    }
}===== END OF crates/icn_blockchain/src/blockchain.rs =====

===== START OF crates/icn_blockchain/src/block.rs =====
// crates/icn_blockchain/src/block.rs
use crate::Transaction;
use serde::{Serialize, Deserialize};
use std::collections::HashMap;
use sha2::{Sha256, Digest};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Block {
    pub index: u64,
    pub timestamp: i64,
    pub transactions: Vec<Transaction>,
    pub previous_hash: String,
    pub hash: String,
    pub nonce: u64,
    pub gas_used: u64,
    pub smart_contract_results: HashMap<String, String>,
}

impl Block {
    pub fn new(index: u64, transactions: Vec<Transaction>, previous_hash: String) -> Self {
        let timestamp = chrono::Utc::now().timestamp();
        let mut block = Block {
            index,
            timestamp,
            transactions,
            previous_hash,
            hash: String::new(),
            nonce: 0,
            gas_used: 0,
            smart_contract_results: HashMap::new(),
        };
        block.hash = block.calculate_hash();
        block
    }

    pub fn calculate_hash(&self) -> String {
        let mut hasher = Sha256::new();
        hasher.update(self.index.to_string());
        hasher.update(self.timestamp.to_string());
        for transaction in &self.transactions {
            hasher.update(transaction.to_string());
        }
        hasher.update(&self.previous_hash);
        hasher.update(self.nonce.to_string());
        format!("{:x}", hasher.finalize())
    }
}===== END OF crates/icn_blockchain/src/block.rs =====

===== START OF crates/icn_blockchain/src/lib.rs =====
// crates/icn_blockchain/src/lib.rs

mod block;
mod transaction;
mod blockchain;
mod asset_tokenization;

pub use block::Block;
pub use transaction::Transaction;
pub use blockchain::Blockchain;
pub use asset_tokenization::{AssetToken, AssetRegistry};

use icn_core::error::{Error, Result};
use icn_consensus::PoCConsensus;
use icn_currency::CurrencyType;

pub struct Blockchain {
    chain: Vec<Block>,
    pending_transactions: Vec<Transaction>,
    asset_registry: AssetRegistry,
    consensus: PoCConsensus,
}

impl Blockchain {
    pub fn new() -> Self {
        Blockchain {
            chain: vec![Block::genesis()],
            pending_transactions: Vec::new(),
            asset_registry: AssetRegistry::new(),
            consensus: PoCConsensus::new(),
        }
    }

    pub fn add_block(&mut self, block: Block, votes: &[(&str, bool)]) -> Result<()> {
        if self.consensus.validate_block(&block.hash, votes)? {
            if self.is_valid_block(&block) {
                self.chain.push(block);
                self.pending_transactions.clear();
                Ok(())
            } else {
                Err(Error::BlockchainError("Invalid block".to_string()))
            }
        } else {
            Err(Error::BlockchainError("Block not approved by consensus".to_string()))
        }
    }

    pub fn add_transaction(&mut self, transaction: Transaction) -> Result<()> {
        if self.is_valid_transaction(&transaction) {
            self.pending_transactions.push(transaction);
            Ok(())
        } else {
            Err(Error::BlockchainError("Invalid transaction".to_string()))
        }
    }

    fn is_valid_block(&self, block: &Block) -> bool {
        // Implement block validation logic
        block.previous_hash == self.chain.last().unwrap().hash
            && block.hash == block.calculate_hash()
            && block.timestamp > self.chain.last().unwrap().timestamp
    }

    fn is_valid_transaction(&self, transaction: &Transaction) -> bool {
        // Implement transaction validation logic
        let sender_balance = self.get_balance(&transaction.from).unwrap_or(0.0);
        sender_balance >= transaction.amount
    }

    pub fn get_balance(&self, address: &str) -> Result<f64> {
        let balance = self.chain.iter()
            .flat_map(|block| &block.transactions)
            .fold(0.0, |acc, tx| {
                if tx.from == address {
                    acc - tx.amount
                } else if tx.to == address {
                    acc + tx.amount
                } else {
                    acc
                }
            });
        Ok(balance)
    }

    pub fn create_asset_token(&mut self, name: String, description: String, owner: String) -> Result<AssetToken> {
        self.asset_registry.create_token(name, description, owner)
    }

    pub fn transfer_asset_token(&mut self, token_id: &str, new_owner: &str) -> Result<()> {
        self.asset_registry.transfer_token(token_id, new_owner.to_string())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_blockchain_creation() {
        let blockchain = Blockchain::new();
        assert_eq!(blockchain.chain.len(), 1);
    }

    #[test]
    fn test_add_transaction() {
        let mut blockchain = Blockchain::new();
        let transaction = Transaction::new("Alice".to_string(), "Bob".to_string(), 100.0, CurrencyType::BasicNeeds);
        assert!(blockchain.add_transaction(transaction).is_ok());
    }

    #[test]
    fn test_add_block() {
        let mut blockchain = Blockchain::new();
        let transaction = Transaction::new("Alice".to_string(), "Bob".to_string(), 100.0, CurrencyType::BasicNeeds);
        blockchain.add_transaction(transaction).unwrap();
        
        let new_block = Block::new(
            blockchain.chain.len() as u64,
            blockchain.pending_transactions.clone(),
            blockchain.chain.last().unwrap().hash.clone(),
        );

        // Assume all members vote in favor for this test
        let votes = vec![("Alice", true), ("Bob", true), ("Charlie", true)];
        assert!(blockchain.add_block(new_block, &votes).is_ok());
        assert_eq!(blockchain.chain.len(), 2);
        assert!(blockchain.pending_transactions.is_empty());
    }
}===== END OF crates/icn_blockchain/src/lib.rs =====

===== START OF crates/icn_blockchain/src/transaction.rs =====
use serde::{Deserialize, Serialize};
use ed25519_dalek::{Keypair, PublicKey, Signature, Signer, Verifier};
use icn_currency::CurrencyType;
use rand::rngs::OsRng;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct Transaction {
    pub from: String,
    pub to: String,
    pub amount: f64,
    pub currency_type: CurrencyType,
    pub gas_limit: u64,
    pub smart_contract_id: Option<String>,
    pub signature: Option<Vec<u8>>,
    pub public_key: Option<Vec<u8>>,
}

impl Transaction {
    pub fn new(from: String, to: String, amount: f64, currency_type: CurrencyType, gas_limit: u64) -> Self {
        Transaction {
            from,
            to,
            amount,
            currency_type,
            gas_limit,
            smart_contract_id: None,
            signature: None,
            public_key: None,
        }
    }

    pub fn sign(&mut self, keypair: &Keypair) -> Result<(), String> {
        let message = self.to_bytes();
        let signature = keypair.sign(&message);
        self.signature = Some(signature.to_bytes().to_vec());
        self.public_key = Some(keypair.public.to_bytes().to_vec());
        Ok(())
    }

    pub fn verify(&self) -> Result<bool, String> {
        let public_key_bytes = self.public_key.as_ref().ok_or("No public key present")?;
        let signature_bytes = self.signature.as_ref().ok_or("No signature present")?;
        
        let public_key = PublicKey::from_bytes(public_key_bytes).map_err(|e| e.to_string())?;
        let signature = Signature::from_bytes(signature_bytes).map_err(|e| e.to_string())?;
        
        let message = self.to_bytes();
        Ok(public_key.verify(&message, &signature).is_ok())
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut bytes = Vec::new();
        bytes.extend_from_slice(self.from.as_bytes());
        bytes.extend_from_slice(self.to.as_bytes());
        bytes.extend_from_slice(&self.amount.to_le_bytes());
        bytes.extend_from_slice(&self.gas_limit.to_le_bytes());
        bytes.extend_from_slice(&serde_json::to_vec(&self.currency_type).unwrap());
        if let Some(contract_id) = &self.smart_contract_id {
            bytes.extend_from_slice(contract_id.as_bytes());
        }
        bytes
    }

    pub fn to_string(&self) -> String {
        format!("{}{}{}{:?}{}", self.from, self.to, self.amount, self.currency_type, self.gas_limit)
    }

    pub fn with_smart_contract(&mut self, smart_contract_id: String) -> &mut Self {
        self.smart_contract_id = Some(smart_contract_id);
        self
    }

    pub fn is_signed(&self) -> bool {
        self.signature.is_some() && self.public_key.is_some()
    }

    pub fn get_fee(&self) -> f64 {
        // This is a simplified fee calculation. In a real system, this would be more complex.
        self.gas_limit as f64 * 0.0001
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_new_transaction() {
        let tx = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            100.0,
            CurrencyType::BasicNeeds,
            1000,
        );
        assert_eq!(tx.from, "Alice");
        assert_eq!(tx.to, "Bob");
        assert_eq!(tx.amount, 100.0);
        assert_eq!(tx.currency_type, CurrencyType::BasicNeeds);
        assert_eq!(tx.gas_limit, 1000);
    }

    #[test]
    fn test_sign_and_verify_transaction() {
        let mut tx = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            100.0,
            CurrencyType::BasicNeeds,
            1000,
        );
        let mut csprng = OsRng{};
        let keypair: Keypair = Keypair::generate(&mut csprng);

        assert!(tx.sign(&keypair).is_ok());
        assert!(tx.is_signed());
        assert!(tx.verify().unwrap());
    }

    #[test]
    fn test_with_smart_contract() {
        let mut tx = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            100.0,
            CurrencyType::BasicNeeds,
            1000,
        );
        tx.with_smart_contract("contract123".to_string());
        assert_eq!(tx.smart_contract_id, Some("contract123".to_string()));
    }

    #[test]
    fn test_get_fee() {
        let tx = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            100.0,
            CurrencyType::BasicNeeds,
            1000,
        );
        assert_eq!(tx.get_fee(), 0.1);
    }
}===== END OF crates/icn_blockchain/src/transaction.rs =====

===== START OF crates/icn_blockchain/src/transaction_validator.rs =====
use crate::{Transaction, Blockchain};
use icn_core::error::{Error, Result};

pub struct TransactionValidator;

impl TransactionValidator {
    pub fn validate_transaction(transaction: &Transaction, blockchain: &Blockchain) -> bool {
        if !Self::is_double_spend(transaction, blockchain) &&
           Self::validate_currency_and_amount(transaction) &&
           Self::check_sufficient_balance(transaction, blockchain) &&
           Self::validate_signature(transaction)
        {
            true
        } else {
            false
        }
    }

    fn is_double_spend(transaction: &Transaction, blockchain: &Blockchain) -> bool {
        for block in &blockchain.chain {
            for tx in &block.transactions {
                if tx == transaction {
                    return true;
                }
            }
        }
        false
    }

    fn validate_currency_and_amount(transaction: &Transaction) -> bool {
        transaction.amount > 0.0
    }

    fn check_sufficient_balance(transaction: &Transaction, blockchain: &Blockchain) -> bool {
        let balance = blockchain.get_balance(&transaction.from);
        balance >= transaction.amount + transaction.get_fee()
    }

    fn validate_signature(transaction: &Transaction) -> bool {
        if let Ok(is_valid) = transaction.verify() {
            is_valid
        } else {
            false
        }
    }

    pub fn can_process_transaction(transaction: &Transaction, blockchain: &Blockchain) -> Result<()> {
        if !Self::validate_transaction(transaction, blockchain) {
            return Err(Error::BlockchainError("Invalid transaction".to_string()));
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::currency::CurrencyType;
    use ed25519_dalek::Keypair;
    use rand::rngs::OsRng;

    fn create_signed_transaction(from: &str, to: &str, amount: f64) -> Transaction {
        let mut tx = Transaction::new(
            from.to_string(),
            to.to_string(),
            amount,
            CurrencyType::BasicNeeds,
            1000,
        );
        let mut csprng = OsRng{};
        let keypair: Keypair = Keypair::generate(&mut csprng);
        tx.sign(&keypair).unwrap();
        tx
    }

    #[test]
    fn test_validate_transaction() {
        let mut blockchain = Blockchain::new();
        let tx = create_signed_transaction("Alice", "Bob", 50.0);

        // Add some balance to Alice's account
        blockchain.add_transaction(create_signed_transaction("Genesis", "Alice", 100.0)).unwrap();
        blockchain.create_block("Miner".to_string()).unwrap();

        assert!(TransactionValidator::validate_transaction(&tx, &blockchain));
    }

    #[test]
    fn test_insufficient_balance() {
        let mut blockchain = Blockchain::new();
        let tx = create_signed_transaction("Alice", "Bob", 150.0);

        // Add some balance to Alice's account, but not enough
        blockchain.add_transaction(create_signed_transaction("Genesis", "Alice", 100.0)).unwrap();
        blockchain.create_block("Miner".to_string()).unwrap();

        assert!(!TransactionValidator::validate_transaction(&tx, &blockchain));
    }

    #[test]
    fn test_double_spend() {
        let mut blockchain = Blockchain::new();
        let tx = create_signed_transaction("Alice", "Bob", 50.0);

        // Add some balance to Alice's account
        blockchain.add_transaction(create_signed_transaction("Genesis", "Alice", 100.0)).unwrap();
        blockchain.create_block("Miner".to_string()).unwrap();

        // Add the transaction to the blockchain
        blockchain.add_transaction(tx.clone()).unwrap();
        blockchain.create_block("Miner".to_string()).unwrap();

        // Try to validate the same transaction again
        assert!(!TransactionValidator::validate_transaction(&tx, &blockchain));
    }
}===== END OF crates/icn_blockchain/src/transaction_validator.rs =====

===== START OF crates/icn_common/Cargo.toml =====
[package]
name = "icn_common"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
log = "0.4"
thiserror = "1.0"
chrono = { version = "0.4", features = ["serde"] }
===== END OF crates/icn_common/Cargo.toml =====

===== START OF crates/icn_common/src/lib.rs =====
// crates/icn_common/src/lib.rs

use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Error {
    pub message: String,
}

pub type Result<T> = std::result::Result<T, Error>;

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, Hash)]
pub enum CurrencyType {
    BasicNeeds,
    Education,
    Environmental,
    Community,
    Volunteer,
    Storage,
    Processing,
    Energy,
    Luxury,
    Service,
    Custom(String),
    AssetToken(String),
    Bond(String),
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Currency {
    pub currency_type: CurrencyType,
    pub total_supply: f64,
    pub creation_date: DateTime<Utc>,
    pub last_issuance: DateTime<Utc>,
    pub issuance_rate: f64,
}

impl Currency {
    pub fn new(currency_type: CurrencyType, initial_supply: f64, issuance_rate: f64) -> Self {
        let now = Utc::now();
        Currency {
            currency_type,
            total_supply: initial_supply,
            creation_date: now,
            last_issuance: now,
            issuance_rate,
        }
    }

    pub fn mint(&mut self, amount: f64) -> Result<()> {
        self.total_supply += amount;
        self.last_issuance = Utc::now();
        Ok(())
    }

    pub fn burn(&mut self, amount: f64) -> Result<()> {
        if amount > self.total_supply {
            return Err(Error {
                message: "Insufficient supply to burn".to_string(),
            });
        }
        self.total_supply -= amount;
        Ok(())
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CurrencySystem {
    pub currencies: HashMap<CurrencyType, Currency>,
}

impl CurrencySystem {
    pub fn new() -> Self {
        CurrencySystem {
            currencies: HashMap::new(),
        }
    }

    pub fn add_currency(&mut self, currency_type: CurrencyType, initial_supply: f64, issuance_rate: f64) {
        let currency = Currency::new(currency_type.clone(), initial_supply, issuance_rate);
        self.currencies.insert(currency_type, currency);
    }

    pub fn get_currency(&self, currency_type: &CurrencyType) -> Option<&Currency> {
        self.currencies.get(currency_type)
    }

    pub fn get_currency_mut(&mut self, currency_type: &CurrencyType) -> Option<&mut Currency> {
        self.currencies.get_mut(currency_type)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_currency_mint_burn() {
        let mut currency = Currency::new(CurrencyType::BasicNeeds, 1000.0, 0.01);
        assert!(currency.mint(100.0).is_ok());
        assert_eq!(currency.total_supply, 1100.0);
        assert!(currency.burn(200.0).is_ok());
        assert_eq!(currency.total_supply, 900.0);
        assert!(currency.burn(1000.0).is_err());
    }

    #[test]
    fn test_currency_system() {
        let mut system = CurrencySystem::new();
        system.add_currency(CurrencyType::BasicNeeds, 1000.0, 0.01);
        system.add_currency(CurrencyType::Education, 500.0, 0.005);

        assert!(system.get_currency(&CurrencyType::BasicNeeds).is_some());
        assert!(system.get_currency(&CurrencyType::Education).is_some());
        assert!(system.get_currency(&CurrencyType::Environmental).is_none());
    }
}===== END OF crates/icn_common/src/lib.rs =====

===== START OF crates/icn_consensus/Cargo.toml =====
[package]
name = "icn_consensus"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
serde = { version = "1.0", features = ["derive"] }
log = "0.4"
thiserror = "1.0"
chrono = { version = "0.4", features = ["serde"] }
sha2 = "0.9.9"

[dev-dependencies]
tokio-test = "0.4"
===== END OF crates/icn_consensus/Cargo.toml =====

===== START OF crates/icn_consensus/src/bft_poc.rs =====
use icn_common::{Error, Result};

#[derive(Debug)]
pub enum ProposalStatus {
    Pending,
    Approved,
    Rejected,
}

impl Clone for ProposalStatus {
    fn clone(&self) -> Self {
        match self {
            ProposalStatus::Pending => ProposalStatus::Pending,
            ProposalStatus::Approved => ProposalStatus::Approved,
            ProposalStatus::Rejected => ProposalStatus::Rejected,
        }
    }
}

pub struct Proposal {
    pub id: String,
    pub status: ProposalStatus,
    pub votes: Vec<Vote>,
}

#[derive(Clone)]
pub struct Vote {
    pub member_id: String,
    pub vote: bool,
}

pub struct BFTPoC {
    pub proposals: Vec<Proposal>,
}

impl BFTPoC {
    pub fn new() -> Self {
        BFTPoC {
            proposals: Vec::new(),
        }
    }

    pub fn create_proposal(&mut self, proposal_id: String) -> Result<()> {
        if self.proposals.iter().any(|p| p.id == proposal_id) {
            return Err(Error {
                message: "Proposal already exists".to_string(),
            });
        }

        let proposal = Proposal {
            id: proposal_id,
            status: ProposalStatus::Pending,
            votes: Vec::new(),
        };

        self.proposals.push(proposal);
        Ok(())
    }

    pub fn vote_on_proposal(&mut self, proposal_id: &str, member_id: String, vote: bool) -> Result<()> {
        let proposal = self.proposals.iter_mut().find(|p| p.id == proposal_id).ok_or_else(|| Error {
            message: "Proposal not found".to_string(),
        })?;

        if proposal.votes.iter().any(|v| v.member_id == member_id) {
            return Err(Error {
                message: "Member has already voted".to_string(),
            });
        }

        proposal.votes.push(Vote { member_id, vote });
        Ok(())
    }

    pub fn finalize_proposal(&mut self, proposal_id: &str) -> Result<ProposalStatus> {
        let proposal = self.proposals.iter_mut().find(|p| p.id == proposal_id).ok_or_else(|| Error {
            message: "Proposal not found".to_string(),
        })?;

        let positive_votes = proposal.votes.iter().filter(|v| v.vote).count();
        let negative_votes = proposal.votes.len() - positive_votes;

        proposal.status = if positive_votes > negative_votes {
            ProposalStatus::Approved
        } else {
            ProposalStatus::Rejected
        };

        Ok(proposal.status.clone())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_proposal() {
        let mut bft_poc = BFTPoC::new();

        assert!(bft_poc.create_proposal("proposal1".to_string()).is_ok());
        assert_eq!(bft_poc.proposals.len(), 1);

        assert!(bft_poc.create_proposal("proposal1".to_string()).is_err());
    }

    #[test]
    fn test_vote_on_proposal() {
        let mut bft_poc = BFTPoC::new();
        bft_poc.create_proposal("proposal1".to_string()).unwrap();

        assert!(bft_poc.vote_on_proposal("proposal1", "member1".to_string(), true).is_ok());
        assert_eq!(bft_poc.proposals[0].votes.len(), 1);

        assert!(bft_poc.vote_on_proposal("proposal1", "member1".to_string(), false).is_err());
    }

    #[test]
    fn test_finalize_proposal() {
        let mut bft_poc = BFTPoC::new();
        bft_poc.create_proposal("proposal1".to_string()).unwrap();

        bft_poc.vote_on_proposal("proposal1", "member1".to_string(), true).unwrap();
        bft_poc.vote_on_proposal("proposal1", "member2".to_string(), false).unwrap();
        bft_poc.vote_on_proposal("proposal1", "member3".to_string(), true).unwrap();

        let status = bft_poc.finalize_proposal("proposal1").unwrap();
        assert_eq!(status, ProposalStatus::Approved);

        bft_poc.create_proposal("proposal2".to_string()).unwrap();
        bft_poc.vote_on_proposal("proposal2", "member1".to_string(), false).unwrap();
        bft_poc.vote_on_proposal("proposal2", "member2".to_string(), false).unwrap();
        bft_poc.vote_on_proposal("proposal2", "member3".to_string(), true).unwrap();

        let status = bft_poc.finalize_proposal("proposal2").unwrap();
        assert_eq!(status, ProposalStatus::Rejected);
    }
}
===== END OF crates/icn_consensus/src/bft_poc.rs =====

===== START OF crates/icn_consensus/src/consensus.rs =====
// src/currency/currency.rs

use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use std::collections::HashMap;
use std::fmt;
use log::{info, error, debug, warn};

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, Hash)]
pub enum CurrencyType {
    BasicNeeds,
    Education,
    Environmental,
    Community,
    Volunteer,
    Storage,
    Processing,
    Energy,
    Luxury,
    Service,
    Custom(String),
    AssetToken(String),
    Bond(String),
}

impl fmt::Display for CurrencyType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            CurrencyType::Custom(name) => write!(f, "Custom({})", name),
            _ => write!(f, "{:?}", self),
        }
    }
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Currency {
    pub currency_type: CurrencyType,
    pub total_supply: f64,
    pub creation_date: DateTime<Utc>,
    pub last_issuance: DateTime<Utc>,
    pub issuance_rate: f64,
}

impl Currency {
    pub fn new(currency_type: CurrencyType, initial_supply: f64, issuance_rate: f64) -> Self {
        let now = Utc::now();
        debug!("Creating new currency: {:?}", currency_type);
        Currency {
            currency_type,
            total_supply: initial_supply,
            creation_date: now,
            last_issuance: now,
            issuance_rate,
        }
    }

    pub fn mint(&mut self, amount: f64) {
        self.total_supply += amount;
        self.last_issuance = Utc::now();
        info!("Minted {} of {:?}. New total supply: {}", amount, self.currency_type, self.total_supply);
    }

    pub fn burn(&mut self, amount: f64) -> Result<(), String> {
        if amount > self.total_supply {
            error!("Attempted to burn more {:?} than available. Requested: {}, Available: {}", self.currency_type, amount, self.total_supply);
            return Err("Insufficient supply to burn".to_string());
        }
        self.total_supply -= amount;
        info!("Burned {} of {:?}. New total supply: {}", amount, self.currency_type, self.total_supply);
        Ok(())
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CurrencySystem {
    pub currencies: HashMap<CurrencyType, Currency>,
}

impl CurrencySystem {
    pub fn new() -> Self {
        debug!("Creating new CurrencySystem");
        let mut system = CurrencySystem {
            currencies: HashMap::new(),
        };
        
        system.add_currency(CurrencyType::BasicNeeds, 1_000_000.0, 0.01);
        system.add_currency(CurrencyType::Education, 500_000.0, 0.005);
        system.add_currency(CurrencyType::Environmental, 750_000.0, 0.008);
        system.add_currency(CurrencyType::Community, 250_000.0, 0.003);
        system.add_currency(CurrencyType::Volunteer, 100_000.0, 0.002);
        system.add_currency(CurrencyType::Storage, 1_000_000.0, 0.01);
        system.add_currency(CurrencyType::Processing, 500_000.0, 0.005);
        system.add_currency(CurrencyType::Energy, 750_000.0, 0.008);
        system.add_currency(CurrencyType::Luxury, 100_000.0, 0.001);
        system.add_currency(CurrencyType::Service, 200_000.0, 0.004);

        info!("CurrencySystem initialized with {} currencies", system.currencies.len());
        system
    }

    pub fn add_currency(&mut self, currency_type: CurrencyType, initial_supply: f64, issuance_rate: f64) {
        let currency = Currency::new(currency_type.clone(), initial_supply, issuance_rate);
        self.currencies.insert(currency_type.clone(), currency);
        info!("Added new currency: {:?}", currency_type);
    }

    pub fn get_currency(&self, currency_type: &CurrencyType) -> Option<&Currency> {
        self.currencies.get(currency_type)
    }

    pub fn get_currency_mut(&mut self, currency_type: &CurrencyType) -> Option<&mut Currency> {
        self.currencies.get_mut(currency_type)
    }

    pub fn create_custom_currency(&mut self, name: String, initial_supply: f64, issuance_rate: f64) -> Result<(), String> {
        let currency_type = CurrencyType::Custom(name.clone());
        if self.currencies.contains_key(&currency_type) {
            error!("Attempted to create duplicate custom currency: {}", name);
            return Err(format!("Currency '{}' already exists", name));
        }
        self.add_currency(currency_type, initial_supply, issuance_rate);
        Ok(())
    }

    pub fn adaptive_issuance(&mut self) {
        debug!("Performing adaptive issuance for all currencies");
        let now = Utc::now();
        for currency in self.currencies.values_mut() {
            let time_since_last_issuance = now.signed_duration_since(currency.last_issuance);
            let issuance_amount = currency.total_supply * currency.issuance_rate * time_since_last_issuance.num_milliseconds() as f64 / 86_400_000.0; // Daily rate
            currency.mint(issuance_amount);
            debug!("Adaptive issuance for {:?}: {}", currency.currency_type, issuance_amount);
        }
        info!("Adaptive issuance completed for all currencies");
    }

    pub fn print_currency_supplies(&self) {
        info!("Current Currency Supplies:");
        for (currency_type, currency) in &self.currencies {
            info!("{:?}: {}", currency_type, currency.total_supply);
        }
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Wallet {
    balances: HashMap<CurrencyType, f64>,
}

impl Wallet {
    pub fn new() -> Self {
        debug!("Creating new Wallet");
        Wallet {
            balances: HashMap::new(),
        }
    }

    pub fn deposit(&mut self, currency_type: CurrencyType, amount: f64) {
        *self.balances.entry(currency_type.clone()).or_insert(0.0) += amount;
        info!("Deposited {} of {:?} into wallet", amount, currency_type);
    }

    pub fn withdraw(&mut self, currency_type: CurrencyType, amount: f64) -> Result<(), String> {
        let balance = self.balances.entry(currency_type.clone()).or_insert(0.0);
        if *balance < amount {
            error!("Insufficient balance for withdrawal. Requested: {}, Available: {}", amount, balance);
            return Err(format!("Insufficient balance for {:?}", currency_type));
        }
        *balance -= amount;
        info!("Withdrawn {} of {:?} from wallet", amount, currency_type);
        Ok(())
    }

    pub fn get_balance(&self, currency_type: &CurrencyType) -> f64 {
        *self.balances.get(currency_type).unwrap_or(&0.0)
    }

    pub fn print_balances(&self) {
        info!("Wallet Balances:");
        for (currency_type, balance) in &self.balances {
            info!("{:?}: {}", currency_type, balance);
        }
    }
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct AssetToken {
    pub asset_id: String,
    pub name: String,
    pub description: String,
    pub owner: String,
    pub value: f64,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Bond {
    pub bond_id: String,
    pub name: String,
    pub description: String,
    pub issuer: String,
    pub face_value: f64,
    pub maturity_date: DateTime<Utc>,
    pub interest_rate: f64,
    pub owner: String,
}===== END OF crates/icn_consensus/src/consensus.rs =====

===== START OF crates/icn_consensus/src/lib.rs =====
// crates/icn_consensus/src/lib.rs

use serde::{Serialize, Deserialize};
use log::error;
use icn_common::{Error, Result};
use std::collections::HashMap;

mod proof_of_cooperation;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Member {
    pub id: String,
    pub reputation: f64,
    pub is_validator: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct PoCConsensus {
    pub members: HashMap<String, Member>,
    pub threshold: f64,
    pub quorum: f64,
}

impl PoCConsensus {
    pub fn new() -> Self {
        PoCConsensus {
            members: HashMap::new(),
            threshold: 0.66, // 66% agreement required for consensus
            quorum: 0.51, // 51% participation required for quorum
        }
    }

    pub fn add_member(&mut self, id: String, is_validator: bool) -> Result<()> {
        if self.members.contains_key(&id) {
            return Err(Error { message: "Member already exists".to_string() });
        }
        self.members.insert(id.clone(), Member {
            id,
            reputation: 1.0,
            is_validator,
        });
        Ok(())
    }

    pub fn remove_member(&mut self, id: &str) -> Result<()> {
        if self.members.remove(id).is_none() {
            return Err(Error { message: "Member not found".to_string() });
        }
        Ok(())
    }

    pub fn update_reputation(&mut self, id: &str, change: f64) -> Result<()> {
        let member = self.members.get_mut(id)
            .ok_or_else(|| Error { message: "Member not found".to_string() })?;
        member.reputation += change;
        member.reputation = member.reputation.max(0.0); // Ensure reputation doesn't go negative
        Ok(())
    }

    pub fn validate_block(&self, _block_hash: &str, votes: &[(&str, bool)]) -> Result<bool> {
        let total_reputation: f64 = self.members.values()
            .filter(|m| m.is_validator)
            .map(|m| m.reputation)
            .sum();

        let mut positive_reputation = 0.0;
        let mut participating_reputation = 0.0;

        for (member_id, vote) in votes {
            if let Some(member) = self.members.get(*member_id) {
                if member.is_validator {
                    participating_reputation += member.reputation;
                    if *vote {
                        positive_reputation += member.reputation;
                    }
                }
            } else {
                return Err(Error { message: "Invalid member in votes".to_string() });
            }
        }

        if participating_reputation / total_reputation < self.quorum {
            return Err(Error { message: "Quorum not reached".to_string() });
        }

        Ok(positive_reputation / participating_reputation >= self.threshold)
    }

    pub fn get_validators(&self) -> Vec<&Member> {
        self.members.values().filter(|m| m.is_validator).collect()
    }
}

// crates/icn_consensus/src/proof_of_cooperation.rs

use serde::{Serialize, Deserialize};
use sha2::{Sha256, Digest};

#[derive(Debug, Serialize, Deserialize)]
pub struct ProofOfCooperation {
    pub blocks: Vec<Block>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Block {
    pub index: u64,
    pub previous_hash: String,
    pub timestamp: u64,
    pub data: String,
    pub hash: String,
}

impl Block {
    pub fn new(index: u64, previous_hash: String, timestamp: u64, data: String) -> Self {
        let mut block = Block {
            index,
            previous_hash,
            timestamp,
            data,
            hash: String::new(),
        };
        block.hash = block.calculate_hash();
        block
    }

    pub fn calculate_hash(&self) -> String {
        let input = format!("{}{}{}{}", self.index, self.previous_hash, self.timestamp, self.data);
        let mut hasher = Sha256::new();
        hasher.update(input.as_bytes());
        format!("{:x}", hasher.finalize())
    }
}

impl ProofOfCooperation {
    pub fn new() -> Self {
        ProofOfCooperation {
            blocks: Vec::new(),
        }
    }

    pub fn add_block(&mut self, data: String) -> Result<(), String> {
        let previous_hash = if let Some(last_block) = self.blocks.last() {
            last_block.hash.clone()
        } else {
            String::new()
        };

        let new_block = Block::new(
            self.blocks.len() as u64,
            previous_hash,
            chrono::Utc::now().timestamp_millis() as u64,
            data,
        );

        self.blocks.push(new_block);
        Ok(())
    }

    pub fn validate_chain(&self) -> Result<(), String> {
        for i in 1..self.blocks.len() {
            let previous_block = &self.blocks[i - 1];
            let current_block = &self.blocks[i];

            if current_block.previous_hash != previous_block.hash {
                return Err("Invalid previous hash".to_string());
            }

            if current_block.hash != current_block.calculate_hash() {
                return Err("Invalid block hash".to_string());
            }
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add_and_remove_member() {
        let mut consensus = PoCConsensus::new();
        assert!(consensus.add_member("Alice".to_string(), true).is_ok());
        assert!(consensus.add_member("Bob".to_string(), false).is_ok());
        assert_eq!(consensus.members.len(), 2);
        assert!(consensus.remove_member("Alice").is_ok());
        assert_eq!(consensus.members.len(), 1);
        assert!(consensus.remove_member("Charlie").is_err());
    }

    #[test]
    fn test_update_reputation() {
        let mut consensus = PoCConsensus::new();
        consensus.add_member("Alice".to_string(), true).unwrap();
        assert!(consensus.update_reputation("Alice", 0.5).is_ok());
        assert_eq!(consensus.members.get("Alice").unwrap().reputation, 1.5);
        assert!(consensus.update_reputation("Bob", 1.0).is_err());
    }

    #[test]
    fn test_validate_block() {
        let mut consensus = PoCConsensus::new();
        consensus.add_member("Alice".to_string(), true).unwrap();
        consensus.add_member("Bob".to_string(), true).unwrap();
        consensus.add_member("Charlie".to_string(), true).unwrap();

        let votes = vec![
            ("Alice", true),
            ("Bob", true),
            ("Charlie", false),
        ];

        assert!(consensus.validate_block("block_hash", &votes).unwrap());

        let insufficient_votes = vec![
            ("Alice", true),===== END OF crates/icn_consensus/src/lib.rs =====

===== START OF crates/icn_consensus/src/proof_of_cooperation.rs =====
use icn_common::{Error, Result};
use sha2::{Sha256, Digest};

#[derive(Debug)]
pub struct ProofOfCooperation {
    pub blocks: Vec<Block>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Block {
    pub index: u64,
    pub previous_hash: String,
    pub timestamp: u64,
    pub data: String,
    pub hash: String,
}

impl Block {
    pub fn new(index: u64, previous_hash: String, timestamp: u64, data: String) -> Self {
        let mut block = Block {
            index,
            previous_hash,
            timestamp,
            data,
            hash: String::new(),
        };
        block.hash = block.calculate_hash();
        block
    }

    pub fn calculate_hash(&self) -> String {
        let input = format!("{}{}{}{}", self.index, self.previous_hash, self.timestamp, self.data);
        let mut hasher = Sha256::new();
        hasher.update(input.as_bytes());
        let result = hasher.finalize();
        format!("{:x}", result)
    }
}

impl ProofOfCooperation {
    pub fn new() -> Self {
        ProofOfCooperation {
            blocks: Vec::new(),
        }
    }

    pub fn add_block(&mut self, data: String) -> Result<()> {
        let previous_hash = if let Some(last_block) = self.blocks.last() {
            last_block.hash.clone()
        } else {
            String::new()
        };

        let new_block = Block::new(
            self.blocks.len() as u64,
            previous_hash,
            chrono::Utc::now().timestamp_millis() as u64,
            data,
        );

        self.blocks.push(new_block);
        Ok(())
    }

    pub fn validate_chain(&self) -> Result<()> {
        for i in 1..self.blocks.len() {
            let previous_block = &self.blocks[i - 1];
            let current_block = &self.blocks[i];

            if current_block.previous_hash != previous_block.hash {
                return Err(Error {
                    message: "Invalid previous hash".to_string(),
                });
            }

            if current_block.hash != current_block.calculate_hash() {
                return Err(Error {
                    message: "Invalid block hash".to_string(),
                });
            }
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add_and_validate_blocks() {
        let mut poc = ProofOfCooperation::new();
        
        poc.add_block("Block 1 Data".to_string()).unwrap();
        poc.add_block("Block 2 Data".to_string()).unwrap();

        assert_eq!(poc.blocks.len(), 2);
        assert!(poc.validate_chain().is_ok());

        // Tamper with a block
        poc.blocks[1].data = "Tampered Data".to_string();
        assert!(poc.validate_chain().is_err());
    }
}
===== END OF crates/icn_consensus/src/proof_of_cooperation.rs =====

===== START OF crates/icn_core/Cargo.toml =====
[package]
name = "icn_core"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
icn_blockchain = { path = "../icn_blockchain" }
icn_vm = { path = "../icn_vm" }
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
log = "0.4"
thiserror = "1.0"
chrono = { version = "0.4", features = ["serde"] }
ed25519-dalek = "1.0"
rand = "0.7"

[dev-dependencies]
tokio-test = "0.4"
===== END OF crates/icn_core/Cargo.toml =====

===== START OF crates/icn_core/src/cli/mod.rs =====
use crate::IcnNode;
use icn_blockchain::Blockchain;
use icn_vm::smart_contract::{AssetTokenContract, BondContract};
use chrono::Utc;
use std::io::{self, Write};

pub fn run_cli(node: &mut IcnNode) {
    loop {
        print_menu();
        let choice = get_user_input("Enter your choice: ");

        match choice.trim() {
            "1" => deploy_contract(node),
            "2" => execute_contracts(node),
            "3" => view_blockchain_state(node),
            "4" => break,
            "9" => create_asset_token(node),
            "10" => transfer_asset_token(node),
            "11" => view_asset_token(node),
            "12" => create_bond(node),
            "13" => transfer_bond(node),
            "14" => view_bond(node),
            _ => println!("Invalid choice. Please try again."),
        }
    }
}

fn print_menu() {
    println!("\n--- Smart Contract CLI ---");
    println!("1. Deploy a new smart contract");
    println!("2. Execute smart contracts in the latest block");
    println!("3. View blockchain state");
    println!("4. Exit");
    println!("9. Create a new asset token");
    println!("10. Transfer an asset token");
    println!("11. View asset token details");
    println!("12. Create a new bond");
    println!("13. Transfer a bond");
    println!("14. View bond details");
}

fn get_user_input(prompt: &str) -> String {
    print!("{}", prompt);
    io::stdout().flush().unwrap();
    let mut input = String::new();
    io::stdin().read_line(&mut input).unwrap();
    input.trim().to_string()
}

fn deploy_contract(node: &mut IcnNode) {
    // Add logic to deploy a smart contract
    println!("Deploying a new smart contract...");
}

fn execute_contracts(node: &mut IcnNode) {
    node.with_blockchain(|blockchain| {
        blockchain.execute_smart_contracts()
    }).unwrap_or_else(|e| println!("Failed to execute smart contracts: {}", e));
}

fn view_blockchain_state(node: &IcnNode) {
    node.with_blockchain(|blockchain| {
        println!("{:#?}", blockchain);
        Ok(())
    }).unwrap_or_else(|e| println!("Failed to view blockchain state: {}", e));
}

fn create_asset_token(node: &mut IcnNode) {
    let asset_id = get_user_input("Enter asset ID: ");
    let name = get_user_input("Enter asset name: ");
    let description = get_user_input("Enter asset description: ");
    let owner = get_user_input("Enter owner ID: ");
    let value: f64 = get_user_input("Enter asset value: ").parse().unwrap_or(0.0);

    let contract = AssetTokenContract::new(asset_id, name, description, owner, value);
    node.with_blockchain(|blockchain| {
        blockchain.deploy_smart_contract(Box::new(contract))
    }).unwrap_or_else(|e| println!("Failed to create asset token: {}", e));
}

fn transfer_asset_token(node: &mut IcnNode) {
    let asset_id = get_user_input("Enter asset ID: ");
    let new_owner = get_user_input("Enter new owner ID: ");

    node.with_blockchain(|blockchain| {
        blockchain.transfer_asset_token(&asset_id, &new_owner)
    }).unwrap_or_else(|e| println!("Failed to transfer asset token: {}", e));
}

fn view_asset_token(node: &IcnNode) {
    let asset_id = get_user_input("Enter asset ID: ");
    node.with_blockchain(|blockchain| {
        if let Some(token) = blockchain.get_asset_token(&asset_id) {
            println!("{:?}", token);
        } else {
            println!("Asset token not found");
        }
        Ok(())
    }).unwrap_or_else(|e| println!("Failed to view asset token: {}", e));
}

fn create_bond(node: &mut IcnNode) {
    let bond_id = get_user_input("Enter bond ID: ");
    let name = get_user_input("Enter bond name: ");
    let description = get_user_input("Enter bond description: ");
    let issuer = get_user_input("Enter issuer ID: ");
    let face_value: f64 = get_user_input("Enter face value: ").parse().unwrap_or(0.0);
    let maturity_date = get_user_input("Enter maturity date (YYYY-MM-DD): ");
    let interest_rate: f64 = get_user_input("Enter interest rate: ").parse().unwrap_or(0.0);
    let owner = get_user_input("Enter owner ID: ");

    let maturity_date = chrono::NaiveDate::parse_from_str(&maturity_date, "%Y-%m-%d")
        .map(|date| date.and_hms(0, 0, 0))
        .map(|naive| chrono::DateTime::<Utc>::from_naive_utc_and_offset(naive, Utc))
        .unwrap_or_else(|_| Utc::now());

    let contract = BondContract::new(bond_id, name, description, issuer, face_value, maturity_date, interest_rate, owner);
    node.with_blockchain(|blockchain| {
        blockchain.deploy_smart_contract(Box::new(contract))
    }).unwrap_or_else(|e| println!("Failed to create bond: {}", e));
}

fn transfer_bond(node: &mut IcnNode) {
    let bond_id = get_user_input("Enter bond ID: ");
    let new_owner = get_user_input("Enter new owner ID: ");

    node.with_blockchain(|blockchain| {
        blockchain.transfer_bond(&bond_id, &new_owner)
    }).unwrap_or_else(|e| println!("Failed to transfer bond: {}", e));
}

fn view_bond(node: &IcnNode) {
    let bond_id = get_user_input("Enter bond ID: ");
    node.with_blockchain(|blockchain| {
        if let Some(bond) = blockchain.get_bond(&bond_id) {
            println!("{:?}", bond);
        } else {
            println!("Bond not found");
        }
        Ok(())
    }).unwrap_or_else(|e| println!("Failed to view bond: {}", e));
}===== END OF crates/icn_core/src/cli/mod.rs =====

===== START OF crates/icn_core/src/error.rs =====
use thiserror::Error;

#[derive(Error, Debug)]
pub enum Error {
    #[error("Blockchain error: {0}")]
    BlockchainError(String),
    
    #[error("Consensus error: {0}")]
    ConsensusError(String),
    
    #[error("Sharding error: {0}")]
    ShardingError(String),
    
    #[error("VM error: {0}")]
    VmError(String),
    
    #[error("Network error: {0}")]
    NetworkError(String),
    
    #[error("Smart contract error: {0}")]
    SmartContractError(String),
    
    #[error("I/O error: {0}")]
    IoError(#[from] std::io::Error),

    #[error("Lock error: {0}")]
    LockError(String),

    #[error("Communication error: {0}")]
    CommunicationError(String),

    #[error("Transaction failed: {0}")]
    TransactionFailed(String),

    #[error("Timeout: {0}")]
    Timeout(String),

    #[error("Currency error: {0}")]
    CurrencyError(String),

    #[error("Identity error: {0}")]
    IdentityError(String),

    #[error("Governance error: {0}")]
    GovernanceError(String),
}

pub type Result<T> = std::result::Result<T, Error>;===== END OF crates/icn_core/src/error.rs =====

===== START OF crates/icn_core/src/lib.rs =====
// crates/icn_core/src/lib.rs

mod error;
pub use error::{Error, Result};

use icn_blockchain::{Blockchain, Block, Transaction};
use icn_consensus::PoCConsensus;
use icn_currency::CurrencySystem;
use icn_governance::DemocraticSystem;
use icn_identity::DecentralizedIdentity;
use icn_network::Network;
use icn_sharding::ShardingManager;
use icn_vm::CoopVM;

pub struct IcnNode {
    pub blockchain: Blockchain,
    pub consensus: PoCConsensus,
    pub currency_system: CurrencySystem,
    pub democratic_system: DemocraticSystem,
    pub identity: DecentralizedIdentity,
    pub network: Network,
    pub sharding_manager: ShardingManager,
    pub vm: CoopVM,
}

impl IcnNode {
    pub fn new() -> Self {
        IcnNode {
            blockchain: Blockchain::new(),
            consensus: PoCConsensus::new(),
            currency_system: CurrencySystem::new(),
            democratic_system: DemocraticSystem::new(),
            identity: DecentralizedIdentity::new(),
            network: Network::new(),
            sharding_manager: ShardingManager::new(),
            vm: CoopVM::new(),
        }
    }

    pub fn process_transaction(&mut self, transaction: Transaction) -> Result<()> {
        self.blockchain.add_transaction(transaction)
    }

    pub fn create_block(&mut self) -> Result<()> {
        let pending_transactions = self.blockchain.pending_transactions().clone();
        let previous_hash = self.blockchain.latest_block().hash.clone();
        let new_block = Block::new(
            self.blockchain.chain().len() as u64,
            pending_transactions,
            previous_hash,
        );

        // Collect votes from validators
        let validators = self.consensus.get_validators();
        let votes: Vec<(&str, bool)> = validators.iter()
            .map(|v| (v.id.as_str(), self.collect_vote(&new_block, v)))
            .collect();

        // Add the block to the blockchain
        self.blockchain.add_block(new_block, &votes)
    }

    fn collect_vote(&self, block: &Block, validator: &icn_consensus::Member) -> bool {
        // In a real implementation, this would involve network communication
        // and potentially running the block through the VM to verify its validity
        // For now, we'll just return true as a placeholder
        true
    }

    pub fn execute_smart_contract(&mut self, contract: String) -> Result<()> {
        let compiled_contract = self.vm.compile(contract)?;
        self.vm.execute(compiled_contract)
    }

    pub fn create_proposal(&mut self, proposal: String) -> Result<String> {
        self.democratic_system.create_proposal(proposal)
    }

    pub fn vote_on_proposal(&mut self, proposal_id: &str, vote: bool) -> Result<()> {
        self.democratic_system.vote(proposal_id, vote)
    }

    pub fn allocate_resources(&mut self, resource_type: String, amount: u64) -> Result<()> {
        self.sharding_manager.allocate_resources(resource_type, amount)
    }

    pub fn update_reputation(&mut self, address: &str, change: f64) -> Result<()> {
        self.consensus.update_reputation(address, change)
    }

    pub fn get_balance(&self, address: &str) -> Result<f64> {
        self.blockchain.get_balance(address)
    }

    pub fn create_asset_token(&mut self, name: String, description: String, owner: String) -> Result<String> {
        let token = self.blockchain.create_asset_token(name, description, owner)?;
        Ok(token.id)
    }

    pub fn transfer_asset_token(&mut self, token_id: &str, new_owner: &str) -> Result<()> {
        self.blockchain.transfer_asset_token(token_id, new_owner)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_icn_node_creation() {
        let node = IcnNode::new();
        assert_eq!(node.blockchain.chain().len(), 1);
    }

    #[test]
    fn test_process_transaction() {
        let mut node = IcnNode::new();
        let transaction = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            100.0,
            icn_currency::CurrencyType::BasicNeeds,
        );
        assert!(node.process_transaction(transaction).is_ok());
    }

    #[test]
    fn test_create_block() {
        let mut node = IcnNode::new();
        let transaction = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            100.0,
            icn_currency::CurrencyType::BasicNeeds,
        );
        node.process_transaction(transaction).unwrap();
        assert!(node.create_block().is_ok());
        assert_eq!(node.blockchain.chain().len(), 2);
    }
}===== END OF crates/icn_core/src/lib.rs =====

===== START OF crates/icn_core/src/logging/mod.rs =====
use log::{info, warn, error, debug};

pub fn log_info(message: &str) {
    info!("{}", message);
}

pub fn log_warn(message: &str) {
    warn!("{}", message);
}

pub fn log_error(message: &str) {
    error!("{}", message);
}

pub fn log_debug(message: &str) {
    debug!("{}", message);
}===== END OF crates/icn_core/src/logging/mod.rs =====

===== START OF crates/icn_core/src/main.rs =====
use log::{info, warn, error};
use chrono::Utc;
use std::collections::HashMap;
use std::error::Error;
use std::sync::Arc;

use icn_core::{IcnNode, Error as IcnNodeError};
use icn_blockchain::Transaction;
use icn_consensus::PoCConsensus;
use icn_currency::CurrencyType;
use icn_governance::{DemocraticSystem, ProposalType, ProposalCategory};
use icn_identity::DecentralizedIdentity;
use icn_network::Network;
use icn_network::node::{Node, NodeType};
use icn_vm::CSCLCompiler;

fn main() -> Result<(), Box<dyn Error>> {
    env_logger::init();
    info!("Starting ICN Node");

    let node = Arc::new(IcnNode::new());
    let mut network = Network::new();
    let mut consensus = PoCConsensus::new(0.5, 0.66);
    let mut democratic_system = DemocraticSystem::new();

    setup_network_and_consensus(&mut network, &mut consensus)?;
    process_initial_transactions(Arc::clone(&node))?;
    create_and_vote_on_proposal(&mut democratic_system)?;
    compile_and_run_cscl(Arc::clone(&node))?;
    simulate_cross_shard_transaction(Arc::clone(&node))?;
    print_final_state(&node, &consensus, &democratic_system);

    info!("ICN Node simulation completed.");
    Ok(())
}

fn setup_network_and_consensus(network: &mut Network, consensus: &mut PoCConsensus) -> Result<(), Box<dyn Error>> {
    let node1 = Node::new("Node1", NodeType::PersonalDevice, "127.0.0.1:8000");
    let node2 = Node::new("Node2", NodeType::PersonalDevice, "127.0.0.1:8001");
    network.add_node(node1);
    network.add_node(node2);

    consensus.add_member("Alice".to_string(), false)?;
    consensus.add_member("Bob".to_string(), false)?;
    consensus.add_member("Charlie".to_string(), false)?;
    consensus.add_member("CorpX".to_string(), true)?;

    Ok(())
}

fn process_initial_transactions(node: Arc<IcnNode>) -> Result<(), Box<dyn Error>> {
    let (alice_did, _) = DecentralizedIdentity::new(HashMap::new());
    let (bob_did, _) = DecentralizedIdentity::new(HashMap::new());

    let tx = Transaction::new(
        alice_did.id.clone(),
        bob_did.id.clone(),
        100.0,
        CurrencyType::BasicNeeds,
        1000,
    );

    node.with_blockchain(|blockchain| {
        blockchain.add_transaction(tx.clone())?;
        blockchain.create_block("Alice".to_string())?;
        if let Some(latest_block) = blockchain.get_latest_block() {
            info!("New block created: {:?}", latest_block);
        } else {
            warn!("No blocks in the blockchain to broadcast");
        }
        Ok(())
    })?;

    Ok(())
}

fn create_and_vote_on_proposal(democratic_system: &mut DemocraticSystem) -> Result<(), Box<dyn Error>> {
    let proposal_id = democratic_system.create_proposal(
        "Community Garden".to_string(),
        "Create a community garden in the local park".to_string(),
        "Alice".to_string(),
        chrono::Duration::weeks(1),
        ProposalType::Constitutional,
        ProposalCategory::Economic,
        0.51,
        Some(Utc::now() + chrono::Duration::days(30)),
    )?;

    democratic_system.vote("Bob".to_string(), proposal_id.clone(), true, 1.0)?;
    democratic_system.vote("Charlie".to_string(), proposal_id.clone(), false, 1.0)?;
    democratic_system.vote("David".to_string(), proposal_id.clone(), true, 1.0)?;
    democratic_system.tally_votes(&proposal_id)?;

    let proposal = democratic_system.get_proposal(&proposal_id)
        .ok_or("Proposal not found after voting")?;
    info!("Proposal status after voting: {:?}", proposal.status);

    Ok(())
}

fn compile_and_run_cscl(node: Arc<IcnNode>) -> Result<(), Box<dyn Error>> {
    let cscl_code = r#"
    x = 100 + 50;
    y = 200 - 25;
    z = x * y / 10;
    emit("Result", z);
    "#;

    let mut compiler = CSCLCompiler::new(cscl_code);
    let opcodes = compiler.compile()?;
    
    node.with_coop_vm(|coop_vm| {
        coop_vm.load_program(opcodes);
        coop_vm.run().map_err(IcnNodeError::VmError)
    })?;

    Ok(())
}

fn simulate_cross_shard_transaction(node: Arc<IcnNode>) -> Result<(), Box<dyn Error>> {
    node.process_cross_shard_transaction(|sharding_manager| {
        sharding_manager.add_address_to_shard("Alice".to_string(), 0);
        sharding_manager.add_address_to_shard("Bob".to_string(), 1);
        sharding_manager.initialize_balance("Alice".to_string(), CurrencyType::BasicNeeds, 1000.0)
    })?;

    let transaction = Transaction::new(
        "Alice".to_string(),
        "Bob".to_string(),
        500.0,
        CurrencyType::BasicNeeds,
        1000,
    );

    node.process_cross_shard_transaction(|sharding_manager| {
        sharding_manager.transfer_between_shards(0, 1, &transaction)
    })?;

    let alice_balance = node.with_sharding_manager(|sharding_manager| {
        sharding_manager.get_balance("Alice".to_string(), CurrencyType::BasicNeeds)
    })?;

    let bob_balance = node.with_sharding_manager(|sharding_manager| {
        sharding_manager.get_balance("Bob".to_string(), CurrencyType::BasicNeeds)
    })?;

    info!("Alice's balance after cross-shard transaction: {:?}", alice_balance);
    info!("Bob's balance after cross-shard transaction: {:?}", bob_balance);

    Ok(())
}

fn print_final_state(node: &Arc<IcnNode>, consensus: &PoCConsensus, democratic_system: &DemocraticSystem) {
    info!("Blockchain state:");
    if let Err(e) = node.with_blockchain(|blockchain| {
        info!("Number of blocks: {}", blockchain.chain.len());
        if let Some(latest_block) = blockchain.get_latest_block() {
            info!("Latest block hash: {}", latest_block.hash);
        } else {
            warn!("No blocks in the blockchain");
        }
        Ok(())
    }) {
        error!("Failed to read blockchain state: {}", e);
    }

    info!("Consensus state:");
    info!("Number of members: {}", consensus.members.len());
    info!("Current vote threshold: {}", consensus.threshold);

    info!("Democratic system state:");
    info!("Number of active proposals: {}", democratic_system.list_active_proposals().len());

    info!("Sharding state:");
    if let Err(e) = node.with_sharding_manager(|sharding_manager| {
        info!("Number of shards: {}", sharding_manager.get_shard_count());
        Ok(())
    }) {
        error!("Failed to read sharding state: {}", e);
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_governance::democracy::ProposalStatus;
    use ed25519_dalek::Keypair;
    use rand::rngs::OsRng;

    #[test]
    fn test_icn_node_creation() {
        let node = Arc::new(IcnNode::new());
        assert!(node.with_blockchain(|blockchain| Ok(blockchain.chain.len() == 1)).unwrap());
        info!("ICN Node creation test passed");
    }

    #[test]
    fn test_cross_shard_transaction() -> Result<(), Box<dyn Error>> {
        let node = Arc::new(IcnNode::new());

        node.process_cross_shard_transaction(|sharding_manager| {
            sharding_manager.add_address_to_shard("Alice".to_string(), 0);
            sharding_manager.add_address_to_shard("Bob".to_string(), 1);
            sharding_manager.initialize_balance("Alice".to_string(), CurrencyType::BasicNeeds, 1000.0)
        })?;

        let mut csprng = OsRng{};
        let keypair: Keypair = Keypair::generate(&mut csprng);

        let mut transaction = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            500.0,
            CurrencyType::BasicNeeds,
            1000,
        );
        transaction.sign(&keypair)?;

        node.process_cross_shard_transaction(|sharding_manager| {
            sharding_manager.transfer_between_shards(0, 1, &transaction)
        })?;

        let alice_balance = node.with_sharding_manager(|sharding_manager| {
            sharding_manager.get_balance("Alice".to_string(), CurrencyType::BasicNeeds)
        })?;

        let bob_balance = node.with_sharding_manager(|sharding_manager| {
            sharding_manager.get_balance("Bob".to_string(), CurrencyType::BasicNeeds)
        })?;

        assert_eq!(alice_balance, 500.0);
        assert_eq!(bob_balance, 500.0);

        info!("Cross-shard transaction test passed");
        Ok(())
    }

    #[test]
    fn test_smart_contract_execution() -> Result<(), Box<dyn Error>> {
        let node = Arc::new(IcnNode::new());
        compile_and_run_cscl(Arc::clone(&node))?;
        info!("Smart contract execution test passed");
        Ok(())
    }

    #[test]
    fn test_democratic_system() -> Result<(), Box<dyn Error>> {
        let mut democratic_system = DemocraticSystem::new();
        
        let proposal_id = democratic_system.create_proposal(
            "Community Garden".to_string(),
            "Create a community garden in the local park".to_string(),
            "Alice".to_string(),
            chrono::Duration::seconds(5), // Shorter duration for testing
            ProposalType::Constitutional,
            ProposalCategory::Economic,
            0.51,
            Some(Utc::now() + chrono::Duration::days(30)),
        )?;

        democratic_system.vote("Bob".to_string(), proposal_id.clone(), true, 1.0)?;
        democratic_system.vote("Charlie".to_string(), proposal_id.clone(), false, 1.0)?;
        democratic_system.vote("David".to_string(), proposal_id.clone(), true, 1.0)?;

        // Wait for the voting period to end
        std::thread::sleep(std::time::Duration::from_secs(6));

        democratic_system.tally_votes(&proposal_id)?;

        let proposal = democratic_system.get_proposal(&proposal_id)
            .ok_or("Proposal not found after voting")?;
        assert_eq!(proposal.status, ProposalStatus::Passed);
        
        info!("Democratic system test passed");
        Ok(())
    }
}===== END OF crates/icn_core/src/main.rs =====

===== START OF crates/icn_core/src/security/mod.rs =====
use crate::error::Result;
use ed25519_dalek::{Keypair, PublicKey, Signature, Verifier};

pub struct SecurityManager {
    // Add fields as needed
}

impl SecurityManager {
    pub fn new() -> Self {
        SecurityManager {
            // Initialize fields
        }
    }

    pub fn verify_signature(&self, public_key: &PublicKey, message: &[u8], signature: &Signature) -> Result<bool> {
        Ok(public_key.verify(message, signature).is_ok())
    }

    pub fn generate_keypair() -> Keypair {
        Keypair::generate(&mut rand::thread_rng())
    }

    // Add more security-related methods as needed
}===== END OF crates/icn_core/src/security/mod.rs =====

===== START OF crates/icn_core/tests/blockchain_and_consensus_tests.rs =====
// Filename: src/tests/blockchain_and_consensus_tests.rs

use crate::blockchain::{Blockchain, Transaction};
use crate::currency::CurrencyType;
use crate::consensus::Consensus;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_blockchain_creation() {
        let blockchain = Blockchain::new();
        assert_eq!(blockchain.chain.len(), 1, "Blockchain should be initialized with one genesis block");
        assert_eq!(blockchain.chain[0].index, 0, "Genesis block should have index 0");
    }

    #[test]
    fn test_block_creation() {
        let mut blockchain = Blockchain::new();
        blockchain.consensus.add_member("Alice".to_string());
        let transactions = vec![
            Transaction::new("Alice".to_string(), "Bob".to_string(), 100.0, CurrencyType::BasicNeeds, 1000),
            Transaction::new("Bob".to_string(), "Charlie".to_string(), 50.0, CurrencyType::Education, 1000),
        ];
        let result = blockchain.create_block("Alice".to_string());
        assert!(result.is_ok(), "Block creation failed: {:?}", result.err());
        assert_eq!(blockchain.chain.len(), 2, "Blockchain should have two blocks after creation");
    }

    #[test]
    fn test_reputation_update() {
        let mut blockchain = Blockchain::new();
        blockchain.consensus.add_member("Alice".to_string());
        blockchain.consensus.update_reputation("Alice", 0.5);
        assert_eq!(blockchain.consensus.get_reputation("Alice"), Some(1.5), 
                   "Alice's reputation should be updated to 1.5");
    }

    #[test]
    fn test_voting() {
        let mut blockchain = Blockchain::new();
        blockchain.consensus.add_member("Alice".to_string());
        blockchain.consensus.add_member("Bob".to_string());
        blockchain.consensus.add_member("Charlie".to_string());
        
        let transactions = vec![
            Transaction::new("Alice".to_string(), "Bob".to_string(), 100.0, CurrencyType::BasicNeeds, 1000),
        ];
        blockchain.create_block("Alice".to_string()).expect("Block creation should succeed");
        
        assert!(blockchain.vote_on_block("Alice", 1, true).is_ok(), "Alice should be able to vote");
        assert!(blockchain.vote_on_block("Bob", 1, true).is_ok(), "Bob should be able to vote");
        assert!(blockchain.vote_on_block("Charlie", 1, true).is_ok(), "Charlie should be able to vote");
        
        assert!(blockchain.consensus.is_block_valid(1), "Block should be valid after voting");
    }
}
===== END OF crates/icn_core/tests/blockchain_and_consensus_tests.rs =====

===== START OF crates/icn_core/tests/blockchain_tests.rs =====
// Filename: src/tests/blockchain_tests.rs

use crate::blockchain::{Blockchain, Transaction};
use crate::currency::CurrencyType;

#[test]
fn test_blockchain_creation() {
    let blockchain = Blockchain::new();
    assert_eq!(blockchain.chain.len(), 1);
    assert_eq!(blockchain.chain[0].index, 0);
}

#[test]
fn test_add_block() {
    let mut blockchain = Blockchain::new();
    let transaction = Transaction::new(
        "Alice".to_string(),
        "Bob".to_string(),
        100.0,
        CurrencyType::BasicNeeds,
        1000,
    );
    blockchain.add_transaction(transaction);
    assert!(blockchain.create_block("Node1".to_string()).is_ok());
    assert_eq!(blockchain.chain.len(), 2);
}

#[test]
fn test_blockchain_validity() {
    let mut blockchain = Blockchain::new();
    let transaction = Transaction::new(
        "Alice".to_string(),
        "Bob".to_string(),
        100.0,
        CurrencyType::BasicNeeds,
        1000,
    );
    blockchain.add_transaction(transaction);
    assert!(blockchain.create_block("Node1".to_string()).is_ok());
    assert!(blockchain.is_chain_valid());
}
===== END OF crates/icn_core/tests/blockchain_tests.rs =====

===== START OF crates/icn_core/tests/icn_node_tests.rs =====
// Filename: src/tests/icn_node_tests.rs

// Import necessary modules and types
use crate::icn_node::{IcnNode, Packet, PacketType};
use std::net::SocketAddr;

#[test]
fn test_fib_functionality() {
    let mut node = IcnNode::new();
    let addr1: SocketAddr = "127.0.0.1:8000".parse().unwrap();
    let addr2: SocketAddr = "127.0.0.1:8001".parse().unwrap();

    node.fib.add_entry("/example/path".to_string(), addr1);
    node.fib.add_entry("/example/path".to_string(), addr2);

    let next_hops = node.fib.get_next_hops("/example/path");
    assert!(next_hops.is_some());
    assert_eq!(next_hops.unwrap().len(), 2);
    assert!(next_hops.unwrap().contains(&addr1));
    assert!(next_hops.unwrap().contains(&addr2));

    let longest_match = node.fib.longest_prefix_match("/example/path/subpath");
    assert!(longest_match.is_some());
    assert_eq!(longest_match.unwrap().name, "/example/path");
}

#[test]
fn test_content_store() {
    let mut node = IcnNode::new();
    let packet = Packet {
        packet_type: PacketType::Data,
        name: "/test/data".to_string(),
        content: vec![1, 2, 3, 4],
    };

    node.content_store.add(packet.name.clone(), packet.clone());
    let retrieved = node.content_store.get(&packet.name);
    assert!(retrieved.is_some());
    assert_eq!(retrieved.unwrap().content, vec![1, 2, 3, 4]);
}

#[test]
fn test_packet_processing() {
    let mut node = IcnNode::new();
    let addr: SocketAddr = "127.0.0.1:8000".parse().unwrap();
    node.add_interface("eth0".to_string(), addr);
    node.fib.add_entry("/test".to_string(), addr);

    let interest_packet = Packet {
        packet_type: PacketType::Interest,
        name: "/test/data".to_string(),
        content: vec![],
    };

    node.process_packet(interest_packet.clone(), "eth0");
    assert!(node.pit.has_pending_interest(&interest_packet.name));

    let data_packet = Packet {
        packet_type: PacketType::Data,
        name: "/test/data".to_string(),
        content: vec![1, 2, 3, 4],
    };

    node.process_packet(data_packet.clone(), "eth0");
    assert!(!node.pit.has_pending_interest(&data_packet.name));
    assert!(node.content_store.get(&data_packet.name).is_some());
}
===== END OF crates/icn_core/tests/icn_node_tests.rs =====

===== START OF crates/icn_core/tests/integration_tests.rs =====
use icn_node::blockchain::Blockchain;
use icn_node::smart_contract::{parse_contract, ContractType};

#[test]
fn test_smart_contract_integration() {
    let mut blockchain = Blockchain::new();

    // Deploy an asset transfer contract
    let contract_input = "Asset Transfer
Creator: Alice
From: Alice
To: Bob
Asset: ICN_TOKEN
Amount: 100.0";

    let contract = parse_contract(contract_input).unwrap();
    blockchain.deploy_smart_contract(contract).unwrap();

    // Deploy a proposal contract
    let proposal_input = "Proposal
Creator: Charlie
Title: New Community Project
Description: Implement a recycling program
Voting Period: 604800
Option 1: Approve
Option 2: Reject
Quorum: 0.5";

    let proposal_contract = parse_contract(proposal_input).unwrap();
    blockchain.deploy_smart_contract(proposal_contract).unwrap();

    // Execute smart contracts
    blockchain.execute_smart_contracts().unwrap();

    // Verify blockchain state
    assert_eq!(blockchain.chain.len(), 2); // Genesis block + 1 block with contracts
    assert_eq!(blockchain.chain.last().unwrap().smart_contracts.len(), 2);

    // Verify contract execution results
    let env = &blockchain.execution_environment;
    assert_eq!(env.balances.get("Bob").unwrap().get("ICN_TOKEN").unwrap(), &100.0);
    assert!(env.votes.contains_key(&blockchain.chain.last().unwrap().smart_contracts[1].id));
}===== END OF crates/icn_core/tests/integration_tests.rs =====

===== START OF crates/icn_core/tests/mod.rs =====
// ===============================================
// Tests Module
// ===============================================
// This module re-exports the contents of the tests submodules.
// The tests submodules contain various test cases to ensure
// the correctness and reliability of the blockchain implementation.

#[cfg(test)]
mod tests {
    use super::*;
    use crate::currency::CurrencyType;
    use ed25519_dalek::Keypair;
    use rand::rngs::OsRng;

    #[test]
    fn test_cross_shard_transaction() {
        let node = IcnNode::new();

        // Initialize balances
        {
            let mut sharding_manager = node.sharding_manager.write().unwrap();
            sharding_manager.add_address_to_shard("Alice".to_string(), 0);
            sharding_manager.add_address_to_shard("Bob".to_string(), 1);
            sharding_manager.initialize_balance("Alice".to_string(), CurrencyType::BasicNeeds, 1000.0);
        }

        let mut csprng = OsRng{};
        let keypair: Keypair = Keypair::generate(&mut csprng);

        let mut transaction = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            500.0,
            CurrencyType::BasicNeeds,
            1000,
        );
        if let Err(e) = transaction.sign(&keypair) {
            panic!("Failed to sign transaction: {}", e);
        }

        println!("Signed transaction: {:?}", transaction);

        assert!(node.process_cross_shard_transaction(&transaction).is_ok(), "Cross-shard transaction failed");

        // Check balances after transaction
        let sharding_manager = node.sharding_manager.read().unwrap();
        assert_eq!(sharding_manager.get_balance("Alice".to_string(), CurrencyType::BasicNeeds), 500.0);
        assert_eq!(sharding_manager.get_balance("Bob".to_string(), CurrencyType::BasicNeeds), 500.0);
    }
}
===== END OF crates/icn_core/tests/mod.rs =====

===== START OF crates/icn_core/tests/smart_contract_tests.rs =====
// Filename: src/tests/smart_contract_tests.rs

use crate::blockchain::Blockchain;
use crate::smart_contract::{parse_contract, ContractType};

#[test]
fn test_smart_contract_integration() {
    let mut blockchain = Blockchain::new();

    // Deploy an asset transfer contract
    let contract_input = "Asset Transfer
Creator: Alice
From: Alice
To: Bob
Asset: ICN_TOKEN
Amount: 100.0";

    let contract = parse_contract(contract_input).unwrap();
    blockchain.deploy_smart_contract(contract).unwrap();

    // Deploy a proposal contract
    let proposal_input = "Proposal
Creator: Charlie
Title: New Community Project
Description: Implement a recycling program
Voting Period: 604800
Option 1: Approve
Option 2: Reject
Quorum: 0.5";

    let proposal_contract = parse_contract(proposal_input).unwrap();
    blockchain.deploy_smart_contract(proposal_contract).unwrap();

    // Execute smart contracts
    blockchain.execute_smart_contracts().unwrap();

    // Verify blockchain state
    assert_eq!(blockchain.chain.len(), 2); // Genesis block + 1 block with contracts
    assert_eq!(blockchain.chain.last().unwrap().smart_contracts.len(), 2);

    // Verify contract execution results
    let env = &blockchain.execution_environment;
    assert_eq!(env.balances.get("Bob").unwrap().get("ICN_TOKEN").unwrap(), &100.0);
    assert!(env.votes.contains_key(&blockchain.chain.last().unwrap().smart_contracts[1].id));
}
===== END OF crates/icn_core/tests/smart_contract_tests.rs =====

===== START OF crates/icn_currency/Cargo.toml =====
[package]
name = "icn_currency"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_core = { path = "../icn_core" }
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
log = "0.4"
thiserror = "1.0"
uuid = { version = "0.8", features = ["v4"] }

[dev-dependencies]
tokio = { version = "1.0", features = ["full"] }===== END OF crates/icn_currency/Cargo.toml =====

===== START OF crates/icn_currency/src/asset_token.rs =====
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct AssetToken {
    pub asset_id: String,
    pub name: String,
    pub description: String,
    pub owner: String,
    pub value: f64,
}

impl AssetToken {
    pub fn new(asset_id: String, name: String, description: String, owner: String, value: f64) -> Self {
        AssetToken {
            asset_id,
            name,
            description,
            owner,
            value,
        }
    }

    pub fn transfer(&mut self, new_owner: String) {
        self.owner = new_owner;
    }
}===== END OF crates/icn_currency/src/asset_token.rs =====

===== START OF crates/icn_currency/src/bond.rs =====
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Bond {
    pub bond_id: String,
    pub name: String,
    pub description: String,
    pub issuer: String,
    pub face_value: f64,
    pub maturity_date: DateTime<Utc>,
    pub interest_rate: f64,
    pub owner: String,
}

impl Bond {
    pub fn new(bond_id: String, name: String, description: String, issuer: String, face_value: f64, maturity_date: DateTime<Utc>, interest_rate: f64, owner: String) -> Self {
        Bond {
            bond_id,
            name,
            description,
            issuer,
            face_value,
            maturity_date,
            interest_rate,
            owner,
        }
    }

    pub fn transfer(&mut self, new_owner: String) {
        self.owner = new_owner;
    }

    pub fn calculate_current_value(&self, current_date: DateTime<Utc>) -> f64 {
        if current_date >= self.maturity_date {
            self.face_value
        } else {
            let years_to_maturity = (self.maturity_date - current_date).num_days() as f64 / 365.0;
            self.face_value * (1.0 + self.interest_rate).powf(years_to_maturity)
        }
    }
}===== END OF crates/icn_currency/src/bond.rs =====

===== START OF crates/icn_currency/src/currency.rs =====
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use std::collections::HashMap;
use std::fmt;
use log::{info, error, debug, warn};
use icn_core::error::{Error, Result};

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, Hash)]
pub enum CurrencyType {
    BasicNeeds,
    Education,
    Environmental,
    Community,
    Volunteer,
    Storage,
    Processing,
    Energy,
    Luxury,
    Service,
    Custom(String),
    AssetToken(String),
    Bond(String),
}

impl fmt::Display for CurrencyType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            CurrencyType::Custom(name) => write!(f, "Custom({})", name),
            _ => write!(f, "{:?}", self),
        }
    }
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Currency {
    pub currency_type: CurrencyType,
    pub total_supply: f64,
    pub creation_date: DateTime<Utc>,
    pub last_issuance: DateTime<Utc>,
    pub issuance_rate: f64,
}

impl Currency {
    pub fn new(currency_type: CurrencyType, initial_supply: f64, issuance_rate: f64) -> Self {
        let now = Utc::now();
        debug!("Creating new currency: {:?}", currency_type);
        Currency {
            currency_type,
            total_supply: initial_supply,
            creation_date: now,
            last_issuance: now,
            issuance_rate,
        }
    }

    pub fn mint(&mut self, amount: f64) -> Result<()> {
        self.total_supply += amount;
        self.last_issuance = Utc::now();
        info!("Minted {} of {:?}. New total supply: {}", amount, self.currency_type, self.total_supply);
        Ok(())
    }

    pub fn burn(&mut self, amount: f64) -> Result<()> {
        if amount > self.total_supply {
            error!("Attempted to burn more {:?} than available. Requested: {}, Available: {}", self.currency_type, amount, self.total_supply);
            return Err(Error::CurrencyError("Insufficient supply to burn".to_string()));
        }
        self.total_supply -= amount;
        info!("Burned {} of {:?}. New total supply: {}", amount, self.currency_type, self.total_supply);
        Ok(())
    }
}

pub struct CurrencySystem {
    pub currencies: HashMap<CurrencyType, Currency>,
}

impl CurrencySystem {
    pub fn new() -> Self {
        debug!("Creating new CurrencySystem");
        let mut system = CurrencySystem {
            currencies: HashMap::new(),
        };
        
        system.add_currency(CurrencyType::BasicNeeds, 1_000_000.0, 0.01);
        system.add_currency(CurrencyType::Education, 500_000.0, 0.005);
        system.add_currency(CurrencyType::Environmental, 750_000.0, 0.008);
        system.add_currency(CurrencyType::Community, 250_000.0, 0.003);
        system.add_currency(CurrencyType::Volunteer, 100_000.0, 0.002);
        system.add_currency(CurrencyType::Storage, 1_000_000.0, 0.01);
        system.add_currency(CurrencyType::Processing, 500_000.0, 0.005);
        system.add_currency(CurrencyType::Energy, 750_000.0, 0.008);
        system.add_currency(CurrencyType::Luxury, 100_000.0, 0.001);
        system.add_currency(CurrencyType::Service, 200_000.0, 0.004);

        info!("CurrencySystem initialized with {} currencies", system.currencies.len());
        system
    }

    pub fn add_currency(&mut self, currency_type: CurrencyType, initial_supply: f64, issuance_rate: f64) {
        let currency = Currency::new(currency_type.clone(), initial_supply, issuance_rate);
        self.currencies.insert(currency_type.clone(), currency);
        info!("Added new currency: {:?}", currency_type);
    }

    pub fn get_currency(&self, currency_type: &CurrencyType) -> Option<&Currency> {
        self.currencies.get(currency_type)
    }

    pub fn get_currency_mut(&mut self, currency_type: &CurrencyType) -> Option<&mut Currency> {
        self.currencies.get_mut(currency_type)
    }

    pub fn create_custom_currency(&mut self, name: String, initial_supply: f64, issuance_rate: f64) -> Result<()> {
        let currency_type = CurrencyType::Custom(name.clone());
        if self.currencies.contains_key(&currency_type) {
            error!("Attempted to create duplicate custom currency: {}", name);
            return Err(Error::CurrencyError(format!("Currency '{}' already exists", name)));
        }
        self.add_currency(currency_type, initial_supply, issuance_rate);
        Ok(())
    }

    pub fn adaptive_issuance(&mut self) -> Result<()> {
        debug!("Performing adaptive issuance for all currencies");
        let now = Utc::now();
        for currency in self.currencies.values_mut() {
            let time_since_last_issuance = now.signed_duration_since(currency.last_issuance);
            let issuance_amount = currency.total_supply * currency.issuance_rate * time_since_last_issuance.num_milliseconds() as f64 / 86_400_000.0; // Daily rate
            currency.mint(issuance_amount)?;
            debug!("Adaptive issuance for {:?}: {}", currency.currency_type, issuance_amount);
        }
        info!("Adaptive issuance completed for all currencies");
        Ok(())
    }

    pub fn print_currency_supplies(&self) {
        info!("Current Currency Supplies:");
        for (currency_type, currency) in &self.currencies {
            info!("{:?}: {}", currency_type, currency.total_supply);
        }
    }
}===== END OF crates/icn_currency/src/currency.rs =====

===== START OF crates/icn_currency/src/lib.rs =====
mod currency;
mod wallet;
mod asset_token;
mod bond;

pub use currency::{Currency, CurrencyType, CurrencySystem};
pub use wallet::Wallet;
pub use asset_token::AssetToken;
pub use bond::Bond;

use icn_core::error::{Error, Result};

pub struct CurrencyManager {
    pub currency_system: CurrencySystem,
}

impl CurrencyManager {
    pub fn new() -> Self {
        CurrencyManager {
            currency_system: CurrencySystem::new(),
        }
    }

    pub fn create_wallet(&self) -> Wallet {
        Wallet::new()
    }

    pub fn create_asset_token(&self, asset_id: String, name: String, description: String, owner: String, value: f64) -> AssetToken {
        AssetToken::new(asset_id, name, description, owner, value)
    }

    pub fn create_bond(&self, bond_id: String, name: String, description: String, issuer: String, face_value: f64, maturity_date: chrono::DateTime<chrono::Utc>, interest_rate: f64, owner: String) -> Bond {
        Bond::new(bond_id, name, description, issuer, face_value, maturity_date, interest_rate, owner)
    }

    pub fn perform_adaptive_issuance(&mut self) -> Result<()> {
        self.currency_system.adaptive_issuance()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Utc;

    #[test]
    fn test_currency_manager() {
        let mut manager = CurrencyManager::new();
        
        // Test wallet creation and operations
        let mut wallet = manager.create_wallet();
        assert!(wallet.deposit(CurrencyType::BasicNeeds, 100.0).is_ok());
        assert_eq!(wallet.get_balance(&CurrencyType::BasicNeeds), 100.0);

        // Test asset token creation
        let asset = manager.create_asset_token(
            "ASSET1".to_string(),
            "Test Asset".to_string(),
            "A test asset".to_string(),
            "Alice".to_string(),
            1000.0
        );
        assert_eq!(asset.owner, "Alice");

        // Test bond creation
        let maturity_date = Utc::now() + chrono::Duration::days(365);
        let bond = manager.create_bond(
            "BOND1".to_string(),
            "Test Bond".to_string(),
            "A test bond".to_string(),
            "ICN".to_string(),
            1000.0,
            maturity_date,
            0.05,
            "Bob".to_string()
        );
        assert_eq!(bond.owner, "Bob");

        // Test adaptive issuance
        assert!(manager.perform_adaptive_issuance().is_ok());
    }
}===== END OF crates/icn_currency/src/lib.rs =====

===== START OF crates/icn_currency/src/wallet.rs =====
use super::CurrencyType;
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use log::{info, error, debug};
use icn_core::error::{Error, Result};

#[derive(Debug, Serialize, Deserialize)]
pub struct Wallet {
    balances: HashMap<CurrencyType, f64>,
}

impl Wallet {
    pub fn new() -> Self {
        debug!("Creating new Wallet");
        Wallet {
            balances: HashMap::new(),
        }
    }

    pub fn deposit(&mut self, currency_type: CurrencyType, amount: f64) -> Result<()> {
        if amount < 0.0 {
            return Err(Error::CurrencyError("Cannot deposit negative amount".to_string()));
        }
        *self.balances.entry(currency_type.clone()).or_insert(0.0) += amount;
        info!("Deposited {} of {:?} into wallet", amount, currency_type);
        Ok(())
    }

    pub fn withdraw(&mut self, currency_type: CurrencyType, amount: f64) -> Result<()> {
        if amount < 0.0 {
            return Err(Error::CurrencyError("Cannot withdraw negative amount".to_string()));
        }
        let balance = self.balances.entry(currency_type.clone()).or_insert(0.0);
        if *balance < amount {
            error!("Insufficient balance for withdrawal. Requested: {}, Available: {}", amount, balance);
            return Err(Error::CurrencyError(format!("Insufficient balance for {:?}", currency_type)));
        }
        *balance -= amount;
        info!("Withdrawn {} of {:?} from wallet", amount, currency_type);
        Ok(())
    }

    pub fn get_balance(&self, currency_type: &CurrencyType) -> f64 {
        *self.balances.get(currency_type).unwrap_or(&0.0)
    }

    pub fn print_balances(&self) {
        info!("Wallet Balances:");
        for (currency_type, balance) in &self.balances {
            info!("{:?}: {}", currency_type, balance);
        }
    }

    pub fn transfer(&mut self, to: &mut Wallet, currency_type: CurrencyType, amount: f64) -> Result<()> {
        self.withdraw(currency_type.clone(), amount)?;
        to.deposit(currency_type, amount)?;
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_wallet_operations() {
        let mut wallet = Wallet::new();
        
        // Test deposit
        assert!(wallet.deposit(CurrencyType::BasicNeeds, 100.0).is_ok());
        assert_eq!(wallet.get_balance(&CurrencyType::BasicNeeds), 100.0);

        // Test withdraw
        assert!(wallet.withdraw(CurrencyType::BasicNeeds, 50.0).is_ok());
        assert_eq!(wallet.get_balance(&CurrencyType::BasicNeeds), 50.0);

        // Test insufficient balance
        assert!(wallet.withdraw(CurrencyType::BasicNeeds, 100.0).is_err());

        // Test transfer
        let mut wallet2 = Wallet::new();
        assert!(wallet.transfer(&mut wallet2, CurrencyType::BasicNeeds, 25.0).is_ok());
        assert_eq!(wallet.get_balance(&CurrencyType::BasicNeeds), 25.0);
        assert_eq!(wallet2.get_balance(&CurrencyType::BasicNeeds), 25.0);
    }
}===== END OF crates/icn_currency/src/wallet.rs =====

===== START OF crates/icn_governance/Cargo.toml =====
[package]
name = "icn_governance"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_core = { path = "../icn_core" }
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
log = "0.4"
thiserror = "1.0"

[dev-dependencies]
tokio = { version = "1.0", features = ["full"] }===== END OF crates/icn_governance/Cargo.toml =====

===== START OF crates/icn_governance/src/democracy.rs =====
use crate::proposal::Proposal;
use crate::voting::Vote;
use icn_core::error::{Error, Result};
use chrono::{DateTime, Utc, Duration};
use serde::{Serialize, Deserialize};
use std::collections::HashMap;
use log::{info, error, debug, warn};

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum ProposalCategory {
    Constitutional,
    Economic,
    Technical,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum ProposalStatus {
    Active,
    Passed,
    Rejected,
    Implemented,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum ProposalType {
    Constitutional,
    EconomicAdjustment,
    NetworkUpgrade,
}

pub struct DemocraticSystem {
    proposals: HashMap<String, Proposal>,
    votes: HashMap<String, Vec<Vote>>,
}

impl DemocraticSystem {
    pub fn new() -> Self {
        debug!("Creating new DemocraticSystem");
        DemocraticSystem {
            proposals: HashMap::new(),
            votes: HashMap::new(),
        }
    }

    pub fn create_proposal(
        &mut self,
        title: String,
        description: String,
        proposer: String,
        voting_period: Duration,
        proposal_type: ProposalType,
        category: ProposalCategory,
        required_quorum: f64,
        execution_timestamp: Option<DateTime<Utc>>,
    ) -> Result<String> {
        let id = format!("prop_{}", Utc::now().timestamp());
        let proposal = Proposal::new(
            id.clone(),
            title,
            description,
            proposer,
            voting_period,
            proposal_type,
            category,
            required_quorum,
            execution_timestamp,
        );
        self.proposals.insert(id.clone(), proposal);
        info!("New proposal created: {}", id);
        Ok(id)
    }

    pub fn vote(&mut self, voter: String, proposal_id: String, in_favor: bool, weight: f64) -> Result<()> {
        let proposal = self.proposals.get(&proposal_id).ok_or(Error::GovernanceError("Proposal not found".to_string()))?;
        
        if proposal.status != ProposalStatus::Active {
            error!("Attempted to vote on inactive proposal: {}", proposal_id);
            return Err(Error::GovernanceError("Voting is not active for this proposal".to_string()));
        }

        if Utc::now() > proposal.voting_ends_at {
            error!("Attempted to vote on expired proposal: {}", proposal_id);
            return Err(Error::GovernanceError("Voting period has ended".to_string()));
        }

        let vote = Vote::new(voter, proposal_id.clone(), in_favor, weight);
        self.votes.entry(proposal_id.clone()).or_insert_with(Vec::new).push(vote);
        info!("Vote recorded for proposal: {}", proposal_id);
        Ok(())
    }

    pub fn tally_votes(&mut self, proposal_id: &str) -> Result<()> {
        let proposal = self.proposals.get_mut(proposal_id).ok_or(Error::GovernanceError("Proposal not found".to_string()))?;
        
        if proposal.status != ProposalStatus::Active {
            error!("Attempted to tally votes for inactive proposal: {}", proposal_id);
            return Err(Error::GovernanceError("Proposal is not active".to_string()));
        }

        if Utc::now() < proposal.voting_ends_at {
            warn!("Attempted to tally votes before voting period ended: {}", proposal_id);
            return Err(Error::GovernanceError("Voting period has not ended yet".to_string()));
        }

        let votes = self.votes.get(proposal_id).ok_or(Error::GovernanceError("No votes found for this proposal".to_string()))?;
        
        let total_weight: f64 = votes.iter().map(|v| v.weight).sum();
        let weight_in_favor: f64 = votes.iter().filter(|v| v.in_favor).map(|v| v.weight).sum();

        if total_weight < proposal.required_quorum {
            proposal.status = ProposalStatus::Rejected;
            info!("Proposal {} rejected due to insufficient quorum", proposal_id);
            return Ok(());
        }

        if weight_in_favor / total_weight > 0.5 {
            proposal.status = ProposalStatus::Passed;
            info!("Proposal {} passed", proposal_id);
        } else {
            proposal.status = ProposalStatus::Rejected;
            info!("Proposal {} rejected", proposal_id);
        }

        Ok(())
    }

    pub fn get_proposal(&self, proposal_id: &str) -> Option<&Proposal> {
        self.proposals.get(proposal_id)
    }

    pub fn get_votes(&self, proposal_id: &str) -> Option<&Vec<Vote>> {
        self.votes.get(proposal_id)
    }

    pub fn list_active_proposals(&self) -> Vec<&Proposal> {
        self.proposals.values()
            .filter(|p| p.status == ProposalStatus::Active)
            .collect()
    }

    pub fn mark_as_implemented(&mut self, proposal_id: &str) -> Result<()> {
        let proposal = self.proposals.get_mut(proposal_id).ok_or(Error::GovernanceError("Proposal not found".to_string()))?;
        
        if proposal.status != ProposalStatus::Passed {
            error!("Attempted to mark non-passed proposal as implemented: {}", proposal_id);
            return Err(Error::GovernanceError("Proposal has not passed".to_string()));
        }

        proposal.status = ProposalStatus::Implemented;
        info!("Proposal {} marked as implemented", proposal_id);
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_democratic_system() {
        let mut system = DemocraticSystem::new();
        
        // Create proposal
        let proposal_id = system.create_proposal(
            "Test Proposal".to_string(),
            "This is a test proposal".to_string(),
            "Alice".to_string(),
            Duration::days(7),
            ProposalType::Constitutional,
            ProposalCategory::Technical,
            0.5,
            None,
        ).unwrap();

        // Vote on proposal
        assert!(system.vote("Bob".to_string(), proposal_id.clone(), true, 1.0).is_ok());
        assert!(system.vote("Charlie".to_string(), proposal_id.clone(), false, 1.0).is_ok());
        assert!(system.vote("David".to_string(), proposal_id.clone(), true, 1.0).is_ok());

        // Try to tally votes before voting period ends (should fail)
        assert!(system.tally_votes(&proposal_id).is_err());

        // Simulate voting period end
        let proposal = system.proposals.get_mut(&proposal_id).unwrap();
        proposal.voting_ends_at = Utc::now() - Duration::hours(1);

        // Tally votes
        assert!(system.tally_votes(&proposal_id).is_ok());

        // Check proposal status
        let proposal = system.get_proposal(&proposal_id).unwrap();
        assert_eq!(proposal.status, ProposalStatus::Passed);

        // Mark as implemented
        assert!(system.mark_as_implemented(&proposal_id).is_ok());
        let updated_proposal = system.get_proposal(&proposal_id).unwrap();
        assert_eq!(updated_proposal.status, ProposalStatus::Implemented);
    }
}===== END OF crates/icn_governance/src/democracy.rs =====

===== START OF crates/icn_governance/src/lib.rs =====
mod democracy;
mod proposal;
mod voting;

pub use democracy::{DemocraticSystem, ProposalCategory, ProposalType, ProposalStatus};
pub use proposal::Proposal;
pub use voting::Vote;

use icn_core::error::{Error, Result};
use chrono::{DateTime, Utc, Duration};
use serde::{Serialize, Deserialize};
use std::collections::HashMap;

pub struct GovernanceSystem {
    democratic_system: DemocraticSystem,
}

impl GovernanceSystem {
    pub fn new() -> Self {
        GovernanceSystem {
            democratic_system: DemocraticSystem::new(),
        }
    }

    pub fn create_proposal(
        &mut self,
        title: String,
        description: String,
        proposer: String,
        voting_period: Duration,
        proposal_type: ProposalType,
        category: ProposalCategory,
        required_quorum: f64,
        execution_timestamp: Option<DateTime<Utc>>,
    ) -> Result<String> {
        self.democratic_system.create_proposal(
            title,
            description,
            proposer,
            voting_period,
            proposal_type,
            category,
            required_quorum,
            execution_timestamp,
        )
    }

    pub fn vote(&mut self, voter: String, proposal_id: String, in_favor: bool, weight: f64) -> Result<()> {
        self.democratic_system.vote(voter, proposal_id, in_favor, weight)
    }

    pub fn tally_votes(&mut self, proposal_id: &str) -> Result<()> {
        self.democratic_system.tally_votes(proposal_id)
    }

    pub fn get_proposal(&self, proposal_id: &str) -> Option<&Proposal> {
        self.democratic_system.get_proposal(proposal_id)
    }

    pub fn list_active_proposals(&self) -> Vec<&Proposal> {
        self.democratic_system.list_active_proposals()
    }

    pub fn mark_as_implemented(&mut self, proposal_id: &str) -> Result<()> {
        self.democratic_system.mark_as_implemented(proposal_id)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_governance_system() {
        let mut gov_system = GovernanceSystem::new();

        // Create a proposal
        let proposal_id = gov_system.create_proposal(
            "Test Proposal".to_string(),
            "This is a test proposal".to_string(),
            "Alice".to_string(),
            Duration::days(7),
            ProposalType::Constitutional,
            ProposalCategory::Technical,
            0.5,
            None,
        ).unwrap();

        // Vote on the proposal
        assert!(gov_system.vote("Bob".to_string(), proposal_id.clone(), true, 1.0).is_ok());
        assert!(gov_system.vote("Charlie".to_string(), proposal_id.clone(), false, 1.0).is_ok());
        assert!(gov_system.vote("David".to_string(), proposal_id.clone(), true, 1.0).is_ok());

        // Tally votes
        assert!(gov_system.tally_votes(&proposal_id).is_ok());

        // Check proposal status
        let proposal = gov_system.get_proposal(&proposal_id).unwrap();
        assert_eq!(proposal.status, ProposalStatus::Passed);

        // Mark as implemented
        assert!(gov_system.mark_as_implemented(&proposal_id).is_ok());
        let updated_proposal = gov_system.get_proposal(&proposal_id).unwrap();
        assert_eq!(updated_proposal.status, ProposalStatus::Implemented);
    }
}===== END OF crates/icn_governance/src/lib.rs =====

===== START OF crates/icn_governance/src/proposal.rs =====
use crate::democracy::{ProposalCategory, ProposalType, ProposalStatus};
use chrono::{DateTime, Utc, Duration};
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Proposal {
    pub id: String,
    pub title: String,
    pub description: String,
    pub proposer: String,
    pub created_at: DateTime<Utc>,
    pub voting_ends_at: DateTime<Utc>,
    pub status: ProposalStatus,
    pub proposal_type: ProposalType,
    pub category: ProposalCategory,
    pub required_quorum: f64,
    pub execution_timestamp: Option<DateTime<Utc>>,
}

impl Proposal {
    pub fn new(
        id: String,
        title: String,
        description: String,
        proposer: String,
        voting_period: Duration,
        proposal_type: ProposalType,
        category: ProposalCategory,
        required_quorum: f64,
        execution_timestamp: Option<DateTime<Utc>>,
    ) -> Self {
        let now = Utc::now();
        Proposal {
            id,
            title,
            description,
            proposer,
            created_at: now,
            voting_ends_at: now + voting_period,
            status: ProposalStatus::Active,
            proposal_type,
            category,
            required_quorum,
            execution_timestamp,
        }
    }
}===== END OF crates/icn_governance/src/proposal.rs =====

===== START OF crates/icn_governance/src/voting.rs =====
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Vote {
    pub voter: String,
    pub proposal_id: String,
    pub in_favor: bool,
    pub weight: f64,
    pub timestamp: DateTime<Utc>,
}

impl Vote {
    pub fn new(voter: String, proposal_id: String, in_favor: bool, weight: f64) -> Self {
        Vote {
            voter,
            proposal_id,
            in_favor,
            weight,
            timestamp: Utc::now(),
        }
    }
}===== END OF crates/icn_governance/src/voting.rs =====

===== START OF crates/icn_identity/Cargo.toml =====
[package]
name = "icn_identity"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_core = { path = "../icn_core" }
ed25519-dalek = "1.0"
rand = "0.7"
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
hex = "0.4"

[dev-dependencies]
tokio = { version = "1.0", features = ["full"] }===== END OF crates/icn_identity/Cargo.toml =====

===== START OF crates/icn_identity/src/did.rs =====
use chrono::{DateTime, Utc};
use ed25519_dalek::{Keypair, PublicKey, Signature, Verifier};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct DecentralizedIdentity {
    pub id: String,
    #[serde(with = "public_key_serde")]
    pub public_key: PublicKey,
    pub created_at: DateTime<Utc>,
    pub reputation: f64,
    pub attributes: HashMap<String, String>,
}

mod public_key_serde {
    use ed25519_dalek::PublicKey;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};

    pub fn serialize<S>(public_key: &PublicKey, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let bytes = public_key.to_bytes();
        bytes.serialize(serializer)
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<PublicKey, D::Error>
    where
        D: Deserializer<'de>,
    {
        let bytes = Vec::<u8>::deserialize(deserializer)?;
        PublicKey::from_bytes(&bytes).map_err(serde::de::Error::custom)
    }
}

impl DecentralizedIdentity {
    pub fn new(attributes: HashMap<String, String>) -> (Self, Keypair) {
        let mut csprng = rand::rngs::OsRng {};
        let keypair: Keypair = Keypair::generate(&mut csprng);
        let public_key = keypair.public;
        let id = format!("did:icn:{}", hex::encode(public_key.to_bytes()));

        (
            Self {
                id,
                public_key,
                created_at: Utc::now(),
                reputation: 1.0,
                attributes,
            },
            keypair,
        )
    }

    pub fn verify_signature(&self, message: &[u8], signature: &Signature) -> bool {
        self.public_key.verify(message, signature).is_ok()
    }
}===== END OF crates/icn_identity/src/did.rs =====

===== START OF crates/icn_identity/src/identity_manager.rs =====
use crate::DecentralizedIdentity;
use ed25519_dalek::Signature;
use icn_core::error::{Error, Result};
use std::collections::HashMap;

pub struct IdentityManager {
    identities: HashMap<String, DecentralizedIdentity>,
}

impl IdentityManager {
    pub fn new() -> Self {
        IdentityManager {
            identities: HashMap::new(),
        }
    }

    pub fn create_identity(&mut self, attributes: HashMap<String, String>) -> Result<DecentralizedIdentity> {
        let (identity, _) = DecentralizedIdentity::new(attributes);
        self.identities.insert(identity.id.clone(), identity.clone());
        Ok(identity)
    }

    pub fn get_identity(&self, id: &str) -> Option<&DecentralizedIdentity> {
        self.identities.get(id)
    }

    pub fn update_reputation(&mut self, id: &str, change: f64) -> Result<()> {
        let identity = self.identities.get_mut(id).ok_or(Error::IdentityError("Identity not found".to_string()))?;
        identity.reputation += change;
        Ok(())
    }

    pub fn verify_signature(&self, id: &str, message: &[u8], signature: &Signature) -> Result<bool> {
        let identity = self.identities.get(id).ok_or(Error::IdentityError("Identity not found".to_string()))?;
        Ok(identity.verify_signature(message, signature))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use ed25519_dalek::{Keypair, Signer};

    #[test]
    fn test_identity_management() {
        let mut manager = IdentityManager::new();
        
        // Create a new identity
        let mut attributes = HashMap::new();
        attributes.insert("name".to_string(), "Alice".to_string());
        let identity = manager.create_identity(attributes).unwrap();
        
        // Verify the identity exists
        assert!(manager.get_identity(&identity.id).is_some());
        
        // Update reputation
        assert!(manager.update_reputation(&identity.id, 0.5).is_ok());
        let updated_identity = manager.get_identity(&identity.id).unwrap();
        assert_eq!(updated_identity.reputation, 1.5);
        
        // Test signature verification
        let message = b"Hello, World!";
        let mut csprng = rand::rngs::OsRng {};
        let keypair = Keypair::generate(&mut csprng);
        let signature = keypair.sign(message);
        
        // This should fail because we're using a different keypair
        assert!(!manager.verify_signature(&identity.id, message, &signature).unwrap());
    }
}===== END OF crates/icn_identity/src/identity_manager.rs =====

===== START OF crates/icn_identity/src/lib.rs =====
mod did;
mod identity_manager;

pub use did::DecentralizedIdentity;
pub use identity_manager::IdentityManager;

use icn_core::error::{Error, Result};===== END OF crates/icn_identity/src/lib.rs =====

===== START OF crates/icn_network/Cargo.toml =====
[package]
name = "icn_network"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_core = { path = "../icn_core" }
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
log = "0.4"
thiserror = "1.0"

[dev-dependencies]
tokio = { version = "1.0", features = ["full"] }
===== END OF crates/icn_network/Cargo.toml =====

===== START OF crates/icn_network/src/discovery.rs =====
use crate::node::Node;
use icn_core::error::Result;

pub struct DiscoveryService;

impl DiscoveryService {
    pub fn new() -> Self {
        DiscoveryService
    }

    pub fn register_node(&self, node: &Node) -> Result<()> {
        // Implement node registration logic
        Ok(())
    }

    pub fn unregister_node(&self, node_id: &str) -> Result<()> {
        // Implement node unregistration logic
        Ok(())
    }
}
===== END OF crates/icn_network/src/discovery.rs =====

===== START OF crates/icn_network/src/lib.rs =====
mod node;
mod packet;
mod routing;
mod protocol;
mod security;
mod discovery;
mod naming;

pub use node::{Node, NodeType};
pub use packet::{Packet, PacketType};
pub use routing::RoutingTable;
pub use protocol::NetworkProtocol;
pub use security::SecurityManager;
pub use discovery::DiscoveryService;
pub use naming::NamingService;

use icn_core::error::{Error, Result};

pub struct Network {
    nodes: Vec<Node>,
    routing_table: RoutingTable,
    protocol: NetworkProtocol,
    security_manager: SecurityManager,
    discovery_service: DiscoveryService,
    naming_service: NamingService,
}

impl Network {
    pub fn new() -> Self {
        Network {
            nodes: Vec::new(),
            routing_table: RoutingTable::new(),
            protocol: NetworkProtocol::new(),
            security_manager: SecurityManager::new(),
            discovery_service: DiscoveryService::new(),
            naming_service: NamingService::new(),
        }
    }

    pub fn add_node(&mut self, node: Node) -> Result<()> {
        self.nodes.push(node);
        self.discovery_service.register_node(&node)?;
        self.routing_table.update(&self.nodes)?;
        Ok(())
    }

    pub fn remove_node(&mut self, node_id: &str) -> Result<()> {
        self.nodes.retain(|n| n.id != node_id);
        self.discovery_service.unregister_node(node_id)?;
        self.routing_table.update(&self.nodes)?;
        Ok(())
    }

    pub fn send_packet(&self, packet: Packet) -> Result<()> {
        self.security_manager.validate_packet(&packet)?;
        let route = self.routing_table.get_route(&packet.destination)?;
        self.protocol.send_packet(&packet, &route)
    }

    pub fn receive_packet(&self, packet: Packet) -> Result<()> {
        self.security_manager.validate_packet(&packet)?;
        self.protocol.process_packet(packet)
    }

    pub fn resolve_name(&self, name: &str) -> Result<String> {
        self.naming_service.resolve(name)
    }

    pub fn register_name(&mut self, name: &str, address: &str) -> Result<()> {
        self.naming_service.register(name, address)
    }
}
===== END OF crates/icn_network/src/lib.rs =====

===== START OF crates/icn_network/src/naming.rs =====
use icn_core::error::{Error, Result};
use std::collections::HashMap;

pub struct NamingService {
    names: HashMap<String, String>,
}

impl NamingService {
    pub fn new() -> Self {
        NamingService {
            names: HashMap::new(),
        }
    }

    pub fn resolve(&self, name: &str) -> Result<String> {
        self.names.get(name)
            .cloned()
            .ok_or_else(|| Error::NetworkError("Name not found".to_string()))
    }

    pub fn register(&mut self, name: &str, address: &str) -> Result<()> {
        if self.names.contains_key(name) {
            return Err(Error::NetworkError("Name already registered".to_string()));
        }
        self.names.insert(name.to_string(), address.to_string());
        Ok(())
    }
}
===== END OF crates/icn_network/src/naming.rs =====

===== START OF crates/icn_network/src/network.rs =====
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use crate::blockchain::Block;
use super::node::Node;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Network {
    nodes: HashMap<String, Node>,
}

impl Network {
    pub fn new() -> Self {
        Network {
            nodes: HashMap::new(),
        }
    }

    pub fn add_node(&mut self, node: Node) {
        self.nodes.insert(node.id.clone(), node);
    }

    pub fn remove_node(&mut self, node_id: &str) {
        self.nodes.remove(node_id);
    }

    pub fn get_node(&self, node_id: &str) -> Option<&Node> {
        self.nodes.get(node_id)
    }

    pub fn broadcast_block(&self, block: &Block) {
        println!("Broadcasting block {} to all nodes", block.index);
        // Actual implementation would involve network communication
    }

    pub fn synchronize_blockchain(&self, _blockchain: &[Block]) {
        // Implement synchronization logic here
    }

    pub fn get_all_nodes(&self) -> Vec<&Node> {
        self.nodes.values().collect()
    }

    pub fn node_count(&self) -> usize {
        self.nodes.len()
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum PacketType {
    Interest,
    Data,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Packet {
    pub packet_type: PacketType,
    pub name: String,
    pub content: Vec<u8>,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::network::node::NodeType;

    #[test]
    fn test_network_operations() {
        let mut network = Network::new();

        let node1 = Node::new("node1", NodeType::PersonalDevice, "192.168.1.1");
        let node2 = Node::new("node2", NodeType::CooperativeServer, "192.168.1.2");
        network.add_node(node1.clone());
        network.add_node(node2.clone());

        assert_eq!(network.node_count(), 2);

        let retrieved_node = network.get_node("node1").unwrap();
        assert_eq!(retrieved_node.id, "node1");
        assert_eq!(retrieved_node.address, "192.168.1.1");

        network.remove_node("node1");
        assert_eq!(network.node_count(), 1);
        assert!(network.get_node("node1").is_none());

        let block = Block {
            index: 1,
            timestamp: 0,
            transactions: vec![],
            previous_hash: "previous_hash".to_string(),
            hash: "hash".to_string(),
            nonce: 0,
            gas_used: 0,
            smart_contract_results: HashMap::new(),
        };
        network.broadcast_block(&block);

        network.synchronize_blockchain(&[block]);
    }

    #[test]
    fn test_packet_creation() {
        let packet = Packet {
            packet_type: PacketType::Interest,
            name: "test_packet".to_string(),
            content: vec![1, 2, 3, 4],
        };

        assert_eq!(packet.name, "test_packet");
        assert_eq!(packet.content, vec![1, 2, 3, 4]);

        match packet.packet_type {
            PacketType::Interest => assert!(true),
            _ => assert!(false, "Unexpected packet type"),
        }
    }
}===== END OF crates/icn_network/src/network.rs =====

===== START OF crates/icn_network/src/node.rs =====
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub enum NodeType {
    PersonalDevice,
    CooperativeServer,
    GovernmentServer,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Node {
    pub id: String,
    pub node_type: NodeType,
    pub address: String,
}

impl Node {
    pub fn new(id: &str, node_type: NodeType, address: &str) -> Self {
        Node {
            id: id.to_string(),
            node_type,
            address: address.to_string(),
        }
    }
}
===== END OF crates/icn_network/src/node.rs =====

===== START OF crates/icn_network/src/packet.rs =====
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PacketType {
    Data,
    Interest,
    Control,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Packet {
    pub packet_type: PacketType,
    pub source: String,
    pub destination: String,
    pub content: Vec<u8>,
}

impl Packet {
    pub fn new(packet_type: PacketType, source: String, destination: String, content: Vec<u8>) -> Self {
        Packet {
            packet_type,
            source,
            destination,
            content,
        }
    }
}
===== END OF crates/icn_network/src/packet.rs =====

===== START OF crates/icn_network/src/protocol.rs =====
use crate::packet::Packet;
use icn_core::error::Result;

pub struct NetworkProtocol;

impl NetworkProtocol {
    pub fn new() -> Self {
        NetworkProtocol
    }

    pub fn send_packet(&self, packet: &Packet, route: &str) -> Result<()> {
        // Implement packet sending logic
        Ok(())
    }

    pub fn process_packet(&self, packet: Packet) -> Result<()> {
        // Implement packet processing logic
        Ok(())
    }
}
===== END OF crates/icn_network/src/protocol.rs =====

===== START OF crates/icn_network/src/routing.rs =====
use crate::node::Node;
use icn_core::error::{Error, Result};
use std::collections::HashMap;

pub struct RoutingTable {
    routes: HashMap<String, String>,
}

impl RoutingTable {
    pub fn new() -> Self {
        RoutingTable {
            routes: HashMap::new(),
        }
    }

    pub fn update(&mut self, nodes: &[Node]) -> Result<()> {
        // Implement routing table update logic
        // This could involve shortest path algorithms or other routing strategies
        Ok(())
    }

    pub fn get_route(&self, destination: &str) -> Result<String> {
        self.routes.get(destination)
            .cloned()
            .ok_or_else(|| Error::NetworkError("Route not found".to_string()))
    }
}
===== END OF crates/icn_network/src/routing.rs =====

===== START OF crates/icn_network/src/security.rs =====
use crate::packet::Packet;
use icn_core::error::Result;

pub struct SecurityManager;

impl SecurityManager {
    pub fn new() -> Self {
        SecurityManager
    }

    pub fn validate_packet(&self, packet: &Packet) -> Result<()> {
        // Implement packet validation logic
        // This could include signature verification, encryption checks, etc.
        Ok(())
    }
}
===== END OF crates/icn_network/src/security.rs =====

===== START OF crates/icn_node_managment/Cargo.toml =====
[package]
name = "icn_node_management"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_core = { path = "../icn_core" }
icn_network = { path = "../icn_network" }
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
log = "0.4"
thiserror = "1.0"

[dev-dependencies]
tokio = { version = "1.0", features = ["full"] }
===== END OF crates/icn_node_managment/Cargo.toml =====

===== START OF crates/icn_node_managment/src/content_store.rs =====
use std::collections::HashMap;
use std::time::{Duration, Instant};

const MAX_CACHE_SIZE: usize = 1000;
const DEFAULT_TTL: Duration = Duration::from_secs(3600);

struct CacheEntry {
    content: Vec<u8>,
    timestamp: Instant,
    ttl: Duration,
}

pub struct ContentStore {
    cache: HashMap<String, CacheEntry>,
}

impl ContentStore {
    pub fn new() -> Self {
        ContentStore {
            cache: HashMap::new(),
        }
    }

    pub fn add(&mut self, name: String, content: Vec<u8>) {
        self.cache.insert(name, CacheEntry {
            content,
            timestamp: Instant::now(),
            ttl: DEFAULT_TTL,
        });

        if self.cache.len() > MAX_CACHE_SIZE {
            self.evict_oldest();
        }
    }

    pub fn get(&self, name: &str) -> Option<Vec<u8>> {
        self.cache.get(name).and_then(|entry| {
            if entry.timestamp.elapsed() < entry.ttl {
                Some(entry.content.clone())
            } else {
                None
            }
        })
    }

    pub fn get_and_pop(&mut self, name: &str) -> Option<Vec<u8>> {
        if let Some(entry) = self.cache.remove(name) {
            if entry.timestamp.elapsed() < entry.ttl {
                Some(entry.content)
            } else {
                None
            }
        } else {
            None
        }
    }

    fn evict_oldest(&mut self) {
        if let Some(oldest_key) = self.cache.keys().next().cloned() {
            self.cache.remove(&oldest_key);
        }
    }

    pub fn remove_expired(&mut self) {
        let now = Instant::now();
        self.cache.retain(|_, entry| now.duration_since(entry.timestamp) < entry.ttl);
    }

    pub fn set_ttl(&mut self, name: &str, ttl: Duration) {
        if let Some(entry) = self.cache.get_mut(name) {
            entry.ttl = ttl;
        }
    }

    pub fn is_empty(&self) -> bool {
        self.cache.is_empty()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_content_store() {
        let mut cs = ContentStore::new();
        let content = vec![1, 2, 3, 4];
        cs.add("test".to_string(), content.clone());

        assert_eq!(cs.get("test"), Some(content.clone()));
        assert_eq!(cs.get("nonexistent"), None);

        cs.set_ttl("test", Duration::from_secs(1));
        std::thread::sleep(Duration::from_secs(2));
        assert_eq!(cs.get("test"), None);

        cs.add("test2".to_string(), vec![5, 6, 7, 8]);
        assert!(!cs.is_empty());

        cs.remove_expired();
        assert_eq!(cs.get("test2"), Some(vec![5, 6, 7, 8]));
    }
}
===== END OF crates/icn_node_managment/src/content_store.rs =====

===== START OF crates/icn_node_managment/src/fib.rs =====
use std::collections::HashMap;
use std::net::SocketAddr;

/// Represents an entry in the Forwarding Information Base (FIB).
#[derive(Debug, Clone)]
pub struct FibEntry {
    pub name: String,           // The name of the content or prefix.
    pub next_hops: Vec<SocketAddr>, // The list of next hop addresses.
}

impl FibEntry {
    pub fn new(name: String, next_hop: SocketAddr) -> Self {
        FibEntry {
            name,
            next_hops: vec![next_hop],
        }
    }

    pub fn add_next_hop(&mut self, next_hop: SocketAddr) {
        if !self.next_hops.contains(&next_hop) {
            self.next_hops.push(next_hop);
        }
    }

    pub fn remove_next_hop(&mut self, next_hop: &SocketAddr) {
        self.next_hops.retain(|&x| x != *next_hop);
    }
}

/// Represents the Forwarding Information Base (FIB) which stores FIB entries.
pub struct ForwardingInformationBase {
    entries: HashMap<String, FibEntry>, // The collection of FIB entries, indexed by name.
}

impl ForwardingInformationBase {
    pub fn new() -> Self {
        ForwardingInformationBase {
            entries: HashMap::new(),
        }
    }

    pub fn add_entry(&mut self, name: String, next_hop: SocketAddr) {
        self.entries
            .entry(name.clone())
            .and_modify(|e| e.add_next_hop(next_hop))
            .or_insert_with(|| FibEntry::new(name, next_hop));
    }

    pub fn remove_entry(&mut self, name: &str) {
        self.entries.remove(name);
    }

    pub fn get_next_hops(&self, name: &str) -> Option<&Vec<SocketAddr>> {
        self.entries.get(name).map(|entry| &entry.next_hops)
    }

    pub fn longest_prefix_match(&self, name: &str) -> Option<&FibEntry> {
        self.entries
            .iter()
            .filter(|(prefix, _)| name.starts_with(*prefix))
            .max_by_key(|(prefix, _)| prefix.len())
            .map(|(_, entry)| entry)
    }

    pub fn is_empty(&self) -> bool {
        self.entries.is_empty()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fib() {
        let mut fib = ForwardingInformationBase::new();

        let addr1: SocketAddr = "127.0.0.1:8000".parse().unwrap();
        let addr2: SocketAddr = "127.0.0.1:8001".parse().unwrap();

        fib.add_entry("/test".to_string(), addr1);
        fib.add_entry("/test/nested".to_string(), addr2);

        assert_eq!(fib.get_next_hops("/test").unwrap().len(), 1);
        assert_eq!(fib.get_next_hops("/test/nested").unwrap().len(), 1);

        let longest_match = fib.longest_prefix_match("/test/nested/deep");
        assert!(longest_match.is_some());
        assert_eq!(longest_match.unwrap().name, "/test/nested");

        fib.remove_entry("/test");
        assert!(fib.get_next_hops("/test").is_none());

        let mut entry = FibEntry::new("/example".to_string(), addr1);
        entry.add_next_hop(addr2);
        assert_eq!(entry.next_hops.len(), 2);
        entry.remove_next_hop(&addr1);
        assert_eq!(entry.next_hops.len(), 1);
        assert_eq!(entry.next_hops[0], addr2);
    }
}
===== END OF crates/icn_node_managment/src/fib.rs =====

===== START OF crates/icn_node_managment/src/icn_node.rs =====
// ===============================================
// ICN Node Implementation
// ===============================================
// This file contains the main implementation for the ICN (InterCooperative Network) node.
// It includes module declarations and the primary structure and functions for node operations.
//
// Key concepts:
// - Modular Structure: Using Rust's module system to organize code.
// - Node Operations: Handling packets, managing blockchain state, and executing smart contracts.

pub mod blockchain;
pub mod consensus;
pub mod currency;
pub mod democracy;
pub mod did;
pub mod network;
pub mod node;
pub mod smart_contract;
pub mod vm;

pub use crate::blockchain::{Block, Transaction, Blockchain};
pub use crate::consensus::PoCConsensus;
pub use crate::currency::{CurrencyType, CurrencySystem, Wallet};
pub use crate::democracy::{DemocraticSystem, ProposalCategory, ProposalType};
pub use crate::did::{DecentralizedIdentity, DidManager};
pub use crate::network::{Node as NetworkNode, Network};
pub use crate::node::{ContentStore, ForwardingInformationBase, Packet, PacketType, PendingInterestTable};
pub use crate::blockchain::TransactionValidator;
pub use crate::vm::{CoopVM, Opcode, Value, CSCLCompiler};

use std::sync::{Arc, Mutex};
use std::error::Error;

/// ICN Node Structure
///
/// This struct represents a node in the InterCooperative Network (ICN).
/// It holds the state for content storage, pending interest table (PIT), forwarding information base (FIB),
/// the blockchain, and the cooperative virtual machine (CoopVM).
///
/// # Fields
/// * `content_store` - Stores data packets
/// * `pit` - Manages pending interest table for interest packets
/// * `fib` - Manages forwarding information base for routing
/// * `blockchain` - The blockchain state
/// * `coop_vm` - The cooperative virtual machine for executing smart contracts
pub struct ICNNode {
    pub content_store: Arc<Mutex<ContentStore>>,
    pub pit: Arc<Mutex<PendingInterestTable>>,
    pub fib: Arc<Mutex<ForwardingInformationBase>>,
    pub blockchain: Arc<Mutex<Blockchain>>,
    pub coop_vm: Arc<Mutex<CoopVM>>,
}

impl ICNNode {
    /// Creates a new ICN Node
    ///
    /// This function initializes a new ICN node with the provided blockchain and cooperative VM instances.
    ///
    /// # Arguments
    /// * `blockchain` - The initial blockchain state
    /// * `coop_vm` - The initial cooperative VM instance
    ///
    /// # Returns
    /// A new instance of `ICNNode`
    pub fn new(blockchain: Blockchain, coop_vm: CoopVM) -> Self {
        Self {
            content_store: Arc::new(Mutex::new(ContentStore::new())),
            pit: Arc::new(Mutex::new(PendingInterestTable::new())),
            fib: Arc::new(Mutex::new(ForwardingInformationBase::new())),
            blockchain: Arc::new(Mutex::new(blockchain)),
            coop_vm: Arc::new(Mutex::new(coop_vm)),
        }
    }

    /// Processes an incoming packet
    ///
    /// This function processes different types of packets by delegating to the appropriate handler.
    ///
    /// # Arguments
    /// * `packet` - The packet to be processed
    ///
    /// # Returns
    /// A result indicating success or failure
    ///
    /// # Errors
    /// This function will return an error if the packet processing fails.
    pub fn process_packet(&self, packet: Packet) -> Result<(), Box<dyn Error>> {
        match packet.packet_type {
            PacketType::Interest => self.process_interest(packet),
            PacketType::Data => self.process_data(packet),
        }
    }

    /// Processes an interest packet
    ///
    /// Interest packets request specific data from the network. This function handles those requests.
    ///
    /// # Arguments
    /// * `packet` - The interest packet to be processed
    ///
    /// # Returns
    /// A result indicating success or failure
    ///
    /// # Errors
    /// This function will return an error if processing the interest packet fails.
    fn process_interest(&self, packet: Packet) -> Result<(), Box<dyn Error>> {
        // Logic to process interest packets
        Ok(())
    }

    /// Processes a data packet
    ///
    /// Data packets contain the requested information. This function handles those packets.
    ///
    /// # Arguments
    /// * `packet` - The data packet to be processed
    ///
    /// # Returns
    /// A result indicating success or failure
    ///
    /// # Errors
    /// This function will return an error if processing the data packet fails.
    fn process_data(&self, packet: Packet) -> Result<(), Box<dyn Error>> {
        // Logic to process data packets
        Ok(())
    }

    /// Executes a smart contract
    ///
    /// This function executes a given smart contract using the cooperative VM.
    ///
    /// # Arguments
    /// * `contract` - The smart contract to be executed
    ///
    /// # Returns
    /// A result indicating success or failure
    ///
    /// # Errors
    /// This function will return an error if executing the smart contract fails.
    pub fn execute_smart_contract(&self, contract: String) -> Result<(), Box<dyn Error>> {
        // Logic to execute smart contract
        Ok(())
    }

    /// Compiles a smart contract
    ///
    /// This function compiles a smart contract string into a sequence of opcodes.
    ///
    /// # Arguments
    /// * `contract` - The smart contract code as a string
    ///
    /// # Returns
    /// A vector of opcodes representing the compiled contract
    ///
    /// # Errors
    /// This function will return an error if compiling the contract fails.
    fn compile_contract(&self, contract: &str) -> Result<Vec<Opcode>, Box<dyn Error>> {
        // Logic to compile contract
        Ok(vec![])
    }
}
===== END OF crates/icn_node_managment/src/icn_node.rs =====

===== START OF crates/icn_node_managment/src/lib.rs =====
mod content_store;
mod fib;
mod pit;

pub use content_store::ContentStore;
pub use fib::ForwardingInformationBase;
pub use pit::PendingInterestTable;

use icn_core::error::{Error, Result};
use icn_network::Node as NetworkNode;

pub struct IcnNodeManager {
    network_node: NetworkNode,
    content_store: ContentStore,
    fib: ForwardingInformationBase,
    pit: PendingInterestTable,
}

impl IcnNodeManager {
    pub fn new(network_node: NetworkNode) -> Self {
        IcnNodeManager {
            network_node,
            content_store: ContentStore::new(),
            fib: ForwardingInformationBase::new(),
            pit: PendingInterestTable::new(),
        }
    }

    pub fn add_content(&mut self, name: String, content: Vec<u8>) -> Result<()> {
        self.content_store.add(name, content);
        Ok(())
    }

    pub fn get_content(&self, name: &str) -> Option<Vec<u8>> {
        self.content_store.get(name)
    }

    pub fn add_fib_entry(&mut self, prefix: String, next_hop: String) -> Result<()> {
        self.fib.add_entry(prefix, next_hop);
        Ok(())
    }

    pub fn add_pit_entry(&mut self, name: String, incoming_face: String) -> Result<()> {
        self.pit.add_interest(name, &incoming_face);
        Ok(())
    }

    pub fn remove_expired_content(&mut self) {
        self.content_store.remove_expired();
    }

    pub fn clear_expired_pit_entries(&mut self) {
        self.pit.clear_expired();
    }

    pub fn process_interest_packet(&self, packet: Packet) -> Result<()> {
        // Logic to process interest packets
        Ok(())
    }

    pub fn process_data_packet(&self, packet: Packet) -> Result<()> {
        // Logic to process data packets
        Ok(())
    }
}
===== END OF crates/icn_node_managment/src/lib.rs =====

===== START OF crates/icn_node_managment/src/node.rs =====
// ===============================================
// Content Store, FIB, and PIT Implementation
// ===============================================
// This file defines the structures and methods for the Content Store, Forwarding Information Base (FIB),
// and Pending Interest Table (PIT) used in the ICN Node.
//
// Key concepts:
// - Content Store: A cache for storing data packets temporarily.
// - Forwarding Information Base (FIB): A table that stores routing information for named data.
// - Pending Interest Table (PIT): A table that keeps track of interests that have been forwarded but not yet satisfied.

use std::collections::HashMap;

/// A struct representing a packet in the ICN Node.
#[derive(Clone)]
pub struct Packet {
    pub packet_type: PacketType,
    pub name: String,
    pub content: Vec<u8>,
}

/// Enum representing the type of a packet, either Interest or Data.
#[derive(Clone)]
pub enum PacketType {
    Interest,
    Data,
}

/// A struct representing the Content Store.
pub struct ContentStore {
    store: HashMap<String, Vec<u8>>,
}

impl ContentStore {
    /// Creates a new Content Store.
    pub fn new() -> Self {
        ContentStore {
            store: HashMap::new(),
        }
    }

    /// Inserts data into the Content Store.
    /// # Arguments
    /// * `name` - The name of the data.
    /// * `content` - The content of the data.
    pub fn insert(&mut self, name: String, content: Vec<u8>) {
        self.store.insert(name, content);
    }

    /// Retrieves data from the Content Store.
    /// # Arguments
    /// * `name` - The name of the data.
    /// # Returns
    /// An optional reference to the content if it exists.
    pub fn get(&self, name: &str) -> Option<&Vec<u8>> {
        self.store.get(name)
    }

    /// Checks if the Content Store is empty.
    /// # Returns
    /// True if the Content Store is empty, otherwise false.
    pub fn is_empty(&self) -> bool {
        self.store.is_empty()
    }
}

/// A struct representing the Forwarding Information Base (FIB).
pub struct ForwardingInformationBase {
    table: HashMap<String, Vec<String>>,
}

impl ForwardingInformationBase {
    /// Creates a new FIB.
    pub fn new() -> Self {
        ForwardingInformationBase {
            table: HashMap::new(),
        }
    }

    /// Adds an entry to the FIB.
    /// # Arguments
    /// * `name` - The name of the data.
    /// * `interface` - The interface to forward the data.
    pub fn add_entry(&mut self, name: String, interface: String) {
        self.table.entry(name).or_insert(Vec::new()).push(interface);
    }

    /// Retrieves the interfaces for a given name from the FIB.
    /// # Arguments
    /// * `name` - The name of the data.
    /// # Returns
    /// An optional reference to a vector of interfaces if they exist.
    pub fn get_interfaces(&self, name: &str) -> Option<&Vec<String>> {
        self.table.get(name)
    }

    /// Checks if the FIB is empty.
    /// # Returns
    /// True if the FIB is empty, otherwise false.
    pub fn is_empty(&self) -> bool {
        self.table.is_empty()
    }
}

/// A struct representing the Pending Interest Table (PIT).
pub struct PendingInterestTable {
    table: HashMap<String, Vec<String>>,
}

impl PendingInterestTable {
    /// Creates a new PIT.
    pub fn new() -> Self {
        PendingInterestTable {
            table: HashMap::new(),
        }
    }

    /// Adds an interest to the PIT.
    /// # Arguments
    /// * `name` - The name of the interest.
    /// * `interface` - The interface from which the interest came.
    pub fn add_interest(&mut self, name: String, interface: String) {
        self.table.entry(name).or_insert(Vec::new()).push(interface);
    }

    /// Retrieves the incoming interfaces for a given name from the PIT.
    /// # Arguments
    /// * `name` - The name of the interest.
    /// # Returns
    /// An optional reference to a vector of interfaces if they exist.
    pub fn get_incoming_interfaces(&self, name: &str) -> Option<&Vec<String>> {
        self.table.get(name)
    }

    /// Checks if the PIT is empty.
    /// # Returns
    /// True if the PIT is empty, otherwise false.
    pub fn is_empty(&self) -> bool {
        self.table.is_empty()
    }
}
===== END OF crates/icn_node_managment/src/node.rs =====

===== START OF crates/icn_node_managment/src/pit.rs =====
use std::collections::HashMap;
use std::time::{Duration, Instant};

const DEFAULT_INTEREST_LIFETIME: Duration = Duration::from_secs(4);

struct PitEntry {
    interfaces: Vec<String>,
    timestamp: Instant,
}

pub struct PendingInterestTable {
    entries: HashMap<String, PitEntry>,
}

impl PendingInterestTable {
    pub fn new() -> Self {
        PendingInterestTable {
            entries: HashMap::new(),
        }
    }

    pub fn add_interest(&mut self, name: String, interface: &str) {
        self.entries
            .entry(name)
            .and_modify(|e| {
                if !e.interfaces.contains(&interface.to_string()) {
                    e.interfaces.push(interface.to_string());
                }
                e.timestamp = Instant::now();
            })
            .or_insert(PitEntry {
                interfaces: vec![interface.to_string()],
                timestamp: Instant::now(),
            });
    }

    pub fn remove_interest(&mut self, name: &str) {
        self.entries.remove(name);
    }

    pub fn has_pending_interest(&self, name: &str) -> bool {
        self.entries.contains_key(name)
    }

    pub fn get_incoming_interfaces(&self, name: &str) -> Option<Vec<String>> {
        self.entries.get(name).map(|entry| entry.interfaces.clone())
    }

    pub fn add_incoming_interface(&mut self, name: &str, interface: &str) {
        if let Some(entry) = self.entries.get_mut(name) {
            if !entry.interfaces.contains(&interface.to_string()) {
                entry.interfaces.push(interface.to_string());
            }
        }
    }

    pub fn clear_expired(&mut self) {
        self.entries.retain(|_, entry| entry.timestamp.elapsed() < DEFAULT_INTEREST_LIFETIME);
    }

    pub fn is_empty(&self) -> bool {
        self.entries.is_empty()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pending_interest_table() {
        let mut pit = PendingInterestTable::new();
        
        pit.add_interest("test".to_string(), "interface1");
        assert!(pit.has_pending_interest("test"));
        
        pit.add_incoming_interface("test", "interface2");
        let interfaces = pit.get_incoming_interfaces("test").unwrap();
        assert_eq!(interfaces.len(), 2);
        assert!(interfaces.contains(&"interface1".to_string()));
        assert!(interfaces.contains(&"interface2".to_string()));
        
        pit.remove_interest("test");
        assert!(!pit.has_pending_interest("test"));

        pit.add_interest("test_expired".to_string(), "interface1");
        std::thread::sleep(Duration::from_secs(5));
        pit.clear_expired();
        assert!(!pit.has_pending_interest("test_expired"));
    }
}
===== END OF crates/icn_node_managment/src/pit.rs =====

===== START OF crates/icn_sharding/Cargo.toml =====
[package]
name = "icn_sharding"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_core = { path = "../icn_core" }
icn_blockchain = { path = "../icn_blockchain" }
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
log = "0.4"
thiserror = "1.0"
chrono = { version = "0.4", features = ["serde"] }
rand = "0.8"
sha2 = "0.9"

[dev-dependencies]
tokio-test = "0.4"===== END OF crates/icn_sharding/Cargo.toml =====

===== START OF crates/icn_sharding/src/cross_shard_communication.rs =====
use crate::blockchain::Transaction;
use crate::sharding::ShardingManager;
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use tokio::sync::mpsc;
use uuid::Uuid;
use crate::error::{Error, Result};

#[derive(Clone, Debug)]
pub struct CrossShardTransaction {
    pub transaction: Transaction,
    pub from_shard: u64,
    pub to_shard: u64,
    pub status: CrossShardTransactionStatus,
}

#[derive(Clone, Debug, PartialEq)]
pub enum CrossShardTransactionStatus {
    Initiated,
    LockAcquired,
    Committed,
    Failed(String),
}

pub struct CrossShardCommunicator {
    sharding_manager: Arc<Mutex<ShardingManager>>,
    pending_transactions: HashMap<String, CrossShardTransaction>,
    tx_channels: HashMap<u64, mpsc::Sender<CrossShardTransaction>>,
}

impl CrossShardCommunicator {
    pub fn new(sharding_manager: Arc<Mutex<ShardingManager>>) -> Self {
        let mut tx_channels = HashMap::new();
        let shard_count = sharding_manager.lock().unwrap().get_shard_count();
        for i in 0..shard_count {
            let (tx, mut rx) = mpsc::channel(100);
            tx_channels.insert(i, tx);
            let sm = Arc::clone(&sharding_manager);
            tokio::spawn(async move {
                while let Some(transaction) = rx.recv().await {
                    if let Err(e) = Self::process_transaction(sm.clone(), transaction).await {
                        eprintln!("Error processing cross-shard transaction: {}", e);
                    }
                }
            });
        }

        CrossShardCommunicator {
            sharding_manager,
            pending_transactions: HashMap::new(),
            tx_channels,
        }
    }

    pub async fn initiate_cross_shard_transaction(&mut self, transaction: Transaction) -> Result<String> {
        let sharding_manager = self.sharding_manager.lock().map_err(|e| Error::LockError(e.to_string()))?;
        let from_shard = sharding_manager.get_shard_for_address(&transaction.from);
        let to_shard = sharding_manager.get_shard_for_address(&transaction.to);

        if from_shard == to_shard {
            return Err(Error::ShardingError("Not a cross-shard transaction".to_string()));
        }

        let cross_shard_tx = CrossShardTransaction {
            transaction: transaction.clone(),
            from_shard,
            to_shard,
            status: CrossShardTransactionStatus::Initiated,
        };

        let tx_id = Uuid::new_v4().to_string();
        self.pending_transactions.insert(tx_id.clone(), cross_shard_tx.clone());

        if let Some(tx) = self.tx_channels.get(&from_shard) {
            tx.send(cross_shard_tx).await.map_err(|e| Error::CommunicationError(e.to_string()))?;
        } else {
            return Err(Error::ShardingError(format!("Channel for shard {} not found", from_shard)));
        }

        Ok(tx_id)
    }

    async fn process_transaction(sharding_manager: Arc<Mutex<ShardingManager>>, mut transaction: CrossShardTransaction) -> Result<()> {
        // Phase 1: Lock funds in the source shard
        {
            let sm = sharding_manager.lock().map_err(|e| Error::LockError(e.to_string()))?;
            sm.lock_funds_in_shard(
                transaction.from_shard,
                &transaction.transaction.from,
                &transaction.transaction.currency_type,
                transaction.transaction.amount
            )?;
        }
        transaction.status = CrossShardTransactionStatus::LockAcquired;

        // Phase 2: Transfer funds to the destination shard
        {
            let sm = sharding_manager.lock().map_err(|e| Error::LockError(e.to_string()))?;
            sm.transfer_between_shards(transaction.from_shard, transaction.to_shard, &transaction.transaction)?;
        }

        // Phase 3: Commit the transaction
        {
            let sm = sharding_manager.lock().map_err(|e| Error::LockError(e.to_string()))?;
            sm.commit_cross_shard_transaction(&transaction.transaction, transaction.from_shard, transaction.to_shard)?;
        }

        transaction.status = CrossShardTransactionStatus::Committed;
        Ok(())
    }

    pub fn get_transaction_status(&self, tx_id: &str) -> Option<CrossShardTransactionStatus> {
        self.pending_transactions.get(tx_id).map(|tx| tx.status.clone())
    }

    pub async fn wait_for_transaction(&self, tx_id: &str, timeout: std::time::Duration) -> Result<CrossShardTransactionStatus> {
        let start_time = std::time::Instant::now();
        while start_time.elapsed() < timeout {
            if let Some(status) = self.get_transaction_status(tx_id) {
                match status {
                    CrossShardTransactionStatus::Committed => return Ok(status),
                    CrossShardTransactionStatus::Failed(reason) => return Err(Error::TransactionFailed(reason)),
                    _ => tokio::time::sleep(std::time::Duration::from_millis(100)).await,
                }
            }
            tokio::time::sleep(std::time::Duration::from_millis(100)).await;
        }
        Err(Error::Timeout("Transaction timeout".to_string()))
    }

    pub async fn cleanup_completed_transactions(&mut self) {
        self.pending_transactions.retain(|_, tx| {
            match tx.status {
                CrossShardTransactionStatus::Committed => false,
                CrossShardTransactionStatus::Failed(_) => false,
                _ => true,
            }
        });
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::currency::CurrencyType;
    use ed25519_dalek::Keypair;
    use rand::rngs::OsRng;

    #[tokio::test]
    async fn test_cross_shard_transaction() {
        let sharding_manager = Arc::new(Mutex::new(ShardingManager::new(2, 10)));
        let mut communicator = CrossShardCommunicator::new(sharding_manager.clone());

        {
            let mut sm = sharding_manager.lock().unwrap();
            sm.add_address_to_shard("Alice".to_string(), 0);
            sm.add_address_to_shard("Bob".to_string(), 1);
            sm.initialize_balance("Alice".to_string(), CurrencyType::BasicNeeds, 1000.0).unwrap();
        }

        let mut csprng = OsRng{};
        let keypair: Keypair = Keypair::generate(&mut csprng);

        let mut transaction = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            200.0,
            CurrencyType::BasicNeeds,
            1000,
        );
        transaction.sign(&keypair).unwrap();

        let tx_id = communicator.initiate_cross_shard_transaction(transaction).await.unwrap();

        // Wait for the transaction to be processed
        let status = communicator.wait_for_transaction(&tx_id, std::time::Duration::from_secs(5)).await.unwrap();
        assert_eq!(status, CrossShardTransactionStatus::Committed);

        let sm = sharding_manager.lock().unwrap();
        let alice_balance = sm.get_balance("Alice".to_string(), CurrencyType::BasicNeeds).unwrap();
        let bob_balance = sm.get_balance("Bob".to_string(), CurrencyType::BasicNeeds).unwrap();
        
        assert_eq!(alice_balance, 800.0);
        assert_eq!(bob_balance, 200.0);
    }

    #[tokio::test]
    async fn test_cross_shard_transaction_insufficient_balance() {
        let sharding_manager = Arc::new(Mutex::new(ShardingManager::new(2, 10)));
        let mut communicator = CrossShardCommunicator::new(sharding_manager.clone());

        {
            let mut sm = sharding_manager.lock().unwrap();
            sm.add_address_to_shard("Charlie".to_string(), 0);
            sm.add_address_to_shard("Dave".to_string(), 1);
            sm.initialize_balance("Charlie".to_string(), CurrencyType::BasicNeeds, 100.0).unwrap();
        }

        let mut csprng = OsRng{};
        let keypair: Keypair = Keypair::generate(&mut csprng);

        let mut transaction = Transaction::new(
            "Charlie".to_string(),
            "Dave".to_string(),
            200.0,
            CurrencyType::BasicNeeds,
            1000,
        );
        transaction.sign(&keypair).unwrap();

        let tx_id = communicator.initiate_cross_shard_transaction(transaction).await.unwrap();

        // Wait for the transaction to be processed
        let result = communicator.wait_for_transaction(&tx_id, std::time::Duration::from_secs(5)).await;
        assert!(matches!(result, Err(Error::TransactionFailed(_))));

        let sm = sharding_manager.lock().unwrap();
        let charlie_balance = sm.get_balance("Charlie".to_string(), CurrencyType::BasicNeeds).unwrap();
        let dave_balance = sm.get_balance("Dave".to_string(), CurrencyType::BasicNeeds).unwrap();
        
        assert_eq!(charlie_balance, 100.0);
        assert_eq!(dave_balance, 0.0);
    }

    #[tokio::test]
    async fn test_cleanup_completed_transactions() {
        let sharding_manager = Arc::new(Mutex::new(ShardingManager::new(2, 10)));
        let mut communicator = CrossShardCommunicator::new(sharding_manager.clone());

        // Add some test transactions
        communicator.pending_transactions.insert(
            "tx1".to_string(),
            CrossShardTransaction {
                transaction: Transaction::new("Alice".to_string(), "Bob".to_string(), 100.0, CurrencyType::BasicNeeds, 1000),
                from_shard: 0,
                to_shard: 1,
                status: CrossShardTransactionStatus::Committed,
            },
        );

        communicator.pending_transactions.insert(
            "tx2".to_string(),
            CrossShardTransaction {
                transaction: Transaction::new("Charlie".to_string(), "Dave".to_string(), 50.0, CurrencyType::BasicNeeds, 1000),
                from_shard: 0,
                to_shard: 1,
                status: CrossShardTransactionStatus::Initiated,
            },
        );

        communicator.pending_transactions.insert(
            "tx3".to_string(),
            CrossShardTransaction {
                transaction: Transaction::new("Eve".to_string(), "Frank".to_string(), 75.0, CurrencyType::BasicNeeds, 1000),
                from_shard: 0,
                to_shard: 1,
                status: CrossShardTransactionStatus::Failed("Insufficient balance".to_string()),
            },
        );

        // Perform cleanup
        communicator.cleanup_completed_transactions().await;

        // Check that only the initiated transaction remains
        assert_eq!(communicator.pending_transactions.len(), 1);
        assert!(communicator.pending_transactions.contains_key("tx2"));
    }
}
===== END OF crates/icn_sharding/src/cross_shard_communication.rs =====

===== START OF crates/icn_sharding/src/cross_shard_sync.rs =====
// This module will handle synchronization across shards for consistency.

pub struct CrossShardSyncManager {
    // Fields and methods for cross-shard synchronization.
}

impl CrossShardSyncManager {
    pub fn new() -> Self {
        CrossShardSyncManager {
            // Initialize fields.
        }
    }

    pub fn synchronize(&self) {
        // Implement synchronization logic.
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_synchronize() {
        let sync_manager = CrossShardSyncManager::new();
        sync_manager.synchronize();
        // Add assertions for synchronization.
    }
}
===== END OF crates/icn_sharding/src/cross_shard_sync.rs =====

===== START OF crates/icn_sharding/src/cross_shard_transaction_manager.rs =====
use crate::blockchain::Transaction;
use crate::sharding::ShardingManager;
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use tokio::sync::mpsc;
use uuid::Uuid;

#[derive(Clone, Debug)]
pub struct CrossShardTransaction {
    pub transaction: Transaction,
    pub from_shard: u64,
    pub to_shard: u64,
    pub status: CrossShardTransactionStatus,
}

#[derive(Clone, Debug, PartialEq)]
pub enum CrossShardTransactionStatus {
    Initiated,
    LockAcquired,
    Committed,
    Failed(String),
}

pub struct CrossShardCommunicator {
    sharding_manager: Arc<Mutex<ShardingManager>>,
    pending_transactions: HashMap<String, CrossShardTransaction>,
    tx_channels: HashMap<u64, mpsc::Sender<CrossShardTransaction>>,
}

impl CrossShardCommunicator {
    pub fn new(sharding_manager: Arc<Mutex<ShardingManager>>) -> Self {
        let mut tx_channels = HashMap::new();
        let shard_count = sharding_manager.lock().unwrap().get_shard_count();
        for i in 0..shard_count {
            let (tx, mut rx) = mpsc::channel(100);
            tx_channels.insert(i, tx);
            let sm = Arc::clone(&sharding_manager);
            tokio::spawn(async move {
                while let Some(transaction) = rx.recv().await {
                    if let Err(e) = Self::process_transaction(sm.clone(), transaction).await {
                        eprintln!("Error processing cross-shard transaction: {}", e);
                    }
                }
            });
        }

        CrossShardCommunicator {
            sharding_manager,
            pending_transactions: HashMap::new(),
            tx_channels,
        }
    }

    pub async fn initiate_cross_shard_transaction(&mut self, transaction: Transaction) -> Result<String, String> {
        let sharding_manager = self.sharding_manager.lock().unwrap();
        let from_shard = sharding_manager.get_shard_for_address(&transaction.from);
        let to_shard = sharding_manager.get_shard_for_address(&transaction.to);

        if from_shard == to_shard {
            return Err("Not a cross-shard transaction".to_string());
        }

        let cross_shard_tx = CrossShardTransaction {
            transaction: transaction.clone(),
            from_shard,
            to_shard,
            status: CrossShardTransactionStatus::Initiated,
        };

        let tx_id = Uuid::new_v4().to_string();
        self.pending_transactions.insert(tx_id.clone(), cross_shard_tx.clone());

        if let Some(tx) = self.tx_channels.get(&from_shard) {
            tx.send(cross_shard_tx).await.map_err(|e| e.to_string())?;
        } else {
            return Err(format!("Channel for shard {} not found", from_shard));
        }

        Ok(tx_id)
    }

    async fn process_transaction(sharding_manager: Arc<Mutex<ShardingManager>>, mut transaction: CrossShardTransaction) -> Result<(), String> {
        // Phase 1: Lock funds in the source shard
        {
            let mut sm = sharding_manager.lock().unwrap();
            sm.lock_funds(&transaction.transaction.from, &transaction.transaction.currency_type, transaction.transaction.amount, transaction.from_shard)?;
        }
        transaction.status = CrossShardTransactionStatus::LockAcquired;

        // Phase 2: Commit the transaction in the destination shard
        {
            let mut sm = sharding_manager.lock().unwrap();
            sm.add_balance(&transaction.transaction.to, transaction.transaction.currency_type.clone(), transaction.transaction.amount)?;
        }

        // Phase 3: Finalize by removing the lock in the source shard
        {
            let mut sm = sharding_manager.lock().unwrap();
            sm.remove_fund_lock(&transaction.transaction.from, &transaction.transaction.currency_type, transaction.transaction.amount, transaction.from_shard)?;
        }

        transaction.status = CrossShardTransactionStatus::Committed;
        Ok(())
    }

    pub fn get_transaction_status(&self, tx_id: &str) -> Option<CrossShardTransactionStatus> {
        self.pending_transactions.get(tx_id).map(|tx| tx.status.clone())
    }
}===== END OF crates/icn_sharding/src/cross_shard_transaction_manager.rs =====

===== START OF crates/icn_sharding/src/lib.rs =====
use std::collections::HashMap;
use sha2::{Sha256, Digest};
use crate::blockchain::{Block, Transaction};
use crate::network::Node;
use crate::currency::CurrencyType;
use std::sync::{Arc, Mutex};
use ed25519_dalek::{PublicKey, Signature, Verifier};
use log::{info, error, warn, debug};
use crate::error::{Error, Result};
use thiserror::Error;

pub mod cross_shard_communication;
pub mod cross_shard_sync;

#[derive(Error, Debug)]
pub enum ShardingError {
    #[error("Shard not found: {0}")]
    ShardNotFound(u64),
    #[error("Insufficient balance: {0}")]
    InsufficientBalance(String),
    #[error("Invalid transaction: {0}")]
    InvalidTransaction(String),
    #[error("Failed to lock shard: {0}")]
    ShardLockFailed(String),
    #[error("Cross-shard communication error: {0}")]
    CrossShardCommunicationError(String),
}

pub struct Shard {
    pub id: u64,
    pub nodes: Vec<Node>,
    pub blockchain: Vec<Block>,
    pub balances: HashMap<String, HashMap<CurrencyType, f64>>,
    pub locked_funds: HashMap<String, HashMap<CurrencyType, f64>>,
}

pub struct ShardingManager {
    shards: HashMap<u64, Arc<Mutex<Shard>>>,
    shard_count: u64,
    nodes_per_shard: usize,
    address_to_shard: HashMap<String, u64>,
    current_shard_id: u64,
}

impl ShardingManager {
    pub fn new(shard_count: u64, nodes_per_shard: usize) -> Self {
        let mut shards = HashMap::new();
        for i in 0..shard_count {
            shards.insert(i, Arc::new(Mutex::new(Shard {
                id: i,
                nodes: Vec::new(),
                blockchain: Vec::new(),
                balances: HashMap::new(),
                locked_funds: HashMap::new(),
            })));
        }
        
        info!("Created new ShardingManager with {} shards and {} nodes per shard", shard_count, nodes_per_shard);
        ShardingManager {
            shards,
            shard_count,
            nodes_per_shard,
            address_to_shard: HashMap::new(),
            current_shard_id: 0,
        }
    }

    pub fn get_shard_count(&self) -> u64 {
        self.shard_count
    }

    pub fn get_shard(&self, shard_id: u64) -> Result<Arc<Mutex<Shard>>> {
        self.shards.get(&shard_id)
            .cloned()
            .ok_or_else(|| Error::ShardingError(ShardingError::ShardNotFound(shard_id).to_string()))
    }

    pub fn get_shard_mut(&mut self, shard_id: u64) -> Result<&mut Arc<Mutex<Shard>>> {
        self.shards.get_mut(&shard_id)
            .ok_or_else(|| Error::ShardingError(ShardingError::ShardNotFound(shard_id).to_string()))
    }

    pub fn process_transaction(&self, shard_id: u64, transaction: &Transaction) -> Result<()> {
        let shard = self.get_shard(shard_id)?;
        let mut shard = shard.lock().map_err(|e| Error::ShardingError(ShardingError::ShardLockFailed(e.to_string()).to_string()))?;

        if !self.verify_transaction(&shard, transaction) {
            return Err(Error::ShardingError(ShardingError::InvalidTransaction("Transaction verification failed".to_string()).to_string()));
        }

        self.update_balances(&mut shard, transaction)
    }

    fn update_balances(&self, shard: &mut Shard, transaction: &Transaction) -> Result<()> {
        let sender_balances = shard.balances.entry(transaction.from.clone()).or_insert_with(HashMap::new);
        let sender_balance = sender_balances.entry(transaction.currency_type.clone()).or_insert(0.0);
        
        if *sender_balance < transaction.amount {
            return Err(Error::ShardingError(ShardingError::InsufficientBalance(format!("Insufficient balance for sender: {}", transaction.from)).to_string()));
        }
        
        *sender_balance -= transaction.amount;

        let recipient_balances = shard.balances.entry(transaction.to.clone()).or_insert_with(HashMap::new);
        let recipient_balance = recipient_balances.entry(transaction.currency_type.clone()).or_insert(0.0);
        *recipient_balance += transaction.amount;

        Ok(())
    }

    pub fn transfer_between_shards(&self, from_shard: u64, to_shard: u64, transaction: &Transaction) -> Result<()> {
        let from_shard_arc = self.get_shard(from_shard)?;
        let to_shard_arc = self.get_shard(to_shard)?;
        
        let mut from_shard = from_shard_arc.lock().map_err(|e| Error::ShardingError(ShardingError::ShardLockFailed(e.to_string()).to_string()))?;
        let mut to_shard = to_shard_arc.lock().map_err(|e| Error::ShardingError(ShardingError::ShardLockFailed(e.to_string()).to_string()))?;

        if !self.verify_transaction(&from_shard, transaction) {
            return Err(Error::ShardingError(ShardingError::InvalidTransaction("Transaction verification failed in the source shard".to_string()).to_string()));
        }

        self.lock_funds(&mut from_shard, &transaction.from, &transaction.currency_type, transaction.amount)?;
        self.add_balance_to_shard(&mut to_shard, &transaction.to, &transaction.currency_type, transaction.amount)?;

        info!("Cross-shard transaction prepared from shard {} to shard {}", from_shard.id, to_shard.id);
        Ok(())
    }

    pub fn lock_funds(&self, shard: &mut Shard, address: &str, currency_type: &CurrencyType, amount: f64) -> Result<()> {
        let sender_balances = shard.balances.get_mut(address)
            .ok_or_else(|| Error::ShardingError(ShardingError::InsufficientBalance("Sender not found".to_string()).to_string()))?;
        
        let balance = sender_balances.get_mut(currency_type)
            .ok_or_else(|| Error::ShardingError(ShardingError::InsufficientBalance("Currency not found".to_string()).to_string()))?;

        if *balance < amount {
            return Err(Error::ShardingError(ShardingError::InsufficientBalance("Insufficient balance".to_string()).to_string()));
        }

        *balance -= amount;

        shard.locked_funds
            .entry(address.to_string())
            .or_insert_with(HashMap::new)
            .entry(currency_type.clone())
            .and_modify(|e| *e += amount)
            .or_insert(amount);

        Ok(())
    }

    pub fn commit_cross_shard_transaction(&self, transaction: &Transaction, from_shard: u64, to_shard: u64) -> Result<()> {
        let from_shard_arc = self.get_shard(from_shard)?;
        let to_shard_arc = self.get_shard(to_shard)?;
        
        let mut from_shard = from_shard_arc.lock().map_err(|e| Error::ShardingError(ShardingError::ShardLockFailed(e.to_string()).to_string()))?;
        let mut to_shard = to_shard_arc.lock().map_err(|e| Error::ShardingError(ShardingError::ShardLockFailed(e.to_string()).to_string()))?;

        self.remove_fund_lock(&mut from_shard, &transaction.from, &transaction.currency_type, transaction.amount)?;
        self.finalize_balance_update(&mut to_shard, &transaction.to, &transaction.currency_type, transaction.amount)?;

        info!("Cross-shard transaction committed from shard {} to shard {}", from_shard.id, to_shard.id);
        Ok(())
    }

    fn remove_fund_lock(&self, shard: &mut Shard, address: &str, currency_type: &CurrencyType, amount: f64) -> Result<()> {
        let locked_funds = shard.locked_funds.get_mut(address)
            .ok_or_else(|| Error::ShardingError(ShardingError::InsufficientBalance("No locked funds found".to_string()).to_string()))?;

        let locked_amount = locked_funds.get_mut(currency_type)
            .ok_or_else(|| Error::ShardingError(ShardingError::InsufficientBalance("No locked funds for this currency".to_string()).to_string()))?;

        if *locked_amount < amount {
            return Err(Error::ShardingError(ShardingError::InsufficientBalance("Insufficient locked funds".to_string()).to_string()));
        }

        *locked_amount -= amount;

        if *locked_amount == 0.0 {
            locked_funds.remove(currency_type);
        }

        if locked_funds.is_empty() {
            shard.locked_funds.remove(address);
        }

        Ok(())
    }

    fn finalize_balance_update(&self, shard: &mut Shard, address: &str, currency_type: &CurrencyType, amount: f64) -> Result<()> {
        let balances = shard.balances.entry(address.to_string()).or_insert_with(HashMap::new);
        let balance = balances.entry(currency_type.clone()).or_insert(0.0);
        *balance += amount;
        Ok(())
    }

    pub fn add_balance(&self, address: &str, currency_type: CurrencyType, amount: f64) -> Result<()> {
        let shard_id = self.get_shard_for_address(address);
        let shard = self.get_shard(shard_id)?;
        let mut shard = shard.lock().map_err(|e| Error::ShardingError(ShardingError::ShardLockFailed(e.to_string()).to_string()))?;
    
        let balance = shard.balances
            .entry(address.to_string())
            .or_insert_with(HashMap::new)
            .entry(currency_type.clone())
            .or_insert(0.0);
        *balance += amount;
        
        info!("Added balance of {} {} for address {} in shard {}", amount, currency_type, address, shard_id);
        Ok(())
    }

    fn add_balance_to_shard(&self, shard: &mut Shard, address: &str, currency_type: &CurrencyType, amount: f64) -> Result<()> {
        let balance = shard.balances
            .entry(address.to_string())
            .or_insert_with(HashMap::new)
            .entry(currency_type.clone())
            .or_insert(0.0);
        *balance += amount;
        Ok(())
    }

    pub fn assign_node_to_shard(&self, node: Node, shard_id: u64) -> Result<()> {
        let shard_arc = self.get_shard(shard_id)?;
        let mut shard = shard_arc.lock().map_err(|e| Error::ShardingError(ShardingError::ShardLockFailed(e.to_string()).to_string()))?;
        if shard.nodes.len() >= self.nodes_per_shard {
            error!("Failed to assign node to shard {}: Shard is full", shard_id);
            return Err(Error::ShardingError(ShardingError::ShardNotFound(shard_id).to_string()));
        }
        shard.nodes.push(node.clone());
        info!("Assigned node {} to shard {}", node.id, shard_id);
        Ok(())
    }

    pub fn get_shard_for_data(&self, data: &[u8]) -> u64 {
        let hash = self.hash_data(data);
        hash % self.shard_count
    }

    pub fn get_shard_for_address(&self, address: &str) -> u64 {
        *self.address_to_shard.get(address).unwrap_or(&(self.hash_data(address.as_bytes()) % self.shard_count))
    }

    pub fn get_current_shard_id(&self) -> u64 {
        self.current_shard_id
    }

    pub fn set_current_shard_id(&mut self, shard_id: u64) {
        self.current_shard_id = shard_id;
    }

    pub fn add_address_to_shard(&mut self, address: String, shard_id: u64) {
        self.address_to_shard.insert(address.clone(), shard_id);
        info!("Added address {} to shard {}", address, shard_id);
    }

    pub fn initialize_balance(&self, address: String, currency_type: CurrencyType, amount: f64) -> Result<()> {
        let shard_id = self.get_shard_for_address(&address);
        let shard = self.get_shard(shard_id)?;
        let mut shard = shard.lock().map_err(|e| Error::ShardingError(ShardingError::ShardLockFailed(e.to_string()).to_string()))?;
        
        shard.balances
            .entry(address.clone())
            .or_insert_with(HashMap::new)
            .insert(currency_type.clone(), amount);
        
        info!("Initialized balance of {} {} for {} in shard {}", amount, currency_type, address, shard_id);
        Ok(())
    }

    pub fn get_balance(&self, address: String, currency_type: CurrencyType) -> Result<f64> {
        let shard_id = self.get_shard_for_address(&address);
        let shard = self.get_shard(shard_id)?;
        let shard = shard.lock().map_err(|e| Error::ShardingError(ShardingError::ShardLockFailed(e.to_string()).to_string()))?;
        
        let balance = shard.balances
            .get(&address)
            .and_then(|balances| balances.get(&currency_type))
            .cloned()
            .unwrap_or(0.0);
        
        Ok(balance)
    }

    pub fn lock_funds_in_shard(&self, shard_id: u64, address: &str, currency_type: &CurrencyType, amount: f64) -> Result<()> {
        let shard = self.get_shard(shard_id)?;
        let mut shard = shard.lock().map_err(|e| Error::ShardingError(ShardingError::ShardLockFailed(e.to_string()).to_string()))?;
        self.lock_funds(&mut shard, address, currency_type, amount)
    }

    fn verify_transaction(&self, shard: &Shard, transaction: &Transaction) -> bool {
        debug!("Checking balance for sender: {}", transaction.from);
        if let Some(sender_balances) = shard.balances.get(&transaction.from) {
            if let Some(balance) = sender_balances.get(&transaction.currency_type) {
                if *balance < transaction.amount {
                    warn!("Insufficient balance for sender: {}", transaction.from);
                    return false;
                }
            } else {
                warn!("Sender does not have the required currency type");
                return false;
            }
        } else {
            warn!("Sender not found in this shard");
            return false;
        }

        debug!("Verifying transaction signature");
        if let (Some(public_key), Some(signature)) = (&transaction.public_key, &transaction.signature) {
            let public_key = PublicKey::from_bytes(public_key).unwrap();
            let signature = Signature::from_bytes(signature).unwrap();
            let message = transaction.to_bytes();
            if public_key.verify(&message, &signature).is_err() {
                warn!("Signature verification failed");
                return false;
            }
        } else {
            warn!("Missing public key or signature");
            return false;
        }

        true
    }

    fn hash_data(&self, data: &[u8]) -> u64 {
        let mut hasher = Sha256::new();
        hasher.update(data);
        let result = hasher.finalize();
        let hash_bytes: [u8; 8] = result[..8].try_into().unwrap_or([0; 8]);
        u64::from_le_bytes(hash_bytes)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::network::Node;
    use crate::network::node::NodeType;
    use crate::currency::CurrencyType;
    use ed25519_dalek::Keypair;
    use rand::rngs::OsRng;

    #[test]
    fn test_create_sharding_manager() {
        let manager = ShardingManager::new(4, 10);
        assert_eq!(manager.shards.len(), 4);
        assert_eq!(manager.shard_count, 4);
        assert_eq!(manager.nodes_per_shard, 10);
    }

    #[test]
    fn test_assign_node_to_shard() {
        let manager = ShardingManager::new(4, 2);
        let node1 = Node::new("node1", NodeType::PersonalDevice, "127.0.0.1:8000");
        let node2 = Node::new("node2", NodeType::PersonalDevice, "127.0.0.1:8001");

        assert!(manager.assign_node_to_shard(node1.clone(), 0).is_ok());
        assert!(manager.assign_node_to_shard(node2.clone(), 1).is_ok());

        assert_eq!(manager.get_shard(0).unwrap().lock().unwrap().nodes.len(), 1);
        assert_eq!(manager.get_shard(1).unwrap().lock().unwrap().nodes.len(), 1);
    }

    #[test]
    fn test_process_transaction() {
        let mut manager = ShardingManager::new(4, 10);
        let mut csprng = OsRng{};
        let keypair: Keypair = Keypair::generate(&mut csprng);

        let mut transaction = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            100.0,
            CurrencyType::BasicNeeds,
            1000,
        );
        transaction.sign(&keypair).unwrap();

        manager.add_address_to_shard("Alice".to_string(), 0);
        manager.add_address_to_shard("Bob".to_string(), 0);
        manager.initialize_balance("Alice".to_string(), CurrencyType::BasicNeeds, 1000.0).unwrap();

        assert!(manager.process_transaction(0, &transaction).is_ok());

        assert_eq!(manager.get_balance("Alice".to_string(), CurrencyType::BasicNeeds).unwrap(), 900.0);
        assert_eq!(manager.get_balance("Bob".to_string(), CurrencyType::BasicNeeds).unwrap(), 100.0);
    }

    #[test]
    fn test_cross_shard_transaction() {
        let mut manager = ShardingManager::new(4, 10);
        let mut csprng = OsRng{};
        let keypair: Keypair = Keypair::generate(&mut csprng);

        let mut transaction = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            100.0,
            CurrencyType::BasicNeeds,
            1000,
        );
        transaction.sign(&keypair).unwrap();

        manager.add_address_to_shard("Alice".to_string(), 0);
        manager.add_address_to_shard("Bob".to_string(), 1);
        manager.initialize_balance("Alice".to_string(), CurrencyType::BasicNeeds, 1000.0).unwrap();

        assert!(manager.transfer_between_shards(0, 1, &transaction).is_ok());
        assert!(manager.commit_cross_shard_transaction(&transaction, 0, 1).is_ok());

        assert_eq!(manager.get_balance("Alice".to_string(), CurrencyType::BasicNeeds).unwrap(), 900.0);
        assert_eq!(manager.get_balance("Bob".to_string(), CurrencyType::BasicNeeds).unwrap(), 100.0);
    }

    #[test]
    fn test_get_shard_for_data() {
        let manager = ShardingManager::new(4, 10);
        let data1 = b"test_data_1";
        let data2 = b"test_data_2";

        let shard1 = manager.get_shard_for_data(data1);
        let shard2 = manager.get_shard_for_data(data2);

        assert!(shard1 < 4);
        assert!(shard2 < 4);
        // There's a small chance these could be equal, but it's unlikely
        assert_ne!(shard1, shard2);
    }

    #[test]
    fn test_get_shard_for_address() {
        let mut manager = ShardingManager::new(4, 10);
        manager.add_address_to_shard("Alice".to_string(), 2);

        assert_eq!(manager.get_shard_for_address("Alice"), 2);
        
        let bob_shard = manager.get_shard_for_address("Bob");
        assert!(bob_shard < 4);
    }

    #[test]
    fn test_add_and_get_balance() {
        let mut manager = ShardingManager::new(4, 10);
        manager.add_address_to_shard("Charlie".to_string(), 3);

        assert!(manager.add_balance("Charlie", CurrencyType::BasicNeeds, 500.0).is_ok());
        assert_eq!(manager.get_balance("Charlie".to_string(), CurrencyType::BasicNeeds).unwrap(), 500.0);

        assert!(manager.add_balance("Charlie", CurrencyType::BasicNeeds, 250.0).is_ok());
        assert_eq!(manager.get_balance("Charlie".to_string(), CurrencyType::BasicNeeds).unwrap(), 750.0);
    }

    #[test]
    fn test_insufficient_balance() {
        let mut manager = ShardingManager::new(4, 10);
        let mut csprng = OsRng{};
        let keypair: Keypair = Keypair::generate(&mut csprng);

        let mut transaction = Transaction::new(
            "David".to_string(),
            "Eve".to_string(),
            1000.0,
            CurrencyType::BasicNeeds,
            1000,
        );
        transaction.sign(&keypair).unwrap();

        manager.add_address_to_shard("David".to_string(), 0);
        manager.add_address_to_shard("Eve".to_string(), 0);
        manager.initialize_balance("David".to_string(), CurrencyType::BasicNeeds, 500.0).unwrap();

        assert!(manager.process_transaction(0, &transaction).is_err());
        assert_eq!(manager.get_balance("David".to_string(), CurrencyType::BasicNeeds).unwrap(), 500.0);
        assert_eq!(manager.get_balance("Eve".to_string(), CurrencyType::BasicNeeds).unwrap(), 0.0);
    }

    #[test]
    fn test_cross_shard_insufficient_balance() {
        let mut manager = ShardingManager::new(4, 10);
        let mut csprng = OsRng{};
        let keypair: Keypair = Keypair::generate(&mut csprng);

        let mut transaction = Transaction::new(
            "Frank".to_string(),
            "Grace".to_string(),
            1000.0,
            CurrencyType::BasicNeeds,
            1000,
        );
        transaction.sign(&keypair).unwrap();

        manager.add_address_to_shard("Frank".to_string(), 0);
        manager.add_address_to_shard("Grace".to_string(), 1);
        manager.initialize_balance("Frank".to_string(), CurrencyType::BasicNeeds, 500.0).unwrap();

        assert!(manager.transfer_between_shards(0, 1, &transaction).is_err());
        assert_eq!(manager.get_balance("Frank".to_string(), CurrencyType::BasicNeeds).unwrap(), 500.0);
        assert_eq!(manager.get_balance("Grace".to_string(), CurrencyType::BasicNeeds).unwrap(), 0.0);
    }
}
===== END OF crates/icn_sharding/src/lib.rs =====

===== START OF crates/icn_storage/Cargo.toml =====
[package]
name = "icn_storage"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_core = { path = "../icn_core" }
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
log = "0.4"
thiserror = "1.0"
sha2 = "0.9"

[dev-dependencies]
tokio-test = "0.4"===== END OF crates/icn_storage/Cargo.toml =====

===== START OF crates/icn_storage/src/lib.rs =====
use std::collections::HashMap;
use sha2::{Sha256, Digest};
use serde::{Serialize, Deserialize};
use icn_core::error::{Error, Result};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct StorageNode {
    data: HashMap<String, Vec<u8>>,
}

impl StorageNode {
    pub fn new() -> Self {
        StorageNode {
            data: HashMap::new(),
        }
    }

    pub fn store(&mut self, content: Vec<u8>) -> String {
        let hash = self.calculate_hash(&content);
        self.data.insert(hash.clone(), content);
        hash
    }

    pub fn retrieve(&self, hash: &str) -> Option<&Vec<u8>> {
        self.data.get(hash)
    }

    pub fn delete(&mut self, hash: &str) -> bool {
        self.data.remove(hash).is_some()
    }

    pub fn update(&mut self, hash: &str, new_content: Vec<u8>) -> Result<()> {
        if self.data.contains_key(hash) {
            let new_hash = self.calculate_hash(&new_content);
            if new_hash != hash {
                return Err(Error::StorageError("Update would change the hash, use store instead".to_string()));
            }
            self.data.insert(hash.to_string(), new_content);
            Ok(())
        } else {
            Err(Error::StorageError("Hash not found".to_string()))
        }
    }

    fn calculate_hash(&self, content: &[u8]) -> String {
        let mut hasher = Sha256::new();
        hasher.update(content);
        let result = hasher.finalize();
        hex::encode(result)
    }

    pub fn list_hashes(&self) -> Vec<String> {
        self.data.keys().cloned().collect()
    }

    pub fn contains(&self, hash: &str) -> bool {
        self.data.contains_key(hash)
    }

    pub fn clear(&mut self) {
        self.data.clear();
    }

    pub fn len(&self) -> usize {
        self.data.len()
    }

    pub fn is_empty(&self) -> bool {
        self.data.is_empty()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_store_and_retrieve() {
        let mut node = StorageNode::new();
        let content = b"Hello, ICN!".to_vec();
        let hash = node.store(content.clone());
        assert_eq!(node.retrieve(&hash), Some(&content));
    }

    #[test]
    fn test_delete() {
        let mut node = StorageNode::new();
        let content = b"Delete me".to_vec();
        let hash = node.store(content);
        assert!(node.delete(&hash));
        assert!(!node.contains(&hash));
    }

    #[test]
    fn test_update() {
        let mut node = StorageNode::new();
        let content = b"Original content".to_vec();
        let hash = node.store(content);
        let new_content = b"Original content".to_vec(); // Same content, should work
        assert!(node.update(&hash, new_content).is_ok());
        let different_content = b"Different content".to_vec();
        assert!(node.update(&hash, different_content).is_err());
    }

    #[test]
    fn test_list_hashes() {
        let mut node = StorageNode::new();
        let hash1 = node.store(b"Content 1".to_vec());
        let hash2 = node.store(b"Content 2".to_vec());
        let hashes = node.list_hashes();
        assert!(hashes.contains(&hash1));
        assert!(hashes.contains(&hash2));
    }

    #[test]
    fn test_clear_and_len() {
        let mut node = StorageNode::new();
        node.store(b"Content 1".to_vec());
        node.store(b"Content 2".to_vec());
        assert_eq!(node.len(), 2);
        node.clear();
        assert!(node.is_empty());
    }
}===== END OF crates/icn_storage/src/lib.rs =====

===== START OF crates/icn_storage/src/storage_manager.rs =====
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use uuid::Uuid;
use crate::storage_node::StorageNode;

#[derive(Debug)]
pub struct StorageManager {
    nodes: HashMap<Uuid, Arc<Mutex<StorageNode>>>,
}

impl StorageManager {
    pub fn new() -> Self {
        StorageManager {
            nodes: HashMap::new(),
        }
    }

    pub fn add_node(&mut self, node: Arc<Mutex<StorageNode>>) -> Uuid {
        let id = Uuid::new_v4();
        self.nodes.insert(id, node);
        id
    }

    pub fn remove_node(&mut self, id: Uuid) {
        self.nodes.remove(&id);
    }

    pub fn get_node(&self, id: &Uuid) -> Option<Arc<Mutex<StorageNode>>> {
        self.nodes.get(id).cloned()
    }

    pub fn list_nodes(&self) -> Vec<Uuid> {
        self.nodes.keys().cloned().collect()
    }
}
===== END OF crates/icn_storage/src/storage_manager.rs =====

===== START OF crates/icn_storage/src/storage_node.rs =====
===== END OF crates/icn_storage/src/storage_node.rs =====

===== START OF crates/icn_testnet/Cargo.toml =====
[package]
name = "icn_testnet"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_core = { path = "../icn_core" }
icn_blockchain = { path = "../icn_blockchain" }
icn_consensus = { path = "../icn_consensus" }
icn_currency = { path = "../icn_currency" }
icn_governance = { path = "../icn_governance" }
icn_identity = { path = "../icn_identity" }
icn_network = { path = "../icn_network" }
icn_sharding = { path = "../icn_sharding" }
icn_vm = { path = "../icn_vm" }
tokio = { version = "1.0", features = ["full"] }
log = "0.4"
env_logger = "0.9"
rand = "0.8"===== END OF crates/icn_testnet/Cargo.toml =====

===== START OF crates/icn_testnet/src/main.rs =====
use icn_core::IcnNode;
use icn_blockchain::Transaction;
use icn_consensus::PoCConsensus;
use icn_currency::CurrencyType;
use icn_governance::DemocraticSystem;
use icn_identity::DecentralizedIdentity;
use icn_network::Network;
use icn_sharding::ShardingManager;
use icn_vm::CoopVM;

fn main() {
    println!("Hello from ICN TestNet!");
}===== END OF crates/icn_testnet/src/main.rs =====

===== START OF crates/icn_vm/Cargo.toml =====
[package]
name = "icn_vm"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
log = "0.4"
thiserror = "1.0"
chrono = { version = "0.4", features = ["serde"] }

[dev-dependencies]
tokio-test = "0.4"
===== END OF crates/icn_vm/Cargo.toml =====

===== START OF crates/icn_vm/src/compiler.rs =====
use crate::vm::opcode::{Opcode, Value};
use std::error::Error;

// Define the tokens that the lexer will generate from source code
#[derive(Debug, PartialEq, Clone)]
enum Token {
    Identifier(String),
    Integer(i64),
    Float(f64),
    String(String),
    True,
    False,
    If,
    Else,
    While,
    Function,
    Return,
    Vote,
    AllocateResource,
    UpdateReputation,
    CreateProposal,
    GetProposalStatus,
    Emit,
    LParen,
    RParen,
    LBrace,
    RBrace,
    Semicolon,
    Comma,
    Equals,
    Plus,
    Minus,
    Multiply,
    Divide,
    Modulo,
    DoubleEquals,
    NotEquals,
    GreaterThan,
    LessThan,
    GreaterThanEquals,
    LessThanEquals,
    And,
    Or,
    Not,
}

// Lexer for converting source code into tokens
struct Lexer {
    input: Vec<char>,
    position: usize,
}

impl Lexer {
    // Create a new lexer with the given input string
    fn new(input: &str) -> Self {
        Lexer {
            input: input.chars().collect(),
            position: 0,
        }
    }

    // Get the next token from the input
    fn next_token(&mut self) -> Option<Token> {
        self.skip_whitespace();

        if self.position >= self.input.len() {
            return None;
        }

        match self.input[self.position] {
            '(' => {
                self.position += 1;
                Some(Token::LParen)
            }
            ')' => {
                self.position += 1;
                Some(Token::RParen)
            }
            '{' => {
                self.position += 1;
                Some(Token::LBrace)
            }
            '}' => {
                self.position += 1;
                Some(Token::RBrace)
            }
            ';' => {
                self.position += 1;
                Some(Token::Semicolon)
            }
            ',' => {
                self.position += 1;
                Some(Token::Comma)
            }
            '+' => {
                self.position += 1;
                Some(Token::Plus)
            }
            '-' => {
                self.position += 1;
                Some(Token::Minus)
            }
            '*' => {
                self.position += 1;
                Some(Token::Multiply)
            }
            '/' => {
                self.position += 1;
                Some(Token::Divide)
            }
            '%' => {
                self.position += 1;
                Some(Token::Modulo)
            }
            '=' => {
                if self.peek_next() == Some('=') {
                    self.position += 2;
                    Some(Token::DoubleEquals)
                } else {
                    self.position += 1;
                    Some(Token::Equals)
                }
            }
            '!' => {
                if self.peek_next() == Some('=') {
                    self.position += 2;
                    Some(Token::NotEquals)
                } else {
                    self.position += 1;
                    Some(Token::Not)
                }
            }
            '>' => {
                if self.peek_next() == Some('=') {
                    self.position += 2;
                    Some(Token::GreaterThanEquals)
                } else {
                    self.position += 1;
                    Some(Token::GreaterThan)
                }
            }
            '<' => {
                if self.peek_next() == Some('=') {
                    self.position += 2;
                    Some(Token::LessThanEquals)
                } else {
                    self.position += 1;
                    Some(Token::LessThan)
                }
            }
            '&' => {
                if self.peek_next() == Some('&') {
                    self.position += 2;
                    Some(Token::And)
                } else {
                    None // Invalid token
                }
            }
            '|' => {
                if self.peek_next() == Some('|') {
                    self.position += 2;
                    Some(Token::Or)
                } else {
                    None // Invalid token
                }
            }
            '"' => Some(self.read_string()),
            c if c.is_alphabetic() => Some(self.read_identifier()),
            c if c.is_digit(10) => Some(self.read_number()),
            _ => None, // Invalid token
        }
    }

    // Skip whitespace characters in the input
    fn skip_whitespace(&mut self) {
        while self.position < self.input.len() && self.input[self.position].is_whitespace() {
            self.position += 1;
        }
    }

    // Peek at the next character without advancing the position
    fn peek_next(&self) -> Option<char> {
        if self.position + 1 < self.input.len() {
            Some(self.input[self.position + 1])
        } else {
            None
        }
    }

    // Read a string token from the input
    fn read_string(&mut self) -> Token {
        self.position += 1; // Skip opening quote
        let start = self.position;
        while self.position < self.input.len() && self.input[self.position] != '"' {
            self.position += 1;
        }
        let value: String = self.input[start..self.position].iter().collect();
        self.position += 1; // Skip closing quote
        Token::String(value)
    }

    // Read an identifier token from the input
    fn read_identifier(&mut self) -> Token {
        let start = self.position;
        while self.position < self.input.len() && (self.input[self.position].is_alphanumeric() || self.input[self.position] == '_') {
            self.position += 1;
        }
        let value: String = self.input[start..self.position].iter().collect();
        match value.as_str() {
            "true" => Token::True,
            "false" => Token::False,
            "if" => Token::If,
            "else" => Token::Else,
            "while" => Token::While,
            "function" => Token::Function,
            "return" => Token::Return,
            "vote" => Token::Vote,
            "allocate_resource" => Token::AllocateResource,
            "update_reputation" => Token::UpdateReputation,
            "create_proposal" => Token::CreateProposal,
            "get_proposal_status" => Token::GetProposalStatus,
            "emit" => Token::Emit,
            _ => Token::Identifier(value),
        }
    }

    // Read a number token from the input
    fn read_number(&mut self) -> Token {
        let start = self.position;
        let mut is_float = false;
        while self.position < self.input.len() && (self.input[self.position].is_digit(10) || self.input[self.position] == '.') {
            if self.input[self.position] == '.' {
                is_float = true;
            }
            self.position += 1;
        }
        let value: String = self.input[start..self.position].iter().collect();
        if is_float {
            Token::Float(value.parse().unwrap())
        } else {
            Token::Integer(value.parse().unwrap())
        }
    }
}

// Parser for converting tokens into opcodes
struct Parser {
    tokens: Vec<Token>,
    position: usize,
}

impl Parser {
    // Create a new parser with the given tokens
    fn new(tokens: Vec<Token>) -> Self {
        Parser {
            tokens,
            position: 0,
        }
    }

    // Parse the tokens into a vector of opcodes
    fn parse(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        let mut opcodes = Vec::new();
        while self.position < self.tokens.len() {
            opcodes.append(&mut self.parse_statement()?);
        }
        Ok(opcodes)
    }

    // Parse a single statement into opcodes
    fn parse_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        match self.current_token() {
            Some(Token::If) => self.parse_if_statement(),
            Some(Token::While) => self.parse_while_statement(),
            Some(Token::Function) => self.parse_function_definition(),
            Some(Token::Return) => self.parse_return_statement(),
            Some(Token::Identifier(_)) => self.parse_assignment_or_function_call(),
            Some(Token::Vote) => self.parse_vote_statement(),
            Some(Token::AllocateResource) => self.parse_allocate_resource_statement(),
            Some(Token::UpdateReputation) => self.parse_update_reputation_statement(),
            Some(Token::CreateProposal) => self.parse_create_proposal_statement(),
            Some(Token::GetProposalStatus) => self.parse_get_proposal_status_statement(),
            Some(Token::Emit) => self.parse_emit_statement(),
            _ => Err("Unexpected token in statement".into()),
        }
    }

    // Parse an if statement into opcodes
    fn parse_if_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        // Implementation for parsing if statements
        Err("If statement parsing not implemented yet".into())
    }

    // Parse a while loop into opcodes
    fn parse_while_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        // Implementation for parsing while loops
        Err("While statement parsing not implemented yet".into())
    }

    // Parse a function definition into opcodes
    fn parse_function_definition(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        // Implementation for parsing function definitions
        Err("Function definition parsing not implemented yet".into())
    }

    // Parse a return statement into opcodes
    fn parse_return_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        self.consume_token(Token::Return)?;
        let mut opcodes = self.parse_expression()?;
        opcodes.push(Opcode::Return);
        self.consume_token(Token::Semicolon)?;
        Ok(opcodes)
    }

    // Parse an assignment or function call into opcodes
    fn parse_assignment_or_function_call(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        let identifier = self.consume_identifier()?;
        match self.current_token() {
            Some(Token::Equals) => self.parse_assignment(identifier),
            Some(Token::LParen) => self.parse_function_call(identifier),
            _ => Err("Expected '=' or '(' after identifier".into()),
        }
    }

    // Parse an assignment statement into opcodes
    fn parse_assignment(&mut self, identifier: String) -> Result<Vec<Opcode>, Box<dyn Error>> {
        self.consume_token(Token::Equals)?;
        let mut opcodes = self.parse_expression()?;
        opcodes.push(Opcode::Store(identifier));
        self.consume_token(Token::Semicolon)?;
        Ok(opcodes)
    }

    // Parse a function call into opcodes
    fn parse_function_call(&mut self, identifier: String) -> Result<Vec<Opcode>, Box<dyn Error>> {
        self.consume_token(Token::LParen)?;
        let mut opcodes = Vec::new();
        while !matches!(self.current_token(), Some(Token::RParen)) {
            opcodes.append(&mut self.parse_expression()?);
            if matches!(self.current_token(), Some(Token::Comma)) {
                self.consume_token(Token::Comma)?;
            }
        }
        self.consume_token(Token::RParen)?;
        opcodes.push(Opcode::Call(identifier));
        self.consume_token(Token::Semicolon)?;
        Ok(opcodes)
    }

    // Parse a vote statement into opcodes
    fn parse_vote_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        self.consume_token(Token::Vote)?;
        self.consume_token(Token::LParen)?;
        let proposal_id = self.consume_string()?;
        self.consume_token(Token::Comma)?;
        let mut opcodes = self.parse_expression()?; // This should push a boolean onto the stack
        self.consume_token(Token::RParen)?;
        opcodes.push(Opcode::Vote(proposal_id));
        self.consume_token(Token::Semicolon)?;
        Ok(opcodes)
    }

    // Parse an allocate resource statement into opcodes
    fn parse_allocate_resource_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        self.consume_token(Token::AllocateResource)?;
        self.consume_token(Token::LParen)?;
        let resource_id = self.consume_string()?;
        self.consume_token(Token::Comma)?;
        let mut opcodes = self.parse_expression()?; // This should push an integer onto the stack
        self.consume_token(Token::RParen)?;
        opcodes.push(Opcode::AllocateResource(resource_id));
        self.consume_token(Token::Semicolon)?;
        Ok(opcodes)
    }

    // Parse an update reputation statement into opcodes
    fn parse_update_reputation_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        self.consume_token(Token::UpdateReputation)?;
        self.consume_token(Token::LParen)?;
        let address = self.consume_string()?;
        self.consume_token(Token::Comma)?;
        let mut opcodes = self.parse_expression()?; // This should push an integer onto the stack
        self.consume_token(Token::RParen)?;
        opcodes.push(Opcode::UpdateReputation(address));
        self.consume_token(Token::Semicolon)?;
        Ok(opcodes)
    }

    // Parse a create proposal statement into opcodes
    fn parse_create_proposal_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        self.consume_token(Token::CreateProposal)?;
        self.consume_token(Token::LParen)?;
        let mut opcodes = self.parse_expression()?; // This should push a string onto the stack
        self.consume_token(Token::RParen)?;
        opcodes.push(Opcode::CreateProposal);
        self.consume_token(Token::Semicolon)?;
        Ok(opcodes)
    }

    // Parse a get proposal status statement into opcodes
    fn parse_get_proposal_status_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        self.consume_token(Token::GetProposalStatus)?;
        self.consume_token(Token::LParen)?;
        let mut opcodes = self.parse_expression()?; // This should push a string onto the stack
        self.consume_token(Token::RParen)?;
        opcodes.push(Opcode::GetProposalStatus);
        self.consume_token(Token::Semicolon)?;
        Ok(opcodes)
    }

    // Parse an emit statement into opcodes
    fn parse_emit_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        self.consume_token(Token::Emit)?;
        self.consume_token(Token::LParen)?;
        let event_name = self.consume_string()?;
        self.consume_token(Token::Comma)?;
        let mut opcodes = self.parse_expression()?; // This should push the event data onto the stack
        self.consume_token(Token::RParen)?;
        opcodes.push(Opcode::Emit(event_name));
        self.consume_token(Token::Semicolon)?;
        Ok(opcodes)
    }

    // Parse an expression into opcodes
    fn parse_expression(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        let mut opcodes = self.parse_term()?;

        while let Some(token) = self.current_token() {
            match token {
                Token::Plus => {
                    self.position += 1;
                    opcodes.append(&mut self.parse_term()?);
                    opcodes.push(Opcode::Add);
                }
                Token::Minus => {
                    self.position += 1;
                    opcodes.append(&mut self.parse_term()?);
                    opcodes.push(Opcode::Sub);
                }
                _ => break,
            }
        }

        Ok(opcodes)
    }

    fn parse_term(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        let mut opcodes = self.parse_factor()?;

        while let Some(token) = self.current_token() {
            match token {
                Token::Multiply => {
                    self.position += 1;
                    opcodes.append(&mut self.parse_factor()?);
                    opcodes.push(Opcode::Mul);
                }
                Token::Divide => {
                    self.position += 1;
                    opcodes.append(&mut self.parse_factor()?);
                    opcodes.push(Opcode::Div);
                }
                _ => break,
            }
        }

        Ok(opcodes)
    }

    fn parse_factor(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        let token = self.current_token().cloned();
        match token {
            Some(Token::Integer(value)) => {
                self.position += 1;
                Ok(vec![Opcode::Push(Value::Int(value))])
            }
            Some(Token::Float(value)) => {
                self.position += 1;
                Ok(vec![Opcode::Push(Value::Float(value))])
            }
            Some(Token::String(value)) => {
                self.position += 1;
                Ok(vec![Opcode::Push(Value::String(value))])
            }
            Some(Token::True) => {
                self.position += 1;
                Ok(vec![Opcode::Push(Value::Bool(true))])
            }
            Some(Token::False) => {
                self.position += 1;
                Ok(vec![Opcode::Push(Value::Bool(false))])
            }
            Some(Token::Identifier(name)) => {
                self.position += 1;
                Ok(vec![Opcode::Load(name)])
            }
            Some(Token::LParen) => {
                self.position += 1;
                let expr = self.parse_expression()?;
                self.consume_token(Token::RParen)?;
                Ok(expr)
            }
            _ => Err("Unexpected token in expression".into()),
        }
    }

    // Consume the next token if it matches the expected token
    fn consume_token(&mut self, expected: Token) -> Result<(), Box<dyn Error>> {
        if self.current_token() == Some(&expected) {
            self.position += 1;
            Ok(())
        } else {
            Err(format!("Unexpected token: expected {:?}, found {:?}", expected, self.current_token()).into())
        }
    }

    // Consume an identifier token
    fn consume_identifier(&mut self) -> Result<String, Box<dyn Error>> {
        if let Some(Token::Identifier(name)) = self.current_token().cloned() {
            self.position += 1;
            Ok(name)
        } else {
            Err(format!("Expected identifier, found {:?}", self.current_token()).into())
        }
    }

    // Consume a string token
    fn consume_string(&mut self) -> Result<String, Box<dyn Error>> {
        if let Some(Token::String(value)) = self.current_token().cloned() {
            self.position += 1;
            Ok(value)
        } else {
            Err(format!("Expected string, found {:?}", self.current_token()).into())
        }
    }

    // Get the current token
    fn current_token(&self) -> Option<&Token> {
        self.tokens.get(self.position)
    }
}

// Compiler for converting source code into opcodes
pub struct CSCLCompiler {
    lexer: Lexer,
}

impl CSCLCompiler {
    // Create a new compiler with the given input source code
    pub fn new(input: &str) -> Self {
        CSCLCompiler {
            lexer: Lexer::new(input),
        }
    }

    // Compile the source code into a vector of opcodes
    pub fn compile(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        let tokens = self.lexer.tokens();
        let mut parser = Parser::new(tokens);
        parser.parse()
    }
}

impl Lexer {
    // Get all tokens from the input
    fn tokens(&mut self) -> Vec<Token> {
        let mut tokens = Vec::new();
        while let Some(token) = self.next_token() {
            tokens.push(token);
        }
        tokens
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_lexer() {
        let input = "function test(x, y) { return x + y; }";
        let mut lexer = Lexer::new(input);
        let tokens = lexer.tokens();

        assert_eq!(tokens, vec![
            Token::Function,
            Token::Identifier("test".to_string()),
            Token::LParen,
            Token::Identifier("x".to_string()),
            Token::Comma,
            Token::Identifier("y".to_string()),
            Token::RParen,
            Token::LBrace,
            Token::Return,
            Token::Identifier("x".to_string()),
            Token::Plus,
            Token::Identifier("y".to_string()),
            Token::Semicolon,
            Token::RBrace,
        ]);
    }

    #[test]
    fn test_compiler() {
        let input = "x = 5 + 3 * 2; y = (10 - 4) / 2;";
        let mut compiler = CSCLCompiler::new(input);
        let opcodes = compiler.compile().unwrap();

        assert_eq!(opcodes, vec![
            Opcode::Push(Value::Int(5)),
            Opcode::Push(Value::Int(3)),
            Opcode::Push(Value::Int(2)),
            Opcode::Mul,
            Opcode::Add,
            Opcode::Store("x".to_string()),
            Opcode::Push(Value::Int(10)),
            Opcode::Push(Value::Int(4)),
            Opcode::Sub,
            Opcode::Push(Value::Int(2)),
            Opcode::Div,
            Opcode::Store("y".to_string()),
        ]);
    }
}
===== END OF crates/icn_vm/src/compiler.rs =====

===== START OF crates/icn_vm/src/coop_vm.rs =====
use super::opcode::{Opcode, Value};
use std::collections::HashMap;

pub struct CoopVM {
    stack: Vec<Value>,
    memory: HashMap<String, Value>,
    program: Vec<Opcode>,
    pc: usize,
}

impl CoopVM {
    pub fn new(program: Vec<Opcode>) -> Self {
        CoopVM {
            stack: Vec::new(),
            memory: HashMap::new(),
            program,
            pc: 0,
        }
    }

    pub fn load_program(&mut self, program: Vec<Opcode>) {
        self.program = program;
        self.pc = 0;
    }

    pub fn run(&mut self) -> Result<(), String> {
        while self.pc < self.program.len() {
            self.execute_instruction()?;
            self.pc += 1;
        }
        Ok(())
    }

    fn execute_instruction(&mut self) -> Result<(), String> {
        let opcode = self.program[self.pc].clone();
        match opcode {
            Opcode::Push(value) => self.stack.push(value),
            Opcode::Pop => {
                self.stack.pop().ok_or("Stack underflow")?;
            }
            Opcode::Add => self.binary_op(|a, b| a + b)?,
            Opcode::Sub => self.binary_op(|a, b| a - b)?,
            Opcode::Mul => self.binary_op(|a, b| a * b)?,
            Opcode::Div => self.binary_op(|a, b| a / b)?,
            Opcode::Eq => self.compare_op(|a, b| a == b)?,
            Opcode::Lt => self.compare_op(|a, b| a < b)?,
            Opcode::Gt => self.compare_op(|a, b| a > b)?,
            Opcode::And => self.logic_op(|a, b| a && b)?,
            Opcode::Or => self.logic_op(|a, b| a || b)?,
            Opcode::Not => {
                let a = self.pop_bool()?;
                self.stack.push(Value::Bool(!a));
            }
            Opcode::Return => return Ok(()), // For now, just return
            Opcode::Store(name) => {
                let value = self.stack.pop().ok_or("Stack underflow")?;
                self.memory.insert(name, value);
            }
            Opcode::Load(name) => {
                let value = self.memory.get(&name).ok_or("Variable not found")?.clone();
                self.stack.push(value);
            }
            Opcode::Call(_) => return Err("Function calls not implemented yet".to_string()),
            Opcode::Vote(proposal_id) => {
                let vote = self.pop_bool()?;
                println!("Voting {} on proposal {}", if vote { "Yes" } else { "No" }, proposal_id);
            }
            Opcode::AllocateResource(resource_id) => {
                let amount = self.pop_int()?;
                println!("Allocating {} units of resource {}", amount, resource_id);
            }
            Opcode::UpdateReputation(address) => {
                let change = self.pop_int()?;
                println!("Updating reputation of {} by {}", address, change);
            }
            Opcode::CreateProposal => {
                let description = self.pop_string()?;
                println!("Creating proposal: {}", description);
                self.stack.push(Value::String("new_proposal_id".to_string()));
            }
            Opcode::GetProposalStatus => {
                let proposal_id = self.pop_string()?;
                println!("Getting status of proposal: {}", proposal_id);
                self.stack.push(Value::String("Active".to_string()));
            }
            Opcode::Emit(event_name) => {
                let event_data = self.stack.pop().ok_or("Stack underflow")?;
                println!("Emitting event {}: {:?}", event_name, event_data);
            }
        }
        Ok(())
    }

    fn binary_op<F>(&mut self, op: F) -> Result<(), String>
    where
        F: Fn(i64, i64) -> i64,
    {
        let b = self.pop_int()?;
        let a = self.pop_int()?;
        self.stack.push(Value::Int(op(a, b)));
        Ok(())
    }

    fn compare_op<F>(&mut self, op: F) -> Result<(), String>
    where
        F: Fn(&Value, &Value) -> bool,
    {
        let b = self.stack.pop().ok_or("Stack underflow")?;
        let a = self.stack.pop().ok_or("Stack underflow")?;
        self.stack.push(Value::Bool(op(&a, &b)));
        Ok(())
    }

    fn logic_op<F>(&mut self, op: F) -> Result<(), String>
    where
        F: Fn(bool, bool) -> bool,
    {
        let b = self.pop_bool()?;
        let a = self.pop_bool()?;
        self.stack.push(Value::Bool(op(a, b)));
        Ok(())
    }

    fn pop_int(&mut self) -> Result<i64, String> {
        match self.stack.pop().ok_or("Stack underflow")? {
            Value::Int(i) => Ok(i),
            _ => Err("Expected integer value".to_string()),
        }
    }

    fn pop_bool(&mut self) -> Result<bool, String> {
        match self.stack.pop().ok_or("Stack underflow")? {
            Value::Bool(b) => Ok(b),
            _ => Err("Expected boolean value".to_string()),
        }
    }

    fn pop_string(&mut self) -> Result<String, String> {
        match self.stack.pop().ok_or("Stack underflow")? {
            Value::String(s) => Ok(s),
            _ => Err("Expected string value".to_string()),
        }
    }

    pub fn get_stack(&self) -> &Vec<Value> {
        &self.stack
    }

    pub fn get_memory(&self) -> &HashMap<String, Value> {
        &self.memory
    }
}
===== END OF crates/icn_vm/src/coop_vm.rs =====

===== START OF crates/icn_vm/src/lib.rs =====
===== END OF crates/icn_vm/src/lib.rs =====

===== START OF crates/icn_vm/src/opcode.rs =====
#[derive(Debug, Clone, PartialEq, PartialOrd)] // Add PartialOrd here
pub enum Value {
    Int(i64),
    Float(f64),
    Bool(bool),
    String(String),
}

#[derive(Debug, Clone, PartialEq)]
pub enum Opcode {
    Push(Value),
    Pop,
    Add,
    Sub,
    Mul,
    Div,
    Eq,
    Lt,
    Gt,
    And,
    Or,
    Not,
    Return,
    Store(String),
    Load(String),
    Call(String),
    Vote(String),
    AllocateResource(String),
    UpdateReputation(String),
    CreateProposal,
    GetProposalStatus,
    Emit(String),
}
===== END OF crates/icn_vm/src/opcode.rs =====

===== START OF crates/icn_vm/src/smart_contract.rs =====
use icn_common::{Error, Result};
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct AssetTokenContract {
    pub tokens: Vec<AssetToken>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct AssetToken {
    pub id: String,
    pub owner: String,
    pub metadata: serde_json::Value,
}

impl AssetTokenContract {
    pub fn new() -> Self {
        AssetTokenContract {
            tokens: Vec::new(),
        }
    }

    pub fn create_token(&mut self, id: String, owner: String, metadata: serde_json::Value) -> Result<AssetToken> {
        if self.tokens.iter().any(|t| t.id == id) {
            return Err(Error {
                message: "Token already exists".to_string(),
            });
        }

        let token = AssetToken {
            id: id.clone(),
            owner: owner.clone(),
            metadata,
        };

        self.tokens.push(token.clone());
        Ok(token)
    }

    pub fn transfer_token(&mut self, id: &str, new_owner: String) -> Result<()> {
        let token = self.tokens.iter_mut().find(|t| t.id == id).ok_or_else(|| Error {
            message: "Token not found".to_string(),
        })?;

        token.owner = new_owner;
        Ok(())
    }

    pub fn get_token(&self, id: &str) -> Option<&AssetToken> {
        self.tokens.iter().find(|t| t.id == id)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct BondContract {
    pub bonds: Vec<Bond>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Bond {
    pub id: String,
    pub owner: String,
    pub terms: String,
}

impl BondContract {
    pub fn new() -> Self {
        BondContract {
            bonds: Vec::new(),
        }
    }

    pub fn create_bond(&mut self, id: String, owner: String, terms: String) -> Result<Bond> {
        if self.bonds.iter().any(|b| b.id == id) {
            return Err(Error {
                message: "Bond already exists".to_string(),
            });
        }

        let bond = Bond {
            id: id.clone(),
            owner: owner.clone(),
            terms,
        };

        self.bonds.push(bond.clone());
        Ok(bond)
    }

    pub fn transfer_bond(&mut self, id: &str, new_owner: String) -> Result<()> {
        let bond = self.bonds.iter_mut().find(|b| b.id == id).ok_or_else(|| Error {
            message: "Bond not found".to_string(),
        })?;

        bond.owner = new_owner;
        Ok(())
    }

    pub fn get_bond(&self, id: &str) -> Option<&Bond> {
        self.bonds.iter().find(|b| b.id == id)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn test_create_and_transfer_token() {
        let mut contract = AssetTokenContract::new();
        let metadata = json!({ "type": "Real Estate", "location": "123 Main St" });

        let token = contract.create_token("token1".to_string(), "Alice".to_string(), metadata).unwrap();
        assert_eq!(token.owner, "Alice");

        contract.transfer_token("token1", "Bob".to_string()).unwrap();
        let updated_token = contract.get_token("token1").unwrap();
        assert_eq!(updated_token.owner, "Bob");
    }

    #[test]
    fn test_create_and_transfer_bond() {
        let mut contract = BondContract::new();
        let bond = contract.create_bond("bond1".to_string(), "Alice".to_string(), "Terms of the bond".to_string()).unwrap();
        assert_eq!(bond.owner, "Alice");

        contract.transfer_bond("bond1", "Bob".to_string()).unwrap();
        let updated_bond = contract.get_bond("bond1").unwrap();
        assert_eq!(updated_bond.owner, "Bob");
    }
}
===== END OF crates/icn_vm/src/smart_contract.rs =====

===== START OF crates/icn_vm/src/templates.rs =====
===== END OF crates/icn_vm/src/templates.rs =====

===== START OF crates/icn_vm/src/vm.rs =====
// File: src/vm.rs

use std::collections::HashMap;
use std::fmt;

#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub enum Value {
    Int(i64),
    Float(f64),
    Bool(bool),
    String(String),
    Address(String),
    List(Vec<Value>),
}

impl fmt::Display for Value {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Value::Int(i) => write!(f, "{}", i),
            Value::Float(fl) => write!(f, "{}", fl),
            Value::Bool(b) => write!(f, "{}", b),
            Value::String(s) => write!(f, "\"{}\"", s),
            Value::Address(a) => write!(f, "Address({})", a),
            Value::List(l) => write!(f, "{:?}", l),
        }
    }
}

#[derive(Debug, Clone)]
pub enum Opcode {
    Push(Value),
    Pop,
    Add,
    Sub,
    Mul,
    Div,
    Mod,
    Eq,
    Neq,
    Gt,
    Lt,
    Gte,
    Lte,
    And,
    Or,
    Not,
    Store(String),
    Load(String),
    JumpIf(usize),
    Jump(usize),
    Call(String),
    Return,
    CreateList,
    AppendList,
    GetListItem,
    SetListItem,
    Vote(String),
    AllocateResource(String),
    UpdateReputation(String),
    CreateProposal,
    GetProposalStatus,
    Emit(String),
}

pub struct CoopVM {
    stack: Vec<Value>,
    memory: HashMap<String, Value>,
    program: Vec<Opcode>,
    pc: usize,
    call_stack: Vec<usize>,
    functions: HashMap<String, usize>,
}

impl CoopVM {
    pub fn new(program: Vec<Opcode>) -> Self {
        CoopVM {
            stack: Vec::new(),
            memory: HashMap::new(),
            program,
            pc: 0,
            call_stack: Vec::new(),
            functions: HashMap::new(),
        }
    }

    pub fn run(&mut self) -> Result<(), String> {
        while self.pc < self.program.len() {
            self.execute_instruction()?;
            self.pc += 1;
        }
        Ok(())
    }

    fn execute_instruction(&mut self) -> Result<(), String> {
        let current_instruction = &self.program[self.pc].clone();
        match current_instruction {
            Opcode::Push(value) => self.stack.push(value.clone()),
            Opcode::Pop => {
                self.stack.pop().ok_or("Stack underflow")?;
            }
            Opcode::Add => self.binary_op(|a, b| a + b)?,
            Opcode::Sub => self.binary_op(|a, b| a - b)?,
            Opcode::Mul => self.binary_op(|a, b| a * b)?,
            Opcode::Div => self.binary_op(|a, b| a / b)?,
            Opcode::Mod => self.binary_op(|a, b| a % b)?,
            Opcode::Eq => self.compare_op(|a, b| a == b)?,
            Opcode::Neq => self.compare_op(|a, b| a != b)?,
            Opcode::Gt => self.compare_op(|a, b| a > b)?,
            Opcode::Lt => self.compare_op(|a, b| a < b)?,
            Opcode::Gte => self.compare_op(|a, b| a >= b)?,
            Opcode::Lte => self.compare_op(|a, b| a <= b)?,
            Opcode::And => self.logic_op(|a, b| a && b)?,
            Opcode::Or => self.logic_op(|a, b| a || b)?,
            Opcode::Not => {
                let a = self.pop_bool()?;
                self.stack.push(Value::Bool(!a));
            }
            Opcode::Store(name) => {
                let value = self.stack.pop().ok_or("Stack underflow")?;
                self.memory.insert(name.clone(), value);
            }
            Opcode::Load(name) => {
                let value = self.memory.get(name).ok_or("Variable not found")?.clone();
                self.stack.push(value);
            }
            Opcode::JumpIf(target) => {
                if self.pop_bool()? {
                    self.pc = *target - 1;
                }
            }
            Opcode::Jump(target) => {
                self.pc = *target - 1;
            }
            Opcode::Call(func_name) => {
                let func_pc = self.functions.get(func_name).ok_or("Function not found")?;
                self.call_stack.push(self.pc);
                self.pc = *func_pc - 1;
            }
            Opcode::Return => {
                self.pc = self.call_stack.pop().ok_or("Return without call")?;
            }
            Opcode::CreateList => {
                self.stack.push(Value::List(Vec::new()));
            }
            Opcode::AppendList => {
                let value = self.stack.pop().ok_or("Stack underflow")?;
                if let Some(Value::List(list)) = self.stack.last_mut() {
                    list.push(value);
                } else {
                    return Err("Expected list on top of stack".to_string());
                }
            }
            Opcode::GetListItem => {
                let index = self.pop_int()?;
                if let Some(Value::List(list)) = self.stack.pop() {
                    let item = list.get(index as usize).ok_or("List index out of bounds")?.clone();
                    self.stack.push(item);
                } else {
                    return Err("Expected list on top of stack".to_string());
                }
            }
            Opcode::SetListItem => {
                let value = self.stack.pop().ok_or("Stack underflow")?;
                let index = self.pop_int()?;
                if let Some(Value::List(list)) = self.stack.last_mut() {
                    if (index as usize) < list.len() {
                        list[index as usize] = value;
                    } else {
                        return Err("List index out of bounds".to_string());
                    }
                } else {
                    return Err("Expected list on top of stack".to_string());
                }
            }
            Opcode::Vote(proposal_id) => {
                let vote = self.pop_bool()?;
                println!("Voting {} on proposal {}", if vote { "Yes" } else { "No" }, proposal_id);
            }
            Opcode::AllocateResource(resource_id) => {
                let amount = self.pop_int()?;
                println!("Allocating {} units of resource {}", amount, resource_id);
            }
            Opcode::UpdateReputation(address) => {
                let change = self.pop_int()?;
                println!("Updating reputation of {} by {}", address, change);
            }
            Opcode::CreateProposal => {
                let description = self.pop_string()?;
                println!("Creating proposal: {}", description);
                self.stack.push(Value::String("new_proposal_id".to_string()));
            }
            Opcode::GetProposalStatus => {
                let proposal_id = self.pop_string()?;
                println!("Getting status of proposal: {}", proposal_id);
                self.stack.push(Value::String("Active".to_string()));
            }
            Opcode::Emit(event_name) => {
                let event_data = self.stack.pop().ok_or("Stack underflow")?;
                println!("Emitting event {}: {}", event_name, event_data);
            }
        }
        Ok(())
    }

    fn binary_op<F>(&mut self, op: F) -> Result<(), String>
    where
        F: Fn(i64, i64) -> i64,
    {
        let b = self.pop_int()?;
        let a = self.pop_int()?;
        self.stack.push(Value::Int(op(a, b)));
        Ok(())
    }

    fn compare_op<F>(&mut self, op: F) -> Result<(), String>
    where
        F: Fn(&Value, &Value) -> bool,
    {
        let b = self.stack.pop().ok_or("Stack underflow")?;
        let a = self.stack.pop().ok_or("Stack underflow")?;
        self.stack.push(Value::Bool(op(&a, &b)));
        Ok(())
    }

    fn logic_op<F>(&mut self, op: F) -> Result<(), String>
    where
        F: Fn(bool, bool) -> bool,
    {
        let b = self.pop_bool()?;
        let a = self.pop_bool()?;
        self.stack.push(Value::Bool(op(a, b)));
        Ok(())
    }

    fn pop_int(&mut self) -> Result<i64, String> {
        match self.stack.pop().ok_or("Stack underflow")? {
            Value::Int(i) => Ok(i),
            _ => Err("Expected integer value".to_string()),
        }
    }

    fn pop_bool(&mut self) -> Result<bool, String> {
        match self.stack.pop().ok_or("Stack underflow")? {
            Value::Bool(b) => Ok(b),
            _ => Err("Expected boolean value".to_string()),
        }
    }

    fn pop_string(&mut self) -> Result<String, String> {
        match self.stack.pop().ok_or("Stack underflow")? {
            Value::String(s) => Ok(s),
            _ => Err("Expected string value".to_string()),
        }
    }

    pub fn register_function(&mut self, name: String, pc: usize) {
        self.functions.insert(name, pc);
    }

    pub fn get_stack(&self) -> &Vec<Value> {
        &self.stack
    }

    pub fn get_memory(&self) -> &HashMap<String, Value> {
        &self.memory
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_operations() {
        let program = vec![
            Opcode::Push(Value::Int(5)),
            Opcode::Push(Value::Int(3)),
            Opcode::Add,
            Opcode::Push(Value::Int(2)),
            Opcode::Mul,
        ];

        let mut vm = CoopVM::new(program);
        vm.run().unwrap();

        assert_eq!(vm.stack, vec![Value::Int(16)]);
    }

    #[test]
    fn test_store_and_load() {
        let program = vec![
            Opcode::Push(Value::Int(42)),
            Opcode::Store("x".to_string()),
            Opcode::Push(Value::Int(10)),
            Opcode::Load("x".to_string()),
            Opcode::Add,
        ];

        let mut vm = CoopVM::new(program);
        vm.run().unwrap();

        assert_eq!(vm.stack, vec![Value::Int(52)]);
    }

    #[test]
    fn test_conditional_jump() {
        let program = vec![
            Opcode::Push(Value::Bool(true)),
            Opcode::JumpIf(3),
            Opcode::Push(Value::Int(1)),
            Opcode::Push(Value::Int(2)),
            Opcode::Add,
        ];

        let mut vm = CoopVM::new(program);
        vm.run().unwrap();

        assert_eq!(vm.stack, vec![Value::Int(2)]);
    }

    #[test]
    fn test_list_operations() {
        let program = vec![
            Opcode::CreateList,
            Opcode::Push(Value::Int(1)),
            Opcode::AppendList,
            Opcode::Push(Value::Int(2)),
            Opcode::AppendList,
            Opcode::Push(Value::Int(0)),
            Opcode::GetListItem,
        ];

        let mut vm = CoopVM::new(program);
        vm.run().unwrap();

        assert_eq!(vm.stack, vec![Value::List(vec![Value::Int(1), Value::Int(2)]), Value::Int(1)]);
    }

    #[test]
    fn test_cooperative_operations() {
        let program = vec![
            Opcode::Push(Value::String("Proposal 1".to_string())),
            Opcode::CreateProposal,
            Opcode::Push(Value::Bool(true)),
            Opcode::Vote("proposal_1".to_string()),
            Opcode::Push(Value::Int(100)),
            Opcode::AllocateResource("computing_power".to_string()),
            Opcode::Push(Value::Int(5)),
            Opcode::UpdateReputation("user1".to_string()),
            Opcode::Push(Value::String("proposal_1".to_string())),
            Opcode::GetProposalStatus,
        ];

        let mut vm = CoopVM::new(program);
        vm.run().unwrap();

        assert_eq!(vm.stack, vec![Value::String("new_proposal_id".to_string()), Value::String("Active".to_string())]);
    }
}
===== END OF crates/icn_vm/src/vm.rs =====

===== START OF Cargo.toml =====
[workspace]
members = [
    "crates/icn_api",
    "crates/icn_blockchain",
    "crates/icn_consensus",
    "crates/icn_core",
    "crates/icn_currency",
    "crates/icn_governance",
    "crates/icn_identity",
    "crates/icn_network",
    "crates/icn_node_managment",
    "crates/icn_sharding",
    "crates/icn_storage",
    "crates/icn_testnet",
    "crates/icn_vm",
]

[profile.release]
opt-level = 3
lto = true===== END OF Cargo.toml =====

