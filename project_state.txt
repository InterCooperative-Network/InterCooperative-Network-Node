=== Project Directory Tree ===
.
├── Cargo.lock
├── Cargo.toml
├── cert.pem
├── commit_message.txt
├── config
│   ├── config.toml
│   └── default_config.toml
├── config.toml
├── generate_project_state.sh
├── .github
│   ├── FUNDING.yml
│   └── workflows
│       ├── ci.yml
│       └── static.yml
├── .gitignore
├── .gitmodules
├── icn_api
│   ├── Cargo.toml
│   └── src
│       ├── lib
│       │   └── mod.rs
│       └── lib.rs
├── icn_blockchain
│   ├── Cargo.toml
│   └── src
│       ├── chain
│       │   └── mod.rs
│       ├── lib
│       │   └── mod.rs
│       ├── lib.rs
│       └── transaction
│           ├── mod.rs
│           ├── transaction.rs
│           └── transaction_type.rs
├── icn_consensus
│   ├── Cargo.toml
│   └── src
│       ├── consensus.rs
│       ├── lib
│       │   └── mod.rs
│       ├── lib.rs
│       └── proof_of_cooperation.rs
├── icn_core
│   ├── Cargo.toml
│   └── src
│       ├── config
│       │   ├── config_loader.rs
│       │   └── mod.rs
│       ├── coordinator
│       │   ├── mod.rs
│       │   └── module_coordinator.rs
│       ├── errors.rs
│       ├── lib
│       │   └── mod.rs
│       ├── lib.rs
│       ├── main.rs
│       └── node
│           ├── mod.rs
│           └── node_manager.rs
├── icn_governance
│   ├── Cargo.toml
│   └── src
│       ├── lib
│       │   └── mod.rs
│       └── lib.rs
├── icn_identity
│   ├── Cargo.toml
│   └── src
│       ├── lib
│       │   └── mod.rs
│       └── lib.rs
├── icn_networking
│   ├── Cargo.toml
│   └── src
│       ├── lib
│       │   └── mod.rs
│       └── lib.rs
├── icn_shared
│   ├── Cargo.toml
│   └── src
│       ├── block.rs
│       ├── consensus.rs
│       ├── error.rs
│       └── lib.rs
├── icn_smart_contracts
│   ├── Cargo.toml
│   └── src
│       ├── compiler.rs
│       ├── lib
│       │   └── mod.rs
│       ├── lib.rs
│       ├── smart_contract.rs
│       └── standard_library.rs
├── icn_storage
│   ├── Cargo.toml
│   └── src
│       ├── block_storage.rs
│       ├── lib
│       │   └── mod.rs
│       ├── lib.rs
│       └── state_storage.rs
├── icn_virtual_machine
│   ├── Cargo.toml
│   └── src
│       ├── bytecode.rs
│       ├── execution_engine.rs
│       ├── lib
│       │   └── mod.rs
│       ├── lib.rs
│       ├── plugin_manager.rs
│       ├── resource_manager.rs
│       ├── security_manager.rs
│       └── state_manager.rs
├── key.pem
├── project_parts
│   └── core_files_00
├── project_state.txt
├── README.md
├── update_project.sh
└── .vscode
    └── settings.json

43 directories, 79 files



=== ./generate_project_state.sh ===
#!/bin/bash

# Define the output file
output_file="project_state.txt"

# Clear the output file if it exists
> $output_file

# Function to write file contents to the output file
write_file_content() {
    local file_path="$1"
    echo "=== $file_path ===" >> $output_file
    cat "$file_path" >> $output_file
    echo -e "\n\n" >> $output_file
}

# Write the tree structure of the project to the output file
echo "=== Project Directory Tree ===" >> $output_file
tree -a -I 'target|.git|node_modules' >> $output_file
echo -e "\n\n" >> $output_file

# Recursively list all files and append their content, excluding build artifacts and temporary files
find . -type f \
    -not -path "./.git/*" \
    -not -path "./target/*" \
    -not -path "./**/node_modules/*" \
    -not -path "./**/*.o" \
    -not -path "./**/*.rs.bk" \
    -not -path "./**/*.log" \
    -not -name "*.txt" \
    -not -name "*.md" | while read file; do
    write_file_content "$file"
done

echo "Project state saved to $output_file"



=== ./icn_networking/Cargo.toml ===
[package]
name = "icn_networking"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1.0", features = ["full"] }
tokio-native-tls = "0.3"
native-tls = "0.2"
log = "0.4"
futures = "0.3"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
thiserror = "1.0"
icn_shared = { path = "../icn_shared" }

[dev-dependencies]
tempfile = "3.2"



=== ./icn_networking/src/lib/mod.rs ===



=== ./icn_networking/src/lib.rs ===
// Filename: icn_networking/src/lib.rs

use std::fs::File;
use std::io::Read;
use std::sync::{Arc, RwLock};
use tokio::net::{TcpListener, TcpStream};
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio_native_tls::{TlsAcceptor, TlsConnector};
use native_tls::Identity;
use futures::lock::Mutex as FuturesMutex;
use thiserror::Error;
use log::{info, error, warn};

/// Custom error type for the networking module.
#[derive(Error, Debug)]
pub enum NetworkingError {
    #[error("Network error: {0}")]
    Network(String),
    #[error("TLS error: {0}")]
    Tls(#[from] native_tls::Error),
    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),
    #[error("Lock error")]
    Lock,
}

/// Type alias for results returned by networking functions.
pub type NetworkingResult<T> = Result<T, NetworkingError>;

/// The `Networking` struct is responsible for managing peer-to-peer network connections
/// in a secure manner using TLS (Transport Layer Security). It allows for starting a server,
/// connecting to peers, and broadcasting messages to all connected peers.
#[derive(Clone)]
pub struct Networking {
    peers: Arc<RwLock<Vec<Arc<FuturesMutex<tokio_native_tls::TlsStream<TcpStream>>>>>>,
    identity: Option<Arc<Identity>>,
}

impl Networking {
    /// Creates a new instance of the `Networking` struct.
    ///
    /// # Returns
    ///
    /// * `Networking` - An instance of the `Networking` struct with an empty list of peers.
    pub fn new() -> Self {
        Networking {
            peers: Arc::new(RwLock::new(vec![])),
            identity: None,
        }
    }

    /// Loads a TLS identity from a certificate and key file.
    ///
    /// # Arguments
    ///
    /// * `cert_path` - The path to the TLS certificate file.
    /// * `key_path` - The path to the TLS key file.
    ///
    /// # Returns
    ///
    /// * `NetworkingResult<Arc<Identity>>` - The loaded TLS identity wrapped in an Arc, or an error if loading fails.
    pub fn load_tls_identity(cert_path: &str, key_path: &str) -> NetworkingResult<Arc<Identity>> {
        if !std::path::Path::new(cert_path).exists() {
            return Err(NetworkingError::Network(format!("Certificate file not found: {}", cert_path)));
        }

        if !std::path::Path::new(key_path).exists() {
            return Err(NetworkingError::Network(format!("Key file not found: {}", key_path)));
        }

        let mut cert_file = File::open(cert_path)?;
        let mut cert = Vec::new();
        cert_file.read_to_end(&mut cert)?;

        let mut key_file = File::open(key_path)?;
        let mut key = Vec::new();
        key_file.read_to_end(&mut key)?;

        let identity = Identity::from_pkcs8(&cert, &key)?;

        Ok(Arc::new(identity))
    }

    /// Starts a server that listens on the specified address using the provided TLS identity.
    ///
    /// # Arguments
    ///
    /// * `address` - The address to bind the server to.
    /// * `identity` - The TLS identity to use for secure connections.
    ///
    /// # Returns
    ///
    /// * `NetworkingResult<()>` - An empty result indicating success, or an error if starting the server fails.
    pub async fn start_server(&mut self, address: &str, identity: Arc<Identity>) -> NetworkingResult<()> {
        self.identity = Some(identity.clone());

        let acceptor = TlsAcceptor::from(
            native_tls::TlsAcceptor::new(identity.as_ref().clone())?
        );

        let listener = TcpListener::bind(address).await?;
        info!("Server started on {}", address);

        loop {
            match listener.accept().await {
                Ok((stream, _)) => {
                    let acceptor = acceptor.clone();
                    let peers = Arc::clone(&self.peers);

                    tokio::spawn(async move {
                        if let Err(e) = handle_client_connection(stream, acceptor, peers, None).await {
                            error!("Error handling client: {:?}", e);
                        }
                    });
                }
                Err(e) => error!("Failed to accept TCP connection: {:?}", e),
            }
        }
    }

    /// Connects to a peer at the specified address using TLS.
    ///
    /// # Arguments
    ///
    /// * `address` - The address of the peer to connect to.
    ///
    /// # Returns
    ///
    /// * `NetworkingResult<()>` - An empty result indicating success, or an error if the connection fails.
    pub async fn connect_to_peer(&self, address: &str) -> NetworkingResult<()> {
        let connector = TlsConnector::from(
            native_tls::TlsConnector::new()?
        );

        let stream = TcpStream::connect(address).await?;

        let tls_stream = connector.connect(address, stream).await?;

        let tls_stream = Arc::new(FuturesMutex::new(tls_stream));

        {
            let mut peers_guard = self.peers.write().map_err(|_| NetworkingError::Lock)?;
            peers_guard.push(tls_stream.clone());
        }

        info!("Connected to peer at {}", address);
        Ok(())
    }

    /// Broadcasts a message to all connected peers.
    ///
    /// # Arguments
    ///
    /// * `message` - The message to broadcast.
    ///
    /// # Returns
    ///
    /// * `NetworkingResult<()>` - An empty result indicating success, or an error if broadcasting fails.
    pub async fn broadcast_message(&self, message: &str) -> NetworkingResult<()> {
        let peers_snapshot = {
            let peers = self.peers.read().map_err(|_| NetworkingError::Lock)?;
            peers.clone()
        };

        for peer in peers_snapshot.iter() {
            let mut locked_peer = peer.lock().await;
            if let Err(e) = locked_peer.write_all(message.as_bytes()).await {
                error!("Failed to send message to peer: {}", e);
                if let Err(e) = self.remove_peer(peer).await {
                    error!("Failed to remove peer: {:?}", e);
                }
            }
        }
        Ok(())
    }

    /// Removes a disconnected or faulty peer from the list.
    ///
    /// # Arguments
    ///
    /// * `peer` - The peer to be removed.
    ///
    /// # Returns
    ///
    /// * `NetworkingResult<()>` - An empty result indicating success, or an error if the removal fails.
    async fn remove_peer(&self, peer: &Arc<FuturesMutex<tokio_native_tls::TlsStream<TcpStream>>>) -> NetworkingResult<()> {
        let mut peers = self.peers.write().map_err(|_| NetworkingError::Lock)?;
        peers.retain(|p| !Arc::ptr_eq(p, peer));
        warn!("Removed disconnected peer");
        Ok(())
    }

    /// Stops the networking component and disconnects all peers.
    ///
    /// # Returns
    ///
    /// * `NetworkingResult<()>` - An empty result indicating success or an error if stopping fails.
    pub async fn stop(&self) -> NetworkingResult<()> {
        let mut peers = self.peers.write().map_err(|_| NetworkingError::Lock)?;

        for peer in peers.iter() {
            let mut locked_peer = peer.lock().await;
            if let Err(e) = locked_peer.shutdown().await {
                error!("Failed to close peer connection: {:?}", e);
            }
        }

        peers.clear();
        info!("Networking component stopped.");
        Ok(())
    }
}

/// Handles an incoming client connection, establishing a secure TLS stream
/// and managing communication with the peer.
///
/// # Arguments
///
/// * `stream` - The TCP stream representing the client connection.
/// * `acceptor` - The TLS acceptor used to secure the connection.
/// * `peers` - The list of currently connected peers.
/// * `_custom_arg` - A placeholder for future use.
///
/// # Returns
///
/// * `NetworkingResult<()>` - An empty result indicating success or an error if the connection fails.
async fn handle_client_connection(
    stream: TcpStream,
    acceptor: TlsAcceptor,
    peers: Arc<RwLock<Vec<Arc<FuturesMutex<tokio_native_tls::TlsStream<TcpStream>>>>>>,
    _custom_arg: Option<()>
) -> NetworkingResult<()> {
    let tls_stream = acceptor.accept(stream).await?;

    let tls_stream = Arc::new(FuturesMutex::new(tls_stream));

    {
        let mut peers_guard = peers.write().map_err(|_| NetworkingError::Lock)?;
        peers_guard.push(tls_stream.clone());
    }

    handle_client(tls_stream, peers).await
}

/// Manages communication with a connected peer, reading and processing messages.
///
/// # Arguments
///
/// * `stream` - The secure TLS stream for the peer connection.
/// * `peers` - The list of currently connected peers.
///
/// # Returns
///
/// * `NetworkingResult<()>` - An empty result indicating success or an error if the connection fails.
async fn handle_client(
    stream: Arc<FuturesMutex<tokio_native_tls::TlsStream<TcpStream>>>,
    peers: Arc<RwLock<Vec<Arc<FuturesMutex<tokio_native_tls::TlsStream<TcpStream>>>>>>,
) -> NetworkingResult<()> {
    let mut buffer = [0; 1024];

    loop {
        let mut locked_stream = stream.lock().await;

        match locked_stream.read(&mut buffer).await {
            Ok(0) => {
                info!("Peer disconnected gracefully");
                break;
            }
            Ok(n) => {
                let message = String::from_utf8_lossy(&buffer[..n]);
                info!("Received message: {}", message);
                // TODO: Process the received message here
            }
            Err(ref e) if e.kind() == std::io::ErrorKind::WouldBlock => {
                continue;
            }
            Err(e) => {
                error!("Error reading from stream: {:?}", e);
                break;
            }
        }
    }

    {
        let mut peers_guard = peers.write().map_err(|_| NetworkingError::Lock)?;
        peers_guard.retain(|p| !Arc::ptr_eq(p, &stream));
        warn!("Removed disconnected peer");
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_load_tls_identity() {
        let cert_path = "path/to/cert.pem";
        let key_path = "path/to/key.pem";

        let result = Networking::load_tls_identity(cert_path, key_path);

        assert!(result.is_err()); // Expect an error because the files don't exist
    }

    #[test]
    fn test_create_networking_instance() {
        let networking = Networking::new();
        assert!(networking.peers.read().unwrap().is_empty());
        assert!(networking.identity.is_none());
    }

    #[tokio::test]
    async fn test_start_server() {
        let cert_path = "path/to/cert.pem";
        let key_path = "path/to/key.pem";

        let identity = Networking::load_tls_identity(cert_path, key_path).unwrap();
        let mut networking = Networking::new();

        let result = networking.start_server("127.0.0.1:0", identity).await;

        assert!(result.is_err()); // Expect an error because the files don't exist
    }

    #[tokio::test]
    async fn test_connect_to_peer() {
        let networking = Networking::new();
        let result = networking.connect_to_peer("127.0.0.1:0").await;

        assert!(result.is_err()); // Expect an error because the peer is not available
    }

    #[tokio::test]
    async fn test_broadcast_message() {
        let networking = Networking::new();
        let result = networking.broadcast_message("Test message").await;

        assert!(result.is_ok()); // Expect success even if no peers are connected
    }

    #[tokio::test]
    async fn test_stop_networking() {
        let networking = Networking::new();
        let result = networking.stop().await;

        assert!(result.is_ok()); // Expect success even if no peers are connected
    }
}



=== ./icn_shared/Cargo.toml ===
[package]
name = "icn_shared"
version = "0.1.0"
edition = "2018"

[dependencies]
sha2 = "0.10"  # Add this line
serde = "1.0"
serde_json = "1.0"
log = "0.4"
native-tls = "0.2"  # Add this line



=== ./icn_shared/src/error.rs ===
// File: icn_shared/src/error.rs

//! This module defines the errors that can occur across various components of the ICN project.
//! These errors are shared across different crates to maintain consistency in error handling.

use thiserror::Error;
use serde_json;

/// The `IcnError` enum represents errors that can occur across different components of the ICN project.
#[derive(Debug, Error)]
pub enum IcnError {
    /// An error that occurs during serialization or deserialization.
    #[error("Serialization error: {0}")]
    Serialization(String),

    /// An error that occurs during storage operations.
    #[error("Storage error: {0}")]
    Storage(String),

    /// An error related to consensus mechanisms.
    #[error("Consensus error: {0}")]
    Consensus(String),

    /// An error related to network operations.
    #[error("Network error: {0}")]
    Network(String),

    /// A generic error for any other type of failure.
    #[error("Generic error: {0}")]
    Generic(String),
}

/// A specialized Result type for the shared module.
pub type IcnResult<T> = Result<T, IcnError>;

// Implement conversion from serde_json errors to IcnError for serialization issues.
impl From<serde_json::Error> for IcnError {
    fn from(err: serde_json::Error) -> Self {
        IcnError::Serialization(err.to_string())
    }
}

// You can add more conversion implementations here if needed for other error types.



=== ./icn_shared/src/block.rs ===

// File: icn_shared/src/block.rs

use serde::{Serialize, Deserialize};
use sha2::{Sha256, Digest};
use std::time::{SystemTime, UNIX_EPOCH};

/// Represents a block in the blockchain.
///
/// Each block contains a list of transactions, a reference to the previous block's hash,
/// a unique hash calculated from its contents, and the ID of the proposer who created the block.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Block {
    pub index: u64,
    pub timestamp: u64,
    pub transactions: Vec<String>, // Transactions are represented as Strings
    pub previous_hash: String,
    pub hash: String,
    pub proposer_id: String,
    pub nonce: u64,
}

impl Block {
    /// Creates a new `Block` instance.
    ///
    /// # Arguments
    ///
    /// * `index` - The index of the block in the blockchain.
    /// * `transactions` - A vector of transactions included in the block.
    /// * `previous_hash` - The hash of the previous block in the chain.
    /// * `proposer_id` - The ID of the node proposing the block.
    ///
    /// # Returns
    ///
    /// * `Block` - A new `Block` instance with a calculated hash.
    pub fn new(
        index: u64,
        transactions: Vec<String>,
        previous_hash: String,
        proposer_id: String,
    ) -> Self {
        let timestamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .expect("Time went backwards")
            .as_secs();

        let mut block = Block {
            index,
            timestamp,
            transactions,
            previous_hash,
            hash: String::new(),
            proposer_id,
            nonce: 0,
        };
        block.hash = block.calculate_hash();
        block
    }

    /// Calculates the hash of the block based on its contents.
    ///
    /// The hash is computed using SHA-256 and includes the block's index, timestamp,
    /// transactions, previous hash, proposer ID, and nonce.
    ///
    /// # Returns
    ///
    /// * `String` - The calculated hash of the block.
    pub fn calculate_hash(&self) -> String {
        let mut hasher = Sha256::new();
        hasher.update(self.index.to_be_bytes());
        hasher.update(self.timestamp.to_be_bytes());
        hasher.update(serde_json::to_string(&self.transactions).unwrap());
        hasher.update(&self.previous_hash);
        hasher.update(&self.proposer_id);
        hasher.update(self.nonce.to_be_bytes());
        format!("{:x}", hasher.finalize())
    }

    /// Validates the block's hash to ensure it matches the calculated hash.
    ///
    /// This method checks the integrity of the block by verifying that its hash is consistent
    /// with its contents.
    ///
    /// # Returns
    ///
    /// * `bool` - Returns `true` if the block is valid, `false` otherwise.
    pub fn is_valid(&self) -> bool {
        self.hash == self.calculate_hash()
    }
}


=== ./icn_shared/src/consensus.rs ===



=== ./icn_shared/src/lib.rs ===
// File: icn_shared/src/lib.rs

//! This module defines the core structures and error handling for the InterCooperative Network (ICN) project.
//! It includes custom error types, the `Block` struct representing a blockchain block, and utility functions.

use std::error::Error;
use std::fmt;
use serde::{Serialize, Deserialize};
use sha2::{Sha256, Digest};
use std::time::{SystemTime, UNIX_EPOCH};
use thiserror::Error;

/// Custom error type for the ICN project.
///
/// This enum encapsulates various types of errors that can occur within the ICN project, including
/// configuration, blockchain, consensus, network, smart contract, storage, I/O, and other errors.
#[derive(Debug, Clone, Serialize, Deserialize, Error)]
pub enum IcnError {
    /// Configuration-related errors.
    #[error("Configuration error: {0}")]
    Config(String),
    /// Blockchain-related errors.
    #[error("Blockchain error: {0}")]
    Blockchain(String),
    /// Consensus-related errors.
    #[error("Consensus error: {0}")]
    Consensus(String),
    /// Network-related errors.
    #[error("Network error: {0}")]
    Network(String),
    /// Smart contract-related errors.
    #[error("Smart contract error: {0}")]
    SmartContract(String),
    /// Storage-related errors.
    #[error("Storage error: {0}")]
    Storage(String),
    /// I/O-related errors.
    #[error("I/O error: {0}")]
    Io(String),
    /// Other miscellaneous errors.
    #[error("Other error: {0}")]
    Other(String),
}

impl From<std::io::Error> for IcnError {
    fn from(err: std::io::Error) -> Self {
        IcnError::Io(err.to_string())
    }
}

impl From<String> for IcnError {
    fn from(err: String) -> Self {
        IcnError::Other(err)
    }
}

/// Result type alias for the ICN project.
pub type IcnResult<T> = Result<T, IcnError>;

/// Represents a block in the blockchain.
///
/// Each block contains an index, timestamp, a list of transactions, the hash of the previous block,
/// a hash of the current block, the ID of the proposer who created the block, and a nonce for mining.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct Block {
    /// The position of the block within the blockchain.
    pub index: u64,
    /// The timestamp when the block was created.
    pub timestamp: u64,
    /// A vector of transactions included in the block.
    pub transactions: Vec<String>,
    /// The hash of the previous block in the chain.
    pub previous_hash: String,
    /// The hash of the current block.
    pub hash: String,
    /// The ID of the proposer who created the block.
    pub proposer_id: String,
    /// A nonce value used for mining/consensus purposes.
    pub nonce: u64,
}

impl Block {
    /// Creates a new `Block` instance.
    ///
    /// This constructor generates a new block with the provided index, transactions, previous hash, and proposer ID.
    /// The block's timestamp is set to the current system time, and the hash is calculated based on the block's data.
    ///
    /// # Arguments
    ///
    /// * `index` - The position of the block within the blockchain.
    /// * `transactions` - A vector of transactions to include in the block.
    /// * `previous_hash` - The hash of the previous block in the chain.
    /// * `proposer_id` - The ID of the proposer who created the block.
    ///
    /// # Returns
    ///
    /// A new instance of `Block`.
    pub fn new(index: u64, transactions: Vec<String>, previous_hash: String, proposer_id: String) -> Self {
        let timestamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .expect("Time went backwards")
            .as_secs();

        let mut block = Block {
            index,
            timestamp,
            transactions,
            previous_hash,
            hash: String::new(),
            proposer_id,
            nonce: 0,
        };
        block.hash = block.calculate_hash();
        block
    }

    /// Calculates the hash of the block.
    ///
    /// This method computes the SHA-256 hash of the block's content, ensuring the block's integrity.
    ///
    /// # Returns
    ///
    /// A string representing the hexadecimal hash of the block.
    pub fn calculate_hash(&self) -> String {
        let mut hasher = Sha256::new();
        hasher.update(self.index.to_be_bytes());
        hasher.update(self.timestamp.to_be_bytes());
        hasher.update(serde_json::to_string(&self.transactions).unwrap());
        hasher.update(&self.previous_hash);
        hasher.update(&self.proposer_id);
        hasher.update(self.nonce.to_be_bytes());
        format!("{:x}", hasher.finalize())
    }

    /// Verifies the block's integrity by checking its hash.
    ///
    /// This method compares the stored hash with the calculated hash to ensure the block's data has not been tampered with.
    ///
    /// # Returns
    ///
    /// `true` if the block is valid, `false` otherwise.
    pub fn is_valid(&self) -> bool {
        self.hash == self.calculate_hash()
    }
}

/// Defines the possible states of a node in the ICN network.
///
/// The `NodeState` enum represents different operational states of a node in the network, such as initialization,
/// normal operation, or shutdown. These states help in managing the lifecycle and operational flow of a node.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum NodeState {
    /// The node is in the initialization phase.
    Initializing,
    /// The node is fully operational.
    Operational,
    /// The node is in the process of shutting down.
    ShuttingDown,
    /// The node is configuring.
    Configuring, 
}

/// Utility functions for the ICN project.
pub mod utils {
    /// Checks if a given string is a valid hexadecimal number.
    ///
    /// This function ensures that the provided string contains only hexadecimal digits (0-9, a-f, A-F).
    ///
    /// # Arguments
    ///
    /// * `hex_string` - A string slice representing the potential hexadecimal number.
    ///
    /// # Returns
    ///
    /// `true` if the string is a valid hexadecimal number, `false` otherwise.
    pub fn is_valid_hex(hex_string: &str) -> bool {
        hex_string.chars().all(|c| c.is_digit(16))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_is_valid_hex() {
        assert!(utils::is_valid_hex("1a2b3c"));
        assert!(utils::is_valid_hex("ABCDEF"));
        assert!(!utils::is_valid_hex("1a2g3c"));
        assert!(!utils::is_valid_hex("xyz"));
    }

    #[test]
    fn test_block_creation() {
        let block = Block::new(0, vec!["tx1".into()], "prev_hash".to_string(), "proposer1".to_string());
        assert_eq!(block.index, 0);
        assert_eq!(block.transactions, vec!["tx1".to_string()]);
        assert_eq!(block.previous_hash, "prev_hash");
        assert_eq!(block.proposer_id, "proposer1");
        assert_eq!(block.nonce, 0);
        assert!(!block.hash.is_empty());
        assert!(block.is_valid());
    }

    #[test]
    fn test_block_validity() {
        let mut block = Block::new(1, vec!["tx2".into()], "prev_hash".to_string(), "proposer2".to_string());
        assert!(block.is_valid());

        // Tamper with the block
        block.transactions.push("tx3".into());
        assert!(!block.is_valid());

        // Recalculate the hash
        block.hash = block.calculate_hash();
        assert!(block.is_valid());
    }

    #[test]
    fn test_block_hash_changes_with_nonce() {
        let mut block = Block::new(2, vec!["tx4".into()], "prev_hash".to_string(), "proposer3".to_string());
        let original_hash = block.hash.clone();

        block.nonce += 1;
        block.hash = block.calculate_hash();

        assert_ne!(original_hash, block.hash);
        assert!(block.is_valid());
    }

    #[test]
    fn test_icn_error_display() {
        let error = IcnError::Blockchain("Invalid block".to_string());
        assert_eq!(error.to_string(), "Blockchain error: Invalid block");

        let error = IcnError::Network("Connection failed".to_string());
        assert_eq!(error.to_string(), "Network error: Connection failed");
    }
}


=== ./config/default_config.toml ===
[node]
name = "MyNode"



=== ./config/config.toml ===



=== ./project_parts/core_files_00 ===
./icn_networking/Cargo.toml
./icn_networking/src/lib/mod.rs
./icn_networking/src/lib.rs
./icn_blockchain/Cargo.toml
./icn_blockchain/src/lib/mod.rs
./icn_blockchain/src/transaction/mod.rs
./icn_blockchain/src/lib.rs
./icn_blockchain/src/block/mod.rs
./icn_blockchain/src/chain/mod.rs
./.github/workflows/ci.yml
./.github/workflows/static.yml
./.github/FUNDING.yml
./.vscode/settings.json
./icn_virtual_machine/Cargo.toml
./icn_virtual_machine/src/lib/mod.rs
./icn_virtual_machine/src/lib.rs
./icn_consensus/Cargo.toml
./icn_consensus/src/lib/mod.rs
./icn_consensus/src/lib.rs
./icn_consensus/src/proof_of_cooperation.rs
./icn_governance/Cargo.toml
./icn_governance/src/lib/mod.rs
./icn_governance/src/lib.rs
./Cargo.toml
./icn_core/Cargo.toml
./icn_core/src/config/mod.rs
./icn_core/src/config/config_loader.rs
./icn_core/src/lib/mod.rs
./icn_core/src/main.rs
./icn_core/src/node/mod.rs
./icn_core/src/node/node_manager.rs
./icn_core/src/lib.rs
./icn_core/src/coordinator/module_coordinator.rs
./icn_core/src/coordinator/mod.rs
./icn_storage/Cargo.toml
./icn_storage/src/lib/mod.rs
./icn_storage/src/lib.rs
./icn_identity/Cargo.toml
./icn_identity/src/lib/mod.rs
./icn_identity/src/lib.rs
./icn_smart_contracts/Cargo.toml
./icn_smart_contracts/src/lib/mod.rs
./icn_smart_contracts/src/lib.rs
./icn_api/Cargo.toml
./icn_api/src/lib/mod.rs
./icn_api/src/lib.rs



=== ./icn_blockchain/Cargo.toml ===
# icn_blockchain/Cargo.toml

[package]
name = "icn_blockchain"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_shared = { path = "../icn_shared" }
icn_consensus = { path = "../icn_consensus" }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
sha2 = "0.10"
chrono = "0.4"
log = "0.4"
rand = "0.8"
thiserror = "1.0"  # For better error handling within the VM and blockchain

# Dependency for Virtual Machine and smart contract functionality
icn_virtual_machine = { path = "../icn_virtual_machine" }  # Added this line for the VirtualMachine module dependency

# WebAssembly runtime for executing smart contracts in the VM
wasmer = "2.1"



=== ./icn_blockchain/src/lib/mod.rs ===



=== ./icn_blockchain/src/transaction/mod.rs ===
// icn_blockchain/src/transaction/mod.rs

mod transaction;

pub use transaction::{Transaction, TransactionType};



=== ./icn_blockchain/src/transaction/transaction.rs ===
use serde::{Serialize, Deserialize};
use icn_shared::{IcnError, IcnResult};

/// Represents the different types of transactions supported by the blockchain.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum TransactionType {
    /// A transfer of assets between accounts.
    Transfer {
        from: String,
        to: String,
        amount: u64,
    },
    /// Deployment of a smart contract.
    DeployContract {
        code: String,
        initial_state: String,
    },
    /// Execution of a smart contract method.
    SmartContractExecution {
        contract_id: String,
        method: String,
        params: Vec<String>,
    },
    /// Validation of a proof.
    ProofValidation {
        proof_id: String,
        data: Vec<u8>,
    },
}

/// Represents a transaction in the blockchain.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Transaction {
    /// The unique identifier for the transaction.
    pub id: String,
    /// The type of the transaction.
    pub transaction_type: TransactionType,
    /// The digital signature of the transaction.
    pub signature: Option<String>,
    /// Additional metadata associated with the transaction.
    pub metadata: Option<String>,
}

impl Transaction {
    /// Creates a new `Transaction` instance.
    ///
    /// # Arguments
    ///
    /// * `id` - A unique identifier for the transaction.
    /// * `transaction_type` - The type of transaction being performed.
    /// * `signature` - An optional digital signature.
    /// * `metadata` - Optional metadata related to the transaction.
    ///
    /// # Returns
    ///
    /// A new `Transaction` instance.
    pub fn new(id: String, transaction_type: TransactionType, signature: Option<String>, metadata: Option<String>) -> Self {
        Transaction {
            id,
            transaction_type,
            signature,
            metadata,
        }
    }

    /// Validates the transaction.
    ///
    /// This function checks the validity of the transaction by validating its type,
    /// checking its signature, and ensuring any additional criteria are met.
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - Returns `Ok(())` if the transaction is valid, otherwise an error.
    pub fn validate(&self) -> IcnResult<()> {
        // Validate the transaction type
        self.validate_transaction_type()?;

        // Check if signature exists
        if self.signature.is_none() {
            return Err(IcnError::Transaction("Transaction must have a signature".into()));
        }

        // Validate the signature (placeholder - implement actual signature verification)
        self.verify_signature()?;

        // Additional validation logic can be added here
        Ok(())
    }

    /// Validates the transaction type and its associated data.
    fn validate_transaction_type(&self) -> IcnResult<()> {
        match &self.transaction_type {
            TransactionType::Transfer { from, to, amount } => {
                if from.is_empty() || to.is_empty() {
                    return Err(IcnError::Transaction("Invalid addresses in transfer".into()));
                }
                if *amount == 0 {
                    return Err(IcnError::Transaction("Transfer amount must be greater than zero".into()));
                }
            }
            TransactionType::DeployContract { code, .. } => {
                if code.is_empty() {
                    return Err(IcnError::Transaction("Contract code cannot be empty".into()));
                }
            }
            TransactionType::SmartContractExecution { contract_id, method, .. } => {
                if contract_id.is_empty() || method.is_empty() {
                    return Err(IcnError::Transaction("Invalid contract execution parameters".into()));
                }
            }
            TransactionType::ProofValidation { proof_id, data } => {
                if proof_id.is_empty() || data.is_empty() {
                    return Err(IcnError::Transaction("Invalid proof validation parameters".into()));
                }
            }
        }
        Ok(())
    }

    /// Verifies the digital signature of the transaction.
    fn verify_signature(&self) -> IcnResult<()> {
        // Placeholder for signature verification logic
        // In a real implementation, you would verify the signature against the transaction data
        Ok(())
    }

    /// Processes the transaction within the blockchain.
    ///
    /// This function executes the transaction according to its type and updates the blockchain state accordingly.
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - Returns `Ok(())` if the transaction is processed successfully, otherwise an error.
    pub fn process(&self) -> IcnResult<()> {
        match &self.transaction_type {
            TransactionType::Transfer { from, to, amount } => {
                // Logic for processing a transfer transaction
                println!("Processing transfer of {} from {} to {}", amount, from, to);
                // Implement actual balance updates here
                Ok(())
            }
            TransactionType::DeployContract { code, initial_state } => {
                // Logic for processing a smart contract deployment
                println!("Deploying smart contract with code length {} and initial state {}", code.len(), initial_state);
                // Implement actual contract deployment logic here
                Ok(())
            }
            TransactionType::SmartContractExecution { contract_id, method, params } => {
                // Logic for processing a smart contract execution
                println!("Executing method {} on contract {} with {} parameters", method, contract_id, params.len());
                // Implement actual contract execution logic here
                Ok(())
            }
            TransactionType::ProofValidation { proof_id, data } => {
                // Logic for processing a proof validation
                println!("Validating proof {} with data length {}", proof_id, data.len());
                // Implement actual proof validation logic here
                Ok(())
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_transaction_creation() {
        let tx = Transaction::new(
            "tx1".to_string(),
            TransactionType::Transfer {
                from: "alice".to_string(),
                to: "bob".to_string(),
                amount: 100,
            },
            Some("signature".to_string()),
            None,
        );
        assert_eq!(tx.id, "tx1");
        assert!(matches!(tx.transaction_type, TransactionType::Transfer { .. }));
    }

    #[test]
    fn test_transaction_validation() {
        let valid_tx = Transaction::new(
            "tx1".to_string(),
            TransactionType::Transfer {
                from: "alice".to_string(),
                to: "bob".to_string(),
                amount: 100,
            },
            Some("signature".to_string()),
            None,
        );
        assert!(valid_tx.validate().is_ok());

        let invalid_tx = Transaction::new(
            "tx2".to_string(),
            TransactionType::Transfer {
                from: "".to_string(),
                to: "bob".to_string(),
                amount: 0,
            },
            None,
            None,
        );
        assert!(invalid_tx.validate().is_err());
    }

    #[test]
    fn test_transaction_processing() {
        let tx = Transaction::new(
            "tx1".to_string(),
            TransactionType::Transfer {
                from: "alice".to_string(),
                to: "bob".to_string(),
                amount: 100,
            },
            Some("signature".to_string()),
            None,
        );
        assert!(tx.process().is_ok());
    }

    #[test]
    fn test_deploy_contract_transaction() {
        let tx = Transaction::new(
            "tx2".to_string(),
            TransactionType::DeployContract {
                code: "contract code".to_string(),
                initial_state: "{}".to_string(),
            },
            Some("signature".to_string()),
            None,
        );
        assert!(tx.validate().is_ok());
        assert!(tx.process().is_ok());
    }

    #[test]
    fn test_smart_contract_execution_transaction() {
        let tx = Transaction::new(
            "tx3".to_string(),
            TransactionType::SmartContractExecution {
                contract_id: "contract1".to_string(),
                method: "transfer".to_string(),
                params: vec!["recipient".to_string(), "100".to_string()],
            },
            Some("signature".to_string()),
            None,
        );
        assert!(tx.validate().is_ok());
        assert!(tx.process().is_ok());
    }

    #[test]
    fn test_proof_validation_transaction() {
        let tx = Transaction::new(
            "tx4".to_string(),
            TransactionType::ProofValidation {
                proof_id: "proof1".to_string(),
                data: vec![1, 2, 3, 4, 5],
            },
            Some("signature".to_string()),
            None,
        );
        assert!(tx.validate().is_ok());
        assert!(tx.process().is_ok());
    }

    #[test]
    fn test_invalid_transactions() {
        let invalid_transfer = Transaction::new(
            "tx5".to_string(),
            TransactionType::Transfer {
                from: "".to_string(),
                to: "bob".to_string(),
                amount: 0,
            },
            Some("signature".to_string()),
            None,
        );
        assert!(invalid_transfer.validate().is_err());

        let invalid_contract_deploy = Transaction::new(
            "tx6".to_string(),
            TransactionType::DeployContract {
                code: "".to_string(),
                initial_state: "{}".to_string(),
            },
            Some("signature".to_string()),
            None,
        );
        assert!(invalid_contract_deploy.validate().is_err());

        let invalid_contract_execution = Transaction::new(
            "tx7".to_string(),
            TransactionType::SmartContractExecution {
                contract_id: "".to_string(),
                method: "".to_string(),
                params: vec![],
            },
            Some("signature".to_string()),
            None,
        );
        assert!(invalid_contract_execution.validate().is_err());

        let invalid_proof_validation = Transaction::new(
            "tx8".to_string(),
            TransactionType::ProofValidation {
                proof_id: "".to_string(),
                data: vec![],
            },
            Some("signature".to_string()),
            None,
        );
        assert!(invalid_proof_validation.validate().is_err());
    }
}



=== ./icn_blockchain/src/transaction/transaction_type.rs ===
// File Location: icn_blockchain/src/transaction/transaction_type.rs

//! Defines the types of transactions that can be performed on the ICN blockchain.
//!
//! This module includes the enumeration of different transaction types,
//! each representing a specific operation or interaction within the blockchain.

/// Enum representing various transaction types in the ICN blockchain.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum TransactionType {
    /// A simple transfer of assets between accounts.
    Transfer { from: String, to: String, amount: u64 },

    /// A smart contract execution transaction.
    SmartContractExecution { contract_id: String, method: String, params: Vec<String> },

    /// A transaction for deploying a new smart contract.
    SmartContractDeployment { code: Vec<u8>, initial_state: String },

    /// A transaction for validating a proof within the blockchain.
    ProofValidation { proof_id: String, data: Vec<u8> },

    /// Additional transaction types can be added here as needed.
}

impl TransactionType {
    /// Validates the transaction type based on its specific rules.
    pub fn validate(&self) -> Result<(), String> {
        match self {
            TransactionType::Transfer { from, to, amount } => {
                // Example validation: Ensure 'from' and 'to' are valid addresses
                if from.is_empty() || to.is_empty() {
                    return Err("Invalid addresses".into());
                }
                if *amount == 0 {
                    return Err("Amount must be greater than zero".into());
                }
                Ok(())
            }
            TransactionType::SmartContractExecution { .. } => {
                // Validation logic for smart contract execution
                Ok(())
            }
            TransactionType::SmartContractDeployment { .. } => {
                // Validation logic for smart contract deployment
                Ok(())
            }
            TransactionType::ProofValidation { .. } => {
                // Validation logic for proof validation
                Ok(())
            }
        }
    }
}



=== ./icn_blockchain/src/lib.rs ===
// File: icn_blockchain/src/lib.rs
// Description: This file defines the Blockchain structure and handles operations like adding blocks,
// executing transactions, and interacting with the virtual machine.

use std::sync::{Arc, RwLock};
use icn_shared::{Block, IcnError, IcnResult};
use icn_consensus::Consensus;
use icn_virtual_machine::VirtualMachine;

pub mod chain;
pub mod transaction;

use crate::chain::Chain;
use crate::transaction::{Transaction, TransactionType};

/// Represents the blockchain and its operations.
pub struct Blockchain<C: Consensus> {
    /// The chain of blocks.
    pub chain: Chain<C>,
    /// The consensus mechanism used for validating and adding blocks.
    pub consensus: Arc<RwLock<C>>,
    /// The virtual machine for executing smart contracts.
    pub vm: VirtualMachine,
}

impl<C: Consensus> Blockchain<C> {
    /// Creates a new blockchain with the given consensus algorithm and initializes the VM.
    ///
    /// # Arguments
    ///
    /// * `consensus` - The consensus algorithm to use for validating and adding blocks.
    ///
    /// # Returns
    ///
    /// * `Blockchain` - A new instance of the blockchain.
    pub fn new(consensus: Arc<RwLock<C>>) -> Self {
        Blockchain {
            chain: Chain::new(consensus.clone()),
            consensus,
            vm: VirtualMachine::new(),
        }
    }

    /// Adds a new block to the blockchain after validating it.
    ///
    /// # Arguments
    ///
    /// * `transactions` - A vector of serialized transaction strings to be included in the block.
    /// * `proposer_id` - The ID of the node proposing the new block.
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - Returns Ok if the block is successfully added, otherwise an error.
    pub fn add_block(&mut self, transactions: Vec<String>, proposer_id: String) -> IcnResult<()> {
        let previous_block = self.chain.latest_block()
            .ok_or_else(|| IcnError::Blockchain("Empty blockchain".to_string()))?;
        let new_block = Block::new(
            self.chain.block_count() as u64,
            transactions,
            previous_block.hash.clone(),
            proposer_id,
        );

        // Validate the block using the consensus mechanism
        let consensus_read = self.consensus.read()
            .map_err(|_| IcnError::Consensus("Failed to acquire read lock on consensus".to_string()))?;
        
        if consensus_read.validate(&new_block)? {
            // If validation is successful, acquire a write lock to modify the chain
            drop(consensus_read); // Release the read lock before acquiring the write lock
            let mut consensus_write = self.consensus.write()
                .map_err(|_| IcnError::Consensus("Failed to acquire write lock on consensus".to_string()))?;
            
            self.chain.add_block(new_block)?;
            
            // Update the consensus state if necessary
            consensus_write.update_state(&self.chain)?;
            Ok(())
        } else {
            Err(IcnError::Blockchain("Invalid block".to_string()))
        }
    }

    /// Executes a transaction, updating the blockchain state accordingly.
    ///
    /// # Arguments
    ///
    /// * `transaction` - The transaction to be executed.
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - Returns Ok if the transaction is successfully executed, otherwise an error.
    pub fn execute_transaction(&mut self, transaction: Transaction) -> IcnResult<()> {
        match &transaction.transaction_type {
            TransactionType::Transfer { from, to, amount } => {
                self.update_balance(from, -(*amount as i64))?;
                self.update_balance(to, *amount as i64)?;
                Ok(())
            }
            TransactionType::DeployContract { code, .. } => {
                let bytecode = self.vm.compile(code)?;
                self.vm.execute(bytecode)?;
                Ok(())
            }
            TransactionType::SmartContractExecution { contract_id, method, params } => {
                let bytecode = self.vm.prepare_execution(contract_id, method, params)?;
                self.vm.execute(bytecode)?;
                Ok(())
            }
            TransactionType::ProofValidation { proof_id, data } => {
                self.validate_proof(proof_id, data)?;
                Ok(())
            }
        }
    }

    /// Updates the balance of an account.
    ///
    /// # Arguments
    ///
    /// * `account` - The account ID to update.
    /// * `change` - The amount to change the balance by (positive for increase, negative for decrease).
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - Returns Ok if the balance is successfully updated, otherwise an error.
    fn update_balance(&mut self, account: &str, change: i64) -> IcnResult<()> {
        if account.is_empty() {
            return Err(IcnError::Blockchain("Account ID cannot be empty".to_string()));
        }
        // TODO: Implement actual balance update logic
        println!("Updating balance of account {} by {}", account, change);
        Ok(())
    }

    /// Validates a proof submitted to the blockchain.
    ///
    /// # Arguments
    ///
    /// * `proof_id` - The ID of the proof to validate.
    /// * `data` - The data associated with the proof.
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - Returns Ok if the proof is successfully validated, otherwise an error.
    fn validate_proof(&self, proof_id: &str, data: &[u8]) -> IcnResult<()> {
        if proof_id.is_empty() || data.is_empty() {
            return Err(IcnError::Blockchain("Invalid proof validation parameters".to_string()));
        }
        // TODO: Implement actual proof validation logic
        println!("Validating proof {} with data length {}", proof_id, data.len());
        Ok(())
    }

    /// Validates the integrity of the blockchain.
    ///
    /// # Returns
    ///
    /// * `bool` - Returns true if the blockchain is valid, otherwise false.
    pub fn is_valid_chain(&self) -> bool {
        self.chain.is_valid()
    }

    /// Gets the current block count of the blockchain.
    ///
    /// # Returns
    ///
    /// * `usize` - The number of blocks in the chain.
    pub fn block_count(&self) -> usize {
        self.chain.block_count()
    }

    /// Gets the latest block in the blockchain.
    ///
    /// # Returns
    ///
    /// * `Option<&Block>` - The latest block if the chain is not empty, otherwise None.
    pub fn latest_block(&self) -> Option<&Block> {
        self.chain.latest_block()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_consensus::ProofOfCooperation;

    fn setup_blockchain() -> Blockchain<ProofOfCooperation> {
        let consensus = Arc::new(RwLock::new(ProofOfCooperation::new()));
        Blockchain::new(consensus)
    }

    #[test]
    fn test_blockchain_creation() {
        let blockchain = setup_blockchain();
        assert!(blockchain.is_valid_chain());
        assert_eq!(blockchain.block_count(), 0);
    }

    #[test]
    fn test_add_block() {
        let mut blockchain = setup_blockchain();
        let transactions = vec!["tx1".to_string(), "tx2".to_string()];
        let result = blockchain.add_block(transactions, "proposer1".to_string());
        assert!(result.is_ok());
        assert_eq!(blockchain.block_count(), 1);
    }

    #[test]
    fn test_execute_transaction() {
        let mut blockchain = setup_blockchain();
        let transaction = Transaction::new(
            "1".to_string(),
            TransactionType::Transfer {
                from: "from_account".to_string(),
                to: "to_account".to_string(),
                amount: 100,
            },
            None,
            None,
        );
        assert!(blockchain.execute_transaction(transaction).is_ok());
    }

    #[test]
    fn test_invalid_block_addition() {
        let mut blockchain = setup_blockchain();
        let invalid_transactions = vec![];
        let result = blockchain.add_block(invalid_transactions, "proposer1".to_string());
        assert!(result.is_err());
    }
}


=== ./icn_blockchain/src/chain/mod.rs ===
// File: icn_blockchain/src/chain/mod.rs
// Description: This file defines the Chain structure for the blockchain, 
//              including functions to manage blocks, validators, and consensus.

use std::sync::{Arc, RwLock};
use icn_shared::{Block, IcnError, IcnResult};
use icn_consensus::Consensus;
use rand::rngs::OsRng;
use rand::Rng;

/// Represents a validator in the blockchain network.
#[derive(Debug, Clone)]
pub struct Validator {
    /// The unique identifier of the validator.
    id: String,
    /// The amount of stake the validator has in the network.
    stake: u64,
    /// The reputation score of the validator.
    reputation: f64,
    /// The validator's uptime as a percentage.
    uptime: f64,
    /// The validator's past performance score.
    past_performance: f64,
}

impl Validator {
    /// Creates a new `Validator` instance.
    ///
    /// # Arguments
    ///
    /// * `id` - The unique identifier of the validator.
    /// * `stake` - The amount of stake the validator has.
    /// * `reputation` - The reputation score of the validator.
    /// * `uptime` - The validator's uptime as a percentage.
    /// * `past_performance` - The validator's past performance score.
    pub fn new(id: String, stake: u64, reputation: f64, uptime: f64, past_performance: f64) -> Self {
        Validator {
            id,
            stake,
            reputation,
            uptime,
            past_performance,
        }
    }

    /// Validates a block based on the consensus rules.
    ///
    /// # Arguments
    ///
    /// * `block` - The block to validate.
    ///
    /// # Returns
    ///
    /// * `IcnResult<bool>` - Returns `Ok(true)` if the block is valid, otherwise returns an error.
    pub fn validate(&self, block: &Block) -> IcnResult<bool> {
        // Implement comprehensive block validation logic
        if !self.verify_block_hash(block) {
            return Err(IcnError::Consensus("Invalid block hash".to_string()));
        }

        if !self.verify_transactions(block) {
            return Err(IcnError::Consensus("Invalid transactions".to_string()));
        }

        if !self.verify_timestamp(block) {
            return Err(IcnError::Consensus("Invalid timestamp".to_string()));
        }

        // Add more validation checks as needed

        Ok(true)
    }

    /// Verifies the block's hash.
    fn verify_block_hash(&self, block: &Block) -> bool {
        block.hash == block.calculate_hash()
    }

    /// Verifies the transactions in the block.
    fn verify_transactions(&self, block: &Block) -> bool {
        // Implement transaction verification logic
        // This is a placeholder implementation
        !block.transactions.is_empty()
    }

    /// Verifies the block's timestamp.
    fn verify_timestamp(&self, block: &Block) -> bool {
        // Implement timestamp verification logic
        // This is a placeholder implementation
        block.timestamp > 0
    }

    /// Casts a vote on a block.
    ///
    /// # Arguments
    ///
    /// * `block` - The block to vote on.
    ///
    /// # Returns
    ///
    /// * `IcnResult<bool>` - Returns `Ok(true)` if the vote is positive, otherwise returns an error.
    pub fn vote(&self, block: &Block) -> IcnResult<bool> {
        // Implement voting logic based on validation and other criteria
        if self.validate(block)? {
            // Additional voting criteria can be added here
            Ok(true)
        } else {
            Ok(false)
        }
    }
}

/// Represents the blockchain, which consists of a series of blocks.
pub struct Chain<C: Consensus> {
    /// The list of blocks in the chain.
    pub blocks: Vec<Block>,
    /// The consensus mechanism used for the chain.
    pub consensus: Arc<RwLock<C>>,
    /// The list of active validators.
    validators: Vec<Validator>,
}

impl<C: Consensus> Chain<C> {
    /// Creates a new blockchain with the given consensus mechanism.
    ///
    /// # Arguments
    ///
    /// * `consensus` - An `Arc` to the consensus mechanism to be used for the blockchain.
    ///
    /// # Returns
    ///
    /// * `Chain<C>` - A new `Chain` instance.
    pub fn new(consensus: Arc<RwLock<C>>) -> Self {
        Chain {
            blocks: Vec::new(),
            consensus,
            validators: Vec::new(),
        }
    }

    /// Adds a new block to the blockchain.
    ///
    /// # Arguments
    ///
    /// * `block` - The block to be added to the chain.
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - Returns `Ok(())` if the block is successfully added,
    ///   or an `IcnError` if validation fails.
    pub fn add_block(&mut self, block: Block) -> IcnResult<()> {
        let consensus = self.consensus.read().map_err(|_| IcnError::Consensus("Failed to acquire read lock on consensus".to_string()))?;
        
        if consensus.validate(&block)? {
            self.blocks.push(block);
            Ok(())
        } else {
            Err(IcnError::Consensus("Block validation failed".to_string()))
        }
    }

    /// Returns the latest block in the blockchain.
    ///
    /// # Returns
    ///
    /// * `Option<&Block>` - Returns an `Option` containing a reference to the latest block,
    ///   or `None` if the blockchain is empty.
    pub fn latest_block(&self) -> Option<&Block> {
        self.blocks.last()
    }

    /// Returns the number of blocks in the chain.
    ///
    /// # Returns
    ///
    /// * `usize` - The number of blocks in the chain.
    pub fn block_count(&self) -> usize {
        self.blocks.len()
    }

    /// Selects validators for block validation based on the consensus mechanism's rules.
    ///
    /// # Returns
    ///
    /// * `IcnResult<Vec<Validator>>` - Returns a vector of selected validators.
    pub fn select_validators(&self) -> IcnResult<Vec<Validator>> {
        let mut rng = OsRng;
        let mut selected_validators = Vec::new();

        for validator in &self.validators {
            let selection_score = validator.stake as f64 * validator.reputation * validator.uptime * validator.past_performance;
            if rng.gen::<f64>() < selection_score {
                selected_validators.push(validator.clone());
            }
        }

        if selected_validators.is_empty() {
            Err(IcnError::Consensus("No validators selected".to_string()))
        } else {
            Ok(selected_validators.into_iter().collect())
        }
    }

    /// Performs stake-weighted voting on a block.
    ///
    /// # Arguments
    ///
    /// * `block` - The block to vote on.
    ///
    /// # Returns
    ///
    /// * `IcnResult<bool>` - Returns `Ok(true)` if the vote passes, otherwise returns an error.
    pub fn stake_weighted_vote(&self, block: &Block) -> IcnResult<bool> {
        let validators = self.select_validators()?;
        let mut total_stake = 0u64;
        let mut positive_stake = 0u64;

        for validator in validators {
            if validator.vote(block)? {
                positive_stake += validator.stake;
            }
            total_stake += validator.stake;
        }

        if total_stake == 0 {
            return Err(IcnError::Consensus("No stake in voting validators".to_string()));
        }

        // Calculate the percentage of positive votes weighted by stake
        let approval_percentage = (positive_stake as f64 / total_stake as f64) * 100.0;

        // Require a 2/3 majority for the vote to pass
        Ok(approval_percentage >= 66.67)
    }

    /// Validates the integrity of the entire blockchain.
    ///
    /// # Returns
    ///
    /// * `bool` - Returns true if the blockchain is valid, otherwise false.
    pub fn is_valid(&self) -> bool {
        for i in 1..self.blocks.len() {
            let current_block = &self.blocks[i];
            let previous_block = &self.blocks[i - 1];

            if current_block.previous_hash != previous_block.hash {
                return false;
            }

            if !current_block.is_valid() {
                return false;
            }
        }
        true
    }

    /// Adds a new validator to the network.
    ///
    /// # Arguments
    ///
    /// * `validator` - The validator to add.
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - Returns Ok if the validator is successfully added, otherwise an error.
    pub fn add_validator(&mut self, validator: Validator) -> IcnResult<()> {
        if self.validators.iter().any(|v| v.id == validator.id) {
            return Err(IcnError::Consensus("Validator already exists".to_string()));
        }
        self.validators.push(validator);
        Ok(())
    }

    /// Updates a validator's information.
    ///
    /// # Arguments
    ///
    /// * `id` - The ID of the validator to update.
    /// * `stake` - The new stake amount.
    /// * `reputation` - The new reputation score.
    /// * `uptime` - The new uptime percentage.
    /// * `past_performance` - The new past performance score.
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - Returns Ok if the validator is successfully updated, otherwise an error.
    pub fn update_validator(&mut self, id: &str, stake: u64, reputation: f64, uptime: f64, past_performance: f64) -> IcnResult<()> {
        if let Some(validator) = self.validators.iter_mut().find(|v| v.id == id) {
            validator.stake = stake;
            validator.reputation = reputation;
            validator.uptime = uptime;
            validator.past_performance = past_performance;
            Ok(())
        } else {
            Err(IcnError::Consensus("Validator not found".to_string()))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_consensus::ProofOfCooperation;

    fn create_test_block() -> Block {
        Block::new(0, vec![], "genesis".to_string(), "test_proposer".to_string())
    }

    #[test]
    fn test_chain_creation() {
        let consensus = Arc::new(RwLock::new(ProofOfCooperation::new()));
        let chain = Chain::new(consensus);
        assert_eq!(chain.block_count(), 0);
    }

    #[test]
    fn test_add_block() {
        let consensus = Arc::new(RwLock::new(ProofOfCooperation::new()));
        let mut chain = Chain::new(consensus);
        let block = create_test_block();
        assert!(chain.add_block(block).is_ok());
        assert_eq!(chain.block_count(), 1);
    }

    #[test]
    fn test_chain_validity() {
        let consensus = Arc::new(RwLock::new(ProofOfCooperation::new()));
        let mut chain = Chain::new(consensus);
        let block1 = create_test_block();
        let block2 = Block::new(1, vec![], block1.hash.clone(), "test_proposer".to_string());
        
        assert!(chain.add_block(block1).is_ok());
        assert!(chain.add_block(block2).is_ok());
        assert!(chain.is_valid());
    }

    #[test]
    fn test_validator_management() {
        let consensus = Arc::new(RwLock::new(ProofOfCooperation::new()));
        let mut chain = Chain::new(consensus);
        let validator = Validator::new("test_validator".to_string(), 100, 0.95, 0.99, 0.98);
        
        assert!(chain.add_validator(validator).is_ok());
        assert!(chain.update_validator("test_validator", 200, 0.96, 0.995, 0.99).is_ok());
        assert!(chain.update_validator("non_existent", 100, 0.9, 0.9, 0.9).is_err());
    }

    // Additional tests for stake_weighted_vote, select_validators, etc.
}



=== ./.github/workflows/ci.yml ===
# name: Rust CI

# on:
#   push:
#     branches: [ main ]
#   pull_request:
#     branches: [ main ]

# env:
#   CARGO_TERM_COLOR: always

# jobs:
#   build:
#     runs-on: ubuntu-latest
#     steps:
#     - uses: actions/checkout@v2
#     - name: Build
#       run: cargo build --verbose
#     - name: Run tests
#       run: cargo test --verbose


=== ./.github/workflows/static.yml ===
# Simple workflow for deploying static content to GitHub Pages
name: Deploy static content to Pages

on:
  # Runs on pushes targeting the default branch
  push:
    branches: ["main"]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # Single deploy job since we're just deploying
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Pages
        uses: actions/configure-pages@v5
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          # Upload entire repository
          path: '.'
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4



=== ./.github/FUNDING.yml ===
#github: [fahertym]
#patreon: InterCooperativeNetwork
open_collective: intercooperative-network



=== ./.vscode/settings.json ===
{
    "liveServer.settings.port": 5501
}


=== ./icn_virtual_machine/Cargo.toml ===
[package]
name = "icn_virtual_machine"
version = "0.1.0"
edition = "2021"

[dependencies]



=== ./icn_virtual_machine/src/plugin_manager.rs ===
// File: icn_virtual_machine/src/plugin_manager.rs

// Placeholder for plugin system implementation
// This will allow extending the VM's capabilities in the future

pub struct PluginManager {
    // ... fields for managing plugins
}

impl PluginManager {
    pub fn new() -> Self {
        // ... initialize plugin manager
    }

    pub fn load_plugin(&mut self, plugin_path: &str) -> Result<(), String> {
        // ... implement plugin loading and registration
    }

    // ... other methods for interacting with plugins
}


=== ./icn_virtual_machine/src/lib/mod.rs ===



=== ./icn_virtual_machine/src/bytecode.rs ===
// File: icn_virtual_machine/src/bytecode.rs

/// Represents an opcode in the ICN Virtual Machine's instruction set
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Opcode {
    // Arithmetic operations
    Add,
    Subtract,
    Multiply,
    Divide,

    // Logic operations
    Equal,
    NotEqual,
    LessThan,
    GreaterThan,

    // Data manipulation
    Push,
    Pop,
    Load,
    Store,

    // Control flow
    Jump,
    JumpIfTrue,
    JumpIfFalse,

    // Blockchain interaction
    GetState,
    SetState,
    CallContract,

    // Other
    Halt,
    // ... more opcodes as needed
}

/// Represents the compiled bytecode of a smart contract
pub struct Bytecode {
    /// The raw bytecode instructions
    pub code: Vec<u8>,
}

impl Bytecode {
    /// Creates a new `Bytecode` instance
    pub fn new(code: Vec<u8>) -> Self {
        Bytecode { code }
    }

    /// Decodes the bytecode into a sequence of `Opcode` and operands
    pub fn decode(&self) -> Vec<(Opcode, Vec<u8>)> {
        let mut instructions = Vec::new();
        let mut pc = 0;

        while pc < self.code.len() {
            let opcode = Opcode::from(self.code[pc]);
            pc += 1;

            let operand_size = match opcode {
                Opcode::Push => {
                    // Assuming Push takes a single byte operand for simplicity
                    // You might need to adjust this based on your actual operand sizes
                    1
                }
                // Add more cases for other opcodes with operands
                _ => 0, 
            };

            let operands = self.code[pc..pc + operand_size].to_vec();
            pc += operand_size;

            instructions.push((opcode, operands));
        }

        instructions
    }
}

impl From<u8> for Opcode {
    fn from(byte: u8) -> Self {
        match byte {
            0x01 => Opcode::Add,
            0x02 => Opcode::Subtract,
            // ... other opcode mappings
            _ => panic!("Invalid opcode: {}", byte), // Handle invalid opcodes gracefully in your actual implementation
        }
    }
}


=== ./icn_virtual_machine/src/state_manager.rs ===
// File: icn_virtual_machine/src/state_manager.rs

/// The StateManager is responsible for storing and retrieving the state during smart contract execution.
/// It acts as the key-value store where smart contracts can persist data.

use std::collections::HashMap;

/// StateManager struct manages the in-memory state storage for smart contracts.
pub struct StateManager {
    state: HashMap<String, String>,
}

impl StateManager {
    /// Creates a new instance of the StateManager with an empty state.
    pub fn new() -> Self {
        StateManager {
            state: HashMap::new(),
        }
    }

    /// Stores a key-value pair in the state.
    ///
    /// # Arguments
    ///
    /// * `key` - A string key to identify the stored value.
    /// * `value` - The string value to be stored.
    pub fn store_value(&mut self, key: String, value: String) {
        self.state.insert(key, value);
    }

    /// Loads a value from the state using the provided key.
    ///
    /// # Arguments
    ///
    /// * `key` - The string key to retrieve the associated value.
    ///
    /// # Returns
    ///
    /// * `String` - The value associated with the key, or an empty string if the key does not exist.
    pub fn load_value(&self, key: &String) -> String {
        self.state.get(key).cloned().unwrap_or_default()
    }
}



=== ./icn_virtual_machine/src/resource_manager.rs ===
// File: icn_virtual_machine/src/resource_manager.rs

/// The ResourceManager tracks and enforces limits on resources consumed during the execution of smart contracts.
/// This includes gas usage, computational limits, and other resource constraints.

/// ResourceManager struct manages the consumption of resources like gas during contract execution.
pub struct ResourceManager {
    gas_limit: u64,
    gas_used: u64,
}

impl ResourceManager {
    /// Creates a new instance of ResourceManager with a default gas limit.
    pub fn new() -> Self {
        ResourceManager {
            gas_limit: 1_000_000, // Example gas limit
            gas_used: 0,
        }
    }

    /// Consumes a specified amount of gas, returning whether the operation was successful.
    ///
    /// # Arguments
    ///
    /// * `amount` - The amount of gas to be consumed.
    ///
    /// # Returns
    ///
    /// * `bool` - `true` if gas consumption is within the limit, `false` if it exceeds the limit.
    pub fn consume_gas(&mut self, amount: u64) -> bool {
        if self.gas_used + amount > self.gas_limit {
            false
        } else {
            self.gas_used += amount;
            true
        }
    }
}



=== ./icn_virtual_machine/src/security_manager.rs ===
// File: icn_virtual_machine/src/security_manager.rs

/// The SecurityManager is responsible for ensuring the safety of executing smart contracts.
/// It performs security checks on the bytecode before execution, such as opcode validation and whitelisting.

/// SecurityManager struct handles the validation of smart contract bytecode for security purposes.
pub struct SecurityManager;

impl SecurityManager {
    /// Creates a new instance of SecurityManager.
    pub fn new() -> Self {
        SecurityManager
    }

    /// Validates the bytecode of a smart contract before execution.
    ///
    /// # Arguments
    ///
    /// * `bytecode` - A slice of u8 representing the bytecode of the smart contract.
    ///
    /// # Returns
    ///
    /// * `bool` - `true` if the bytecode passes security validation, `false` otherwise.
    pub fn validate(&self, bytecode: &[u8]) -> bool {
        // Implement security checks, such as opcode whitelisting
        true // Placeholder for actual validation logic
    }
}



=== ./icn_virtual_machine/src/lib.rs ===
// File: icn_virtual_machine/src/lib.rs

use crate::bytecode::Bytecode;
use crate::execution_engine::ExecutionEngine;
use crate::state_manager::StateManager;
use crate::resource_manager::ResourceManager;
use crate::security_manager::SecurityManager;
use crate::plugin_manager::PluginManager;
use icn_shared::IcnResult;

/// The core structure representing the ICN Virtual Machine
pub struct VirtualMachine {
    execution_engine: ExecutionEngine,
    state_manager: StateManager,
    resource_manager: ResourceManager,
    security_manager: SecurityManager,
    plugin_manager: PluginManager,
}

impl VirtualMachine {
    /// Creates a new instance of the `VirtualMachine`
    pub fn new() -> Self {
        VirtualMachine {
            execution_engine: ExecutionEngine::new(),
            state_manager: StateManager::new(),
            resource_manager: ResourceManager::new(),
            security_manager: SecurityManager::new(),
            plugin_manager: PluginManager::new(),
        }
    }

    /// Executes the given bytecode within the virtual machine environment
    pub fn execute(&mut self, bytecode: Bytecode) -> IcnResult<()> {
        // 1. Security and Compliance Checks
        self.security_manager.sandbox_contract(&bytecode.code)?; // Ensure contract is sandboxed
        self.security_manager.perform_static_analysis(&bytecode.code)?; // Perform static analysis
        self.security_manager.check_compliance(&bytecode.code)?; // Check for compliance

        // 2. Resource Management
        // Placeholder: Check if the contract has enough resources to execute
        // You'll need to implement the actual resource management logic here

        // 3. Execute the Bytecode
        self.execution_engine.execute(bytecode)?;

        // 4. Log Execution (if successful)
        // Placeholder: Log execution details 
        // You'll need to implement the actual logging mechanism here

        Ok(())
    }

    // ... other methods for interacting with state, resources, plugins, etc.
}


=== ./icn_virtual_machine/src/execution_engine.rs ===
// File: icn_virtual_machine/src/execution_engine.rs

/// The Execution Engine is responsible for running smart contracts on the ICN virtual machine.
/// It manages the execution context, handles security validations, and interacts with the state and resources.

use crate::state_manager::StateManager;
use crate::resource_manager::ResourceManager;
use crate::security_manager::SecurityManager;

/// ExecutionEngine struct encapsulates the components needed for executing smart contracts.
pub struct ExecutionEngine {
    pub state_manager: StateManager,
    pub resource_manager: ResourceManager,
    pub security_manager: SecurityManager,
}

/// ExecutionContext holds the current state and data required during the execution of a contract.
pub struct ExecutionContext {
    pub current_key: String,
    pub current_value: String,
}

/// ExecutionResult is used to communicate the result of contract execution back to the caller.
pub enum ExecutionResult {
    Success(String),
    Error(String),
}

impl ExecutionEngine {
    /// Creates a new instance of the ExecutionEngine with default managers.
    pub fn new() -> Self {
        ExecutionEngine {
            state_manager: StateManager::new(),
            resource_manager: ResourceManager::new(),
            security_manager: SecurityManager::new(),
        }
    }

    /// Executes a smart contract by processing its bytecode and updating the state accordingly.
    ///
    /// # Arguments
    ///
    /// * `bytecode` - A vector of u8 representing the compiled bytecode of the smart contract.
    /// * `context` - The execution context holding the initial state.
    ///
    /// # Returns
    ///
    /// * `ExecutionResult` - The outcome of the contract execution, either success or error.
    pub fn execute_contract(&mut self, bytecode: Vec<u8>, context: ExecutionContext) -> ExecutionResult {
        // Perform security validation on the bytecode before execution.
        if !self.security_manager.validate(&bytecode) {
            return ExecutionResult::Error("Security validation failed".to_string());
        }

        // Initialize the execution context.
        let mut ctx = context;

        // Process each bytecode instruction.
        for opcode in bytecode {
            match opcode {
                // Example opcode: 0x01 -> Store value in state
                0x01 => self.state_manager.store_value(ctx.current_key.clone(), ctx.current_value.clone()),
                // Example opcode: 0x02 -> Load value from state
                0x02 => ctx.current_value = self.state_manager.load_value(&ctx.current_key),
                // Handle unknown opcodes
                _ => return ExecutionResult::Error("Unknown opcode".to_string()),
            }
        }

        // Return the result of the execution.
        ExecutionResult::Success(ctx.current_value)
    }
}



=== ./.gitmodules ===



=== ./cert.pem ===
-----BEGIN CERTIFICATE-----
MIIFazCCA1OgAwIBAgIUKz5dfZ9jTOfAmPkt/87h5PFHc0AwDQYJKoZIhvcNAQEL
BQAwRTELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUxITAfBgNVBAoM
GEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDAeFw0yNDA4MjEyMDE5NDdaFw0yNTA4
MjEyMDE5NDdaMEUxCzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEw
HwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQwggIiMA0GCSqGSIb3DQEB
AQUAA4ICDwAwggIKAoICAQCyX/kj6bH9NeS4RZjWVQslhM2W0TctsvFZ2hw6tK3b
dmTmZX+KLejd+0FGTRTcInspbIkIedCeqsgBYoJie4/PvECG9OFN0unremCJZ0OY
54VsTur2RX0JbwjS2cmKQvK7Ex7xHndWckEPomRONEbFpUY0+S0ZQs2Qxw4LDI83
TJNM1s7mzjHGXXERg7rnuA4A4zDD0wkZ73Z1rGEFQ1cSs92KfSRYB3B0FVrXCtVa
VoFxTPscGQOX7w2AG98P2sla6uao/set3NEj2ZYOAYiF81PMNHRqR46Ecenm6Ao4
L+m+f7tUqViWtzm9/uThl8ekkzAZV5orLMqKqnlfcJlsmDNr2QquCxjPsmvXi3/1
TusmP6la/hgQ/0orbVVZQXg00xbziBIuFiixMkhPcn972mVbIQfEbcntGo/54shY
cvrrAPedBOGHuOhfvp50rA9Sp7kiIsxfxum54QyUAJBjx2d7DV0Qgzhbo8mCUDQh
HycNVJJlnZlE8TuelvXoG4N1DYxV21w2hy98YVnkSdaYB02dCiEMlczo6mSmVJHP
bt9t+/ODSRP+g7GurMTZXMcd4UeNDViuZy8S53ym6fbkLZNcrZ6Fk41o/3EbwZkF
alORB4xE3fTIacQes2ctc34b9rVYeZ5zXWwU4wPuE5EFD5R7Hs6Iw/rp8+4CDXeP
XwIDAQABo1MwUTAdBgNVHQ4EFgQUqJe/RlkHNUXMyhweeZSj7KfkJGswHwYDVR0j
BBgwFoAUqJe/RlkHNUXMyhweeZSj7KfkJGswDwYDVR0TAQH/BAUwAwEB/zANBgkq
hkiG9w0BAQsFAAOCAgEAjYs6tXpdAKY/WKhuTML/jneDghX0FPJWXwG5KHMF3oqJ
Bd4mQO5dQ+cBcgYReXgsLj2/HNaVhlr0kChhrwN/1LozhFJD+HEFJCTHPscBiVQf
rnsUozcDJUhj0g8K1ZC+v8Ld6A3xka1Ga3htbqTuBUZnIP/Tdvqq5Xjl+vQpclE1
1PUxazD28dUhaDrjgPGWlsu4xVuPekbsBpbR5vMDx7jh7A0J5Et5ST6GOgD0BSrg
5fwzRGgzfzEfpYe3Jegtk1YV/R2ZGUPihUXJxeuxqBwlLBAARaXg29cvXwpG4nDq
Ok89eCArXi378cj9TThDOIwFI+Ztw1ysaSaX8EUaeepeclHYnUgY9puppc7tYqch
fAznRCe7zmA+5RYPs894xgxQ1t+GjK614pC0STQ4+jHnhO+6qPkpx5rumUOXaaJc
3ZBkvGmeV7XG7qdYz0tB/VwX803xwmZB7vezf+E7brxLfEXz1NsGxRufwvQv0IPp
VL4ysn3jVrmMlCyNm6Maew/c/BvZVBm+g1HKoCrQ0+PhrK5DOx3xWQ8jzaYTx1fS
WW2PdhoD8/urJU+X70KTLqVdlhQVwi3MPEBtNkKceSZlmGnkrKZN3LuupokkToIH
ZRVOhSKJMi86jkWwzAGA0kLWDdAEEferP3X8TDyvPXX9htPjzvepYQS/ELxy8HY=
-----END CERTIFICATE-----



=== ./icn_consensus/Cargo.toml ===
[package]
name = "icn_consensus"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_shared = { path = "../icn_shared" }
log = "0.4"
rand = "0.8"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"



=== ./icn_consensus/src/consensus.rs ===
// Filename: icn_consensus/src/consensus.rs

use icn_shared::Block;

/// The `Consensus` trait defines the interface for consensus mechanisms
/// within the InterCooperative Network blockchain system.
///
/// Implementing this trait allows different consensus algorithms to be
/// used interchangeably within the blockchain.
pub trait Consensus: Clone + Send + Sync {
    /// Validates a block according to the consensus rules.
    ///
    /// # Arguments
    ///
    /// * `block` - A reference to the block that needs to be validated.
    ///
    /// # Returns
    ///
    /// * `Result<bool, String>` - Returns `Ok(true)` if the block is valid,
    ///   or an error message if validation fails.
    fn validate(&mut self, block: &Block) -> Result<bool, String>;

    /// Selects a proposer for the next block based on the consensus mechanism's rules.
    ///
    /// # Returns
    ///
    /// * `Result<String, String>` - Returns the ID of the selected proposer,
    ///   or an error message if selection fails.
    fn select_proposer(&mut self) -> Result<String, String>;

    /// Retrieves the list of eligible peers for proposer selection.
    ///
    /// # Returns
    ///
    /// * `Vec<String>` - A vector containing the IDs of eligible peers.
    fn get_eligible_peers(&self) -> Vec<String>;
}



=== ./icn_consensus/src/lib/mod.rs ===



=== ./icn_consensus/src/lib.rs ===
// File: icn_consensus/src/lib.rs

//! This module defines the consensus mechanisms for the InterCooperative Network (ICN) project.
//! It includes traits and structures for implementing various consensus algorithms.

pub mod consensus;
pub mod proof_of_cooperation;

pub use crate::consensus::Consensus;
pub use crate::proof_of_cooperation::ProofOfCooperation;



=== ./icn_consensus/src/proof_of_cooperation.rs ===
// Filename: icn_consensus/src/proof_of_cooperation.rs

use std::collections::{HashMap, HashSet, VecDeque};
use std::time::{SystemTime, UNIX_EPOCH};
use icn_shared::{Block, Chain, IcnError, IcnResult};
use icn_smart_contracts::SmartContractEngine;
use rand::{Rng, thread_rng};
use log::{info, warn, error};
use serde_json;

use crate::consensus::Consensus;

// Constants
const REPUTATION_DECAY_FACTOR: f64 = 0.95;
const CONSISTENCY_WEIGHT: f64 = 0.3;
const QUALITY_WEIGHT: f64 = 0.4;
const NETWORK_IMPACT_WEIGHT: f64 = 0.3;
const MAX_RECENT_CONTRIBUTIONS: usize = 100;
const MIN_STAKE_FOR_SYBIL_RESISTANCE: u64 = 1000;
const MIN_REPUTATION_FOR_SYBIL_RESISTANCE: f64 = 0.7;
const MIN_GOVERNANCE_PARTICIPATION_FOR_SYBIL_RESISTANCE: u64 = 10;
const BLOCK_TIME_THRESHOLD: u64 = 10; // Minimum time between blocks in seconds
const MAX_VALIDATORS: usize = 10; // Maximum number of validators for a block

/// The main struct implementing the Proof of Cooperation consensus mechanism
#[derive(Clone, Debug)]
pub struct ProofOfCooperation {
    known_peers: HashSet<String>,
    cooperation_scores: HashMap<String, f64>,
    reputation_scores: HashMap<String, f64>,
    contribution_history: HashMap<String, VecDeque<(u64, f64)>>,
    stake_info: HashMap<String, StakeInfo>,
    computational_power: HashMap<String, ComputationalPower>,
    storage_provision: HashMap<String, StorageProvision>,
    governance_participation: HashMap<String, GovernanceParticipation>,
    last_block_time: u64,
    smart_contract_engine: SmartContractEngine,
}

/// Struct representing a peer's stake information
#[derive(Clone, Debug)]
struct StakeInfo {
    amount: u64,
    asset_type: String,
    duration: u64,
}

/// Struct representing a peer's computational power contribution
#[derive(Clone, Debug)]
struct ComputationalPower {
    cpu_power: u64,
    gpu_power: u64,
    specialized_hardware: Vec<String>,
}

/// Struct representing a peer's storage provision
#[derive(Clone, Debug)]
struct StorageProvision {
    capacity: u64,
    reliability: f64,
}

/// Struct representing a peer's participation in governance
#[derive(Clone, Debug)]
struct GovernanceParticipation {
    proposals_submitted: u64,
    votes_cast: u64,
    discussions_participated: u64,
}

impl ProofOfCooperation {
    /// Creates a new instance of the ProofOfCooperation consensus mechanism
    pub fn new() -> Self {
        ProofOfCooperation {
            known_peers: HashSet::new(),
            cooperation_scores: HashMap::new(),
            reputation_scores: HashMap::new(),
            contribution_history: HashMap::new(),
            stake_info: HashMap::new(),
            computational_power: HashMap::new(),
            storage_provision: HashMap::new(),
            governance_participation: HashMap::new(),
            last_block_time: 0,
            smart_contract_engine: SmartContractEngine::new(),
        }
    }

    /// Registers a new peer in the network
    ///
    /// This function initializes all necessary data structures for a new peer,
    /// setting default values for various metrics.
    ///
    /// # Arguments
    ///
    /// * `peer_id` - A string slice that holds the identifier of the new peer
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - Returns Ok(()) if the peer is successfully registered, or an error otherwise.
    pub fn register_peer(&mut self, peer_id: &str) -> IcnResult<()> {
        self.known_peers.insert(peer_id.to_string());
        self.cooperation_scores.insert(peer_id.to_string(), 1.0);
        self.reputation_scores.insert(peer_id.to_string(), 1.0);
        self.contribution_history.insert(peer_id.to_string(), VecDeque::new());
        self.stake_info.insert(peer_id.to_string(), StakeInfo {
            amount: 0,
            asset_type: "ICN".to_string(),
            duration: 0,
        });
        self.computational_power.insert(peer_id.to_string(), ComputationalPower {
            cpu_power: 0,
            gpu_power: 0,
            specialized_hardware: Vec::new(),
        });
        self.storage_provision.insert(peer_id.to_string(), StorageProvision {
            capacity: 0,
            reliability: 1.0,
        });
        self.governance_participation.insert(peer_id.to_string(), GovernanceParticipation {
            proposals_submitted: 0,
            votes_cast: 0,
            discussions_participated: 0,
        });
        info!("Registered peer: {}", peer_id);
        Ok(())
    }

    /// Selects validators for block validation
    ///
    /// This function chooses a set of validators based on their stake, reputation,
    /// and other factors to ensure a fair and secure validation process.
    ///
    /// # Returns
    ///
    /// * `IcnResult<Vec<String>>` - A result containing a vector of selected validator IDs or an error
    fn select_validators(&self) -> IcnResult<Vec<String>> {
        let validators: Vec<String> = self.known_peers.iter()
            .filter(|&peer_id| {
                let stake = self.stake_info.get(peer_id).map(|info| info.amount).unwrap_or(0);
                let reputation = self.reputation_scores.get(peer_id).cloned().unwrap_or(0.0);
                stake > 0 && reputation > 0.5
            })
            .cloned()
            .collect();

        if validators.len() < 3 {
            return Err(IcnError::Consensus("Not enough eligible validators".to_string()));
        }

        let mut sorted_validators = validators;
        sorted_validators.sort_by(|a, b| {
            let a_score = self.calculate_validator_score(a);
            let b_score = self.calculate_validator_score(b);
            b_score.partial_cmp(&a_score).unwrap()
        });

        Ok(sorted_validators.into_iter().take(MAX_VALIDATORS).collect())
    }

    /// Calculates the score of a validator based on stake and reputation
    ///
    /// This function computes a score for a validator, which is used in the
    /// validator selection process.
    ///
    /// # Arguments
    ///
    /// * `peer_id` - A string slice that holds the identifier of the peer
    ///
    /// # Returns
    ///
    /// * `f64` - The calculated validator score
    fn calculate_validator_score(&self, peer_id: &str) -> f64 {
        let stake = self.stake_info.get(peer_id).map(|info| info.amount).unwrap_or(0) as f64;
        let reputation = self.reputation_scores.get(peer_id).cloned().unwrap_or(0.0);
        stake * reputation
    }

    /// Conducts a stake-weighted vote for block validation
    ///
    /// This function simulates a vote by a validator, taking into account their
    /// stake and reputation to determine the voting power.
    ///
    /// # Arguments
    ///
    /// * `validator_id` - A string slice that holds the identifier of the validator
    /// * `block` - A reference to the Block being voted on
    ///
    /// # Returns
    ///
    /// * `IcnResult<bool>` - A result containing the vote (true for valid, false for invalid) or an error
    fn stake_weighted_vote(&self, validator_id: &str, block: &Block) -> IcnResult<bool> {
        let stake = self.stake_info.get(validator_id)
            .ok_or_else(|| IcnError::Consensus(format!("No stake info for validator: {}", validator_id)))?
            .amount as f64;
        let reputation = self.reputation_scores.get(validator_id)
            .cloned()
            .unwrap_or(0.0);

        // Combine stake and reputation for voting power
        let voting_power = (stake * reputation).sqrt();
        let random_threshold = thread_rng().gen::<f64>();

        // Execute smart contract for additional voting logic
        let voting_contract = self.smart_contract_engine.get_contract("voting_logic")
            .ok_or_else(|| IcnError::Consensus("Voting logic smart contract not found".to_string()))?;
        let args = vec![
            voting_power.to_string(),
            random_threshold.to_string(),
            serde_json::to_string(block).map_err(|e| IcnError::Consensus(format!("Failed to serialize block: {}", e)))?
        ];
        let result = self.smart_contract_engine.call_contract(voting_contract.id, "validate_vote", args)?;

        Ok(result == "true")
    }

    /// Records a contribution made by a peer
    ///
    /// This function logs a contribution to the peer's history, which is used
    /// in calculating their cooperation and reputation scores.
    ///
    /// # Arguments
    ///
    /// * `peer_id` - A string slice that holds the identifier of the peer
    /// * `score` - A f64 representing the score of the contribution
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - A result indicating success or an error
    fn record_contribution(&mut self, peer_id: &str, score: f64) -> IcnResult<()> {
        let timestamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .map_err(|e| IcnError::Other(format!("System time error: {}", e)))?
            .as_secs();

        let history = self.contribution_history
            .entry(peer_id.to_string())
            .or_insert_with(VecDeque::new);

        history.push_back((timestamp, score));

        while history.len() > MAX_RECENT_CONTRIBUTIONS {
            history.pop_front();
        }

        Ok(())
    }

    /// Calculates the consistency of a peer's contributions
    ///
    /// This function evaluates how consistent a peer's contributions have been
    /// over time, which is a factor in their reputation score.
    ///
    /// # Arguments
    ///
    /// * `peer_id` - A string slice that holds the identifier of the peer
    ///
    /// # Returns
    ///
    /// * `IcnResult<f64>` - A result containing the calculated consistency score or an error
    fn calculate_consistency(&self, peer_id: &str) -> IcnResult<f64> {
        let history = self.contribution_history
            .get(peer_id)
            .ok_or_else(|| IcnError::Consensus(format!("Unknown peer: {}", peer_id)))?;

        if history.is_empty() {
            return Ok(1.0);
        }

        let recent_contributions: Vec<f64> = history.iter().map(|&(_, score)| score).collect();
        let mean: f64 = recent_contributions.iter().sum::<f64>() / recent_contributions.len() as f64;
        let variance: f64 = recent_contributions.iter().map(|&score| (score - mean).powi(2)).sum::<f64>() / recent_contributions.len() as f64;
        let std_deviation = variance.sqrt();

        Ok(1.0 / (1.0 + std_deviation))
    }

    /// Updates the reputation of a peer based on their actions
    ///
    /// This function adjusts a peer's reputation score based on their recent actions
    /// and overall contribution to the network.
    ///
    /// # Arguments
    ///
    /// * `peer_id` - A string slice that holds the identifier of the peer
    /// * `positive_action` - A boolean indicating whether the action was positive or negative
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - A result indicating success or an error
    pub fn update_reputation(&mut self, peer_id: &str, positive_action: bool) -> IcnResult<()> {
        let coop_score = *self.cooperation_scores
            .get(peer_id)
            .ok_or_else(|| IcnError::Consensus(format!("Unknown peer: {}", peer_id)))?;

        let consistency = self.calculate_consistency(peer_id)?;
        let network_impact = self.calculate_network_impact(peer_id)?;

        let rep_score = self.reputation_scores
            .entry(peer_id.to_string())
            .or_insert(1.0);

        let quality_factor = if positive_action { 1.1 } else { 0.9 };

        let new_rep_score = (
            CONSISTENCY_WEIGHT * consistency +
            QUALITY_WEIGHT * coop_score * quality_factor +
            NETWORK_IMPACT_WEIGHT * network_impact
        ) * REPUTATION_DECAY_FACTOR + (1.0 - REPUTATION_DECAY_FACTOR) * *rep_score;

        *rep_score = new_rep_score.max(0.0).min(1.0);

        // Execute smart contract for additional reputation logic
        let reputation_contract = self.smart_contract_engine.get_contract("reputation_adjustment")
            .ok_or_else(|| IcnError::Consensus("Reputation adjustment smart contract not found".to_string()))?;
        let args = vec![
            peer_id.to_string(),
            rep_score.to_string(),
            positive_action.to_string()
        ];
        let adjusted_score = self.smart_contract_engine.call_contract(reputation_contract.id, "adjust_reputation", args)?;
        *rep_score = adjusted_score.parse::<f64>().map_err(|e| IcnError::Consensus(format!("Failed to parse adjusted reputation score: {}", e)))?;

        Ok(())
    }

    /// Calculates the network impact of a peer
    ///
    /// This function evaluates a peer's overall impact on the network based on
    /// their stake, computational power, storage provision, and governance participation.
    ///
    /// # Arguments
    ///
    /// * `peer_id` - A string slice that holds the identifier of the peer
    ///
    /// # Returns
    ///
    /// * `IcnResult<f64>` - A result containing the calculated network impact score or an error
    fn calculate_network_impact(&self, peer_id: &str) -> IcnResult<f64> {
        let stake_info = self.stake_info.get(peer_id)
            .ok_or_else(|| IcnError::Consensus(format!("No stake info for peer: {}", peer_id)))?;

        let comp_power = self.computational_power.get(peer_id)
            .ok_or_else(|| IcnError::Consensus(format!("No computational power info for peer: {}", peer_id)))?;

        let storage = self.storage_provision.get(peer_id)
            .ok_or_else(|| IcnError::Consensus(format!("No storage provision info for peer: {}", peer_id)))?;

        let governance = self.governance_participation.get(peer_id)
            .ok_or_else(|| IcnError::Consensus(format!("No governance participation info for peer: {}", peer_id)))?;

        let stake_impact = (stake_info.amount as f64).log10() / 10.0;
        let comp_impact = (comp_power.cpu_power as f64 + comp_power.gpu_power as f64).log10() / 10.0;
        let storage_impact = (storage.capacity as f64).log10() / 20.0 * storage.reliability;
        let governance_impact = (governance.proposals_submitted + governance.votes_cast) as f64 / 100.0;

        let total_impact = stake_impact + comp_impact + storage_impact + governance_impact;

        // Execute smart contract for additional network impact calculation
        let impact_contract = self.smart_contract_engine.get_contract("network_impact")
            .ok_or_else(|| IcnError::Consensus("Network impact smart contract not found".to_string()))?;
        let args = vec![
            total_impact.to_string(),
            serde_json::to_string(stake_info).map_err(|e| IcnError::Consensus(format!("Failed to serialize stake info: {}", e)))?,
            serde_json::to_string(comp_power).map_err(|e| IcnError::Consensus(format!("Failed to serialize computational power: {}", e)))?,
            serde_json::to_string(storage).map_err(|e| IcnError::Consensus(format!("Failed to serialize storage provision: {}", e)))?,
            serde_json::to_string(governance).map_err(|e| IcnError::Consensus(format!("Failed to serialize governance participation: {}", e)))?
        ];
        let adjusted_impact = self.smart_contract_engine.call_contract(impact_contract.id, "calculate_impact", args)?;
        let final_impact = adjusted_impact.parse::<f64>().map_err(|e| IcnError::Consensus(format!("Failed to parse adjusted network impact: {}", e)))?;

        Ok(final_impact.min(1.0))
    }

    /// Updates the cooperation score of a peer
    ///
    /// This function adjusts a peer's cooperation score based on their recent actions
    /// and contributions to the network.
    ///
    /// # Arguments
    ///
    /// * `peer_id` - A string slice that holds the identifier of the peer
    /// * `new_score` - A f64 representing the new cooperation score
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - A result indicating success or an error
    pub fn update_cooperation_score(&mut self, peer_id: &str, new_score: f64) -> IcnResult<()> {
        let score = self.cooperation_scores
            .entry(peer_id.to_string())
            .or_insert(1.0);

        *score = (*score + new_score.max(0.0).min(1.0)) / 2.0;
        self.record_contribution(peer_id, new_score)?;

        // Execute smart contract for additional cooperation score adjustment
        let cooperation_contract = self.smart_contract_engine.get_contract("cooperation_adjustment")
            .ok_or_else(|| IcnError::Consensus("Cooperation adjustment smart contract not found".to_string()))?;
        let args = vec![
            peer_id.to_string(),
            score.to_string(),
            new_score.to_string()
        ];
        let adjusted_score = self.smart_contract_engine.call_contract(cooperation_contract.id, "adjust_cooperation", args)?;
        *score = adjusted_score.parse::<f64>().map_err(|e| IcnError::Consensus(format!("Failed to parse adjusted cooperation score: {}", e)))?;

        Ok(())
    }

    /// Retrieves a list of eligible peers for validation
    ///
    /// This function returns a list of peers that meet the minimum requirements
    /// for stake, reputation, and governance participation to be considered for validation.
    ///
    /// # Returns
    ///
    /// * `Vec<String>` - A vector of peer IDs that are eligible for validation
    pub fn get_eligible_peers(&self) -> Vec<String> {
        self.known_peers.iter()
            .filter(|&peer_id| {
                let stake = self.stake_info.get(peer_id).map(|info| info.amount).unwrap_or(0);
                let reputation = self.reputation_scores.get(peer_id).cloned().unwrap_or(0.0);
                stake >= MIN_STAKE_FOR_SYBIL_RESISTANCE && reputation >= MIN_REPUTATION_FOR_SYBIL_RESISTANCE
            })
            .cloned()
            .collect()
    }

    /// Updates the stake information of a peer
    ///
    /// This function updates the stake amount, asset type, and duration for a given peer.
    ///
    /// # Arguments
    ///
    /// * `peer_id` - A string slice that holds the identifier of the peer
    /// * `amount` - A u64 representing the new stake amount
    /// * `asset_type` - A String representing the type of asset being staked
    /// * `duration` - A u64 representing the duration of the stake in seconds
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - A result indicating success or an error
    pub fn update_stake(&mut self, peer_id: &str, amount: u64, asset_type: String, duration: u64) -> IcnResult<()> {
        let stake_info = self.stake_info
            .entry(peer_id.to_string())
            .or_insert(StakeInfo {
                amount: 0,
                asset_type: asset_type.clone(),
                duration: 0,
            });

        stake_info.amount = amount;
        stake_info.asset_type = asset_type;
        stake_info.duration = duration;

        // Execute smart contract for stake validation and potential bonuses
        let stake_contract = self.smart_contract_engine.get_contract("stake_management")
            .ok_or_else(|| IcnError::Consensus("Stake management smart contract not found".to_string()))?;
        let args = vec![
            peer_id.to_string(),
            amount.to_string(),
            stake_info.asset_type.clone(),
            duration.to_string()
        ];
        let result = self.smart_contract_engine.call_contract(stake_contract.id, "validate_and_adjust_stake", args)?;
        let adjusted_stake: StakeInfo = serde_json::from_str(&result)
            .map_err(|e| IcnError::Consensus(format!("Failed to parse adjusted stake info: {}", e)))?;

        *stake_info = adjusted_stake;

        info!("Updated stake for peer {}: amount={}, asset_type={}, duration={}", 
              peer_id, stake_info.amount, stake_info.asset_type, stake_info.duration);
        Ok(())
    }

    /// Updates the computational power information of a peer
    ///
    /// This function updates the CPU power, GPU power, and specialized hardware
    /// information for a given peer.
    ///
    /// # Arguments
    ///
    /// * `peer_id` - A string slice that holds the identifier of the peer
    /// * `cpu_power` - A u64 representing the CPU power
    /// * `gpu_power` - A u64 representing the GPU power
    /// * `specialized_hardware` - A Vec<String> representing specialized hardware capabilities
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - A result indicating success or an error
    pub fn update_computational_power(&mut self, peer_id: &str, cpu_power: u64, gpu_power: u64, specialized_hardware: Vec<String>) -> IcnResult<()> {
        let comp_power = self.computational_power
            .entry(peer_id.to_string())
            .or_insert(ComputationalPower {
                cpu_power: 0,
                gpu_power: 0,
                specialized_hardware: Vec::new(),
            });

        comp_power.cpu_power = cpu_power;
        comp_power.gpu_power = gpu_power;
        comp_power.specialized_hardware = specialized_hardware.clone();

        info!("Updated computational power for peer {}: cpu_power={}, gpu_power={}, specialized_hardware={:?}", 
              peer_id, cpu_power, gpu_power, specialized_hardware);
        Ok(())
    }

    /// Updates the storage provision information of a peer
    ///
    /// This function updates the storage capacity and reliability for a given peer.
    ///
    /// # Arguments
    ///
    /// * `peer_id` - A string slice that holds the identifier of the peer
    /// * `capacity` - A u64 representing the storage capacity in bytes
    /// * `reliability` - A f64 representing the reliability score (0.0 to 1.0)
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - A result indicating success or an error
    pub fn update_storage_provision(&mut self, peer_id: &str, capacity: u64, reliability: f64) -> IcnResult<()> {
        let storage_info = self.storage_provision
            .entry(peer_id.to_string())
            .or_insert(StorageProvision {
                capacity: 0,
                reliability: 1.0,
            });

        storage_info.capacity = capacity;
        storage_info.reliability = reliability.max(0.0).min(1.0);

        info!("Updated storage provision for peer {}: capacity={}, reliability={}", peer_id, capacity, reliability);
        Ok(())
    }

    /// Updates the governance participation information of a peer
    ///
    /// This function updates the number of proposals submitted, votes cast,
    /// and discussions participated in for a given peer.
    ///
    /// # Arguments
    ///
    /// * `peer_id` - A string slice that holds the identifier of the peer
    /// * `proposals_submitted` - A u64 representing the number of proposals submitted
    /// * `votes_cast` - A u64 representing the number of votes cast
    /// * `discussions_participated` - A u64 representing the number of discussions participated in
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - A result indicating success or an error
    pub fn update_governance_participation(&mut self, peer_id: &str, proposals_submitted: u64, votes_cast: u64, discussions_participated: u64) -> IcnResult<()> {
        let governance_info = self.governance_participation
            .entry(peer_id.to_string())
            .or_insert(GovernanceParticipation {
                proposals_submitted: 0,
                votes_cast: 0,
                discussions_participated: 0,
            });

        governance_info.proposals_submitted = proposals_submitted;
        governance_info.votes_cast = votes_cast;
        governance_info.discussions_participated = discussions_participated;

        // Execute smart contract for governance participation validation and potential bonuses
        let governance_contract = self.smart_contract_engine.get_contract("governance_participation")
            .ok_or_else(|| IcnError::Consensus("Governance participation smart contract not found".to_string()))?;
        let args = vec![
            peer_id.to_string(),
            proposals_submitted.to_string(),
            votes_cast.to_string(),
            discussions_participated.to_string()
        ];
        let result = self.smart_contract_engine.call_contract(governance_contract.id, "validate_and_adjust_participation", args)?;
        let adjusted_participation: GovernanceParticipation = serde_json::from_str(&result)
            .map_err(|e| IcnError::Consensus(format!("Failed to parse adjusted governance participation: {}", e)))?;

        *governance_info = adjusted_participation;

        info!("Updated governance participation for peer {}: proposals_submitted={}, votes_cast={}, discussions_participated={}", 
              peer_id, governance_info.proposals_submitted, governance_info.votes_cast, governance_info.discussions_participated);
        Ok(())
    }

    /// Checks if a peer passes the Sybil resistance criteria
    ///
    /// This function evaluates whether a peer meets the minimum requirements
    /// for stake, reputation, and governance participation to be considered
    /// resistant to Sybil attacks.
    ///
    /// # Arguments
    ///
    /// * `peer_id` - A string slice that holds the identifier of the peer
    ///
    /// # Returns
    ///
    /// * `bool` - true if the peer passes the Sybil resistance check, false otherwise
    pub fn sybil_resistant_check(&self, peer_id: &str) -> bool {
        let stake = self.stake_info.get(peer_id).map(|info| info.amount).unwrap_or(0);
        let reputation = self.reputation_scores.get(peer_id).cloned().unwrap_or(0.0);
        let governance_participation = self.governance_participation.get(peer_id)
            .map(|info| info.proposals_submitted + info.votes_cast)
            .unwrap_or(0);

        stake >= MIN_STAKE_FOR_SYBIL_RESISTANCE &&
        reputation >= MIN_REPUTATION_FOR_SYBIL_RESISTANCE &&
        governance_participation >= MIN_GOVERNANCE_PARTICIPATION_FOR_SYBIL_RESISTANCE
    }

    /// Calculates the reward for a peer based on their contributions and reputation
    ///
    /// This function computes a reward for a peer based on their cooperation score,
    /// reputation score, and network impact.
    ///
    /// # Arguments
    ///
    /// * `peer_id` - A string slice that holds the identifier of the peer
    ///
    /// # Returns
    ///
    /// * `IcnResult<u64>` - A result containing the calculated reward or an error
    pub fn calculate_reward(&self, peer_id: &str) -> IcnResult<u64> {
        let cooperation_score = self.cooperation_scores.get(peer_id)
            .ok_or_else(|| IcnError::Consensus(format!("Unknown peer: {}", peer_id)))?;

        let reputation_score = self.reputation_scores.get(peer_id)
            .ok_or_else(|| IcnError::Consensus(format!("Unknown peer: {}", peer_id)))?;

        let network_impact = self.calculate_network_impact(peer_id)?;

        let base_reward = 100;

        let adjusted_reward = (base_reward as f64 * cooperation_score * reputation_score * (1.0 + network_impact)).round() as u64;

        // Execute smart contract for reward calculation
        let reward_contract = self.smart_contract_engine.get_contract("reward_calculation")
            .ok_or_else(|| IcnError::Consensus("Reward calculation smart contract not found".to_string()))?;
        let args = vec![
            peer_id.to_string(),
            cooperation_score.to_string(),
            reputation_score.to_string(),
            network_impact.to_string(),
            adjusted_reward.to_string()
        ];
        let final_reward = self.smart_contract_engine.call_contract(reward_contract.id, "calculate_final_reward", args)?;

        Ok(final_reward.parse::<u64>().map_err(|e| IcnError::Consensus(format!("Failed to parse final reward: {}", e)))?)
    }

    /// Distributes rewards to all eligible peers
    ///
    /// This function calculates and distributes rewards to all peers that meet
    /// the eligibility criteria.
    ///
    /// # Returns
    ///
    /// * `IcnResult<HashMap<String, u64>>` - A result containing a map of peer IDs to their rewards, or an error
    pub fn distribute_rewards(&mut self) -> IcnResult<HashMap<String, u64>> {
        let mut rewards = HashMap::new();

        for peer_id in self.get_eligible_peers() {
            let reward = self.calculate_reward(&peer_id)?;
            rewards.insert(peer_id, reward);
        }

        // Execute smart contract for reward distribution
        let distribution_contract = self.smart_contract_engine.get_contract("reward_distribution")
            .ok_or_else(|| IcnError::Consensus("Reward distribution smart contract not found".to_string()))?;
        let args = vec![serde_json::to_string(&rewards).map_err(|e| IcnError::Consensus(format!("Failed to serialize rewards: {}", e)))?];
        let distributed_rewards = self.smart_contract_engine.call_contract(distribution_contract.id, "distribute_rewards", args)?;

        let final_rewards: HashMap<String, u64> = serde_json::from_str(&distributed_rewards)
            .map_err(|e| IcnError::Consensus(format!("Failed to parse distributed rewards: {}", e)))?;

        Ok(final_rewards)
    }

    /// Applies a penalty to a peer based on the severity of their misconduct
    ///
    /// This function reduces a peer's cooperation score, reputation score, and
    /// potentially their stake based on the severity of their misconduct.
    ///
    /// # Arguments
    ///
    /// * `peer_id` - A string slice that holds the identifier of the peer
    /// * `severity` - A f64 representing the severity of the misconduct (0.0 to 1.0)
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - A result indicating success or an error
    pub fn apply_penalty(&mut self, peer_id: &str, severity: f64) -> IcnResult<()> {
        let severity = severity.max(0.0).min(1.0);

        if let Some(score) = self.cooperation_scores.get_mut(peer_id) {
            *score *= 1.0 - severity;
        }

        if let Some(score) = self.reputation_scores.get_mut(peer_id) {
            *score *= 1.0 - severity;
        }

        if severity > 0.5 {
            if let Some(stake_info) = self.stake_info.get_mut(peer_id) {
                stake_info.amount = (stake_info.amount as f64 * (1.0 - severity * 0.5)) as u64;
            }
        }

        // Execute smart contract for penalty application
        let penalty_contract = self.smart_contract_engine.get_contract("penalty_application")
            .ok_or_else(|| IcnError::Consensus("Penalty application smart contract not found".to_string()))?;
        let args = vec![
            peer_id.to_string(),
            severity.to_string(),
            self.cooperation_scores.get(peer_id).unwrap_or(&0.0).to_string(),
            self.reputation_scores.get(peer_id).unwrap_or(&0.0).to_string(),
            self.stake_info.get(peer_id).map(|s| s.amount).unwrap_or(0).to_string()
        ];
        let penalty_result = self.smart_contract_engine.call_contract(penalty_contract.id, "apply_penalty", args)?;

        let penalty_data: HashMap<String, f64> = serde_json::from_str(&penalty_result)
            .map_err(|e| IcnError::Consensus(format!("Failed to parse penalty result: {}", e)))?;

        if let Some(coop_score) = penalty_data.get("cooperation_score") {
            self.cooperation_scores.insert(peer_id.to_string(), *coop_score);
        }
        if let Some(rep_score) = penalty_data.get("reputation_score") {
            self.reputation_scores.insert(peer_id.to_string(), *rep_score);
        }
        if let Some(stake_amount) = penalty_data.get("stake_amount") {
            if let Some(stake_info) = self.stake_info.get_mut(peer_id) {
                stake_info.amount = *stake_amount as u64;
            }
        }

        info!("Applied penalty to peer {} with severity {}", peer_id, severity);
        Ok(())
    }

    /// Evaluates the overall health of the network
    ///
    /// This function calculates a health score for the entire network based on
    /// average cooperation and reputation scores, as well as stake distribution.
    ///
    /// # Returns
    ///
    /// * `IcnResult<f64>` - A result containing the calculated health score or an error
    pub fn evaluate_network_health(&self) -> IcnResult<f64> {
        let avg_cooperation = self.cooperation_scores.values().sum::<f64>() / self.cooperation_scores.len() as f64;
        let avg_reputation = self.reputation_scores.values().sum::<f64>() / self.reputation_scores.len() as f64;

        let total_stake: u64 = self.stake_info.values().map(|info| info.amount).sum();
        let stake_distribution = 1.0 - (self.stake_info.values().map(|info| info.amount as f64 / total_stake as f64).map(|x| x * x).sum::<f64>().sqrt());

        let health_score = (avg_cooperation + avg_reputation + stake_distribution) / 3.0;

        // Execute smart contract for network health evaluation
        let health_contract = self.smart_contract_engine.get_contract("network_health")
            .ok_or_else(|| IcnError::Consensus("Network health smart contract not found".to_string()))?;
        let args = vec![
            avg_cooperation.to_string(),
            avg_reputation.to_string(),
            stake_distribution.to_string(),
            health_score.to_string()
        ];
        let final_health_score = self.smart_contract_engine.call_contract(health_contract.id, "evaluate_health", args)?;

        Ok(final_health_score.parse::<f64>().map_err(|e| IcnError::Consensus(format!("Failed to parse final health score: {}", e)))?)
    }
}

/// Implement the `Consensus` trait for `ProofOfCooperation`
impl Consensus for ProofOfCooperation {
    /// Validates a block according to the Proof of Cooperation consensus rules
    ///
    /// This function checks if a block is valid by verifying the proposer,
    /// ensuring proper time between blocks, and conducting a stake-weighted vote.
    ///
    /// # Arguments
    ///
    /// * `block` - A reference to the Block to be validated
    ///
    /// # Returns
    ///
    /// * `IcnResult<bool>` - A result containing true if the block is valid, false otherwise, or an error
    fn validate(&mut self, block: &Block) -> IcnResult<bool> {
        if !self.known_peers.contains(&block.proposer_id) {
            return Err(IcnError::Consensus(format!("Unknown proposer: {}", block.proposer_id)));
        }

        let current_time = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .map_err(|e| IcnError::Consensus(format!("System time error: {}", e)))?
            .as_secs();

        if current_time < self.last_block_time + BLOCK_TIME_THRESHOLD {
            return Err(IcnError::Consensus("Block proposed too soon".to_string()));
        }

        let validators = self.select_validators()?;
        let mut valid_votes = 0;
        let total_votes = validators.len();

        for validator in validators {
            let vote = self.stake_weighted_vote(&validator, block)?;
            if vote {
                valid_votes += 1;
            }
        }

        let validation_threshold = (total_votes as f64 * 2.0 / 3.0).ceil() as usize;
        let is_valid = valid_votes >= validation_threshold;

        // Update reputation of the proposer based on the block's validity
        self.update_reputation(&block.proposer_id, is_valid)?;

        Ok(is_valid)
    }

    /// Selects a proposer for the next block
    ///
    /// This function chooses a peer to propose the next block based on their
    /// stake, reputation, and other factors to ensure a fair and secure selection process.
    ///
    /// # Returns
    ///
    /// * `IcnResult<String>` - A result containing the ID of the selected proposer or an error
    fn select_proposer(&mut self) -> IcnResult<String> {
        let eligible_peers = self.get_eligible_peers();
        if eligible_peers.is_empty() {
            return Err(IcnError::Consensus("No eligible proposers available".to_string()));
        }

        let total_score: f64 = eligible_peers.iter()
            .map(|peer_id| self.calculate_validator_score(peer_id))
            .sum();

        let mut rng = thread_rng();
        let mut cumulative_weight = 0.0;
        let random_value = rng.gen::<f64>() * total_score;

        for peer_id in &eligible_peers {
            cumulative_weight += self.calculate_validator_score(peer_id);
            if cumulative_weight >= random_value {
                return Ok(peer_id.clone());
            }
        }

        Err(IcnError::Consensus("Failed to select proposer".to_string()))
    }

    /// Gets the list of eligible peers for consensus participation
    ///
    /// This function returns a list of peer IDs that meet the minimum requirements
    /// for participating in the consensus process.
    ///
    /// # Returns
    ///
    /// * `Vec<String>` - A vector of eligible peer IDs
    fn get_eligible_peers(&self) -> Vec<String> {
        self.get_eligible_peers() // This calls the public method we defined earlier
    }

    /// Updates the consensus state based on the current blockchain state
    ///
    /// This function is called after a new block is added to the chain to update
    /// the internal state of the consensus mechanism.
    ///
    /// # Arguments
    ///
    /// * `chain` - A reference to the current blockchain
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - A result indicating success or an error
    fn update_state(&mut self, chain: &Chain<Self>) -> IcnResult<()> {
        if let Some(latest_block) = chain.latest_block() {
            self.last_block_time = latest_block.timestamp;
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_shared::Block;

    fn setup_test_poc() -> ProofOfCooperation {
        let mut poc = ProofOfCooperation::new();
        poc.register_peer("peer1").unwrap();
        poc.register_peer("peer2").unwrap();
        poc.register_peer("peer3").unwrap();
        poc
    }

    #[test]
    fn test_register_and_validate_peer() {
        let mut poc = ProofOfCooperation::new();
        poc.register_peer("peer1").unwrap();

        assert!(poc.known_peers.contains("peer1"));
        assert!(!poc.known_peers.contains("unknown_peer"));

        let block = Block::new(0, vec![], "previous_hash".to_string(), "peer1".to_string());
        assert!(poc.validate(&block).is_ok());

        let invalid_block = Block::new(0, vec![], "previous_hash".to_string(), "unknown_peer".to_string());
        assert!(poc.validate(&invalid_block).is_err());
    }

    #[test]
    fn test_update_and_calculate_reputation() {
        let mut poc = setup_test_poc();

        poc.update_cooperation_score("peer1", 0.8).unwrap();
        poc.update_reputation("peer1", true).unwrap();

        let reputation = poc.reputation_scores.get("peer1").cloned().unwrap_or(0.0);
        assert!(reputation > 0.5, "Reputation should increase after positive action");

        poc.update_cooperation_score("peer1", 0.2).unwrap();
        poc.update_reputation("peer1", false).unwrap();

        let new_reputation = poc.reputation_scores.get("peer1").cloned().unwrap_or(0.0);
        assert!(new_reputation < reputation, "Reputation should decrease after negative action");
    }

    #[test]
    fn test_sybil_resistant_check() {
        let mut poc = setup_test_poc();

        poc.update_stake("peer1", 2000, "ICN".to_string(), 60).unwrap();
        poc.update_reputation("peer1", true).unwrap();
        poc.update_governance_participation("peer1", 5, 10, 3).unwrap();

        poc.update_stake("peer2", 500, "ICN".to_string(), 30).unwrap();
        poc.update_reputation("peer2", false).unwrap();
        poc.update_governance_participation("peer2", 1, 2, 1).unwrap();

        assert!(poc.sybil_resistant_check("peer1"), "Good peer should pass Sybil resistance check");
        assert!(!poc.sybil_resistant_check("peer2"), "Bad peer should fail Sybil resistance check");
    }

    #[test]
    fn test_calculate_and_distribute_rewards() {
        let mut poc = setup_test_poc();

        poc.update_stake("peer1", 1000, "ICN".to_string(), 30).unwrap();
        poc.update_cooperation_score("peer1", 0.9).unwrap();
        poc.update_reputation("peer1", true).unwrap();

        poc.update_stake("peer2", 500, "ICN".to_string(), 30).unwrap();
        poc.update_cooperation_score("peer2", 0.5).unwrap();
        poc.update_reputation("peer2", true).unwrap();

        poc.update_stake("peer3", 2000, "ICN".to_string(), 60).unwrap();
        poc.update_cooperation_score("peer3", 0.7).unwrap();
        poc.update_reputation("peer3", true).unwrap();

        let reward1 = poc.calculate_reward("peer1").unwrap();
        let reward2 = poc.calculate_reward("peer2").unwrap();
        let reward3 = poc.calculate_reward("peer3").unwrap();

        assert!(reward1 > reward2, "Peer1 should have higher reward than Peer2");
        assert!(reward3 > reward1, "Peer3 should have higher reward than Peer1");

        let rewards = poc.distribute_rewards().unwrap();
        assert_eq!(rewards.len(), 3, "All three peers should receive rewards");
        assert_eq!(rewards.get("peer1"), Some(&reward1));
        assert_eq!(rewards.get("peer2"), Some(&reward2));
        assert_eq!(rewards.get("peer3"), Some(&reward3));
    }

    #[test]
    fn test_apply_penalty() {
        let mut poc = setup_test_poc();

        poc.update_cooperation_score("peer1", 0.8).unwrap();
        poc.update_reputation("peer1", true).unwrap();
        poc.update_stake("peer1", 1000, "ICN".to_string(), 30).unwrap();

        let initial_cooperation = poc.cooperation_scores.get("peer1").cloned().unwrap();
        let initial_reputation = poc.reputation_scores.get("peer1").cloned().unwrap();
        let initial_stake = poc.stake_info.get("peer1").unwrap().amount;

        poc.apply_penalty("peer1", 0.3).unwrap();

        let after_penalty_cooperation = poc.cooperation_scores.get("peer1").cloned().unwrap();
        let after_penalty_reputation = poc.reputation_scores.get("peer1").cloned().unwrap();
        let after_penalty_stake = poc.stake_info.get("peer1").unwrap().amount;

        assert!(after_penalty_cooperation < initial_cooperation, "Cooperation score should decrease after penalty");
        assert!(after_penalty_reputation < initial_reputation, "Reputation score should decrease after penalty");
        assert_eq!(after_penalty_stake, initial_stake, "Stake should not change for moderate penalty");

        poc.apply_penalty("peer1", 0.8).unwrap();

        let final_cooperation = poc.cooperation_scores.get("peer1").cloned().unwrap();
        let final_reputation = poc.reputation_scores.get("peer1").cloned().unwrap();
        let final_stake = poc.stake_info.get("peer1").unwrap().amount;

        assert!(final_cooperation < after_penalty_cooperation, "Cooperation score should decrease further after severe penalty");
        assert!(final_reputation < after_penalty_reputation, "Reputation score should decrease further after severe penalty");
        assert!(final_stake < after_penalty_stake, "Stake should decrease for severe penalty");
    }

    #[test]
    fn test_network_health_evaluation() {
        let mut poc = setup_test_poc();

        for (i, peer) in ["peer1", "peer2", "peer3"].iter().enumerate() {
            poc.update_cooperation_score(peer, 0.8 + i as f64 * 0.1).unwrap();
            poc.update_reputation(peer, true).unwrap();
            poc.update_stake(peer, 1000 + i as u64 * 500, "ICN".to_string(), 30).unwrap();
        }

        let health_score = poc.evaluate_network_health().unwrap();
        assert!(health_score > 0.8, "Network health should be high for a well-balanced network");

        poc.update_cooperation_score("peer1", 0.3).unwrap();
        poc.update_reputation("peer1", false).unwrap();
        poc.update_stake("peer2", 10000, "ICN".to_string(), 30).unwrap();

        let new_health_score = poc.evaluate_network_health().unwrap();
        assert!(new_health_score < health_score, "Network health should decrease for an imbalanced network");
    }

    #[test]
    fn test_select_proposer() {
        let mut poc = setup_test_poc();

        // Set up peers with different stakes and reputations
        poc.update_stake("peer1", 2000, "ICN".to_string(), 60).unwrap();
        poc.update_reputation("peer1", true).unwrap();
        poc.update_cooperation_score("peer1", 0.9).unwrap();

        poc.update_stake("peer2", 1000, "ICN".to_string(), 30).unwrap();
        poc.update_reputation("peer2", true).unwrap();
        poc.update_cooperation_score("peer2", 0.7).unwrap();

        poc.update_stake("peer3", 3000, "ICN".to_string(), 90).unwrap();
        poc.update_reputation("peer3", true).unwrap();
        poc.update_cooperation_score("peer3", 0.8).unwrap();

        // Run multiple selections to check for randomness and weighted probability
        let mut selections = HashMap::new();
        for _ in 0..1000 {
            let proposer = poc.select_proposer().unwrap();
            *selections.entry(proposer).or_insert(0) += 1;
        }

        // Check that all peers were selected at least once
        assert!(selections.contains_key("peer1"));
        assert!(selections.contains_key("peer2"));
        assert!(selections.contains_key("peer3"));

        // Check that the peer with the highest stake and reputation (peer3) was selected most often
        assert!(selections.get("peer3").unwrap() > selections.get("peer1").unwrap());
        assert!(selections.get("peer3").unwrap() > selections.get("peer2").unwrap());
    }

    #[test]
    fn test_update_computational_power() {
        let mut poc = setup_test_poc();

        poc.update_computational_power("peer1", 100, 200, vec!["ASIC".to_string()]).unwrap();

        let comp_power = poc.computational_power.get("peer1").unwrap();
        assert_eq!(comp_power.cpu_power, 100);
        assert_eq!(comp_power.gpu_power, 200);
        assert_eq!(comp_power.specialized_hardware, vec!["ASIC".to_string()]);
    }

    #[test]
    fn test_update_storage_provision() {
        let mut poc = setup_test_poc();

        poc.update_storage_provision("peer1", 1000, 0.95).unwrap();

        let storage = poc.storage_provision.get("peer1").unwrap();
        assert_eq!(storage.capacity, 1000);
        assert_eq!(storage.reliability, 0.95);
    }

    #[test]
    fn test_update_governance_participation() {
        let mut poc = setup_test_poc();

        poc.update_governance_participation("peer1", 5, 10, 3).unwrap();

        let governance = poc.governance_participation.get("peer1").unwrap();
        assert_eq!(governance.proposals_submitted, 5);
        assert_eq!(governance.votes_cast, 10);
        assert_eq!(governance.discussions_participated, 3);
    }

    #[test]
    fn test_calculate_network_impact() {
        let mut poc = setup_test_poc();

        poc.update_stake("peer1", 2000, "ICN".to_string(), 60).unwrap();
        poc.update_computational_power("peer1", 100, 200, vec!["ASIC".to_string()]).unwrap();
        poc.update_storage_provision("peer1", 1000, 0.95).unwrap();
        poc.update_governance_participation("peer1", 5, 10, 3).unwrap();

        let impact = poc.calculate_network_impact("peer1").unwrap();
        assert!(impact > 0.0 && impact <= 1.0, "Network impact should be between 0 and 1");
    }

    #[test]
    fn test_validate_block() {
        let mut poc = setup_test_poc();

        // Set up peers with stakes and reputations
        for peer in ["peer1", "peer2", "peer3"].iter() {
            poc.update_stake(peer, 2000, "ICN".to_string(), 60).unwrap();
            poc.update_reputation(peer, true).unwrap();
            poc.update_cooperation_score(peer, 0.9).unwrap();
        }

        // Create a valid block
        let valid_block = Block::new(1, vec![], "previous_hash".to_string(), "peer1".to_string());

        // Ensure enough time has passed since the last block
        poc.last_block_time = 0;

        // Validate the block
        let validation_result = poc.validate(&valid_block);
        assert!(validation_result.is_ok(), "Block validation should succeed");
        assert!(validation_result.unwrap(), "Block should be considered valid");

        // Test invalid block (proposer not in known peers)
        let invalid_block = Block::new(2, vec![], valid_block.hash.clone(), "unknown_peer".to_string());
        let invalid_result = poc.validate(&invalid_block);
        assert!(invalid_result is_err(), "Validation should fail for unknown proposer");

        // Test block proposed too soon
        poc.last_block_time = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();
        let too_soon_block = Block::new(3, vec![], valid_block.hash.clone(), "peer2".to_string());
        let too_soon_result = poc.validate(&too_soon_block);
        assert!(too_soon_result.is_err(), "Validation should fail for block proposed too soon");
    }

    #[test]
    fn test_update_state() {
        let mut poc = setup_test_poc();
        let mut chain = Chain::new();

        // Add a block to the chain
        let block = Block::new(1, vec![], "previous_hash".to_string(), "peer1".to_string());
        chain.add_block(block.clone()).unwrap();

        // Update the consensus state
        poc.update_state(&chain).unwrap();

        // Check if the last block time was updated
        assert_eq!(poc.last_block_time, block.timestamp, "Last block time should be updated");
    }
}


=== ./icn_governance/Cargo.toml ===
[package]
name = "icn_governance"
version = "0.1.0"
edition = "2021"

[dependencies]



=== ./icn_governance/src/lib/mod.rs ===



=== ./icn_governance/src/lib.rs ===
pub struct Proposal {
    pub id: u32,
    pub description: String,
    pub votes_for: u32,
    pub votes_against: u32,
}

impl Proposal {
    pub fn new(id: u32, description: &str) -> Self {
        Proposal {
            id,
            description: description.to_string(),
            votes_for: 0,
            votes_against: 0,
        }
    }

    pub fn vote_for(&mut self) {
        self.votes_for += 1;
    }

    pub fn vote_against(&mut self) {
        self.votes_against += 1;
    }
}



=== ./Cargo.toml ===
[workspace]
members = [
    "icn_core",
    "icn_blockchain",
    "icn_consensus",
    "icn_networking",
    "icn_identity",
    "icn_governance",
    "icn_smart_contracts",
    "icn_virtual_machine",
    "icn_api",
    "icn_storage",
    "icn_shared"
]
default-run = "icn_core"

resolver = "2"


=== ./Cargo.lock ===
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "addr2line"
version = "0.22.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e4503c46a5c0c7844e948c9a4d6acd9f50cccb4de1c48eb9e291ea17470c678"
dependencies = [
 "gimli 0.29.0",
]

[[package]]
name = "adler"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe"

[[package]]
name = "ahash"
version = "0.7.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "891477e0c6a8957309ee5c45a6368af3ae14bb510732d2684ffa19af310920f9"
dependencies = [
 "getrandom",
 "once_cell",
 "version_check",
]

[[package]]
name = "aho-corasick"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
dependencies = [
 "memchr",
]

[[package]]
name = "android-tzdata"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0"

[[package]]
name = "android_system_properties"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
dependencies = [
 "libc",
]

[[package]]
name = "anstream"
version = "0.6.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "64e15c1ab1f89faffbf04a634d5e1962e9074f2741eef6d97f3c4e322426d526"
dependencies = [
 "anstyle",
 "anstyle-parse",
 "anstyle-query",
 "anstyle-wincon",
 "colorchoice",
 "is_terminal_polyfill",
 "utf8parse",
]

[[package]]
name = "anstyle"
version = "1.0.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bec1de6f59aedf83baf9ff929c98f2ad654b97c9510f4e70cf6f661d49fd5b1"

[[package]]
name = "anstyle-parse"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eb47de1e80c2b463c735db5b217a0ddc39d612e7ac9e2e96a5aed1f57616c1cb"
dependencies = [
 "utf8parse",
]

[[package]]
name = "anstyle-query"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6d36fc52c7f6c869915e99412912f22093507da8d9e942ceaf66fe4b7c14422a"
dependencies = [
 "windows-sys 0.52.0",
]

[[package]]
name = "anstyle-wincon"
version = "3.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5bf74e1b6e971609db8ca7a9ce79fd5768ab6ae46441c572e46cf596f59e57f8"
dependencies = [
 "anstyle",
 "windows-sys 0.52.0",
]

[[package]]
name = "async-trait"
version = "0.1.81"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e0c28dcc82d7c8ead5cb13beb15405b57b8546e93215673ff8ca0349a028107"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.76",
]

[[package]]
name = "autocfg"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0c4b4d0bd25bd0b74681c0ad21497610ce1b7c91b1022cd21c80c6fbdd9476b0"

[[package]]
name = "backtrace"
version = "0.3.73"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5cc23269a4f8976d0a4d2e7109211a419fe30e8d88d677cd60b6bc79c5732e0a"
dependencies = [
 "addr2line",
 "cc",
 "cfg-if",
 "libc",
 "miniz_oxide",
 "object 0.36.4",
 "rustc-demangle",
]

[[package]]
name = "base64"
version = "0.13.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e1b586273c5702936fe7b7d6896644d8be71e6314cfe09d3167c95f712589e8"

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b048fb63fd8b5923fc5aa7b340d8e156aec7ec02f0c78fa8a6ddc2613f6f71de"

[[package]]
name = "bitvec"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bc2832c24239b0141d5674bb9174f9d68a8b5b3f2753311927c172ca46f7e9c"
dependencies = [
 "funty",
 "radium",
 "tap",
 "wyz",
]

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array",
]

[[package]]
name = "bumpalo"
version = "3.16.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "79296716171880943b8470b5f8d03aa55eb2e645a4874bdbb28adb49162e012c"

[[package]]
name = "bytecheck"
version = "0.6.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "23cdc57ce23ac53c931e88a43d06d070a6fd142f2617be5855eb75efc9beb1c2"
dependencies = [
 "bytecheck_derive",
 "ptr_meta",
 "simdutf8",
]

[[package]]
name = "bytecheck_derive"
version = "0.6.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3db406d29fbcd95542e92559bed4d8ad92636d1ca8b3b72ede10b4bcc010e659"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "bytes"
version = "1.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8318a53db07bb3f8dca91a600466bdb3f2eaadeedfdbcf02e1accbad9271ba50"

[[package]]
name = "cc"
version = "1.1.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "57b6a275aa2903740dc87da01c62040406b8812552e97129a63ea8850a17c6e6"
dependencies = [
 "shlex",
]

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "cfg_aliases"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "613afe47fcd5fac7ccf1db93babcb082c5994d996f20b8b159f2ad1658eb5724"

[[package]]
name = "chrono"
version = "0.4.38"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a21f936df1771bf62b77f047b726c4625ff2e8aa607c01ec06e5a05bd8463401"
dependencies = [
 "android-tzdata",
 "iana-time-zone",
 "js-sys",
 "num-traits",
 "wasm-bindgen",
 "windows-targets",
]

[[package]]
name = "clap"
version = "4.5.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed6719fffa43d0d87e5fd8caeab59be1554fb028cd30edc88fc4369b17971019"
dependencies = [
 "clap_builder",
 "clap_derive",
]

[[package]]
name = "clap_builder"
version = "4.5.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "216aec2b177652e3846684cbfe25c9964d18ec45234f0f5da5157b207ed1aab6"
dependencies = [
 "anstream",
 "anstyle",
 "clap_lex",
 "strsim",
]

[[package]]
name = "clap_derive"
version = "4.5.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "501d359d5f3dcaf6ecdeee48833ae73ec6e42723a1e52419c79abf9507eec0a0"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "syn 2.0.76",
]

[[package]]
name = "clap_lex"
version = "0.7.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1462739cb27611015575c0c11df5df7601141071f07518d56fcc1be504cbec97"

[[package]]
name = "colorchoice"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3fd119d74b830634cea2a0f58bbd0d54540518a14397557951e79340abc28c0"

[[package]]
name = "config"
version = "0.13.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "23738e11972c7643e4ec947840fc463b6a571afcd3e735bdfce7d03c7a784aca"
dependencies = [
 "async-trait",
 "json5",
 "lazy_static",
 "nom",
 "pathdiff",
 "ron",
 "rust-ini",
 "serde",
 "serde_json",
 "toml",
 "yaml-rust",
]

[[package]]
name = "core-foundation"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "91e195e091a93c46f7102ec7818a2aa394e1e1771c3ab4825963fa03e45afb8f"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "core-foundation-sys"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"

[[package]]
name = "corosensei"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "80128832c58ea9cbd041d2a759ec449224487b2c1e400453d99d244eead87a8e"
dependencies = [
 "autocfg",
 "cfg-if",
 "libc",
 "scopeguard",
 "windows-sys 0.33.0",
]

[[package]]
name = "cpufeatures"
version = "0.2.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "51e852e6dc9a5bed1fae92dd2375037bf2b768725bf3be87811edee3249d09ad"
dependencies = [
 "libc",
]

[[package]]
name = "cranelift-bforest"
version = "0.82.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38faa2a16616c8e78a18d37b4726b98bfd2de192f2fdc8a39ddf568a408a0f75"
dependencies = [
 "cranelift-entity",
]

[[package]]
name = "cranelift-codegen"
version = "0.82.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26f192472a3ba23860afd07d2b0217dc628f21fcc72617aa1336d98e1671f33b"
dependencies = [
 "cranelift-bforest",
 "cranelift-codegen-meta",
 "cranelift-codegen-shared",
 "cranelift-entity",
 "gimli 0.26.2",
 "log",
 "regalloc",
 "smallvec",
 "target-lexicon",
]

[[package]]
name = "cranelift-codegen-meta"
version = "0.82.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0f32ddb89e9b89d3d9b36a5b7d7ea3261c98235a76ac95ba46826b8ec40b1a24"
dependencies = [
 "cranelift-codegen-shared",
]

[[package]]
name = "cranelift-codegen-shared"
version = "0.82.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "01fd0d9f288cc1b42d9333b7a776b17e278fc888c28e6a0f09b5573d45a150bc"

[[package]]
name = "cranelift-entity"
version = "0.82.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e3bfe172b83167604601faf9dc60453e0d0a93415b57a9c4d1a7ae6849185cf"

[[package]]
name = "cranelift-frontend"
version = "0.82.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a006e3e32d80ce0e4ba7f1f9ddf66066d052a8c884a110b91d05404d6ce26dce"
dependencies = [
 "cranelift-codegen",
 "log",
 "smallvec",
 "target-lexicon",
]

[[package]]
name = "crc32fast"
version = "1.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a97769d94ddab943e4510d138150169a2758b5ef3eb191a9ee688de3e23ef7b3"
dependencies = [
 "cfg-if",
]

[[package]]
name = "crossbeam-deque"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "613f8cc01fe9cf1a3eb3d7f488fd2fa8388403e97039e2f73692932e291a770d"
dependencies = [
 "crossbeam-epoch",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-epoch"
version = "0.9.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-utils"
version = "0.8.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22ec99545bb0ed0ea7bb9b8e1e9122ea386ff8a48c0922e43f36d45ab09e0e80"

[[package]]
name = "crypto-common"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
dependencies = [
 "generic-array",
 "typenum",
]

[[package]]
name = "ctrlc"
version = "3.4.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "90eeab0aa92f3f9b4e87f258c72b139c207d251f9cbc1080a0086b86a8870dd3"
dependencies = [
 "nix",
 "windows-sys 0.59.0",
]

[[package]]
name = "darling"
version = "0.20.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6f63b86c8a8826a49b8c21f08a2d07338eec8d900540f8630dc76284be802989"
dependencies = [
 "darling_core",
 "darling_macro",
]

[[package]]
name = "darling_core"
version = "0.20.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "95133861a8032aaea082871032f5815eb9e98cef03fa916ab4500513994df9e5"
dependencies = [
 "fnv",
 "ident_case",
 "proc-macro2",
 "quote",
 "syn 2.0.76",
]

[[package]]
name = "darling_macro"
version = "0.20.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d336a2a514f6ccccaa3e09b02d41d35330c07ddf03a62165fcec10bb561c7806"
dependencies = [
 "darling_core",
 "quote",
 "syn 2.0.76",
]

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer",
 "crypto-common",
]

[[package]]
name = "dlv-list"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0688c2a7f92e427f44895cd63841bff7b29f8d7a1648b9e7e07a4a365b2e1257"

[[package]]
name = "either"
version = "1.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "60b1af1c220855b6ceac025d3f6ecdd2b7c4894bfe9cd9bda4fbb4bc7c0d4cf0"

[[package]]
name = "enum-iterator"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4eeac5c5edb79e4e39fe8439ef35207780a11f69c52cbe424ce3dfad4cb78de6"
dependencies = [
 "enum-iterator-derive",
]

[[package]]
name = "enum-iterator-derive"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c134c37760b27a871ba422106eedbb8247da973a09e82558bf26d619c882b159"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "enumset"
version = "1.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d07a4b049558765cef5f0c1a273c3fc57084d768b44d2f98127aef4cceb17293"
dependencies = [
 "enumset_derive",
]

[[package]]
name = "enumset_derive"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59c3b24c345d8c314966bdc1832f6c2635bfcce8e7cf363bd115987bba2ee242"
dependencies = [
 "darling",
 "proc-macro2",
 "quote",
 "syn 2.0.76",
]

[[package]]
name = "env_logger"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4cd405aab171cb85d6735e5c8d9db038c17d3ca007a4d2c25f337935c3d90580"
dependencies = [
 "humantime",
 "is-terminal",
 "log",
 "regex",
 "termcolor",
]

[[package]]
name = "errno"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "534c5cf6194dfab3db3242765c03bbe257cf92f22b38f6bc0c58d59108a820ba"
dependencies = [
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "fallible-iterator"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4443176a9f2c162692bd3d352d745ef9413eec5782a80d8fd6f8a1ac692a07f7"

[[package]]
name = "fastrand"
version = "2.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8c02a5121d4ea3eb16a80748c74f5549a5665e4c21333c6098f283870fbdea6"

[[package]]
name = "fnv"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"

[[package]]
name = "foreign-types"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6f339eb8adc052cd2ca78910fda869aefa38d22d5cb648e6485e4d3fc06f3b1"
dependencies = [
 "foreign-types-shared",
]

[[package]]
name = "foreign-types-shared"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00b0228411908ca8685dba7fc2cdd70ec9990a6e753e89b6ac91a84c40fbaf4b"

[[package]]
name = "funty"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6d5a32815ae3f33302d95fdcb2ce17862f8c65363dcfd29360480ba1001fc9c"

[[package]]
name = "futures"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "645c6916888f6cb6350d2550b80fb63e734897a8498abe35cfb732b6487804b0"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-executor",
 "futures-io",
 "futures-sink",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-channel"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eac8f7d7865dcb88bd4373ab671c8cf4508703796caa2b1985a9ca867b3fcb78"
dependencies = [
 "futures-core",
 "futures-sink",
]

[[package]]
name = "futures-core"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dfc6580bb841c5a68e9ef15c77ccc837b40a7504914d52e47b8b0e9bbda25a1d"

[[package]]
name = "futures-executor"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a576fc72ae164fca6b9db127eaa9a9dda0d61316034f33a0a0d4eda41f02b01d"
dependencies = [
 "futures-core",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-io"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a44623e20b9681a318efdd71c299b6b222ed6f231972bfe2f224ebad6311f0c1"

[[package]]
name = "futures-macro"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87750cf4b7a4c0625b1529e4c543c2182106e4dedc60a2a6455e00d212c489ac"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.76",
]

[[package]]
name = "futures-sink"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fb8e00e87438d937621c1c6269e53f536c14d3fbd6a042bb24879e57d474fb5"

[[package]]
name = "futures-task"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38d84fa142264698cdce1a9f9172cf383a0c82de1bddcf3092901442c4097004"

[[package]]
name = "futures-util"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3d6401deb83407ab3da39eba7e33987a73c3df0c82b4bb5813ee871c19c41d48"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-io",
 "futures-macro",
 "futures-sink",
 "futures-task",
 "memchr",
 "pin-project-lite",
 "pin-utils",
 "slab",
]

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "typenum",
 "version_check",
]

[[package]]
name = "getrandom"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c4567c8db10ae91089c99af84c68c38da3ec2f087c3f82960bcdbf3656b6f4d7"
dependencies = [
 "cfg-if",
 "libc",
 "wasi",
]

[[package]]
name = "gimli"
version = "0.26.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22030e2c5a68ec659fde1e949a745124b48e6fa8b045b7ed5bd1fe4ccc5c4e5d"
dependencies = [
 "fallible-iterator",
 "indexmap",
 "stable_deref_trait",
]

[[package]]
name = "gimli"
version = "0.29.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "40ecd4077b5ae9fd2e9e169b102c6c330d0605168eb0e8bf79952b256dbefffd"

[[package]]
name = "hashbrown"
version = "0.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ab5ef0d4909ef3724cc8cce6ccc8572c5c817592e9285f5464f8e86f8bd3726e"
dependencies = [
 "ahash",
]

[[package]]
name = "hashbrown"
version = "0.12.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888"
dependencies = [
 "ahash",
]

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "hermit-abi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d231dfb89cfffdbc30e7fc41579ed6066ad03abda9e567ccafae602b97ec5024"

[[package]]
name = "hermit-abi"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fbf6a919d6cf397374f7dfeeea91d974c7c0a7221d0d0f4f20d859d329e53fcc"

[[package]]
name = "home"
version = "0.5.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3d1354bf6b7235cb4a0576c2619fd4ed18183f689b12b006a0ee7329eeff9a5"
dependencies = [
 "windows-sys 0.52.0",
]

[[package]]
name = "humantime"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a3a5bfb195931eeb336b2a7b4d761daec841b97f947d34394601737a7bba5e4"

[[package]]
name = "iana-time-zone"
version = "0.1.60"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7ffbb5a1b541ea2561f8c41c087286cc091e21e556a4f09a8f6cbf17b69b141"
dependencies = [
 "android_system_properties",
 "core-foundation-sys",
 "iana-time-zone-haiku",
 "js-sys",
 "wasm-bindgen",
 "windows-core",
]

[[package]]
name = "iana-time-zone-haiku"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
dependencies = [
 "cc",
]

[[package]]
name = "icn_api"
version = "0.1.0"

[[package]]
name = "icn_blockchain"
version = "0.1.0"
dependencies = [
 "chrono",
 "icn_consensus",
 "icn_shared",
 "icn_virtual_machine",
 "log",
 "rand",
 "serde",
 "serde_json",
 "sha2",
 "thiserror",
 "wasmer",
]

[[package]]
name = "icn_consensus"
version = "0.1.0"
dependencies = [
 "icn_shared",
 "log",
 "rand",
 "serde",
 "serde_json",
]

[[package]]
name = "icn_core"
version = "0.1.0"
dependencies = [
 "clap",
 "config",
 "ctrlc",
 "env_logger",
 "icn_blockchain",
 "icn_consensus",
 "icn_governance",
 "icn_identity",
 "icn_networking",
 "icn_shared",
 "log",
 "native-tls",
 "rand",
 "serde",
 "serde_json",
 "tempfile",
 "thiserror",
 "tokio",
 "toml",
]

[[package]]
name = "icn_governance"
version = "0.1.0"

[[package]]
name = "icn_identity"
version = "0.1.0"
dependencies = [
 "icn_blockchain",
 "icn_governance",
 "icn_shared",
 "icn_smart_contracts",
 "serde",
 "tokio",
]

[[package]]
name = "icn_networking"
version = "0.1.0"
dependencies = [
 "futures",
 "icn_shared",
 "log",
 "native-tls",
 "serde",
 "serde_json",
 "tempfile",
 "thiserror",
 "tokio",
 "tokio-native-tls",
]

[[package]]
name = "icn_shared"
version = "0.1.0"
dependencies = [
 "log",
 "native-tls",
 "serde",
 "serde_json",
 "sha2",
]

[[package]]
name = "icn_smart_contracts"
version = "0.1.0"
dependencies = [
 "icn_shared",
 "icn_virtual_machine",
 "thiserror",
]

[[package]]
name = "icn_storage"
version = "0.1.0"
dependencies = [
 "icn_blockchain",
 "icn_shared",
 "serde",
 "serde_json",
 "sha2",
]

[[package]]
name = "icn_virtual_machine"
version = "0.1.0"

[[package]]
name = "ident_case"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9e0384b61958566e926dc50660321d12159025e767c18e043daf26b70104c39"

[[package]]
name = "indexmap"
version = "1.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bd070e393353796e801d209ad339e89596eb4c8d430d18ede6a1cced8fafbd99"
dependencies = [
 "autocfg",
 "hashbrown 0.12.3",
 "serde",
]

[[package]]
name = "is-terminal"
version = "0.4.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "261f68e344040fbd0edea105bef17c66edf46f984ddb1115b775ce31be948f4b"
dependencies = [
 "hermit-abi 0.4.0",
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "is_terminal_polyfill"
version = "1.70.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7943c866cc5cd64cbc25b2e01621d07fa8eb2a1a23160ee81ce38704e97b8ecf"

[[package]]
name = "itoa"
version = "1.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49f1f14873335454500d59611f1cf4a4b0f786f9ac11f4312a78e4cf2566695b"

[[package]]
name = "js-sys"
version = "0.3.70"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1868808506b929d7b0cfa8f75951347aa71bb21144b7791bae35d9bccfcfe37a"
dependencies = [
 "wasm-bindgen",
]

[[package]]
name = "json5"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96b0db21af676c1ce64250b5f40f3ce2cf27e4e47cb91ed91eb6fe9350b430c1"
dependencies = [
 "pest",
 "pest_derive",
 "serde",
]

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"

[[package]]
name = "leb128"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "884e2677b40cc8c339eaefcb701c32ef1fd2493d71118dc0ca4b6a736c93bd67"

[[package]]
name = "libc"
version = "0.2.158"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d8adc4bb1803a324070e64a98ae98f38934d91957a99cfb3a43dcbc01bc56439"

[[package]]
name = "libloading"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b67380fd3b2fbe7527a606e18729d21c6f3951633d0500574c4dc22d2d638b9f"
dependencies = [
 "cfg-if",
 "winapi",
]

[[package]]
name = "linked-hash-map"
version = "0.5.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0717cef1bc8b636c6e1c1bbdefc09e6322da8a9321966e8928ef80d20f7f770f"

[[package]]
name = "linux-raw-sys"
version = "0.4.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78b3ae25bc7c8c38cec158d1f2757ee79e9b3740fbc7ccf0e59e4b08d793fa89"

[[package]]
name = "lock_api"
version = "0.4.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07af8b9cdd281b7915f413fa73f29ebd5d55d0d3f0155584dade1ff18cea1b17"
dependencies = [
 "autocfg",
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7a70ba024b9dc04c27ea2f0c0548feb474ec5c54bba33a7f72f873a39d07b24"

[[package]]
name = "loupe"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b6a72dfa44fe15b5e76b94307eeb2ff995a8c5b283b55008940c02e0c5b634d"
dependencies = [
 "indexmap",
 "loupe-derive",
 "rustversion",
]

[[package]]
name = "loupe-derive"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0fbfc88337168279f2e9ae06e157cfed4efd3316e14dc96ed074d4f2e6c5952"
dependencies = [
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "mach"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b823e83b2affd8f40a9ee8c29dbc56404c1e34cd2710921f2801e2cf29527afa"
dependencies = [
 "libc",
]

[[package]]
name = "mach2"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "19b955cdeb2a02b9117f121ce63aa52d08ade45de53e48fe6a38b39c10f6f709"
dependencies = [
 "libc",
]

[[package]]
name = "memchr"
version = "2.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3"

[[package]]
name = "memmap2"
version = "0.5.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "83faa42c0a078c393f6b29d5db232d8be22776a891f8f56e5284faee4a20b327"
dependencies = [
 "libc",
]

[[package]]
name = "memoffset"
version = "0.6.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5aa361d4faea93603064a027415f07bd8e1d5c88c9fbf68bf56a285428fd79ce"
dependencies = [
 "autocfg",
]

[[package]]
name = "minimal-lexical"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"

[[package]]
name = "miniz_oxide"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b8a240ddb74feaf34a79a7add65a741f3167852fba007066dcac1ca548d89c08"
dependencies = [
 "adler",
]

[[package]]
name = "mio"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "80e04d1dcff3aae0704555fe5fee3bcfaf3d1fdf8a7e521d5b9d2b42acb52cec"
dependencies = [
 "hermit-abi 0.3.9",
 "libc",
 "wasi",
 "windows-sys 0.52.0",
]

[[package]]
name = "more-asserts"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7843ec2de400bcbc6a6328c958dc38e5359da6e93e72e37bc5246bf1ae776389"

[[package]]
name = "native-tls"
version = "0.2.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8614eb2c83d59d1c8cc974dd3f920198647674a0a035e1af1fa58707e317466"
dependencies = [
 "libc",
 "log",
 "openssl",
 "openssl-probe",
 "openssl-sys",
 "schannel",
 "security-framework",
 "security-framework-sys",
 "tempfile",
]

[[package]]
name = "nix"
version = "0.29.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "71e2746dc3a24dd78b3cfcb7be93368c6de9963d30f43a6a73998a9cf4b17b46"
dependencies = [
 "bitflags 2.6.0",
 "cfg-if",
 "cfg_aliases",
 "libc",
]

[[package]]
name = "nom"
version = "7.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
dependencies = [
 "memchr",
 "minimal-lexical",
]

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
]

[[package]]
name = "object"
version = "0.28.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e42c982f2d955fac81dd7e1d0e1426a7d702acd9c98d19ab01083a6a0328c424"
dependencies = [
 "crc32fast",
 "hashbrown 0.11.2",
 "indexmap",
 "memchr",
]

[[package]]
name = "object"
version = "0.36.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "084f1a5821ac4c651660a94a7153d27ac9d8a53736203f58b31945ded098070a"
dependencies = [
 "memchr",
]

[[package]]
name = "once_cell"
version = "1.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3fdb12b2476b595f9358c5161aa467c2438859caa136dec86c26fdd2efe17b92"

[[package]]
name = "openssl"
version = "0.10.66"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9529f4786b70a3e8c61e11179af17ab6188ad8d0ded78c5529441ed39d4bd9c1"
dependencies = [
 "bitflags 2.6.0",
 "cfg-if",
 "foreign-types",
 "libc",
 "once_cell",
 "openssl-macros",
 "openssl-sys",
]

[[package]]
name = "openssl-macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a948666b637a0f465e8564c73e89d4dde00d72d4d473cc972f390fc3dcee7d9c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.76",
]

[[package]]
name = "openssl-probe"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ff011a302c396a5197692431fc1948019154afc178baf7d8e37367442a4601cf"

[[package]]
name = "openssl-sys"
version = "0.9.103"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f9e8deee91df40a943c71b917e5874b951d32a802526c85721ce3b776c929d6"
dependencies = [
 "cc",
 "libc",
 "pkg-config",
 "vcpkg",
]

[[package]]
name = "ordered-multimap"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ccd746e37177e1711c20dd619a1620f34f5c8b569c53590a72dedd5344d8924a"
dependencies = [
 "dlv-list",
 "hashbrown 0.12.3",
]

[[package]]
name = "parking_lot"
version = "0.12.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f1bf18183cf54e8d6059647fc3063646a1801cf30896933ec2311622cc4b9a27"
dependencies = [
 "lock_api",
 "parking_lot_core",
]

[[package]]
name = "parking_lot_core"
version = "0.9.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e401f977ab385c9e4e3ab30627d6f26d00e2c73eef317493c4ec6d468726cf8"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall",
 "smallvec",
 "windows-targets",
]

[[package]]
name = "pathdiff"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8835116a5c179084a830efb3adc117ab007512b535bc1a21c991d3b32a6b44dd"

[[package]]
name = "pest"
version = "2.7.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cd53dff83f26735fdc1ca837098ccf133605d794cdae66acfc2bfac3ec809d95"
dependencies = [
 "memchr",
 "thiserror",
 "ucd-trie",
]

[[package]]
name = "pest_derive"
version = "2.7.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2a548d2beca6773b1c244554d36fcf8548a8a58e74156968211567250e48e49a"
dependencies = [
 "pest",
 "pest_generator",
]

[[package]]
name = "pest_generator"
version = "2.7.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c93a82e8d145725dcbaf44e5ea887c8a869efdcc28706df2d08c69e17077183"
dependencies = [
 "pest",
 "pest_meta",
 "proc-macro2",
 "quote",
 "syn 2.0.76",
]

[[package]]
name = "pest_meta"
version = "2.7.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a941429fea7e08bedec25e4f6785b6ffaacc6b755da98df5ef3e7dcf4a124c4f"
dependencies = [
 "once_cell",
 "pest",
 "sha2",
]

[[package]]
name = "pin-project-lite"
version = "0.2.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bda66fc9667c18cb2758a2ac84d1167245054bcf85d5d1aaa6923f45801bdd02"

[[package]]
name = "pin-utils"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"

[[package]]
name = "pkg-config"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d231b230927b5e4ad203db57bbcbee2802f6bce620b1e4a9024a07d94e2907ec"

[[package]]
name = "ppv-lite86"
version = "0.2.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77957b295656769bb8ad2b6a6b09d897d94f05c41b069aede1fcdaa675eaea04"
dependencies = [
 "zerocopy",
]

[[package]]
name = "proc-macro-error"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "da25490ff9892aab3fcf7c36f08cfb902dd3e71ca0f9f9517bea02a73a5ce38c"
dependencies = [
 "proc-macro-error-attr",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
 "version_check",
]

[[package]]
name = "proc-macro-error-attr"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1be40180e52ecc98ad80b184934baf3d0d29f979574e439af5a55274b35f869"
dependencies = [
 "proc-macro2",
 "quote",
 "version_check",
]

[[package]]
name = "proc-macro2"
version = "1.0.86"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e719e8df665df0d1c8fbfd238015744736151d4445ec0836b8e628aae103b77"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "ptr_meta"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0738ccf7ea06b608c10564b31debd4f5bc5e197fc8bfe088f68ae5ce81e7a4f1"
dependencies = [
 "ptr_meta_derive",
]

[[package]]
name = "ptr_meta_derive"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "16b845dbfca988fa33db069c0e230574d15a3088f147a87b64c7589eb662c9ac"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "quote"
version = "1.0.37"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b5b9d34b8991d19d98081b46eacdd8eb58c6f2b201139f7c5f643cc155a633af"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "radium"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc33ff2d4973d518d823d61aa239014831e521c75da58e3df4840d3f47749d09"

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "libc",
 "rand_chacha",
 "rand_core",
]

[[package]]
name = "rand_chacha"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
dependencies = [
 "ppv-lite86",
 "rand_core",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom",
]

[[package]]
name = "rayon"
version = "1.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b418a60154510ca1a002a752ca9714984e21e4241e804d32555251faf8b78ffa"
dependencies = [
 "either",
 "rayon-core",
]

[[package]]
name = "rayon-core"
version = "1.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1465873a3dfdaa8ae7cb14b4383657caab0b3e8a0aa9ae8e04b044854c8dfce2"
dependencies = [
 "crossbeam-deque",
 "crossbeam-utils",
]

[[package]]
name = "redox_syscall"
version = "0.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2a908a6e00f1fdd0dfd9c0eb08ce85126f6d8bbda50017e74bc4a4b7d4a926a4"
dependencies = [
 "bitflags 2.6.0",
]

[[package]]
name = "regalloc"
version = "0.0.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62446b1d3ebf980bdc68837700af1d77b37bc430e524bf95319c6eada2a4cc02"
dependencies = [
 "log",
 "rustc-hash",
 "smallvec",
]

[[package]]
name = "regex"
version = "1.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4219d74c6b67a3654a9fbebc4b419e22126d13d2f3c4a07ee0cb61ff79a79619"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata",
 "regex-syntax",
]

[[package]]
name = "regex-automata"
version = "0.4.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38caf58cc5ef2fed281f89292ef23f6365465ed9a41b7a7754eb4e26496c92df"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax",
]

[[package]]
name = "regex-syntax"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a66a03ae7c801facd77a29370b4faec201768915ac14a721ba36f20bc9c209b"

[[package]]
name = "region"
version = "3.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6b6ebd13bc009aef9cd476c1310d49ac354d36e240cf1bd753290f3dc7199a7"
dependencies = [
 "bitflags 1.3.2",
 "libc",
 "mach2",
 "windows-sys 0.52.0",
]

[[package]]
name = "rend"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "71fe3824f5629716b1589be05dacd749f6aa084c87e00e016714a8cdfccc997c"
dependencies = [
 "bytecheck",
]

[[package]]
name = "rkyv"
version = "0.7.45"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9008cd6385b9e161d8229e1f6549dd23c3d022f132a2ea37ac3a10ac4935779b"
dependencies = [
 "bitvec",
 "bytecheck",
 "bytes",
 "hashbrown 0.12.3",
 "ptr_meta",
 "rend",
 "rkyv_derive",
 "seahash",
 "tinyvec",
 "uuid",
]

[[package]]
name = "rkyv_derive"
version = "0.7.45"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "503d1d27590a2b0a3a4ca4c94755aa2875657196ecbf401a42eff41d7de532c0"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "ron"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "88073939a61e5b7680558e6be56b419e208420c2adb92be54921fa6b72283f1a"
dependencies = [
 "base64",
 "bitflags 1.3.2",
 "serde",
]

[[package]]
name = "rust-ini"
version = "0.18.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6d5f2436026b4f6e79dc829837d467cc7e9a55ee40e750d716713540715a2df"
dependencies = [
 "cfg-if",
 "ordered-multimap",
]

[[package]]
name = "rustc-demangle"
version = "0.1.24"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "719b953e2095829ee67db738b3bfa9fa368c94900df327b3f07fe6e794d2fe1f"

[[package]]
name = "rustc-hash"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2"

[[package]]
name = "rustix"
version = "0.38.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a85d50532239da68e9addb745ba38ff4612a242c1c7ceea689c4bc7c2f43c36f"
dependencies = [
 "bitflags 2.6.0",
 "errno",
 "libc",
 "linux-raw-sys",
 "windows-sys 0.52.0",
]

[[package]]
name = "rustversion"
version = "1.0.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "955d28af4278de8121b7ebeb796b6a45735dc01436d898801014aced2773a3d6"

[[package]]
name = "ryu"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f3cb5ba0dc43242ce17de99c180e96db90b235b8a9fdc9543c96d2209116bd9f"

[[package]]
name = "schannel"
version = "0.1.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fbc91545643bcf3a0bbb6569265615222618bdf33ce4ffbbd13c4bbd4c093534"
dependencies = [
 "windows-sys 0.52.0",
]

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "seahash"
version = "4.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1c107b6f4780854c8b126e228ea8869f4d7b71260f962fefb57b996b8959ba6b"

[[package]]
name = "security-framework"
version = "2.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "897b2245f0b511c87893af39b033e5ca9cce68824c4d7e7630b5a1d339658d02"
dependencies = [
 "bitflags 2.6.0",
 "core-foundation",
 "core-foundation-sys",
 "libc",
 "security-framework-sys",
]

[[package]]
name = "security-framework-sys"
version = "2.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75da29fe9b9b08fe9d6b22b5b4bcbc75d8db3aa31e639aa56bb62e9d46bfceaf"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "serde"
version = "1.0.209"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "99fce0ffe7310761ca6bf9faf5115afbc19688edd00171d81b1bb1b116c63e09"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_bytes"
version = "0.11.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "387cc504cb06bb40a96c8e04e951fe01854cf6bc921053c954e4a606d9675c6a"
dependencies = [
 "serde",
]

[[package]]
name = "serde_derive"
version = "1.0.209"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a5831b979fd7b5439637af1752d535ff49f4860c0f341d1baeb6faf0f4242170"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.76",
]

[[package]]
name = "serde_json"
version = "1.0.127"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8043c06d9f82bd7271361ed64f415fe5e12a77fdb52e573e7f06a516dea329ad"
dependencies = [
 "itoa",
 "memchr",
 "ryu",
 "serde",
]

[[package]]
name = "sha2"
version = "0.10.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "793db75ad2bcafc3ffa7c68b215fee268f537982cd901d132f89c6343f3a3dc8"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "signal-hook-registry"
version = "1.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a9e9e0b4211b72e7b8b6e85c807d36c212bdb33ea8587f7569562a84df5465b1"
dependencies = [
 "libc",
]

[[package]]
name = "simdutf8"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f27f6278552951f1f2b8cf9da965d10969b2efdea95a6ec47987ab46edfe263a"

[[package]]
name = "slab"
version = "0.4.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f92a496fb766b417c996b9c5e57daf2f7ad3b0bebe1ccfca4856390e3d3bb67"
dependencies = [
 "autocfg",
]

[[package]]
name = "smallvec"
version = "1.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c5e1a9a646d36c3599cd173a41282daf47c44583ad367b8e6837255952e5c67"

[[package]]
name = "socket2"
version = "0.5.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ce305eb0b4296696835b71df73eb912e0f1ffd2556a501fcede6e0c50349191c"
dependencies = [
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "stable_deref_trait"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3"

[[package]]
name = "strsim"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"

[[package]]
name = "syn"
version = "1.0.109"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "syn"
version = "2.0.76"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "578e081a14e0cefc3279b0472138c513f37b41a08d5a3cca9b6e4e8ceb6cd525"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "tap"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "55937e1799185b12863d447f42597ed69d9928686b8d88a1df17376a097d8369"

[[package]]
name = "target-lexicon"
version = "0.12.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "61c41af27dd6d1e27b1b16b489db798443478cef1f06a660c96db617ba5de3b1"

[[package]]
name = "tempfile"
version = "3.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "04cbcdd0c794ebb0d4cf35e88edd2f7d2c4c3e9a5a6dab322839b321c6a87a64"
dependencies = [
 "cfg-if",
 "fastrand",
 "once_cell",
 "rustix",
 "windows-sys 0.59.0",
]

[[package]]
name = "termcolor"
version = "1.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06794f8f6c5c898b3275aebefa6b8a1cb24cd2c6c79397ab15774837a0bc5755"
dependencies = [
 "winapi-util",
]

[[package]]
name = "thiserror"
version = "1.0.63"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0342370b38b6a11b6cc11d6a805569958d54cfa061a29969c3b5ce2ea405724"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "1.0.63"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4558b58466b9ad7ca0f102865eccc95938dca1a74a856f2b57b6629050da261"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.76",
]

[[package]]
name = "tinyvec"
version = "1.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "445e881f4f6d382d5f27c034e25eb92edd7c784ceab92a0937db7f2e9471b938"
dependencies = [
 "tinyvec_macros",
]

[[package]]
name = "tinyvec_macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"

[[package]]
name = "tokio"
version = "1.40.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e2b070231665d27ad9ec9b8df639893f46727666c6767db40317fbe920a5d998"
dependencies = [
 "backtrace",
 "bytes",
 "libc",
 "mio",
 "parking_lot",
 "pin-project-lite",
 "signal-hook-registry",
 "socket2",
 "tokio-macros",
 "windows-sys 0.52.0",
]

[[package]]
name = "tokio-macros"
version = "2.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "693d596312e88961bc67d7f1f97af8a70227d9f90c31bba5806eec004978d752"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.76",
]

[[package]]
name = "tokio-native-tls"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbae76ab933c85776efabc971569dd6119c580d8f5d448769dec1764bf796ef2"
dependencies = [
 "native-tls",
 "tokio",
]

[[package]]
name = "toml"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f4f7f0dd8d50a853a531c426359045b1998f04219d88799810762cd4ad314234"
dependencies = [
 "serde",
]

[[package]]
name = "tracing"
version = "0.1.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3523ab5a71916ccf420eebdf5521fcef02141234bbc0b8a49f2fdc4544364ef"
dependencies = [
 "log",
 "pin-project-lite",
 "tracing-attributes",
 "tracing-core",
]

[[package]]
name = "tracing-attributes"
version = "0.1.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34704c8d6ebcbc939824180af020566b01a7c01f80641264eba0999f6c2b6be7"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.76",
]

[[package]]
name = "tracing-core"
version = "0.1.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c06d3da6113f116aaee68e4d601191614c9053067f9ab7f6edbcb161237daa54"
dependencies = [
 "once_cell",
]

[[package]]
name = "typenum"
version = "1.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42ff0bf0c66b8238c6f3b578df37d0b7848e55df8577b3f74f92a69acceeb825"

[[package]]
name = "ucd-trie"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed646292ffc8188ef8ea4d1e0e0150fb15a5c2e12ad9b8fc191ae7a8a7f3c4b9"

[[package]]
name = "unicode-ident"
version = "1.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b"

[[package]]
name = "unicode-width"
version = "0.1.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0336d538f7abc86d282a4189614dfaa90810dfc2c6f6427eaf88e16311dd225d"

[[package]]
name = "utf8parse"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"

[[package]]
name = "uuid"
version = "1.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "81dfa00651efa65069b0b6b651f4aaa31ba9e3c3ce0137aaad053604ee7e0314"

[[package]]
name = "vcpkg"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "accd4ea62f7bb7a82fe23066fb0957d48ef677f6eeb8215f372f52e48bb32426"

[[package]]
name = "version_check"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"

[[package]]
name = "wasi"
version = "0.11.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"

[[package]]
name = "wasm-bindgen"
version = "0.2.93"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a82edfc16a6c469f5f44dc7b571814045d60404b55a0ee849f9bcfa2e63dd9b5"
dependencies = [
 "cfg-if",
 "once_cell",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.93"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9de396da306523044d3302746f1208fa71d7532227f15e347e2d93e4145dd77b"
dependencies = [
 "bumpalo",
 "log",
 "once_cell",
 "proc-macro2",
 "quote",
 "syn 2.0.76",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.93"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "585c4c91a46b072c92e908d99cb1dcdf95c5218eeb6f3bf1efa991ee7a68cccf"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.93"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "afc340c74d9005395cf9dd098506f7f44e38f2b4a21c6aaacf9a105ea5e1e836"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.76",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.93"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c62a0a307cb4a311d3a07867860911ca130c3494e8c2719593806c08bc5d0484"

[[package]]
name = "wasm-encoder"
version = "0.216.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "04c23aebea22c8a75833ae08ed31ccc020835b12a41999e58c31464271b94a88"
dependencies = [
 "leb128",
]

[[package]]
name = "wasmer"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ea8d8361c9d006ea3d7797de7bd6b1492ffd0f91a22430cfda6c1658ad57bedf"
dependencies = [
 "cfg-if",
 "indexmap",
 "js-sys",
 "loupe",
 "more-asserts",
 "target-lexicon",
 "thiserror",
 "wasm-bindgen",
 "wasmer-artifact",
 "wasmer-compiler",
 "wasmer-compiler-cranelift",
 "wasmer-derive",
 "wasmer-engine",
 "wasmer-engine-dylib",
 "wasmer-engine-universal",
 "wasmer-types",
 "wasmer-vm",
 "wat",
 "winapi",
]

[[package]]
name = "wasmer-artifact"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7aaf9428c29c1d8ad2ac0e45889ba8a568a835e33fd058964e5e500f2f7ce325"
dependencies = [
 "enumset",
 "loupe",
 "thiserror",
 "wasmer-compiler",
 "wasmer-types",
]

[[package]]
name = "wasmer-compiler"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e67a6cd866aed456656db2cfea96c18baabbd33f676578482b85c51e1ee19d2c"
dependencies = [
 "enumset",
 "loupe",
 "rkyv",
 "serde",
 "serde_bytes",
 "smallvec",
 "target-lexicon",
 "thiserror",
 "wasmer-types",
 "wasmparser",
]

[[package]]
name = "wasmer-compiler-cranelift"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48be2f9f6495f08649e4f8b946a2cbbe119faf5a654aa1457f9504a99d23dae0"
dependencies = [
 "cranelift-codegen",
 "cranelift-entity",
 "cranelift-frontend",
 "gimli 0.26.2",
 "loupe",
 "more-asserts",
 "rayon",
 "smallvec",
 "target-lexicon",
 "tracing",
 "wasmer-compiler",
 "wasmer-types",
]

[[package]]
name = "wasmer-derive"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00e50405cc2a2f74ff574584710a5f2c1d5c93744acce2ca0866084739284b51"
dependencies = [
 "proc-macro-error",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "wasmer-engine"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f98f010978c244db431b392aeab0661df7ea0822343334f8f2a920763548e45"
dependencies = [
 "backtrace",
 "enumset",
 "lazy_static",
 "loupe",
 "memmap2",
 "more-asserts",
 "rustc-demangle",
 "serde",
 "serde_bytes",
 "target-lexicon",
 "thiserror",
 "wasmer-artifact",
 "wasmer-compiler",
 "wasmer-types",
 "wasmer-vm",
]

[[package]]
name = "wasmer-engine-dylib"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ad0358af9c154724587731175553805648d9acb8f6657880d165e378672b7e53"
dependencies = [
 "cfg-if",
 "enum-iterator",
 "enumset",
 "leb128",
 "libloading",
 "loupe",
 "object 0.28.4",
 "rkyv",
 "serde",
 "tempfile",
 "tracing",
 "wasmer-artifact",
 "wasmer-compiler",
 "wasmer-engine",
 "wasmer-object",
 "wasmer-types",
 "wasmer-vm",
 "which",
]

[[package]]
name = "wasmer-engine-universal"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "440dc3d93c9ca47865a4f4edd037ea81bf983b5796b59b3d712d844b32dbef15"
dependencies = [
 "cfg-if",
 "enumset",
 "leb128",
 "loupe",
 "region",
 "rkyv",
 "wasmer-compiler",
 "wasmer-engine",
 "wasmer-engine-universal-artifact",
 "wasmer-types",
 "wasmer-vm",
 "winapi",
]

[[package]]
name = "wasmer-engine-universal-artifact"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68f1db3f54152657eb6e86c44b66525ff7801dad8328fe677da48dd06af9ad41"
dependencies = [
 "enum-iterator",
 "enumset",
 "loupe",
 "rkyv",
 "thiserror",
 "wasmer-artifact",
 "wasmer-compiler",
 "wasmer-types",
]

[[package]]
name = "wasmer-object"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8d831335ff3a44ecf451303f6f891175c642488036b92ceceb24ac8623a8fa8b"
dependencies = [
 "object 0.28.4",
 "thiserror",
 "wasmer-compiler",
 "wasmer-types",
]

[[package]]
name = "wasmer-types"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "39df01ea05dc0a9bab67e054c7cb01521e53b35a7bb90bd02eca564ed0b2667f"
dependencies = [
 "backtrace",
 "enum-iterator",
 "indexmap",
 "loupe",
 "more-asserts",
 "rkyv",
 "serde",
 "thiserror",
]

[[package]]
name = "wasmer-vm"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "30d965fa61f4dc4cdb35a54daaf7ecec3563fbb94154a6c35433f879466247dd"
dependencies = [
 "backtrace",
 "cc",
 "cfg-if",
 "corosensei",
 "enum-iterator",
 "indexmap",
 "lazy_static",
 "libc",
 "loupe",
 "mach",
 "memoffset",
 "more-asserts",
 "region",
 "rkyv",
 "scopeguard",
 "serde",
 "thiserror",
 "wasmer-artifact",
 "wasmer-types",
 "winapi",
]

[[package]]
name = "wasmparser"
version = "0.83.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "718ed7c55c2add6548cca3ddd6383d738cd73b892df400e96b9aa876f0141d7a"

[[package]]
name = "wast"
version = "216.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f7eb1f2eecd913fdde0dc6c3439d0f24530a98ac6db6cb3d14d92a5328554a08"
dependencies = [
 "bumpalo",
 "leb128",
 "memchr",
 "unicode-width",
 "wasm-encoder",
]

[[package]]
name = "wat"
version = "1.216.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac0409090fb5154f95fb5ba3235675fd9e579e731524d63b6a2f653e1280c82a"
dependencies = [
 "wast",
]

[[package]]
name = "which"
version = "4.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87ba24419a2078cd2b0f2ede2691b6c66d8e47836da3b6db8265ebad47afbfc7"
dependencies = [
 "either",
 "home",
 "once_cell",
 "rustix",
]

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-util"
version = "0.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cf221c93e13a30d793f7645a0e7762c55d169dbb0a49671918a2319d289b10bb"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows-core"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33ab640c8d7e35bf8ba19b884ba838ceb4fba93a4e8c65a9059d08afcfc683d9"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-sys"
version = "0.33.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "43dbb096663629518eb1dfa72d80243ca5a6aca764cae62a2df70af760a9be75"
dependencies = [
 "windows_aarch64_msvc 0.33.0",
 "windows_i686_gnu 0.33.0",
 "windows_i686_msvc 0.33.0",
 "windows_x86_64_gnu 0.33.0",
 "windows_x86_64_msvc 0.33.0",
]

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm",
 "windows_aarch64_msvc 0.52.6",
 "windows_i686_gnu 0.52.6",
 "windows_i686_gnullvm",
 "windows_i686_msvc 0.52.6",
 "windows_x86_64_gnu 0.52.6",
 "windows_x86_64_gnullvm",
 "windows_x86_64_msvc 0.52.6",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.33.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cd761fd3eb9ab8cc1ed81e56e567f02dd82c4c837e48ac3b2181b9ffc5060807"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_i686_gnu"
version = "0.33.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cab0cf703a96bab2dc0c02c0fa748491294bf9b7feb27e1f4f96340f208ada0e"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_msvc"
version = "0.33.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8cfdbe89cc9ad7ce618ba34abc34bbb6c36d99e96cae2245b7943cd75ee773d0"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_x86_64_gnu"
version = "0.33.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b4dd9b0c0e9ece7bb22e84d70d01b71c6d6248b81a3c60d11869451b4cb24784"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_msvc"
version = "0.33.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ff1e4aa646495048ec7f3ffddc411e1d829c026a2ec62b39da15c1055e406eaa"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "wyz"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05f360fc0b24296329c78fda852a1e9ae82de9cf7b27dae4b7f62f118f77b9ed"
dependencies = [
 "tap",
]

[[package]]
name = "yaml-rust"
version = "0.4.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56c1936c4cc7a1c9ab21a1ebb602eb942ba868cbd44a99cb7cdc5892335e1c85"
dependencies = [
 "linked-hash-map",
]

[[package]]
name = "zerocopy"
version = "0.7.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b9b4fd18abc82b8136838da5d50bae7bdea537c574d8dc1a34ed098d6c166f0"
dependencies = [
 "byteorder",
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.7.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa4f8080344d4671fb4e831a13ad1e68092748387dfc4f55e356242fae12ce3e"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.76",
]



=== ./icn_core/Cargo.toml ===
[package]
name = "icn_core"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tempfile = "3.2"
native-tls = "0.2"
tokio = { version = "1", features = ["full"] }
config = "0.13"
env_logger = "0.10"
log = "0.4"
icn_blockchain = { path = "../icn_blockchain" }
icn_consensus = { path = "../icn_consensus" }
icn_identity = { path = "../icn_identity" }
icn_governance = { path = "../icn_governance" }
icn_networking = { path = "../icn_networking" }
icn_shared = { path = "../icn_shared" }
toml = "0.5"
thiserror = "1.0"
rand = "0.8"
clap = { version = "4.3", features = ["derive"] }
ctrlc = "3.2"


=== ./icn_core/src/config/mod.rs ===
// File: icn_core/src/config/mod.rs

pub mod config_loader;

pub use config_loader::{Config, ConfigLoader};



=== ./icn_core/src/config/config_loader.rs ===
// File: icn_core/src/config/config_loader.rs

use std::fs;
use serde::Deserialize;
use icn_shared::{IcnError, IcnResult};
use log::{info, debug, error};

/// Represents the application configuration loaded from a TOML file.
///
/// This struct holds configuration details necessary for the server and database
/// components of the application. It is deserialized from a TOML file.
#[derive(Debug, Deserialize, Clone)]
pub struct Config {
    /// Configuration for the server, such as host, port, and TLS settings.
    pub server: ServerConfig,
    /// Configuration for the database, including connection URLs.
    pub database: DatabaseConfig,
}

/// Configuration for the server, including network and TLS settings.
///
/// This struct is used to configure the server's network-related parameters
/// and TLS (Transport Layer Security) settings for secure communication.
#[derive(Debug, Deserialize, Clone)]
pub struct ServerConfig {
    /// The host address where the server will run.
    ///
    /// This can be an IP address or a domain name. Use "0.0.0.0" to bind to all available interfaces.
    pub host: String,

    /// The port on which the server will listen for incoming connections.
    pub port: u16,

    /// Debug mode flag for enabling or disabling verbose output.
    ///
    /// When set to true, additional debug information will be logged.
    pub debug: bool,

    /// The file path to the TLS certificate.
    ///
    /// This should be the full path to the PEM-encoded certificate file.
    pub cert_file_path: String,

    /// The file path to the TLS private key.
    ///
    /// This should be the full path to the PEM-encoded private key file.
    pub key_file_path: String,

    /// The password for the TLS private key, if it is password-protected.
    ///
    /// Leave this empty if the private key is not password-protected.
    pub cert_password: String,
}

/// Configuration for the database, including connection URLs.
///
/// This struct holds the configuration required to connect to one or more databases.
#[derive(Debug, Deserialize, Clone)]
pub struct DatabaseConfig {
    /// A list of database connection URLs.
    pub urls: Vec<String>,
}

/// `ConfigLoader` handles the loading and parsing of TOML configuration files.
///
/// This struct is responsible for reading the configuration file from disk,
/// parsing its content, and providing access to the application's configuration.
#[derive(Debug, Clone)]
pub struct ConfigLoader {
    /// The application's configuration as loaded from the TOML file.
    config: Config,
}

impl ConfigLoader {
    /// Creates a new `ConfigLoader` instance by loading and parsing a TOML configuration file.
    ///
    /// # Arguments
    ///
    /// * `config_path` - The path to the TOML configuration file.
    ///
    /// # Returns
    ///
    /// * `IcnResult<Self>` - A new `ConfigLoader` instance if successful, otherwise an `IcnError`.
    ///
    /// # Errors
    ///
    /// * Returns an `IcnError::Config` if the file cannot be read or parsed.
    pub fn new(config_path: &str) -> IcnResult<Self> {
        info!("Loading configuration from file: {}", config_path);
        
        // Read the contents of the configuration file
        let config_content = fs::read_to_string(config_path)
            .map_err(|e| {
                error!("Failed to read config file '{}': {}", config_path, e);
                IcnError::Config(format!("Failed to read config file '{}': {}", config_path, e))
            })?;

        debug!("Configuration file content loaded successfully");

        // Parse the TOML content into a Config struct
        let config: Config = toml::from_str(&config_content)
            .map_err(|e| {
                error!("Failed to parse TOML from '{}': {}", config_path, e);
                IcnError::Config(format!("Failed to parse TOML from '{}': {}", config_path, e))
            })?;

        info!("Configuration loaded and parsed successfully");
        debug!("Loaded configuration: {:?}", config);

        Ok(ConfigLoader { config })
    }

    /// Returns a reference to the loaded configuration.
    ///
    /// # Returns
    ///
    /// * `&Config` - A reference to the configuration.
    ///
    /// # Example
    ///
    /// ```
    /// let config_loader = ConfigLoader::new("config.toml").unwrap();
    /// let config = config_loader.get_config();
    /// println!("Server host: {}", config.server.host);
    /// ```
    pub fn get_config(&self) -> &Config {
        &self.config
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::NamedTempFile;
    use std::io::Write;

    /// Helper function to create a temporary configuration file for testing.
    fn create_test_config() -> NamedTempFile {
        let mut file = NamedTempFile::new().unwrap();
        write!(file, r#"
            [server]
            host = "localhost"
            port = 8080
            debug = true
            cert_file_path = "/path/to/cert.pem"
            key_file_path = "/path/to/key.pem"
            cert_password = ""

            [database]
            urls = ["postgresql://user:pass@localhost/db1", "postgresql://user:pass@localhost/db2"]
        "#).unwrap();
        file
    }

    #[test]
    /// Tests the `ConfigLoader` by loading a test configuration and verifying its content.
    fn test_config_loader() {
        let test_config = create_test_config();
        let config_loader = ConfigLoader::new(test_config.path().to_str().unwrap()).unwrap();

        let config = config_loader.get_config();

        assert_eq!(config.server.host, "localhost");
        assert_eq!(config.server.port, 8080);
        assert!(config.server.debug);
        assert_eq!(config.server.cert_file_path, "/path/to/cert.pem");
        assert_eq!(config.server.key_file_path, "/path/to/key.pem");
        assert_eq!(config.server.cert_password, "");
        assert_eq!(
            config.database.urls,
            vec![
                "postgresql://user:pass@localhost/db1".to_string(),
                "postgresql://user:pass@localhost/db2".to_string()
            ]
        );
    }
}


=== ./icn_core/src/lib/mod.rs ===



=== ./icn_core/src/errors.rs ===
// File: icn_core/src/errors.rs

use std::fmt;
use std::error::Error;

/// Custom error type for the ICN project, used across core functionalities.
#[derive(Debug)]
pub enum IcnError {
    /// Configuration error, typically occurs during loading or parsing configuration files.
    Config(String),

    /// IO error, wraps standard I/O errors.
    Io(std::io::Error),

    /// TOML parsing error, occurs during the parsing of TOML configuration files.
    Toml(toml::de::Error),

    /// Blockchain error, used for errors related to blockchain operations.
    Blockchain(String),

    /// Consensus error, used for errors related to consensus algorithms and operations.
    Consensus(String),

    /// Networking error, used for errors during networking operations.
    Networking(String),

    /// Smart Contract error, used for errors related to smart contract execution or validation.
    SmartContract(String),

    /// Virtual Machine error, used for errors within the virtual machine environment.
    VirtualMachine(String),

    /// Storage error, used for errors related to data storage operations.
    Storage(String),

    /// Serialization error, used for errors related to serialization and deserialization.
    Serialization(String),

    /// Other errors, used for any miscellaneous errors that don't fit into the above categories.
    Other(String),
}

impl fmt::Display for IcnError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            IcnError::Config(msg) => write!(f, "Configuration error: {}", msg),
            IcnError::Io(err) => write!(f, "I/O error: {}", err),
            IcnError::Toml(err) => write!(f, "TOML parsing error: {}", err),
            IcnError::Blockchain(msg) => write!(f, "Blockchain error: {}", msg),
            IcnError::Consensus(msg) => write!(f, "Consensus error: {}", msg),
            IcnError::Networking(msg) => write!(f, "Networking error: {}", msg),
            IcnError::SmartContract(msg) => write!(f, "Smart Contract error: {}", msg),
            IcnError::VirtualMachine(msg) => write!(f, "Virtual Machine error: {}", msg),
            IcnError::Storage(msg) => write!(f, "Storage error: {}", msg),
            IcnError::Serialization(msg) => write!(f, "Serialization error: {}", msg),
            IcnError::Other(msg) => write!(f, "Other error: {}", msg),
        }
    }
}

impl Error for IcnError {}

// Conversion from standard IO errors to IcnError.
impl From<std::io::Error> for IcnError {
    fn from(err: std::io::Error) -> Self {
        IcnError::Io(err)
    }
}

// Conversion from TOML parsing errors to IcnError.
impl From<toml::de::Error> for IcnError {
    fn from(err: toml::de::Error) -> Self {
        IcnError::Toml(err)
    }
}

// Conversion from serde_json errors to IcnError for handling serialization errors.
impl From<serde_json::Error> for IcnError {
    fn from(err: serde_json::Error) -> Self {
        IcnError::Serialization(err.to_string())
    }
}



=== ./icn_core/src/main.rs ===
// File: icn_core/src/main.rs

use std::sync::Arc;
use std::sync::atomic::{AtomicBool, Ordering};
use log::{error, info, debug};
use clap::Parser;
use icn_core::config::ConfigLoader;
use icn_core::coordinator::ModuleCoordinator;
use icn_consensus::ProofOfCooperation;
use icn_shared::IcnError;

#[derive(Parser)]
#[command(author, version, about, long_about = None)]
struct Cli {
    /// Path to the configuration file
    #[arg(short, long, default_value = "config.toml")]
    config: String,

    /// Set the log level (error, warn, info, debug, trace)
    #[arg(short, long, default_value = "info")]
    log_level: String,
}

#[tokio::main]
async fn main() -> Result<(), IcnError> {
    let cli = Cli::parse();

    // Initialize logging
    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or(&cli.log_level)).init();

    info!("Starting ICN Core...");

    // Load the configuration
    let _config_loader = ConfigLoader::new(&cli.config).map_err(|e| {
        error!("Failed to load configuration: {}", e);
        IcnError::Config(format!("Failed to load configuration: {}", e))
    })?;

    info!("Configuration loaded successfully from: {}", cli.config);

    let _consensus = Arc::new(ProofOfCooperation::new());
    let mut coordinator = ModuleCoordinator::new();

    // Set up graceful shutdown
    let running = Arc::new(AtomicBool::new(true));
    let r = running.clone();

    ctrlc::set_handler(move || {
        info!("Received interrupt signal. Initiating graceful shutdown...");
        r.store(false, Ordering::SeqCst);
    })
    .expect("Error setting Ctrl-C handler");

    coordinator.start().map_err(|e| {
        error!("Coordinator failed to start: {}", e);
        IcnError::Other(format!("Coordinator failed to start: {}", e))
    })?;

    info!("ICN Core started successfully");

    // Main loop
    while running.load(Ordering::SeqCst) {
        // Perform periodic tasks here
        tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
        debug!("Node is running...");
    }

    info!("Shutting down ICN Core...");

    // Perform cleanup
    coordinator.stop().map_err(|e| {
        error!("Coordinator failed to stop: {}", e);
        IcnError::Other(format!("Coordinator failed to stop: {}", e))
    })?;

    info!("ICN Core shutdown complete.");

    Ok(())
}



=== ./icn_core/src/node/mod.rs ===
mod node_manager;
pub use node_manager::NodeManager;



=== ./icn_core/src/node/node_manager.rs ===
use crate::config::{ConfigLoader, config_loader}; // Ensure correct imports for ConfigLoader and config_loader
use crate::coordinator::ModuleCoordinator;
use icn_shared::IcnResult;
use config::Config;

pub struct NodeManager {
    config_loader: ConfigLoader,
    coordinator: ModuleCoordinator,
}

impl NodeManager {
    pub fn new(config_loader: ConfigLoader, coordinator: ModuleCoordinator) -> IcnResult<Self> {
        Ok(NodeManager {
            config_loader,
            coordinator,
        })
    }

    pub async fn start(&mut self) -> IcnResult<()> {
        let config = self.config_loader.get_config();  // Get the custom config
        let config_converted = self.convert_to_external_config(&config); // Convert to `config::Config` using reference
        self.coordinator.start(&config_converted).await?;
        Ok(())
    }

    fn convert_to_external_config(&self, config: &config_loader::Config) -> Config {
        let mut external_config = Config::builder();

        // Assuming that `host` and `port` are relevant fields you want to use for configuring
        external_config = external_config.set_override("server.host", config.server.host.clone()).unwrap();
        external_config = external_config.set_override("server.port", config.server.port.to_string()).unwrap();
        external_config = external_config.set_override("database.urls", config.database.urls.join(",")).unwrap();

        external_config.build().unwrap()
    }

    // Other methods...
}



=== ./icn_core/src/lib.rs ===
// File: icn_core/src/lib.rs

pub mod config;
pub mod coordinator;
pub mod errors;

pub use config::ConfigLoader;
pub use coordinator::module_coordinator::ModuleCoordinator;
pub use errors::IcnError;



=== ./icn_core/src/coordinator/module_coordinator.rs ===
// File: icn_core/src/coordinator/module_coordinator.rs

use log::{info, error, debug};
use std::sync::{Arc, Mutex};
use tokio::sync::mpsc;

/// This module defines the `ModuleCoordinator` responsible for managing
/// and coordinating the different modules of the InterCooperative Network (ICN).
/// The coordinator handles initialization, starting, and stopping of all modules.

/// Define a custom error type for the coordinator module.
#[derive(Debug, thiserror::Error)]
pub enum CoordinatorError {
    #[error("Initialization Error: {0}")]
    InitializationError(String),
    #[error("Start Error: {0}")]
    StartError(String),
    #[error("Stop Error: {0}")]
    StopError(String),
}

/// Custom result type for the coordinator module.
pub type CoordinatorResult<T> = Result<T, CoordinatorError>;

/// The `ModuleCoordinator` struct is responsible for managing and coordinating
/// the various modules that make up the ICN node. It ensures that all modules
/// are initialized, started, and stopped in the correct order.
pub struct ModuleCoordinator {
    modules: Vec<Arc<Mutex<Box<dyn Module>>>>,
    shutdown_sender: mpsc::Sender<()>,
    shutdown_receiver: mpsc::Receiver<()>,
}

impl ModuleCoordinator {
    /// Creates a new instance of `ModuleCoordinator`.
    pub fn new() -> Self {
        let (shutdown_sender, shutdown_receiver) = mpsc::channel(1);
        ModuleCoordinator {
            modules: Vec::new(),
            shutdown_sender,
            shutdown_receiver,
        }
    }

    /// Registers a new module with the coordinator.
    ///
    /// # Arguments
    ///
    /// * `module` - The module to be registered.
    ///
    /// # Returns
    ///
    /// * `CoordinatorResult<()>` - Returns `Ok(())` if the module is successfully registered, or an error otherwise.
    pub fn register_module(&mut self, module: Box<dyn Module>) -> CoordinatorResult<()> {
        debug!("Registering new module");
        self.modules.push(Arc::new(Mutex::new(module)));
        Ok(())
    }

    /// Initializes all registered modules.
    ///
    /// # Returns
    ///
    /// * `CoordinatorResult<()>` - Returns `Ok(())` if all modules are successfully initialized, or an error otherwise.
    pub fn initialize(&mut self) -> CoordinatorResult<()> {
        info!("Initializing all modules...");
        for (index, module) in self.modules.iter().enumerate() {
            debug!("Initializing module {}", index);
            module.lock()
                .map_err(|e| CoordinatorError::InitializationError(format!("Failed to acquire lock for module {}: {}", index, e)))?
                .initialize()
                .map_err(|e| CoordinatorError::InitializationError(format!("Failed to initialize module {}: {}", index, e)))?;
        }
        info!("All modules initialized successfully");
        Ok(())
    }

    /// Starts all registered modules.
    ///
    /// # Returns
    ///
    /// * `CoordinatorResult<()>` - Returns `Ok(())` if all modules are successfully started, or an error otherwise.
    pub fn start(&mut self) -> CoordinatorResult<()> {
        info!("Starting all modules...");
        for (index, module) in self.modules.iter().enumerate() {
            debug!("Starting module {}", index);
            module.lock()
                .map_err(|e| CoordinatorError::StartError(format!("Failed to acquire lock for module {}: {}", index, e)))?
                .start()
                .map_err(|e| CoordinatorError::StartError(format!("Failed to start module {}: {}", index, e)))?;
        }
        info!("All modules started successfully");
        Ok(())
    }

    /// Stops all registered modules.
    ///
    /// # Returns
    ///
    /// * `CoordinatorResult<()>` - Returns `Ok(())` if all modules are successfully stopped, or an error otherwise.
    pub fn stop(&mut self) -> CoordinatorResult<()> {
        info!("Stopping all modules...");
        for (index, module) in self.modules.iter().enumerate().rev() {
            debug!("Stopping module {}", index);
            module.lock()
                .map_err(|e| CoordinatorError::StopError(format!("Failed to acquire lock for module {}: {}", index, e)))?
                .stop()
                .map_err(|e| CoordinatorError::StopError(format!("Failed to stop module {}: {}", index, e)))?;
        }
        info!("All modules stopped successfully");
        Ok(())
    }

    /// Returns a clone of the shutdown sender.
    pub fn get_shutdown_sender(&self) -> mpsc::Sender<()> {
        self.shutdown_sender.clone()
    }

    /// Waits for a shutdown signal.
    pub async fn wait_for_shutdown(&mut self) {
        if self.shutdown_receiver.recv().await.is_some() {
            info!("Received shutdown signal");
        }
    }
}

/// The `Module` trait defines the interface for modules that can be managed by the `ModuleCoordinator`.
/// Each module must implement methods for initialization, starting, and stopping.
pub trait Module: Send + Sync {
    /// Initializes the module.
    ///
    /// # Returns
    ///
    /// * `CoordinatorResult<()>` - Returns `Ok(())` if the module is successfully initialized, or an error otherwise.
    fn initialize(&mut self) -> CoordinatorResult<()>;

    /// Starts the module.
    ///
    /// # Returns
    ///
    /// * `CoordinatorResult<()>` - Returns `Ok(())` if the module is successfully started, or an error otherwise.
    fn start(&mut self) -> CoordinatorResult<()>;

    /// Stops the module.
    ///
    /// # Returns
    ///
    /// * `CoordinatorResult<()>` - Returns `Ok(())` if the module is successfully stopped, or an error otherwise.
    fn stop(&mut self) -> CoordinatorResult<()>;
}

#[cfg(test)]
mod tests {
    use super::*;

    struct TestModule {
        initialized: bool,
        started: bool,
    }

    impl Module for TestModule {
        fn initialize(&mut self) -> CoordinatorResult<()> {
            self.initialized = true;
            Ok(())
        }

        fn start(&mut self) -> CoordinatorResult<()> {
            if !self.initialized {
                return Err(CoordinatorError::InitializationError(
                    "Module not initialized".to_string(),
                ));
            }
            self.started = true;
            Ok(())
        }

        fn stop(&mut self) -> CoordinatorResult<()> {
            self.started = false;
            Ok(())
        }
    }

    #[tokio::test]
    async fn test_module_coordinator() {
        let mut coordinator = ModuleCoordinator::new();
        let module = Box::new(TestModule {
            initialized: false,
            started: false,
        });

        assert!(coordinator.register_module(module).is_ok());
        assert!(coordinator.initialize().is_ok());
        assert!(coordinator.start().is_ok());
        assert!(coordinator.stop().is_ok());

        // Test shutdown signal
        let shutdown_sender = coordinator.get_shutdown_sender();
        tokio::spawn(async move {
            tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
            shutdown_sender.send(()).await.unwrap();
        });
        coordinator.wait_for_shutdown().await;
    }
}



=== ./icn_core/src/coordinator/mod.rs ===
// File: icn_core/src/coordinator/mod.rs

//! This is the module entry point for the coordinator module.
//! It re-exports the `ModuleCoordinator`, `CoordinatorError`, and `CoordinatorResult`.

pub mod module_coordinator;

pub use self::module_coordinator::{ModuleCoordinator, CoordinatorError, CoordinatorResult};



=== ./icn_storage/Cargo.toml ===
[package]
name = "icn_storage"
version = "0.1.0"
edition = "2018"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
icn_blockchain = { path = "../icn_blockchain" }
icn_shared = { path = "../icn_shared" }
sha2 = "0.10"


=== ./icn_storage/src/lib/mod.rs ===



=== ./icn_storage/src/block_storage.rs ===
// File: icn_storage/src/block_storage.rs

use std::collections::HashMap;
use icn_shared::{Block, IcnError, IcnResult};
use sha2::{Sha256, Digest};
use serde_json;

/// `BlockStorage` manages the storage of blockchain blocks.
///
/// This struct provides methods for adding, retrieving, and verifying the
/// integrity of blocks in the blockchain. It uses an in-memory HashMap for
/// storage, making it efficient for quick access but not persistent across
/// program restarts.
pub struct BlockStorage {
    /// Stores blocks with their hash as the key
    storage: HashMap<String, Block>,
    /// Stores integrity checksums for each block
    integrity_checks: HashMap<String, String>,
}

impl BlockStorage {
    /// Creates a new instance of `BlockStorage`.
    ///
    /// # Returns
    ///
    /// * `BlockStorage` - A new, empty instance of `BlockStorage`.
    pub fn new() -> Self {
        BlockStorage {
            storage: HashMap::new(),
            integrity_checks: HashMap::new(),
        }
    }

    /// Stores a block in the storage.
    ///
    /// This method calculates a checksum for the block before storing it,
    /// which can be used later to verify the block's integrity.
    ///
    /// # Arguments
    ///
    /// * `block` - The block to store.
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - Returns `Ok(())` if the block is successfully stored,
    ///   or an `IcnError` if there's an issue (e.g., duplicate block).
    pub fn store_block(&mut self, block: Block) -> IcnResult<()> {
        let block_hash = block.hash.clone();
        if self.storage.contains_key(&block_hash) {
            return Err(IcnError::Storage("Block with this hash already exists".to_string()));
        }

        let checksum = self.calculate_checksum(&block)?;
        self.storage.insert(block_hash.clone(), block);
        self.integrity_checks.insert(block_hash, checksum);
        Ok(())
    }

    /// Retrieves a block from the storage.
    ///
    /// # Arguments
    ///
    /// * `hash` - The hash of the block to retrieve.
    ///
    /// # Returns
    ///
    /// * `Option<Block>` - Returns `Some(Block)` if found, or `None` if not.
    pub fn retrieve_block(&self, hash: &str) -> Option<Block> {
        self.storage.get(hash).cloned()
    }

    /// Verifies the integrity of a block in the storage.
    ///
    /// This method recalculates the checksum for the stored block and compares
    /// it with the stored checksum to ensure the block hasn't been tampered with.
    ///
    /// # Arguments
    ///
    /// * `hash` - The hash of the block to verify.
    ///
    /// # Returns
    ///
    /// * `IcnResult<bool>` - Returns `Ok(true)` if the block's integrity is verified,
    ///   `Ok(false)` if it fails verification, or an `IcnError` if the block is not found.
    pub fn verify_integrity(&self, hash: &str) -> IcnResult<bool> {
        let block = self.retrieve_block(hash)
            .ok_or_else(|| IcnError::Storage("Block not found".to_string()))?;
        
        let stored_checksum = self.integrity_checks.get(hash)
            .ok_or_else(|| IcnError::Storage("Checksum not found".to_string()))?;
        
        let current_checksum = self.calculate_checksum(&block)?;

        Ok(stored_checksum == &current_checksum)
    }

    /// Calculates the checksum for a block.
    ///
    /// This method uses SHA-256 to create a unique checksum based on the block's contents.
    ///
    /// # Arguments
    ///
    /// * `block` - The block for which to calculate the checksum.
    ///
    /// # Returns
    ///
    /// * `IcnResult<String>` - Returns the checksum as a string, or an `IcnError` if serialization fails.
    fn calculate_checksum(&self, block: &Block) -> IcnResult<String> {
        let mut hasher = Sha256::new();
        hasher.update(&block.index.to_be_bytes());
        hasher.update(&block.timestamp.to_be_bytes());
        hasher.update(serde_json::to_string(&block.transactions)
            .map_err(|e| IcnError::Storage(format!("Failed to serialize transactions: {}", e)))?);
        hasher.update(&block.previous_hash);
        hasher.update(&block.proposer_id);
        Ok(format!("{:x}", hasher.finalize()))
    }

    /// Returns the number of blocks stored.
    ///
    /// # Returns
    ///
    /// * `usize` - The number of blocks stored.
    pub fn block_count(&self) -> usize {
        self.storage.len()
    }

    /// Checks if a block exists in the storage.
    ///
    /// # Arguments
    ///
    /// * `hash` - The hash of the block to check.
    ///
    /// # Returns
    ///
    /// * `bool` - Returns `true` if the block exists, `false` otherwise.
    pub fn block_exists(&self, hash: &str) -> bool {
        self.storage.contains_key(hash)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_store_and_retrieve_block() {
        let mut storage = BlockStorage::new();
        let block = Block::new(0, vec![], "genesis".to_string(), "proposer".to_string());
        let block_hash = block.hash.clone();

        assert!(storage.store_block(block.clone()).is_ok());
        let retrieved_block = storage.retrieve_block(&block_hash);
        assert!(retrieved_block.is_some());
        assert_eq!(retrieved_block.unwrap(), block);
    }

    #[test]
    fn test_block_integrity() {
        let mut storage = BlockStorage::new();
        let block = Block::new(0, vec![], "genesis".to_string(), "proposer".to_string());
        let block_hash = block.hash.clone();

        assert!(storage.store_block(block).is_ok());
        assert!(storage.verify_integrity(&block_hash).unwrap());
    }

    #[test]
    fn test_block_count_and_exists() {
        let mut storage = BlockStorage::new();
        let block1 = Block::new(0, vec![], "genesis".to_string(), "proposer".to_string());
        let block2 = Block::new(1, vec![], block1.hash.clone(), "proposer".to_string());

        assert!(storage.store_block(block1.clone()).is_ok());
        assert!(storage.store_block(block2.clone()).is_ok());

        assert_eq!(storage.block_count(), 2);
        assert!(storage.block_exists(&block1.hash));
        assert!(storage.block_exists(&block2.hash));
        assert!(!storage.block_exists("nonexistent_hash"));
    }
}


=== ./icn_storage/src/state_storage.rs ===
// file: icn_storage/src/state_storage.rs

use std::collections::HashMap;
use icn_shared::IcnResult;

/// The `StateStorage` struct is responsible for managing the state of the blockchain.
/// It uses an in-memory `HashMap` to store key-value pairs representing the state.
pub struct StateStorage {
    storage: HashMap<String, String>,
}

impl StateStorage {
    /// Creates a new `StateStorage` instance.
    pub fn new() -> Self {
        StateStorage {
            storage: HashMap::new(),
        }
    }

    /// Updates the state storage with a new key-value pair.
    ///
    /// # Arguments
    ///
    /// * `key` - A string slice that holds the key.
    /// * `value` - A string slice that holds the value.
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - Returns `Ok(())` if the state is successfully updated.
    pub fn update_state(&mut self, key: &str, value: &str) -> IcnResult<()> {
        self.storage.insert(key.to_string(), value.to_string());
        Ok(())
    }

    /// Retrieves a value from the state storage by its key.
    ///
    /// # Arguments
    ///
    /// * `key` - A string slice that holds the key.
    ///
    /// # Returns
    ///
    /// * `Option<String>` - Returns an `Option` containing the value associated with the key,
    ///   or `None` if the key does not exist.
    pub fn get_state(&self, key: &str) -> Option<String> {
        self.storage.get(key).cloned()
    }

    /// Removes a key-value pair from the state storage.
    ///
    /// # Arguments
    ///
    /// * `key` - A string slice that holds the key to be removed.
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - Returns `Ok(())` if the key-value pair is successfully removed or didn't exist.
    pub fn remove_state(&mut self, key: &str) -> IcnResult<()> {
        self.storage.remove(key);
        Ok(())
    }

    /// Checks if a key exists in the state storage.
    ///
    /// # Arguments
    ///
    /// * `key` - A string slice that holds the key to check.
    ///
    /// # Returns
    ///
    /// * `bool` - Returns `true` if the key exists, `false` otherwise.
    pub fn has_state(&self, key: &str) -> bool {
        self.storage.contains_key(key)
    }

    /// Returns the number of key-value pairs in the state storage.
    ///
    /// # Returns
    ///
    /// * `usize` - The number of key-value pairs in the storage.
    pub fn state_count(&self) -> usize {
        self.storage.len()
    }

    /// Clears all key-value pairs from the state storage.
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - Returns `Ok(())` if the storage is successfully cleared.
    pub fn clear_state(&mut self) -> IcnResult<()> {
        self.storage.clear();
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_update_and_get_state() {
        let mut storage = StateStorage::new();
        assert!(storage.update_state("key1", "value1").is_ok());
        assert_eq!(storage.get_state("key1"), Some("value1".to_string()));
    }

    #[test]
    fn test_remove_state() {
        let mut storage = StateStorage::new();
        storage.update_state("key1", "value1").unwrap();
        assert!(storage.remove_state("key1").is_ok());
        assert_eq!(storage.get_state("key1"), None);
    }

    #[test]
    fn test_has_state_and_state_count() {
        let mut storage = StateStorage::new();
        storage.update_state("key1", "value1").unwrap();
        storage.update_state("key2", "value2").unwrap();
        assert!(storage.has_state("key1"));
        assert!(!storage.has_state("key3"));
        assert_eq!(storage.state_count(), 2);
    }

    #[test]
    fn test_clear_state() {
        let mut storage = StateStorage::new();
        storage.update_state("key1", "value1").unwrap();
        storage.update_state("key2", "value2").unwrap();
        assert!(storage.clear_state().is_ok());
        assert_eq!(storage.state_count(), 0);
    }
}


=== ./icn_storage/src/lib.rs ===
// File: icn_storage/src/lib.rs

//! This module defines the storage components for the InterCooperative Network (ICN).
//! 
//! It provides a centralized interface for managing both block and state storage,
//! offering thread-safe access to these storage components through the use of
//! `Arc` and `RwLock`. The `Storage` struct serves as the main entry point for
//! all storage-related operations in the ICN node.

use std::sync::{Arc, RwLock};
use icn_shared::{Block, IcnResult, IcnError};

pub mod block_storage;
pub mod state_storage;

use block_storage::BlockStorage;
use state_storage::StateStorage;

/// `Storage` is the central structure that manages block and state storage for the ICN node.
/// 
/// This struct provides methods for adding blocks, retrieving states, and verifying data integrity.
/// It uses `Arc` and `RwLock` to ensure thread-safe access to the underlying storage components.
pub struct Storage {
    /// Thread-safe access to block storage
    block_storage: Arc<RwLock<BlockStorage>>,
    /// Thread-safe access to state storage
    state_storage: Arc<RwLock<StateStorage>>,
}

impl Storage {
    /// Creates a new instance of `Storage`.
    ///
    /// This method initializes both block and state storage components.
    ///
    /// # Returns
    ///
    /// * `Storage` - A new instance of `Storage`.
    pub fn new() -> Self {
        Storage {
            block_storage: Arc::new(RwLock::new(BlockStorage::new())),
            state_storage: Arc::new(RwLock::new(StateStorage::new())),
        }
    }

    /// Adds a block to the block storage.
    ///
    /// This method acquires a write lock on the block storage before adding the block.
    ///
    /// # Arguments
    ///
    /// * `block` - The block to add.
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - Returns `Ok(())` if the block is successfully added, or an `IcnError` otherwise.
    pub fn add_block(&self, block: Block) -> IcnResult<()> {
        let mut storage = self.block_storage.write()
            .map_err(|_| IcnError::Storage("Failed to acquire write lock for block storage".to_string()))?;
        storage.store_block(block)
    }

    /// Retrieves a block from the block storage.
    ///
    /// This method acquires a read lock on the block storage before retrieving the block.
    ///
    /// # Arguments
    ///
    /// * `hash` - The hash of the block to retrieve.
    ///
    /// # Returns
    ///
    /// * `IcnResult<Option<Block>>` - Returns the block if found, or `None` if not found, or an `IcnError` if lock acquisition fails.
    pub fn get_block(&self, hash: &str) -> IcnResult<Option<Block>> {
        let storage = self.block_storage.read()
            .map_err(|_| IcnError::Storage("Failed to acquire read lock for block storage".to_string()))?;
        Ok(storage.retrieve_block(hash))
    }

    /// Updates a state in the state storage.
    ///
    /// This method acquires a write lock on the state storage before updating the state.
    ///
    /// # Arguments
    ///
    /// * `key` - The key of the state to update.
    /// * `value` - The value to set for the key.
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - Returns `Ok(())` if the state is successfully updated, or an `IcnError` otherwise.
    pub fn update_state(&self, key: &str, value: &str) -> IcnResult<()> {
        let mut storage = self.state_storage.write()
            .map_err(|_| IcnError::Storage("Failed to acquire write lock for state storage".to_string()))?;
        storage.update_state(key, value)
    }

    /// Retrieves a state from the state storage.
    ///
    /// This method acquires a read lock on the state storage before retrieving the state.
    ///
    /// # Arguments
    ///
    /// * `key` - The key of the state to retrieve.
    ///
    /// # Returns
    ///
    /// * `IcnResult<Option<String>>` - Returns the state value if found, or `None` if not found, or an `IcnError` if lock acquisition fails.
    pub fn get_state(&self, key: &str) -> IcnResult<Option<String>> {
        let storage = self.state_storage.read()
            .map_err(|_| IcnError::Storage("Failed to acquire read lock for state storage".to_string()))?;
        Ok(storage.get_state(key))
    }

    /// Verifies the integrity of a block in the block storage.
    ///
    /// This method acquires a read lock on the block storage before verifying the block's integrity.
    ///
    /// # Arguments
    ///
    /// * `hash` - The hash of the block to verify.
    ///
    /// # Returns
    ///
    /// * `IcnResult<bool>` - Returns `Ok(true)` if the block's integrity is verified, `Ok(false)` if it fails verification, or an `IcnError` if lock acquisition fails or the block is not found.
    pub fn verify_block_integrity(&self, hash: &str) -> IcnResult<bool> {
        let storage = self.block_storage.read()
            .map_err(|_| IcnError::Storage("Failed to acquire read lock for block storage".to_string()))?;
        storage.verify_integrity(hash)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add_and_retrieve_block() {
        let storage = Storage::new();
        let block = Block::new(0, vec![], "genesis".to_string(), "proposer".to_string());
        let block_hash = block.hash.clone();

        assert!(storage.add_block(block.clone()).is_ok());
        let retrieved_block = storage.get_block(&block_hash).unwrap();
        assert!(retrieved_block.is_some());
        assert_eq!(retrieved_block.unwrap(), block);
    }

    #[test]
    fn test_update_and_retrieve_state() {
        let storage = Storage::new();
        assert!(storage.update_state("key1", "value1").is_ok());
        let retrieved_value = storage.get_state("key1").unwrap();
        assert_eq!(retrieved_value, Some("value1".to_string()));
    }

    #[test]
    fn test_verify_block_integrity() {
        let storage = Storage::new();
        let block = Block::new(0, vec![], "genesis".to_string(), "proposer".to_string());
        let block_hash = block.hash.clone();

        assert!(storage.add_block(block).is_ok());
        assert!(storage.verify_block_integrity(&block_hash).unwrap());
    }
}


=== ./config.toml ===
# Server configuration
[server]
# The host address where the server will run
host = "127.0.0.1"
# The port on which the server will listen
port = 8080
# Enable debug mode for verbose output
debug = true
# Path to the TLS certificate file
cert_file_path = "/opt/InterCooperative-Network-Node/cert.pem"
# Path to the TLS private key file
key_file_path = "/opt/InterCooperative-Network-Node/key.pem"
# Password for the TLS private key (leave empty if not password-protected)
cert_password = ""

# Database configuration
[database]
# List of database connection URLs
urls = ["postgresql://user:password@localhost/db1", "postgresql://user:password@localhost/db2"]


=== ./icn_identity/Cargo.toml ===
[package]
name = "icn_identity"
version = "0.1.0"
edition = "2021"

[dependencies]
# Shared types and utilities used across the ICN project
icn_shared = { path = "../icn_shared" }

# Blockchain-related functionalities like DID registration and transactions
icn_blockchain = { path = "../icn_blockchain" }

# Governance module for reputation and voting systems
icn_governance = { path = "../icn_governance" }

# Smart contract engine for executing contracts related to identity and access control
icn_smart_contracts = { path = "../icn_smart_contracts" }


# Serialization and deserialization support
serde = { version = "1.0", features = ["derive"] }

# Synchronization primitives like Arc and RwLock
tokio = { version = "1", features = ["full"] }



=== ./icn_identity/src/lib/mod.rs ===



=== ./icn_identity/src/lib.rs ===
// icn_identity/src/lib.rs

/// The Identity module manages node identity within the ICN.
/// It holds basic identity information like node ID and name.
pub struct Identity {
    /// The unique identifier for the node.
    pub id: String,
    /// The name associated with the node.
    pub name: String,
}

impl Identity {
    /// Creates a new instance of Identity.
    pub fn new(id: &str, name: &str) -> Self {
        Identity {
            id: id.to_string(),
            name: name.to_string(),
        }
    }

    /// Initializes the identity module.
    ///
    /// # Returns
    /// * `IcnResult<()>` - An empty result indicating success or failure.
    pub fn initialize(&self) -> Result<(), String> {
        // Initialization logic here (if any)
        Ok(())
    }
}



=== ./update_project.sh ===
#!/bin/bash

# Generate the latest project state before committing
./generate_project_state.sh

# Check if the project state was generated successfully
if [[ $? -ne 0 ]]; then
    echo "Error: Failed to generate project state."
    exit 1
fi

# Prompt the user to enter a commit message
echo "Enter the commit message (end input with a single period on a new line):"

# Read the commit message, allowing for multi-line input until a period on its own line
COMMIT_MSG=""
while IFS= read -r line; do
    if [[ "$line" == "." ]]; then
        break
    fi
    COMMIT_MSG+="$line"$'\n'
done

# Ensure the commit message is not empty
if [[ -z "$COMMIT_MSG" ]]; then
    echo "Error: Commit message cannot be empty!"
    exit 1
fi

# Stage all changes for commit
git add .

# Commit the changes with the provided message
git commit -m "$COMMIT_MSG"

# Check if the commit was successful
if [[ $? -ne 0 ]]; then
    echo "Error: Commit failed."
    exit 1
fi

# Push the changes to the remote repository
git push origin main

# Check if the push was successful
if [[ $? -ne 0 ]]; then
    echo "Error: Push failed."
    exit 1
fi

echo "Changes have been successfully committed and pushed."



=== ./.gitignore ===
/target
**/*.rs.bk
Cargo.lock



=== ./icn_smart_contracts/Cargo.toml ===
[package]
name = "icn_smart_contracts"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_shared = { path = "../icn_shared" }
icn_virtual_machine = { path = "../icn_virtual_machine" }
thiserror = "1.0"





=== ./icn_smart_contracts/src/compiler.rs ===
// File: icn_smart_contracts/src/compiler.rs

use crate::bytecode::Opcode; // Assuming you have defined Opcode in your bytecode module

pub struct Compiler {
    // ... (you'll likely need some internal state here, e.g., for symbol tables, etc.)
}

impl Compiler {
    pub fn new() -> Self {
        Compiler {
            // ... initialize internal state
        }
    }

    pub fn compile(&self, source_code: &str) -> Result<Vec<u8>, String> {
        // 1. Lexical Analysis (Tokenization)
        let tokens = self.tokenize(source_code)?;

        // 2. Parsing (Syntax Analysis)
        let ast = self.parse(tokens)?;

        // 3. Code Generation (Bytecode Emission)
        let bytecode = self.generate_bytecode(ast)?;

        Ok(bytecode)
    }

    fn tokenize(&self, source_code: &str) -> Result<Vec<Token>, String> {
        // ... implement tokenization logic here
        // This will involve breaking down the source code into a sequence of tokens
        todo!() // Placeholder for now
    }

    fn parse(&self, tokens: Vec<Token>) -> Result<ASTNode, String> {
        // ... implement parsing logic here
        // This will involve constructing an Abstract Syntax Tree (AST) from the tokens
        todo!() // Placeholder for now
    }

    fn generate_bytecode(&self, ast: ASTNode) -> Result<Vec<u8>, String> {
        let mut bytecode = Vec::new();

        // Example: Simple bytecode generation for an addition operation
        // You'll need to expand this to handle the full AST and generate appropriate bytecode
        match ast {
            ASTNode::Add(left, right) => {
                bytecode.extend(self.generate_bytecode(*left)?);
                bytecode.extend(self.generate_bytecode(*right)?);
                bytecode.push(Opcode::Add as u8); 
            }
            // ... other AST node cases
        }

        Ok(bytecode)
    }
}

// Define your Token and ASTNode structures here based on your language design
// Example:
enum Token {
    // ... your token types
}

enum ASTNode {
    // ... your AST node types
    Add(Box<ASTNode>, Box<ASTNode>), 
    // ...
}


=== ./icn_smart_contracts/src/lib/mod.rs ===



=== ./icn_smart_contracts/src/smart_contract.rs ===
// File: icn_smart_contracts/src/smart_contract.rs

/// The SmartContract module defines the structure and deployment mechanisms for smart contracts.
/// It integrates with the ICN Virtual Machine to enable contract execution on the network.

use icn_virtual_machine::execution_engine::{ExecutionEngine, ExecutionContext, ExecutionResult};

/// SmartContract struct represents a compiled smart contract ready for deployment on the ICN.
pub struct SmartContract {
    pub bytecode: Vec<u8>,
}

impl SmartContract {
    /// Creates a new instance of SmartContract with the provided bytecode.
    ///
    /// # Arguments
    ///
    /// * `bytecode` - A vector of u8 representing the compiled bytecode of the smart contract.
    pub fn new(bytecode: Vec<u8>) -> Self {
        SmartContract { bytecode }
    }

    /// Deploys the smart contract on the provided execution engine.
    ///
    /// # Arguments
    ///
    /// * `vm` - A mutable reference to the ExecutionEngine instance.
    /// * `context` - The execution context for the contract deployment.
    ///
    /// # Returns
    ///
    /// * `ExecutionResult` - The result of the contract deployment.
    pub fn deploy(&self, vm: &mut ExecutionEngine, context: ExecutionContext) -> ExecutionResult {
        vm.execute_contract(self.bytecode.clone(), context)
    }
}



=== ./icn_smart_contracts/src/lib.rs ===
// File: icn_smart_contracts/src/lib.rs
// Description: This file defines the SmartContractEngine and SmartContract structures, handling operations like deployment and execution of smart contracts.

use std::collections::HashMap;
use icn_shared::{IcnError, IcnResult};
use icn_virtual_machine::{Bytecode, VirtualMachine};

/// Custom error type for smart contract-related operations
#[derive(Debug, thiserror::Error)]
pub enum SmartContractError {
    /// Error for invalid arguments provided to a smart contract function
    #[error("Invalid arguments: {0}")]
    InvalidArguments(String),

    /// Error when a contract is not found
    #[error("Contract not found: {0}")]
    ContractNotFound(u32),

    /// Error during contract compilation
    #[error("Compilation error: {0}")]
    CompilationError(String),

    /// Error during contract execution
    #[error("Execution error: {0}")]
    ExecutionError(String),

    /// Error for unsupported operations
    #[error("Unsupported operation: {0}")]
    UnsupportedOperation(String),
}

/// Result type alias for smart contract operations
pub type SmartContractResult<T> = Result<T, SmartContractError>;

/// Represents a smart contract within the ICN ecosystem
#[derive(Debug, Clone)]
pub struct SmartContract {
    /// Unique identifier for the contract
    pub id: u32,
    /// Source code of the contract
    pub code: String,
    /// Compiled bytecode of the contract (if available)
    pub bytecode: Option<Bytecode>,
}

impl SmartContract {
    /// Creates a new `SmartContract` instance
    ///
    /// # Arguments
    ///
    /// * `id` - Unique identifier for the contract
    /// * `code` - Source code of the contract
    ///
    /// # Returns
    ///
    /// A new `SmartContract` instance
    pub fn new(id: u32, code: &str) -> Self {
        SmartContract {
            id,
            code: code.to_string(),
            bytecode: None,
        }
    }

    /// Sets the compiled bytecode for the contract
    ///
    /// # Arguments
    ///
    /// * `bytecode` - Compiled bytecode of the contract
    pub fn set_bytecode(&mut self, bytecode: Bytecode) {
        self.bytecode = Some(bytecode);
    }
}

/// The core engine for managing and executing smart contracts
pub struct SmartContractEngine {
    /// Map of contract IDs to SmartContract instances
    contracts: HashMap<u32, SmartContract>,
    /// Virtual Machine instance for executing contracts
    vm: VirtualMachine,
}

impl SmartContractEngine {
    /// Creates a new instance of the `SmartContractEngine`
    ///
    /// # Returns
    ///
    /// A new `SmartContractEngine` instance
    pub fn new() -> Self {
        SmartContractEngine {
            contracts: HashMap::new(),
            vm: VirtualMachine::new(),
        }
    }

    /// Deploys a new smart contract to the network
    ///
    /// # Arguments
    ///
    /// * `code` - Source code of the contract to be deployed
    ///
    /// # Returns
    ///
    /// The ID of the newly deployed contract, or an error if deployment fails
    pub fn deploy_contract(&mut self, code: &str) -> SmartContractResult<u32> {
        // Compile the contract code
        let bytecode = self.compile_contract(code)?;

        // Create and store the smart contract
        let id = self.contracts.len() as u32 + 1;
        let mut contract = SmartContract::new(id, code);
        contract.set_bytecode(bytecode.clone());
        self.contracts.insert(id, contract);

        // Deploy bytecode to the virtual machine
        self.vm.execute(bytecode)
            .map_err(|e| SmartContractError::ExecutionError(e.to_string()))?;

        Ok(id)
    }

    /// Calls a function on an existing smart contract
    ///
    /// # Arguments
    ///
    /// * `id` - ID of the contract to call
    /// * `function` - Name of the function to call
    /// * `args` - Arguments to pass to the function
    ///
    /// # Returns
    ///
    /// The result of the function call as a string, or an error if the call fails
    pub fn call_contract(&mut self, id: u32, function: &str, args: Vec<String>) -> SmartContractResult<String> {
        // Retrieve the contract
        let contract = self.contracts.get(&id)
            .ok_or_else(|| SmartContractError::ContractNotFound(id))?;

        // Prepare the function call
        let call_data = self.encode_function_call(function, args)?;

        // Execute the function call on the VM
        let bytecode = contract.bytecode.clone()
            .ok_or_else(|| SmartContractError::ExecutionError("Contract bytecode not available".to_string()))?;
        self.vm.execute(bytecode)
            .map_err(|e| SmartContractError::ExecutionError(e.to_string()))?;

        // Retrieve and return the result from the VM
        let result = self.get_vm_result()?;
        Ok(result)
    }

    /// Compiles the contract source code into bytecode
    ///
    /// # Arguments
    ///
    /// * `code` - Source code of the contract to compile
    ///
    /// # Returns
    ///
    /// Compiled bytecode, or an error if compilation fails
    fn compile_contract(&self, code: &str) -> SmartContractResult<Bytecode> {
        // Placeholder for actual compilation logic
        // Return dummy bytecode for now
        Ok(Bytecode::new(vec![0, 1, 2, 3]))
    }

    /// Encodes a function call into bytecode
    ///
    /// # Arguments
    ///
    /// * `function` - Name of the function to call
    /// * `args` - Arguments to pass to the function
    ///
    /// # Returns
    ///
    /// Encoded function call as bytecode, or an error if encoding fails
    fn encode_function_call(&self, function: &str, args: Vec<String>) -> SmartContractResult<Vec<u8>> {
        // Placeholder for actual function call encoding
        // Return dummy encoding for now
        Ok(vec![0, 1, 2, 3])
    }

    /// Retrieves the result of a VM execution
    ///
    /// # Returns
    ///
    /// The result of the VM execution as a string, or an error if retrieval fails
    fn get_vm_result(&self) -> SmartContractResult<String> {
        // Placeholder for actual result retrieval from the VM
        // Return dummy result for now
        Ok("Function executed successfully".to_string())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_deploy_contract() {
        let mut engine = SmartContractEngine::new();
        let code = "contract Test { function greet() public pure returns (string memory) { return \"Hello, World!\"; } }";
        let result = engine.deploy_contract(code);
        assert!(result.is_ok());
        let contract_id = result.unwrap();
        assert_eq!(contract_id, 1);
    }

    #[test]
    fn test_call_contract() {
        let mut engine = SmartContractEngine::new();
        let code = "contract Test { function greet() public pure returns (string memory) { return \"Hello, World!\"; } }";
        let contract_id = engine.deploy_contract(code).unwrap();
        let result = engine.call_contract(contract_id, "greet", vec![]);
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "Function executed successfully");
    }

    #[test]
    fn test_contract_not_found() {
        let mut engine = SmartContractEngine::new();
        let result = engine.call_contract(1, "greet", vec![]);
        assert!(matches!(result, Err(SmartContractError::ContractNotFound(1))));
    }
}



=== ./icn_smart_contracts/src/standard_library.rs ===
// File: icn_smart_contracts/src/standard_library.rs

// Define standard library functions here that can be used in smart contracts

// Example: A simple function to calculate the square of a number
pub fn square(x: u64) -> u64 {
    x * x
}

// ... other standard library functions


=== ./key.pem ===
-----BEGIN PRIVATE KEY-----
MIIJQQIBADANBgkqhkiG9w0BAQEFAASCCSswggknAgEAAoICAQCyX/kj6bH9NeS4
RZjWVQslhM2W0TctsvFZ2hw6tK3bdmTmZX+KLejd+0FGTRTcInspbIkIedCeqsgB
YoJie4/PvECG9OFN0unremCJZ0OY54VsTur2RX0JbwjS2cmKQvK7Ex7xHndWckEP
omRONEbFpUY0+S0ZQs2Qxw4LDI83TJNM1s7mzjHGXXERg7rnuA4A4zDD0wkZ73Z1
rGEFQ1cSs92KfSRYB3B0FVrXCtVaVoFxTPscGQOX7w2AG98P2sla6uao/set3NEj
2ZYOAYiF81PMNHRqR46Ecenm6Ao4L+m+f7tUqViWtzm9/uThl8ekkzAZV5orLMqK
qnlfcJlsmDNr2QquCxjPsmvXi3/1TusmP6la/hgQ/0orbVVZQXg00xbziBIuFiix
MkhPcn972mVbIQfEbcntGo/54shYcvrrAPedBOGHuOhfvp50rA9Sp7kiIsxfxum5
4QyUAJBjx2d7DV0Qgzhbo8mCUDQhHycNVJJlnZlE8TuelvXoG4N1DYxV21w2hy98
YVnkSdaYB02dCiEMlczo6mSmVJHPbt9t+/ODSRP+g7GurMTZXMcd4UeNDViuZy8S
53ym6fbkLZNcrZ6Fk41o/3EbwZkFalORB4xE3fTIacQes2ctc34b9rVYeZ5zXWwU
4wPuE5EFD5R7Hs6Iw/rp8+4CDXePXwIDAQABAoICABRfLf2XhEVL1pY4a0xYmcrM
VYya0rH3RLrt1EPc0cRa9mAdNHPsFV3mLbN2keIoVVJK+9rfdV+XAqZXLAFND696
gRDIvpicSiyjeotcI1YUZGJqdZ7wcGeCP7WREQRSQWrzM+6he6CrBi+KbOlE7YDy
L3KqXf0LakiAK2RAqB9Ohr4uWaKg5wIQNvMjTSvcvfYE/H3znWT8ZSuVpzOqLV4h
87SMNqPlHvHrDx0N4YW36SsETzjgyc5xi2RXtTdC1gn6V6NHtzdt8jwlbrlPxy9W
iySrKFE2YJpTcOghv9ULR9ICwDra58Fi0LHt1BHIZhEvjD1AtNynI29d0+R+Cs+G
zUPxdWmgaa5/khk6LC4Zvc3uwcC1SdqS0LeH+0mBz/ZJV1d833hOXf7MaoWH0tal
UcHuk0ihUGGJiL6G+nkwWzsYiTb8vfLbnpKCLesg0b35Tk/f7HCy2aRucqEMKCXv
eM7nxClOXbPZi+JarH0CZ+jy4JJ73VQELtfFqlEle4pxTwlGkXCm4zUPbyYoghD+
mTUrB9/L/mKYGjtHw2AMBeZYi9o8soEmTGN4T9yFpGGPXWUp8b2/80LEaamqC8E9
cPQLt/YCfoWdevWQHGzyDvCrtRHItoAivbf4w7k3+Bepb3n7FIelx0tbK6HRHNi9
2OMlhbX2D7xYFjTp/XvlAoIBAQDlbLXD96RIWWMpp0HHaEkdxwMGnpAlErxZML/P
cPDNIYV5u1jewuBLyMoVcRUiIQx4UuS6W+19ZooC0IljgPtsW0VhPnmOQo8+MyTq
utQ/KfPpmvKRo+BnccrLusNfM5u33Qdjcep+F4LdWJYew7bmFKoy1R7H0YuxH455
s5pGHg/6QKoaN+dIDyGu/ZfWFwLUf0BYu7LUmU5e85jtIc1B7FWXtRp2juWp6ftC
zSxdnOPX277aqKqoAeI4rU4TJOusWM5Ttth3W7GrREb9Eh4OV3+sKGg/1M5FxWTS
XgDH+EDltHRX6PtB3QoumY1VjjF10leP1W+S954FvanMSQzbAoIBAQDHCXL1PJ0y
UqbS4xm+gOeE1Qy9AB3fdc359afP5B4hBzBz/0fFHLZWBkZxmcX/HSqXPM1jsacX
kpAoTy3VqDsEboRHXKAsP/VXfj6yA5tcaLtbDU/lvdmYSjxGdfeYI16TeuNfTD3B
cPbmJ+pDr5MyCNmGe2s5Fn2IUN+GDuAoogKJlHfR8eqCT4P/QfiQrQ5t5TkY22Ug
NzEjgwqK6V8EG6E1iJLWog94By1cnf8t9RA7ocUz2RXPgI0jPkwb0iBSOlcC6SOc
pum292wlQfpjSnDRG1vF3Tr8aR35JcqJVSE556n5Xdzy6TwiXwvAhmiXarHZhD2N
AVJgwoDeegzNAoIBADrGzRJ1oVr/u43yUcHaj9DXKYlKmjdFQ4e+G4Xzs116Vw3G
14/KcVg5CrzPidCCkwVIh1zPLFrSKE1sS6Z4ZvFtuKqfLNkraDNROwX/81xzTQ/u
KHLzfwxBdOkY4fDD8gL612e8yYygTWCTz3H2RidP6AK54vbiUl2Abinzv3RzQzij
1HB/HfuyFLkWMw4gOxNhvoR9IeWhmRhuZCFsZX+cIpmJRkxVc7VCQqLsmY8qIJ0u
qQiv6Xi9cs1+aOAyt0YiQknkMDT0AuKTzXQMbjLSa90ZRQwFYwsw9RGID78rdMTk
pGHZSHWpQXCK2lCu6zD6QICS99C5K3zhCF1T4b0CggEAMyojqhUF19zVU5rbkFQ0
r7nQx3kTNNFkvJ/AnrlmYVkmxHrYKTyDRsPgMe20rysBOtV/euQ9LtsXQbVw896G
JVJ/oJSX/CgI2o/yb/JraqrllrdqVYWjPPnAWuCSYEKfWkwZzPKdYW+3mFykZPfq
X89Uk7SAULGOXY9klmKWjvtuqY1H6+lDPnJQXTrJOe+yqN9m+RPVAB4P/K//8suh
CD5OB6PvE0ufrFwz9f4LjfXUUW/5cKWabLgAEBJAoFo4wsqKeY4TAH8Lz2P1IfK+
+e016RseUVPYiPBAqz5ivUDsBKWf1SGi3bLFKZTDQZ+LnXjo9SCAbhHr6kG1vPsk
9QKCAQAL8PwaPMKnNY+58JL9B/uQkk4rrMnUnJqD/jgVTAQrOfdsgM5k7MqoxaZt
XCDoVbgxDc+IkTmqpRtUnl3CvnBIMV+2GVUD3agi9Cr70Mg1ZraUNYD131o/6lBf
R8U7hJesISmIPErQIGYKsTI2tfwszzSP+ZoBJUuA3XlmkG1kQKpBaCftP8wWLLv2
DvOE/0r8rI4fBicfW+GCv6rsZ7YfenNLpZDWA9XItcDcXaw3M1Ynnmxf3hQQ32gx
UInf0U7QexJAscq4oinryX97YsW1lJgr6oNKUrOEHYm7toNRPC51oqNsosbQUqbl
lOPY2ph9WIs4o1YpwEzHTl0BThZX
-----END PRIVATE KEY-----



=== ./icn_api/Cargo.toml ===
[package]
name = "icn_api"
version = "0.1.0"
edition = "2021"

[dependencies]



=== ./icn_api/src/lib/mod.rs ===



=== ./icn_api/src/lib.rs ===
pub fn add(left: u64, right: u64) -> u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}



