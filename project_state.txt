=== Project Directory Tree ===
.
├── Cargo.lock
├── Cargo.toml
├── cert.pem
├── commit_message.txt
├── config
│   ├── config.toml
│   └── default_config.toml
├── config.toml
├── generate_project_state.sh
├── .github
│   ├── FUNDING.yml
│   └── workflows
│       ├── ci.yml
│       └── static.yml
├── .gitignore
├── .gitmodules
├── icn_api
│   ├── Cargo.toml
│   └── src
│       ├── lib
│       │   └── mod.rs
│       └── lib.rs
├── icn_blockchain
│   ├── Cargo.toml
│   └── src
│       ├── chain
│       │   └── mod.rs
│       ├── lib
│       │   └── mod.rs
│       ├── lib.rs
│       └── transaction
│           ├── mod.rs
│           └── transaction_type.rs
├── icn_consensus
│   ├── Cargo.toml
│   └── src
│       ├── consensus.rs
│       ├── lib
│       │   └── mod.rs
│       ├── lib.rs
│       └── proof_of_cooperation.rs
├── icn_core
│   ├── Cargo.toml
│   └── src
│       ├── config
│       │   ├── config_loader.rs
│       │   └── mod.rs
│       ├── coordinator
│       │   ├── mod.rs
│       │   └── module_coordinator.rs
│       ├── errors.rs
│       ├── lib
│       │   └── mod.rs
│       ├── lib.rs
│       ├── main.rs
│       └── node
│           ├── mod.rs
│           └── node_manager.rs
├── icn_governance
│   ├── Cargo.toml
│   └── src
│       ├── lib
│       │   └── mod.rs
│       └── lib.rs
├── icn_identity
│   ├── Cargo.toml
│   └── src
│       ├── lib
│       │   └── mod.rs
│       └── lib.rs
├── icn_networking
│   ├── Cargo.toml
│   └── src
│       ├── lib
│       │   └── mod.rs
│       └── lib.rs
├── icn_shared
│   ├── Cargo.toml
│   └── src
│       ├── block.rs
│       ├── consensus.rs
│       ├── error.rs
│       └── lib.rs
├── icn_smart_contracts
│   ├── Cargo.toml
│   └── src
│       ├── lib
│       │   └── mod.rs
│       └── lib.rs
├── icn_storage
│   ├── Cargo.toml
│   └── src
│       ├── block_storage.rs
│       ├── lib
│       │   └── mod.rs
│       ├── lib.rs
│       └── state_storage.rs
├── icn_virtual_machine
│   ├── Cargo.toml
│   └── src
│       ├── bytecode.rs
│       ├── execution_engine.rs
│       ├── lib
│       │   └── mod.rs
│       └── lib.rs
├── key.pem
├── project_parts
│   └── core_files_00
├── project_state.txt
├── README.md
├── update_project.sh
└── .vscode
    └── settings.json

43 directories, 71 files



=== ./generate_project_state.sh ===
#!/bin/bash

# Define the output file
output_file="project_state.txt"

# Clear the output file if it exists
> $output_file

# Function to write file contents to the output file
write_file_content() {
    local file_path="$1"
    echo "=== $file_path ===" >> $output_file
    cat "$file_path" >> $output_file
    echo -e "\n\n" >> $output_file
}

# Write the tree structure of the project to the output file
echo "=== Project Directory Tree ===" >> $output_file
tree -a -I 'target|.git|node_modules' >> $output_file
echo -e "\n\n" >> $output_file

# Recursively list all files and append their content, excluding build artifacts and temporary files
find . -type f \
    -not -path "./.git/*" \
    -not -path "./target/*" \
    -not -path "./**/node_modules/*" \
    -not -path "./**/*.o" \
    -not -path "./**/*.rs.bk" \
    -not -path "./**/*.log" \
    -not -name "*.txt" \
    -not -name "*.md" | while read file; do
    write_file_content "$file"
done

echo "Project state saved to $output_file"



=== ./icn_networking/Cargo.toml ===
[package]
name = "icn_networking"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1.0", features = ["full"] }
tokio-native-tls = "0.3"
native-tls = "0.2"
log = "0.4"
icn_shared = { path = "../icn_shared" }

[dev-dependencies]
tempfile = "3.2"


=== ./icn_networking/src/lib/mod.rs ===



=== ./icn_networking/src/lib.rs ===
use std::fs::File;
use std::io::Read;
use std::sync::{Arc, RwLock};
use tokio::net::{TcpListener, TcpStream};
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::sync::Mutex; // Using Tokio's async Mutex
use tokio_native_tls::{TlsAcceptor, TlsConnector};
use native_tls::Identity;
use icn_shared::{IcnError, IcnResult};
use log::{info, error};

/// The `Networking` struct is responsible for managing peer-to-peer network connections
/// in a secure manner using TLS (Transport Layer Security). It allows for starting a server,
/// connecting to peers, and broadcasting messages to all connected peers.
#[derive(Clone)]
pub struct Networking {
    peers: Arc<RwLock<Vec<Arc<Mutex<tokio_native_tls::TlsStream<TcpStream>>>>>>,
    identity: Option<Arc<Identity>>,
}

impl Networking {
    /// Creates a new instance of the `Networking` struct.
    ///
    /// # Returns
    /// 
    /// * `Networking` - An instance of the `Networking` struct with an empty list of peers.
    pub fn new() -> Self {
        Networking {
            peers: Arc::new(RwLock::new(vec![])),
            identity: None,
        }
    }

    /// Loads a TLS identity from a certificate and key file.
    ///
    /// # Arguments
    ///
    /// * `cert_path` - The path to the TLS certificate file.
    /// * `key_path` - The path to the TLS key file.
    /// * `password` - The password for the TLS key.
    ///
    /// # Returns
    ///
    /// * `IcnResult<Arc<Identity>>` - The loaded TLS identity wrapped in an Arc, or an error if loading fails.
    pub fn load_tls_identity(cert_path: &str, key_path: &str, _password: &str) -> IcnResult<Arc<Identity>> {
        if !std::path::Path::new(cert_path).exists() {
            return Err(IcnError::Network(format!("Certificate file not found: {}", cert_path)));
        }

        if !std::path::Path::new(key_path).exists() {
            return Err(IcnError::Network(format!("Key file not found: {}", key_path)));
        }

        let mut cert_file = File::open(cert_path)
            .map_err(|e| IcnError::Network(format!("Failed to open certificate file: {}", e)))?;
        let mut cert = Vec::new();
        cert_file.read_to_end(&mut cert)
            .map_err(|e| IcnError::Network(format!("Failed to read certificate file: {}", e)))?;

        let mut key_file = File::open(key_path)
            .map_err(|e| IcnError::Network(format!("Failed to open key file: {}", e)))?;
        let mut key = Vec::new();
        key_file.read_to_end(&mut key)
            .map_err(|e| IcnError::Network(format!("Failed to read key file: {}", e)))?;

        let identity = Identity::from_pkcs8(&cert, &key)
            .map_err(|e| IcnError::Network(format!("Failed to load TLS identity: {}", e)))?;

        Ok(Arc::new(identity))
    }

    /// Starts a server that listens on the specified address using the provided TLS identity.
    ///
    /// # Arguments
    ///
    /// * `address` - The address to bind the server to.
    /// * `identity` - The TLS identity to use for secure connections.
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - An empty result indicating success or an error if starting the server fails.
    pub async fn start_server(&mut self, address: &str, identity: Arc<Identity>) -> IcnResult<()> {
        self.identity = Some(identity.clone());
        let acceptor = TlsAcceptor::from(
            native_tls::TlsAcceptor::new((*identity).clone())
                .map_err(|e| IcnError::Network(format!("Failed to create TLS acceptor: {}", e)))?
        );

        let listener = TcpListener::bind(address).await
            .map_err(|e| IcnError::Network(format!("Failed to bind to address: {}", e)))?;
        info!("Server started on {}", address);

        loop {
            match listener.accept().await {
                Ok((stream, _)) => {
                    let acceptor = acceptor.clone();
                    let peers = Arc::clone(&self.peers);

                    tokio::spawn(async move {
                        if let Err(e) = handle_client_connection(stream, acceptor, peers, None).await {
                            error!("Error handling client: {:?}", e);
                        }
                    });
                }
                Err(e) => error!("Failed to accept TCP connection: {:?}", e),
            }
        }
    }

    /// Connects to a peer at the specified address using TLS.
    ///
    /// # Arguments
    ///
    /// * `address` - The address of the peer to connect to.
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - An empty result indicating success or an error if the connection fails.
    pub async fn connect_to_peer(&self, address: &str) -> IcnResult<()> {
        let connector = TlsConnector::from(
            native_tls::TlsConnector::new()
                .map_err(|e| IcnError::Network(format!("Failed to create TLS connector: {}", e)))?
        );

        let stream = TcpStream::connect(address).await
            .map_err(|e| IcnError::Network(format!("Failed to connect to peer: {}", e)))?;

        let tls_stream = connector.connect(address, stream).await
            .map_err(|e| IcnError::Network(format!("Failed to establish TLS connection: {}", e)))?;

        let tls_stream = Arc::new(Mutex::new(tls_stream));

        {
            let mut peers_guard = self.peers.write().map_err(|_| IcnError::Network("Failed to acquire peers lock".to_string()))?;
            peers_guard.push(tls_stream.clone());
        }

        info!("Connected to peer at {}", address);
        Ok(())
    }

    /// Broadcasts a message to all connected peers.
    ///
    /// # Arguments
    ///
    /// * `message` - The message to broadcast.
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - An empty result indicating success or an error if the message could not be sent.
    pub async fn broadcast_message(&self, message: &str) -> IcnResult<()> {
        let peers = self.peers.read().map_err(|_| IcnError::Network("Failed to acquire peers lock".to_string()))?;
        for peer in peers.iter() {
            let mut locked_peer = peer.lock().await;
            locked_peer.write_all(message.as_bytes()).await
                .map_err(|e| IcnError::Network(format!("Failed to send message: {}", e)))?;
        }
        Ok(())
    }

    /// Stops the networking component and disconnects all peers.
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - An empty result indicating success or an error if stopping fails.
    pub async fn stop(&self) -> IcnResult<()> {
        let mut peers = self.peers.write().map_err(|_| IcnError::Network("Failed to acquire peers lock".to_string()))?;
        for peer in peers.iter() {
            let mut locked_peer = peer.lock().await;
            if let Err(e) = locked_peer.shutdown().await {
                error!("Failed to close peer connection: {:?}", e);
            }
        }
        peers.clear();
        info!("Networking component stopped.");
        Ok(())
    }
}

/// Handles an incoming client connection, establishing a secure TLS stream
/// and managing communication with the peer.
///
/// # Arguments
///
/// * `stream` - The TCP stream representing the client connection.
/// * `acceptor` - The TLS acceptor used to secure the connection.
/// * `peers` - The list of currently connected peers.
/// * `_custom_arg` - A placeholder for future use.
///
/// # Returns
///
/// * `IcnResult<()>` - An empty result indicating success or an error if the connection fails.
async fn handle_client_connection(
    stream: TcpStream,
    acceptor: TlsAcceptor,
    peers: Arc<RwLock<Vec<Arc<Mutex<tokio_native_tls::TlsStream<TcpStream>>>>>>,
    _custom_arg: Option<()>
) -> IcnResult<()> {
    let tls_stream = acceptor.accept(stream).await
        .map_err(|e| IcnError::Network(format!("Failed to accept TLS connection: {:?}", e)))?;

    let tls_stream = Arc::new(Mutex::new(tls_stream));

    {
        let mut peers_guard = peers.write().map_err(|_| IcnError::Network("Failed to acquire peers lock".to_string()))?;
        peers_guard.push(tls_stream.clone());
    }

    handle_client(tls_stream, peers).await
}

/// Manages communication with a connected peer, reading and processing messages.
///
/// # Arguments
///
/// * `stream` - The secure TLS stream for the peer connection.
/// * `peers` - The list of currently connected peers.
///
/// # Returns
///
/// * `IcnResult<()>` - An empty result indicating success or an error if the connection fails.
async fn handle_client(
    stream: Arc<Mutex<tokio_native_tls::TlsStream<TcpStream>>>, 
    peers: Arc<RwLock<Vec<Arc<Mutex<tokio_native_tls::TlsStream<TcpStream>>>>>>,
) -> IcnResult<()> {
    let mut buffer = [0; 1024];

    loop {
        let mut locked_stream = stream.lock().await;
        match locked_stream.read(&mut buffer).await {
            Ok(0) => break,
            Ok(n) => {
                let message = String::from_utf8_lossy(&buffer[..n]);
                info!("Received message: {}", message);
            }
            Err(e) => {
                error!("Error reading from stream: {:?}", e);
                break;
            }
        }
    }

    let mut peers = peers.write().map_err(|_| IcnError::Network("Failed to acquire peers lock".to_string()))?;
    peers.retain(|p| !Arc::ptr_eq(p, &stream));
    Ok(())
}




=== ./icn_shared/Cargo.toml ===
[package]
name = "icn_shared"
version = "0.1.0"
edition = "2018"

[dependencies]
sha2 = "0.10"  # Add this line
serde = "1.0"
serde_json = "1.0"
log = "0.4"
native-tls = "0.2"  # Add this line



=== ./icn_shared/src/error.rs ===



=== ./icn_shared/src/block.rs ===
use serde::{Serialize, Deserialize};
use sha2::{Sha256, Digest};
use std::time::{SystemTime, UNIX_EPOCH};

/// Represents a block in the blockchain.
///
/// Each block contains a list of transactions, a reference to the previous block's hash,
/// a unique hash calculated from its contents, and the ID of the proposer who created the block.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Block {
    pub index: u64,
    pub timestamp: u64,
    pub transactions: Vec<String>, // Transactions are represented as Strings
    pub previous_hash: String,
    pub hash: String,
    pub proposer_id: String,
    pub nonce: u64,
}

impl Block {
    /// Creates a new `Block` instance.
    ///
    /// # Arguments
    ///
    /// * `index` - The index of the block in the blockchain.
    /// * `transactions` - A vector of transactions included in the block.
    /// * `previous_hash` - The hash of the previous block in the chain.
    /// * `proposer_id` - The ID of the node proposing the block.
    ///
    /// # Returns
    ///
    /// * `Block` - A new `Block` instance with a calculated hash.
    pub fn new(
        index: u64,
        transactions: Vec<String>,
        previous_hash: String,
        proposer_id: String,
    ) -> Self {
        let timestamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .expect("Time went backwards")
            .as_secs();

        let mut block = Block {
            index,
            timestamp,
            transactions,
            previous_hash,
            hash: String::new(),
            proposer_id,
            nonce: 0,
        };
        block.hash = block.calculate_hash();
        block
    }

    /// Calculates the hash of the block based on its contents.
    ///
    /// The hash is computed using SHA-256 and includes the block's index, timestamp,
    /// transactions, previous hash, proposer ID, and nonce.
    ///
    /// # Returns
    ///
    /// * `String` - The calculated hash of the block.
    pub fn calculate_hash(&self) -> String {
        let mut hasher = Sha256::new();
        hasher.update(self.index.to_be_bytes());
        hasher.update(self.timestamp.to_be_bytes());
        hasher.update(serde_json::to_string(&self.transactions).unwrap());
        hasher.update(&self.previous_hash);
        hasher.update(&self.proposer_id);
        hasher.update(self.nonce.to_be_bytes());
        format!("{:x}", hasher.finalize())
    }

    /// Validates the block's hash to ensure it matches the calculated hash.
    ///
    /// This method checks the integrity of the block by verifying that its hash is consistent
    /// with its contents.
    ///
    /// # Returns
    ///
    /// * `bool` - Returns `true` if the block is valid, `false` otherwise.
    pub fn is_valid(&self) -> bool {
        self.hash == self.calculate_hash()
    }
}



=== ./icn_shared/src/consensus.rs ===



=== ./icn_shared/src/lib.rs ===
use std::error::Error;
use std::fmt;
use std::time::{SystemTime, UNIX_EPOCH}; // Import the missing time components
use serde::{Serialize, Deserialize};
use sha2::{Sha256, Digest}; // Import the missing sha2 crate

/// Custom error type for the ICN project.
///
/// This enum represents various error cases that can occur within the InterCooperative Network system.
/// It is used across different crates to provide a consistent error handling mechanism.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum IcnError {
    Config(String),
    Blockchain(String),
    Consensus(String),
    Network(String),
    SmartContract(String),
    Storage(String),
    Io(String),
    Other(String),
}

impl fmt::Display for IcnError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            IcnError::Config(msg) => write!(f, "Configuration error: {}", msg),
            IcnError::Blockchain(msg) => write!(f, "Blockchain error: {}", msg),
            IcnError::Consensus(msg) => write!(f, "Consensus error: {}", msg),
            IcnError::Network(msg) => write!(f, "Network error: {}", msg),
            IcnError::SmartContract(msg) => write!(f, "Smart contract error: {}", msg),
            IcnError::Storage(msg) => write!(f, "Storage error: {}", msg),
            IcnError::Io(msg) => write!(f, "I/O error: {}", msg),
            IcnError::Other(msg) => write!(f, "Other error: {}", msg),
        }
    }
}

impl Error for IcnError {}

/// Converts a standard I/O error into an `IcnError`.
impl From<std::io::Error> for IcnError {
    fn from(err: std::io::Error) -> Self {
        IcnError::Io(err.to_string())
    }
}

/// A type alias for `Result` with `IcnError` as the error type.
///
/// This alias is used throughout the project to provide a consistent result type
/// that uses our custom `IcnError`.
pub type IcnResult<T> = Result<T, IcnError>;

/// Represents the current state of a node in the network.
///
/// This enum is used to track the lifecycle of nodes within the network.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum NodeState {
    Initializing,
    Operational,
    ShuttingDown,
}

/// Common block structure that can be used across crates
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Block {
    pub index: u64,
    pub timestamp: u64,
    pub transactions: Vec<String>,
    pub previous_hash: String,
    pub hash: String,
    pub proposer_id: String,
}

impl Block {
    /// Creates a new block
    pub fn new(index: u64, transactions: Vec<String>, previous_hash: String, proposer_id: String) -> Self {
        let timestamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .expect("Time went backwards")
            .as_secs();

        // Simulating hash calculation
        let hash = format!("{:x}", Sha256::digest(format!("{:?}", index).as_bytes()));

        Block {
            index,
            timestamp,
            transactions,
            previous_hash,
            hash,
            proposer_id,
        }
    }
}

/// This module contains utility functions used across the project.
pub mod utils {
    /// Validates if a given string is a valid hexadecimal representation.
    pub fn is_valid_hex(hex_string: &str) -> bool {
        hex_string.chars().all(|c| c.is_digit(16))
    }

    // Additional utility functions can be added here as needed
}

#[cfg(test)]
mod tests {
    use super::*;

    /// Tests for the `is_valid_hex` utility function.
    #[test]
    fn test_is_valid_hex() {
        assert!(utils::is_valid_hex("1a2b3c"));
        assert!(utils::is_valid_hex("ABCDEF"));
        assert!(!utils::is_valid_hex("1a2g3c"));
        assert!(!utils::is_valid_hex("xyz"));
    }
}



=== ./config/default_config.toml ===
[node]
name = "MyNode"



=== ./config/config.toml ===



=== ./project_parts/core_files_00 ===
./icn_networking/Cargo.toml
./icn_networking/src/lib/mod.rs
./icn_networking/src/lib.rs
./icn_blockchain/Cargo.toml
./icn_blockchain/src/lib/mod.rs
./icn_blockchain/src/transaction/mod.rs
./icn_blockchain/src/lib.rs
./icn_blockchain/src/block/mod.rs
./icn_blockchain/src/chain/mod.rs
./.github/workflows/ci.yml
./.github/workflows/static.yml
./.github/FUNDING.yml
./.vscode/settings.json
./icn_virtual_machine/Cargo.toml
./icn_virtual_machine/src/lib/mod.rs
./icn_virtual_machine/src/lib.rs
./icn_consensus/Cargo.toml
./icn_consensus/src/lib/mod.rs
./icn_consensus/src/lib.rs
./icn_consensus/src/proof_of_cooperation.rs
./icn_governance/Cargo.toml
./icn_governance/src/lib/mod.rs
./icn_governance/src/lib.rs
./Cargo.toml
./icn_core/Cargo.toml
./icn_core/src/config/mod.rs
./icn_core/src/config/config_loader.rs
./icn_core/src/lib/mod.rs
./icn_core/src/main.rs
./icn_core/src/node/mod.rs
./icn_core/src/node/node_manager.rs
./icn_core/src/lib.rs
./icn_core/src/coordinator/module_coordinator.rs
./icn_core/src/coordinator/mod.rs
./icn_storage/Cargo.toml
./icn_storage/src/lib/mod.rs
./icn_storage/src/lib.rs
./icn_identity/Cargo.toml
./icn_identity/src/lib/mod.rs
./icn_identity/src/lib.rs
./icn_smart_contracts/Cargo.toml
./icn_smart_contracts/src/lib/mod.rs
./icn_smart_contracts/src/lib.rs
./icn_api/Cargo.toml
./icn_api/src/lib/mod.rs
./icn_api/src/lib.rs



=== ./icn_blockchain/Cargo.toml ===
[package]
name = "icn_blockchain"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_shared = { path = "../icn_shared" }
icn_consensus = { path = "../icn_consensus" }
log = "0.4"

serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
sha2 = "0.10"
chrono = "0.4"



=== ./icn_blockchain/src/lib/mod.rs ===



=== ./icn_blockchain/src/transaction/mod.rs ===
// icn_blockchain/src/transaction/mod.rs

use serde::{Serialize, Deserialize};

/// Represents the different types of transactions supported by the blockchain.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum TransactionType {
    Transfer,
    DeployContract,
    // Add more variants as needed
}

/// The `Transaction` struct defines a blockchain transaction, including its sender,
/// receiver, amount, and type of transaction.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Transaction {
    pub sender: String,
    pub receiver: String,
    pub amount: u64,
    pub transaction_type: TransactionType,
}

impl Transaction {
    /// Creates a new `Transaction` instance with the given sender, receiver, and amount.
    ///
    /// # Arguments
    ///
    /// * `sender` - The ID of the sender.
    /// * `receiver` - The ID of the receiver.
    /// * `amount` - The amount being transferred in the transaction.
    ///
    /// # Returns
    ///
    /// * `Transaction` - A new `Transaction` instance of type `Transfer`.
    pub fn new(sender: &str, receiver: &str, amount: u64) -> Self {
        Transaction {
            sender: sender.to_string(),
            receiver: receiver.to_string(),
            amount,
            transaction_type: TransactionType::Transfer,
        }
    }

    /// Validates the transaction based on its type.
    ///
    /// # Returns
    ///
    /// * `bool` - Returns `true` if the transaction is valid, `false` otherwise.
    ///
    /// This method performs basic validation depending on the transaction type.
    pub fn validate_transaction(&self) -> bool {
        match self.transaction_type {
            TransactionType::Transfer => {
                !self.sender.is_empty() && !self.receiver.is_empty() && self.amount > 0
            }
            TransactionType::DeployContract => {
                // Validation logic specific to DeployContract transactions
                // Add your validation logic here
                false // Placeholder for now
            }
            // Add more match arms for other transaction types as needed
        }
    }
}



=== ./icn_blockchain/src/transaction/transaction_type.rs ===
/// Represents the different types of transactions supported by the blockchain
#[derive(Debug, Clone, PartialEq, Eq)] // Add necessary derives based on your project's requirements
pub enum TransactionType {
    Transfer,
    DeployContract,
    // Add more variants as needed
}



=== ./icn_blockchain/src/lib.rs ===
// icn_blockchain/src/lib.rs

pub mod chain;
pub mod transaction;

pub use icn_shared::Block; // Use Block from icn_shared
pub use chain::Chain;
pub use transaction::Transaction;



=== ./icn_blockchain/src/chain/mod.rs ===
// file: icn_blockchain/src/chain/mod.rs

use icn_shared::{Block, IcnError};
use icn_consensus::Consensus;
use std::sync::Arc;

/// The `Chain` struct represents the blockchain, which consists of a series of blocks.
/// It manages the addition of new blocks, block validation, and access to the latest block.
pub struct Chain<C: Consensus> {
    pub blocks: Vec<Block>,
    pub consensus: Arc<C>,  // Use Arc<C> instead of C directly
}

impl<C: Consensus> Chain<C> {
    /// Creates a new blockchain with the given consensus mechanism.
    ///
    /// # Arguments
    ///
    /// * `consensus` - An `Arc` to the consensus mechanism to be used for the blockchain.
    ///
    /// # Returns
    ///
    /// * `Chain<C>` - A new `Chain` instance.
    pub fn new(consensus: Arc<C>) -> Self {
        Chain {
            blocks: Vec::new(),
            consensus,  // Now stores an Arc<C>
        }
    }

    /// Adds a new block to the blockchain.
    ///
    /// # Arguments
    ///
    /// * `transactions` - A vector of transactions to include in the block.
    /// * `previous_hash` - The hash of the previous block in the chain.
    /// * `proposer_id` - The ID of the proposer of the block.
    ///
    /// # Returns
    ///
    /// * `Result<(), IcnError>` - Returns `Ok(())` if the block is successfully added, 
    ///   or an `IcnError` if validation fails.
    pub fn add_block(&mut self, transactions: Vec<String>, previous_hash: String, proposer_id: String) -> Result<(), IcnError> {
        let index = self.blocks.len() as u64;

        let new_block = Block::new(index, transactions, previous_hash, proposer_id);

        // Propagate the custom error type directly, removing the need for String conversion
        if self.consensus.validate(&new_block)? {
            self.blocks.push(new_block);
            Ok(())
        } else {
            Err(IcnError::Consensus("Block validation failed.".to_string()))
        }
    }

    /// Returns the latest block in the blockchain.
    ///
    /// # Returns
    ///
    /// * `Option<&Block>` - Returns an `Option` containing a reference to the latest block,
    ///   or `None` if the blockchain is empty.
    pub fn latest_block(&self) -> Option<&Block> {
        self.blocks.last()
    }

    /// Validates a block according to the consensus mechanism.
    ///
    /// This method ensures that the block meets the criteria set by the consensus mechanism, including
    /// cooperation scores, reputation scores, and other factors.
    pub fn validate_block(&self, block: &Block) -> Result<(), IcnError> {
        let validators = self.consensus.select_validators(block)?;
        for validator in validators {
            let is_valid = validator.validate(block)?;
            if !is_valid {
                return Err(IcnError::Consensus("Block validation failed.".to_string()));
            }
        }
        Ok(())
    }

    /// Selects validators for block validation based on the consensus mechanism.
    ///
    /// The selection process may involve factors such as stake, reputation, and recent activity.
    fn select_validators(&self, block: &Block) -> Result<Vec<Validator>, IcnError> {
        // Logic to select validators based on stake, reputation, and recent activity
        Ok(vec![]) // Placeholder
    }

    /// Performs stake-weighted voting on a block.
    ///
    /// Voting influence is proportional to the validator's stake and reputation, ensuring a fair and balanced decision.
    pub fn stake_weighted_vote(&self, block: &Block) -> Result<bool, IcnError> {
        let mut total_weight = 0.0;
        let mut weighted_votes = 0.0;

        for validator in self.validators.iter() {
            let weight = validator.stake + validator.reputation;
            let vote = validator.vote(block)?;
            total_weight += weight;
            weighted_votes += vote as f64 * weight;
        }

        Ok(weighted_votes / total_weight > 0.5)
    }
}



=== ./.github/workflows/ci.yml ===
# name: Rust CI

# on:
#   push:
#     branches: [ main ]
#   pull_request:
#     branches: [ main ]

# env:
#   CARGO_TERM_COLOR: always

# jobs:
#   build:
#     runs-on: ubuntu-latest
#     steps:
#     - uses: actions/checkout@v2
#     - name: Build
#       run: cargo build --verbose
#     - name: Run tests
#       run: cargo test --verbose


=== ./.github/workflows/static.yml ===
# Simple workflow for deploying static content to GitHub Pages
name: Deploy static content to Pages

on:
  # Runs on pushes targeting the default branch
  push:
    branches: ["main"]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # Single deploy job since we're just deploying
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Pages
        uses: actions/configure-pages@v5
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          # Upload entire repository
          path: '.'
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4



=== ./.github/FUNDING.yml ===
#github: [fahertym]
#patreon: InterCooperativeNetwork
open_collective: intercooperative-network



=== ./.vscode/settings.json ===
{
    "liveServer.settings.port": 5501
}


=== ./icn_virtual_machine/Cargo.toml ===
[package]
name = "icn_virtual_machine"
version = "0.1.0"
edition = "2021"

[dependencies]



=== ./icn_virtual_machine/src/lib/mod.rs ===



=== ./icn_virtual_machine/src/bytecode.rs ===
// icn_virtual_machine/src/bytecode.rs

/// The `Bytecode` struct represents the compiled code of a smart contract.
/// It contains a vector of bytes that the virtual machine can execute.
pub struct Bytecode {
    pub code: Vec<u8>,
}

impl Bytecode {
    /// Creates a new instance of `Bytecode`.
    ///
    /// # Arguments
    ///
    /// * `code` - A vector of bytes representing the compiled code of a smart contract.
    ///
    /// # Returns
    ///
    /// * `Bytecode` - A new instance of `Bytecode` containing the provided bytecode.
    pub fn new(code: Vec<u8>) -> Self {
        Bytecode { code }
    }
}


=== ./icn_virtual_machine/src/lib.rs ===
// icn_virtual_machine/src/lib.rs
pub mod bytecode;
pub mod execution_engine;

use bytecode::Bytecode;
use execution_engine::ExecutionEngine;

/// The `VirtualMachine` struct is responsible for executing smart contracts.
/// It processes bytecode using an execution engine.
pub struct VirtualMachine {
    engine: ExecutionEngine,
}

impl VirtualMachine {
    /// Creates a new instance of the `VirtualMachine`.
    pub fn new() -> Self {
        VirtualMachine {
            engine: ExecutionEngine::new(),
        }
    }

    /// Executes a smart contract represented by bytecode.
    ///
    /// # Arguments
    ///
    /// * `bytecode` - The bytecode to be executed.
    ///
    /// # Returns
    ///
    /// * `Result<(), String>` - `Ok` if execution succeeds, otherwise an error message.
    pub fn execute(&mut self, bytecode: Bytecode) -> Result<(), String> {
        self.engine.execute(bytecode)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_virtual_machine_execution() {
        let mut vm = VirtualMachine::new();
        let bytecode = Bytecode::new(vec![0x01, 0x02, 0x03]);

        // Test execution with non-empty bytecode
        assert!(vm.execute(bytecode).is_ok());

        // Test execution with empty bytecode
        let empty_bytecode = Bytecode::new(vec![]);
        assert!(vm.execute(empty_bytecode).is_err());
    }
}



=== ./icn_virtual_machine/src/execution_engine.rs ===
use crate::bytecode::Bytecode;

/// The `ExecutionEngine` struct is responsible for interpreting and executing smart contract bytecode.
/// It forms the core logic of the virtual machine within the ICN project.
pub struct ExecutionEngine;

impl ExecutionEngine {
    /// Creates a new instance of `ExecutionEngine`.
    ///
    /// # Returns
    ///
    /// * `ExecutionEngine` - A new instance of the `ExecutionEngine` struct.
    pub fn new() -> Self {
        ExecutionEngine
    }

    /// Executes the provided bytecode.
    ///
    /// # Arguments
    ///
    /// * `bytecode` - The bytecode to be executed, represented as a `Bytecode` struct.
    ///
    /// # Returns
    ///
    /// * `Result<(), String>` - Returns `Ok(())` if the execution succeeds, or an error message if it fails.
    ///
    /// # Example
    ///
    /// ```
    /// let engine = ExecutionEngine::new();
    /// let bytecode = Bytecode::new(vec![0x01, 0x02]);
    /// let result = engine.execute(bytecode);
    /// assert!(result.is_ok());
    /// ```
    ///
    /// # Errors
    ///
    /// - Returns an error if the bytecode is empty.
    /// - Returns an error if the bytecode contains unknown instructions.
    pub fn execute(&self, bytecode: Bytecode) -> Result<(), String> {
        if bytecode.code.is_empty() {
            return Err("Bytecode is empty".to_string());
        }

        // Example: Interpreting and executing the bytecode.
        // This implementation should be expanded to handle actual instructions.
        for instruction in bytecode.code {
            match instruction {
                0x01 => println!("Instruction: 0x01 - No-op"),
                _ => return Err(format!("Unknown instruction: 0x{:x}", instruction)),
            }
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::bytecode::Bytecode;

    #[test]
    /// Tests the execution of non-empty bytecode.
    fn test_execution_with_non_empty_bytecode() {
        let engine = ExecutionEngine::new();
        let bytecode = Bytecode::new(vec![0x01, 0x02, 0x03]);
        assert!(engine.execute(bytecode).is_ok());
    }

    #[test]
    /// Tests the execution of empty bytecode, expecting an error.
    fn test_execution_with_empty_bytecode() {
        let engine = ExecutionEngine::new();
        let empty_bytecode = Bytecode::new(vec![]);
        assert!(engine.execute(empty_bytecode).is_err());
    }
}



=== ./.gitmodules ===



=== ./cert.pem ===
-----BEGIN CERTIFICATE-----
MIIFazCCA1OgAwIBAgIUKz5dfZ9jTOfAmPkt/87h5PFHc0AwDQYJKoZIhvcNAQEL
BQAwRTELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUxITAfBgNVBAoM
GEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDAeFw0yNDA4MjEyMDE5NDdaFw0yNTA4
MjEyMDE5NDdaMEUxCzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEw
HwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQwggIiMA0GCSqGSIb3DQEB
AQUAA4ICDwAwggIKAoICAQCyX/kj6bH9NeS4RZjWVQslhM2W0TctsvFZ2hw6tK3b
dmTmZX+KLejd+0FGTRTcInspbIkIedCeqsgBYoJie4/PvECG9OFN0unremCJZ0OY
54VsTur2RX0JbwjS2cmKQvK7Ex7xHndWckEPomRONEbFpUY0+S0ZQs2Qxw4LDI83
TJNM1s7mzjHGXXERg7rnuA4A4zDD0wkZ73Z1rGEFQ1cSs92KfSRYB3B0FVrXCtVa
VoFxTPscGQOX7w2AG98P2sla6uao/set3NEj2ZYOAYiF81PMNHRqR46Ecenm6Ao4
L+m+f7tUqViWtzm9/uThl8ekkzAZV5orLMqKqnlfcJlsmDNr2QquCxjPsmvXi3/1
TusmP6la/hgQ/0orbVVZQXg00xbziBIuFiixMkhPcn972mVbIQfEbcntGo/54shY
cvrrAPedBOGHuOhfvp50rA9Sp7kiIsxfxum54QyUAJBjx2d7DV0Qgzhbo8mCUDQh
HycNVJJlnZlE8TuelvXoG4N1DYxV21w2hy98YVnkSdaYB02dCiEMlczo6mSmVJHP
bt9t+/ODSRP+g7GurMTZXMcd4UeNDViuZy8S53ym6fbkLZNcrZ6Fk41o/3EbwZkF
alORB4xE3fTIacQes2ctc34b9rVYeZ5zXWwU4wPuE5EFD5R7Hs6Iw/rp8+4CDXeP
XwIDAQABo1MwUTAdBgNVHQ4EFgQUqJe/RlkHNUXMyhweeZSj7KfkJGswHwYDVR0j
BBgwFoAUqJe/RlkHNUXMyhweeZSj7KfkJGswDwYDVR0TAQH/BAUwAwEB/zANBgkq
hkiG9w0BAQsFAAOCAgEAjYs6tXpdAKY/WKhuTML/jneDghX0FPJWXwG5KHMF3oqJ
Bd4mQO5dQ+cBcgYReXgsLj2/HNaVhlr0kChhrwN/1LozhFJD+HEFJCTHPscBiVQf
rnsUozcDJUhj0g8K1ZC+v8Ld6A3xka1Ga3htbqTuBUZnIP/Tdvqq5Xjl+vQpclE1
1PUxazD28dUhaDrjgPGWlsu4xVuPekbsBpbR5vMDx7jh7A0J5Et5ST6GOgD0BSrg
5fwzRGgzfzEfpYe3Jegtk1YV/R2ZGUPihUXJxeuxqBwlLBAARaXg29cvXwpG4nDq
Ok89eCArXi378cj9TThDOIwFI+Ztw1ysaSaX8EUaeepeclHYnUgY9puppc7tYqch
fAznRCe7zmA+5RYPs894xgxQ1t+GjK614pC0STQ4+jHnhO+6qPkpx5rumUOXaaJc
3ZBkvGmeV7XG7qdYz0tB/VwX803xwmZB7vezf+E7brxLfEXz1NsGxRufwvQv0IPp
VL4ysn3jVrmMlCyNm6Maew/c/BvZVBm+g1HKoCrQ0+PhrK5DOx3xWQ8jzaYTx1fS
WW2PdhoD8/urJU+X70KTLqVdlhQVwi3MPEBtNkKceSZlmGnkrKZN3LuupokkToIH
ZRVOhSKJMi86jkWwzAGA0kLWDdAEEferP3X8TDyvPXX9htPjzvepYQS/ELxy8HY=
-----END CERTIFICATE-----



=== ./icn_consensus/Cargo.toml ===
[package]
name = "icn_consensus"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_shared = { path = "../icn_shared" }
log = "0.4"
rand = "0.8"



=== ./icn_consensus/src/consensus.rs ===
//file: icn_consensus/src/consensus.rs

use icn_blockchain::block::Block;

/// The `Consensus` trait defines the interface for consensus mechanisms
/// within the InterCooperative Network blockchain system.
///
/// Implementing this trait allows different consensus algorithms to be
/// used interchangeably within the blockchain.
pub trait Consensus {
    /// Validates a block according to the consensus rules.
    ///
    /// # Arguments
    ///
    /// * `block` - A reference to the block that needs to be validated.
    ///
    /// # Returns
    ///
    /// * `Result<bool, String>` - Returns `Ok(true)` if the block is valid,
    ///   or an error message if validation fails.
    fn validate(&self, block: &Block) -> Result<bool, String>;

    /// Selects a proposer for the next block based on the consensus mechanism's rules.
    ///
    /// # Returns
    ///
    /// * `Result<String, String>` - Returns the ID of the selected proposer,
    ///   or an error message if selection fails.
    fn select_proposer(&self) -> Result<String, String>;
}



=== ./icn_consensus/src/lib/mod.rs ===



=== ./icn_consensus/src/lib.rs ===
use icn_shared::{Block, IcnError, IcnResult};
use rand::Rng;
use std::collections::{HashMap, HashSet};
use std::time::{SystemTime, UNIX_EPOCH};
use log::info;

/// The `Consensus` trait defines the interface for consensus mechanisms
/// within the InterCooperative Network blockchain system.
pub trait Consensus: Clone + Send + Sync {
    fn validate(&self, block: &Block) -> IcnResult<bool>;
    fn select_proposer(&self) -> IcnResult<String>;
}

/// The `ProofOfCooperation` struct implements the consensus mechanism for the ICN project.
#[derive(Clone, Debug)]  // Adding Debug trait for better error handling and logging
pub struct ProofOfCooperation {
    known_peers: HashSet<String>,
    cooperation_scores: HashMap<String, u64>,
    last_block_time: u64,
}

impl ProofOfCooperation {
    pub fn new() -> Self {
        ProofOfCooperation {
            known_peers: HashSet::new(),
            cooperation_scores: HashMap::new(),
            last_block_time: 0,
        }
    }

    pub fn register_peer(&mut self, peer_id: &str) {
        self.known_peers.insert(peer_id.to_string());
        self.cooperation_scores.insert(peer_id.to_string(), 100);
        info!("Registered peer: {}", peer_id);
    }

    pub fn is_registered(&self, peer_id: &str) -> bool {
        self.known_peers.contains(peer_id)
    }
}

impl Consensus for ProofOfCooperation {
    fn validate(&self, block: &Block) -> IcnResult<bool> {
        if !self.is_registered(&block.proposer_id) {
            return Err(IcnError::Consensus(format!("Unknown proposer: {}", block.proposer_id)));
        }

        let current_time = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .map_err(|e| IcnError::Consensus(format!("System time error: {}", e)))?
            .as_secs();

        if current_time < self.last_block_time + 10 {
            return Err(IcnError::Consensus("Block proposed too soon".to_string()));
        }

        Ok(true)
    }

    fn select_proposer(&self) -> IcnResult<String> {
        let mut rng = rand::thread_rng();
        let total_score: u64 = self.cooperation_scores.values().sum();
        let random_value: u64 = rng.gen_range(0..total_score);

        let mut cumulative_score = 0;
        for (peer_id, score) in &self.cooperation_scores {
            cumulative_score += score;
            if cumulative_score >= random_value {
                return Ok(peer_id.clone());
            }
        }

        Err(IcnError::Consensus("Failed to select a proposer".to_string()))
    }
}



=== ./icn_consensus/src/proof_of_cooperation.rs ===
// file: icn_consensus/src/proof_of_cooperation.rs

use std::collections::{HashMap, HashSet};
use std::time::{SystemTime, UNIX_EPOCH};
use std::sync::{Arc, RwLock};
use icn_shared::{Block, IcnError, IcnResult};
use rand::Rng;
use log::info;

/// The `ProofOfCooperation` struct implements the Proof of Cooperation consensus mechanism.
/// It manages the registration of peers, validation of blocks, selection of proposers,
/// and updates of cooperation and reputation scores.
#[derive(Debug)]
pub struct ProofOfCooperation {
    known_peers: HashSet<String>,
    cooperation_scores: HashMap<String, f64>,
    reputation_scores: HashMap<String, f64>,  // New field for reputation scores
    last_block_time: u64,
}

impl ProofOfCooperation {
    /// Creates a new `ProofOfCooperation` instance.
    pub fn new() -> Self {
        ProofOfCooperation {
            known_peers: HashSet::new(),
            cooperation_scores: HashMap::new(),
            reputation_scores: HashMap::new(),
            last_block_time: 0,
        }
    }

    /// Registers a peer in the consensus mechanism.
    pub fn register_peer(&mut self, peer_id: &str) {
        self.known_peers.insert(peer_id.to_string());
        self.cooperation_scores.insert(peer_id.to_string(), 1.0);
        self.reputation_scores.insert(peer_id.to_string(), 1.0);  // Initialize reputation score
        info!("Registered peer: {}", peer_id);
    }

    /// Checks if a peer is registered in the consensus mechanism.
    pub fn is_registered(&self, peer_id: &str) -> bool {
        self.known_peers.contains(peer_id)
    }

    /// Validates a block according to the Proof of Cooperation consensus mechanism.
    ///
    /// This function checks the proposer ID, ensures that the block is not proposed too soon after the previous block,
    /// and may include additional validation logic such as checking signatures or cooperation.
    pub fn validate(&mut self, block: &Block) -> IcnResult<bool> {
        if !self.is_registered(&block.proposer_id) {
            return Err(IcnError::Consensus(format!("Unknown proposer: {}", block.proposer_id)));
        }

        let current_time = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .map_err(|e| IcnError::Other(format!("System time error: {}", e)))?
            .as_secs();

        if current_time < self.last_block_time + 10 {
            return Err(IcnError::Consensus("Block proposed too soon".to_string()));
        }

        self.last_block_time = current_time;

        // Example of additional validation logic (e.g., checking signatures, ensuring cooperation)
        // Here, we could also validate the quality of transactions, adherence to protocol rules, etc.

        Ok(true)
    }

    /// Selects a proposer based on cooperation and reputation scores.
    ///
    /// The selection process is weighted by both cooperation and reputation scores, ensuring that
    /// nodes that contribute positively to the network have a higher chance of being selected as the proposer.
    pub fn select_proposer(&self) -> IcnResult<String> {
        let mut rng = rand::thread_rng();
        let total_score: f64 = self.cooperation_scores
            .iter()
            .zip(self.reputation_scores.iter())
            .map(|((_, coop_score), (_, rep_score))| coop_score + rep_score)
            .sum();
        let random_value: f64 = rng.gen::<f64>() * total_score;

        let mut cumulative_score = 0.0;
        for (peer_id, coop_score) in &self.cooperation_scores {
            let rep_score = self.reputation_scores.get(peer_id).unwrap_or(&0.0);
            cumulative_score += coop_score + rep_score;
            if cumulative_score >= random_value {
                return Ok(peer_id.clone());
            }
        }

        Err(IcnError::Consensus("Failed to select a proposer".to_string()))
    }

    /// Updates the cooperation score of a peer.
    ///
    /// Performance is a multiplier that adjusts the cooperation score. The score is bounded by a minimum
    /// and maximum value to ensure stability and prevent extreme changes.
    pub fn update_cooperation_score(&mut self, peer_id: &str, performance: f64) -> IcnResult<()> {
        let score = self.cooperation_scores
            .get_mut(peer_id)
            .ok_or_else(|| IcnError::Consensus(format!("Unknown peer: {}", peer_id)))?;
        
        *score = (*score * performance).max(0.1).min(2.0);  // Adjust score with a min and max range
        self.update_reputation(peer_id)?;  // Update reputation based on new cooperation score
        Ok(())
    }

    /// Updates the reputation score based on historical cooperation scores.
    ///
    /// Reputation is a critical factor in the network, and this function calculates it by averaging the current
    /// reputation score with the updated cooperation score. This method could be replaced with more complex
    /// reputation algorithms if needed.
    pub fn update_reputation(&mut self, peer_id: &str) -> IcnResult<()> {
        let coop_score = *self.cooperation_scores
            .get(peer_id)
            .ok_or_else(|| IcnError::Consensus(format!("Unknown peer: {}", peer_id)))?;
        
        let rep_score = self.reputation_scores
            .entry(peer_id.to_string())
            .or_insert(1.0);

        // For simplicity, we're averaging the reputation, but this could be replaced with a more complex formula
        *rep_score = (*rep_score + coop_score) / 2.0;

        Ok(())
    }

    /// Handles a blockchain fork by selecting the most valid chain.
    ///
    /// This decision can be influenced by the quality of the blocks in each chain, such as cooperation and reputation scores.
    pub fn handle_fork<'a>(&self, chain_a: &'a [Block], chain_b: &'a [Block]) -> &'a [Block] {
        // Basic chain selection logic: select the longer chain
        if chain_a.len() >= chain_b.len() {
            chain_a
        } else {
            chain_b
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_shared::Block;

    #[test]
    fn test_register_and_validate_peer() {
        let mut poc = ProofOfCooperation::new();
        poc.register_peer("peer1");
        
        let block = Block::new(0, vec![], "previous_hash".to_string(), "peer1".to_string());
        assert!(poc.validate(&block).is_ok());

        let invalid_block = Block::new(0, vec![], "previous_hash".to_string(), "unknown_peer".to_string());
        assert!(poc.validate(&invalid_block).is_err());
    }

    #[test]
    fn test_select_proposer() {
        let mut poc = ProofOfCooperation::new();
        poc.register_peer("peer1");
        poc.register_peer("peer2");
        
        let proposer = poc.select_proposer().unwrap();
        assert!(vec!["peer1", "peer2"].contains(&proposer.as_str()));
    }

    #[test]
    fn test_update_cooperation_score() {
        let mut poc = ProofOfCooperation::new();
        poc.register_peer("peer1");
        
        poc.update_cooperation_score("peer1", 1.5).unwrap();
        assert!(poc.cooperation_scores["peer1"] > 1.0);

        poc.update_cooperation_score("peer1", 0.5).unwrap();
        assert!(poc.cooperation_scores["peer1"] < 1.0);
    }

    #[test]
    fn test_update_reputation() {
        let mut poc = ProofOfCooperation::new();
        poc.register_peer("peer1");
        
        poc.update_cooperation_score("peer1", 1.5).unwrap();
        poc.update_reputation("peer1").unwrap();
        assert!(poc.reputation_scores["peer1"] > 1.0);

        poc.update_cooperation_score("peer1", 0.5).unwrap();
        poc.update_reputation("peer1").unwrap();
        assert!(poc.reputation_scores["peer1"] < 1.0);
    }
}



=== ./icn_governance/Cargo.toml ===
[package]
name = "icn_governance"
version = "0.1.0"
edition = "2021"

[dependencies]



=== ./icn_governance/src/lib/mod.rs ===



=== ./icn_governance/src/lib.rs ===
pub struct Proposal {
    pub id: u32,
    pub description: String,
    pub votes_for: u32,
    pub votes_against: u32,
}

impl Proposal {
    pub fn new(id: u32, description: &str) -> Self {
        Proposal {
            id,
            description: description.to_string(),
            votes_for: 0,
            votes_against: 0,
        }
    }

    pub fn vote_for(&mut self) {
        self.votes_for += 1;
    }

    pub fn vote_against(&mut self) {
        self.votes_against += 1;
    }
}



=== ./Cargo.toml ===
[workspace]
members = [
    "icn_core",
    "icn_blockchain",
    "icn_consensus",
    "icn_networking",
    "icn_identity",
    "icn_governance",
    "icn_smart_contracts",
    "icn_virtual_machine",
    "icn_api",
    "icn_storage",
    "icn_shared"
]
default-run = "icn_core"

resolver = "2"


=== ./Cargo.lock ===
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "addr2line"
version = "0.22.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e4503c46a5c0c7844e948c9a4d6acd9f50cccb4de1c48eb9e291ea17470c678"
dependencies = [
 "gimli",
]

[[package]]
name = "adler"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe"

[[package]]
name = "ahash"
version = "0.7.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "891477e0c6a8957309ee5c45a6368af3ae14bb510732d2684ffa19af310920f9"
dependencies = [
 "getrandom",
 "once_cell",
 "version_check",
]

[[package]]
name = "aho-corasick"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
dependencies = [
 "memchr",
]

[[package]]
name = "android-tzdata"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0"

[[package]]
name = "android_system_properties"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
dependencies = [
 "libc",
]

[[package]]
name = "async-trait"
version = "0.1.81"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e0c28dcc82d7c8ead5cb13beb15405b57b8546e93215673ff8ca0349a028107"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "autocfg"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0c4b4d0bd25bd0b74681c0ad21497610ce1b7c91b1022cd21c80c6fbdd9476b0"

[[package]]
name = "backtrace"
version = "0.3.73"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5cc23269a4f8976d0a4d2e7109211a419fe30e8d88d677cd60b6bc79c5732e0a"
dependencies = [
 "addr2line",
 "cc",
 "cfg-if",
 "libc",
 "miniz_oxide",
 "object",
 "rustc-demangle",
]

[[package]]
name = "base64"
version = "0.13.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e1b586273c5702936fe7b7d6896644d8be71e6314cfe09d3167c95f712589e8"

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b048fb63fd8b5923fc5aa7b340d8e156aec7ec02f0c78fa8a6ddc2613f6f71de"

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array",
]

[[package]]
name = "bumpalo"
version = "3.16.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "79296716171880943b8470b5f8d03aa55eb2e645a4874bdbb28adb49162e012c"

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "bytes"
version = "1.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8318a53db07bb3f8dca91a600466bdb3f2eaadeedfdbcf02e1accbad9271ba50"

[[package]]
name = "cc"
version = "1.1.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72db2f7947ecee9b03b510377e8bb9077afa27176fdbff55c51027e976fdcc48"
dependencies = [
 "shlex",
]

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "chrono"
version = "0.4.38"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a21f936df1771bf62b77f047b726c4625ff2e8aa607c01ec06e5a05bd8463401"
dependencies = [
 "android-tzdata",
 "iana-time-zone",
 "js-sys",
 "num-traits",
 "wasm-bindgen",
 "windows-targets",
]

[[package]]
name = "config"
version = "0.13.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "23738e11972c7643e4ec947840fc463b6a571afcd3e735bdfce7d03c7a784aca"
dependencies = [
 "async-trait",
 "json5",
 "lazy_static",
 "nom",
 "pathdiff",
 "ron",
 "rust-ini",
 "serde",
 "serde_json",
 "toml",
 "yaml-rust",
]

[[package]]
name = "core-foundation"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "91e195e091a93c46f7102ec7818a2aa394e1e1771c3ab4825963fa03e45afb8f"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "core-foundation-sys"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"

[[package]]
name = "cpufeatures"
version = "0.2.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "51e852e6dc9a5bed1fae92dd2375037bf2b768725bf3be87811edee3249d09ad"
dependencies = [
 "libc",
]

[[package]]
name = "crypto-common"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
dependencies = [
 "generic-array",
 "typenum",
]

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer",
 "crypto-common",
]

[[package]]
name = "dlv-list"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0688c2a7f92e427f44895cd63841bff7b29f8d7a1648b9e7e07a4a365b2e1257"

[[package]]
name = "env_logger"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4cd405aab171cb85d6735e5c8d9db038c17d3ca007a4d2c25f337935c3d90580"
dependencies = [
 "humantime",
 "is-terminal",
 "log",
 "regex",
 "termcolor",
]

[[package]]
name = "errno"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "534c5cf6194dfab3db3242765c03bbe257cf92f22b38f6bc0c58d59108a820ba"
dependencies = [
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "fastrand"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fc0510504f03c51ada170672ac806f1f105a88aa97a5281117e1ddc3368e51a"

[[package]]
name = "foreign-types"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6f339eb8adc052cd2ca78910fda869aefa38d22d5cb648e6485e4d3fc06f3b1"
dependencies = [
 "foreign-types-shared",
]

[[package]]
name = "foreign-types-shared"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00b0228411908ca8685dba7fc2cdd70ec9990a6e753e89b6ac91a84c40fbaf4b"

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "typenum",
 "version_check",
]

[[package]]
name = "getrandom"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c4567c8db10ae91089c99af84c68c38da3ec2f087c3f82960bcdbf3656b6f4d7"
dependencies = [
 "cfg-if",
 "libc",
 "wasi",
]

[[package]]
name = "gimli"
version = "0.29.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "40ecd4077b5ae9fd2e9e169b102c6c330d0605168eb0e8bf79952b256dbefffd"

[[package]]
name = "hashbrown"
version = "0.12.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888"
dependencies = [
 "ahash",
]

[[package]]
name = "hermit-abi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d231dfb89cfffdbc30e7fc41579ed6066ad03abda9e567ccafae602b97ec5024"

[[package]]
name = "hermit-abi"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fbf6a919d6cf397374f7dfeeea91d974c7c0a7221d0d0f4f20d859d329e53fcc"

[[package]]
name = "humantime"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a3a5bfb195931eeb336b2a7b4d761daec841b97f947d34394601737a7bba5e4"

[[package]]
name = "iana-time-zone"
version = "0.1.60"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7ffbb5a1b541ea2561f8c41c087286cc091e21e556a4f09a8f6cbf17b69b141"
dependencies = [
 "android_system_properties",
 "core-foundation-sys",
 "iana-time-zone-haiku",
 "js-sys",
 "wasm-bindgen",
 "windows-core",
]

[[package]]
name = "iana-time-zone-haiku"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
dependencies = [
 "cc",
]

[[package]]
name = "icn_api"
version = "0.1.0"

[[package]]
name = "icn_blockchain"
version = "0.1.0"
dependencies = [
 "chrono",
 "icn_consensus",
 "icn_shared",
 "log",
 "serde",
 "serde_json",
 "sha2",
]

[[package]]
name = "icn_consensus"
version = "0.1.0"
dependencies = [
 "icn_shared",
 "log",
 "rand",
]

[[package]]
name = "icn_core"
version = "0.1.0"
dependencies = [
 "config",
 "env_logger",
 "icn_blockchain",
 "icn_consensus",
 "icn_governance",
 "icn_identity",
 "icn_networking",
 "icn_shared",
 "log",
 "native-tls",
 "serde",
 "serde_json",
 "tempfile",
 "thiserror",
 "tokio",
 "toml",
]

[[package]]
name = "icn_governance"
version = "0.1.0"

[[package]]
name = "icn_identity"
version = "0.1.0"
dependencies = [
 "icn_shared",
]

[[package]]
name = "icn_networking"
version = "0.1.0"
dependencies = [
 "icn_shared",
 "log",
 "native-tls",
 "tempfile",
 "tokio",
 "tokio-native-tls",
]

[[package]]
name = "icn_shared"
version = "0.1.0"
dependencies = [
 "log",
 "native-tls",
 "serde",
 "serde_json",
 "sha2",
]

[[package]]
name = "icn_smart_contracts"
version = "0.1.0"

[[package]]
name = "icn_storage"
version = "0.1.0"
dependencies = [
 "icn_blockchain",
 "icn_shared",
]

[[package]]
name = "icn_virtual_machine"
version = "0.1.0"

[[package]]
name = "is-terminal"
version = "0.4.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "261f68e344040fbd0edea105bef17c66edf46f984ddb1115b775ce31be948f4b"
dependencies = [
 "hermit-abi 0.4.0",
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "itoa"
version = "1.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49f1f14873335454500d59611f1cf4a4b0f786f9ac11f4312a78e4cf2566695b"

[[package]]
name = "js-sys"
version = "0.3.70"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1868808506b929d7b0cfa8f75951347aa71bb21144b7791bae35d9bccfcfe37a"
dependencies = [
 "wasm-bindgen",
]

[[package]]
name = "json5"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96b0db21af676c1ce64250b5f40f3ce2cf27e4e47cb91ed91eb6fe9350b430c1"
dependencies = [
 "pest",
 "pest_derive",
 "serde",
]

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"

[[package]]
name = "libc"
version = "0.2.158"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d8adc4bb1803a324070e64a98ae98f38934d91957a99cfb3a43dcbc01bc56439"

[[package]]
name = "linked-hash-map"
version = "0.5.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0717cef1bc8b636c6e1c1bbdefc09e6322da8a9321966e8928ef80d20f7f770f"

[[package]]
name = "linux-raw-sys"
version = "0.4.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78b3ae25bc7c8c38cec158d1f2757ee79e9b3740fbc7ccf0e59e4b08d793fa89"

[[package]]
name = "lock_api"
version = "0.4.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07af8b9cdd281b7915f413fa73f29ebd5d55d0d3f0155584dade1ff18cea1b17"
dependencies = [
 "autocfg",
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7a70ba024b9dc04c27ea2f0c0548feb474ec5c54bba33a7f72f873a39d07b24"

[[package]]
name = "memchr"
version = "2.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3"

[[package]]
name = "minimal-lexical"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"

[[package]]
name = "miniz_oxide"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b8a240ddb74feaf34a79a7add65a741f3167852fba007066dcac1ca548d89c08"
dependencies = [
 "adler",
]

[[package]]
name = "mio"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "80e04d1dcff3aae0704555fe5fee3bcfaf3d1fdf8a7e521d5b9d2b42acb52cec"
dependencies = [
 "hermit-abi 0.3.9",
 "libc",
 "wasi",
 "windows-sys 0.52.0",
]

[[package]]
name = "native-tls"
version = "0.2.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8614eb2c83d59d1c8cc974dd3f920198647674a0a035e1af1fa58707e317466"
dependencies = [
 "libc",
 "log",
 "openssl",
 "openssl-probe",
 "openssl-sys",
 "schannel",
 "security-framework",
 "security-framework-sys",
 "tempfile",
]

[[package]]
name = "nom"
version = "7.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
dependencies = [
 "memchr",
 "minimal-lexical",
]

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
]

[[package]]
name = "object"
version = "0.36.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "27b64972346851a39438c60b341ebc01bba47464ae329e55cf343eb93964efd9"
dependencies = [
 "memchr",
]

[[package]]
name = "once_cell"
version = "1.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3fdb12b2476b595f9358c5161aa467c2438859caa136dec86c26fdd2efe17b92"

[[package]]
name = "openssl"
version = "0.10.66"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9529f4786b70a3e8c61e11179af17ab6188ad8d0ded78c5529441ed39d4bd9c1"
dependencies = [
 "bitflags 2.6.0",
 "cfg-if",
 "foreign-types",
 "libc",
 "once_cell",
 "openssl-macros",
 "openssl-sys",
]

[[package]]
name = "openssl-macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a948666b637a0f465e8564c73e89d4dde00d72d4d473cc972f390fc3dcee7d9c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "openssl-probe"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ff011a302c396a5197692431fc1948019154afc178baf7d8e37367442a4601cf"

[[package]]
name = "openssl-sys"
version = "0.9.103"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f9e8deee91df40a943c71b917e5874b951d32a802526c85721ce3b776c929d6"
dependencies = [
 "cc",
 "libc",
 "pkg-config",
 "vcpkg",
]

[[package]]
name = "ordered-multimap"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ccd746e37177e1711c20dd619a1620f34f5c8b569c53590a72dedd5344d8924a"
dependencies = [
 "dlv-list",
 "hashbrown",
]

[[package]]
name = "parking_lot"
version = "0.12.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f1bf18183cf54e8d6059647fc3063646a1801cf30896933ec2311622cc4b9a27"
dependencies = [
 "lock_api",
 "parking_lot_core",
]

[[package]]
name = "parking_lot_core"
version = "0.9.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e401f977ab385c9e4e3ab30627d6f26d00e2c73eef317493c4ec6d468726cf8"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall",
 "smallvec",
 "windows-targets",
]

[[package]]
name = "pathdiff"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8835116a5c179084a830efb3adc117ab007512b535bc1a21c991d3b32a6b44dd"

[[package]]
name = "pest"
version = "2.7.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cd53dff83f26735fdc1ca837098ccf133605d794cdae66acfc2bfac3ec809d95"
dependencies = [
 "memchr",
 "thiserror",
 "ucd-trie",
]

[[package]]
name = "pest_derive"
version = "2.7.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2a548d2beca6773b1c244554d36fcf8548a8a58e74156968211567250e48e49a"
dependencies = [
 "pest",
 "pest_generator",
]

[[package]]
name = "pest_generator"
version = "2.7.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c93a82e8d145725dcbaf44e5ea887c8a869efdcc28706df2d08c69e17077183"
dependencies = [
 "pest",
 "pest_meta",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "pest_meta"
version = "2.7.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a941429fea7e08bedec25e4f6785b6ffaacc6b755da98df5ef3e7dcf4a124c4f"
dependencies = [
 "once_cell",
 "pest",
 "sha2",
]

[[package]]
name = "pin-project-lite"
version = "0.2.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bda66fc9667c18cb2758a2ac84d1167245054bcf85d5d1aaa6923f45801bdd02"

[[package]]
name = "pkg-config"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d231b230927b5e4ad203db57bbcbee2802f6bce620b1e4a9024a07d94e2907ec"

[[package]]
name = "ppv-lite86"
version = "0.2.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77957b295656769bb8ad2b6a6b09d897d94f05c41b069aede1fcdaa675eaea04"
dependencies = [
 "zerocopy",
]

[[package]]
name = "proc-macro2"
version = "1.0.86"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e719e8df665df0d1c8fbfd238015744736151d4445ec0836b8e628aae103b77"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.36"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fa76aaf39101c457836aec0ce2316dbdc3ab723cdda1c6bd4e6ad4208acaca7"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "libc",
 "rand_chacha",
 "rand_core",
]

[[package]]
name = "rand_chacha"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
dependencies = [
 "ppv-lite86",
 "rand_core",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom",
]

[[package]]
name = "redox_syscall"
version = "0.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2a908a6e00f1fdd0dfd9c0eb08ce85126f6d8bbda50017e74bc4a4b7d4a926a4"
dependencies = [
 "bitflags 2.6.0",
]

[[package]]
name = "regex"
version = "1.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4219d74c6b67a3654a9fbebc4b419e22126d13d2f3c4a07ee0cb61ff79a79619"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata",
 "regex-syntax",
]

[[package]]
name = "regex-automata"
version = "0.4.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38caf58cc5ef2fed281f89292ef23f6365465ed9a41b7a7754eb4e26496c92df"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax",
]

[[package]]
name = "regex-syntax"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a66a03ae7c801facd77a29370b4faec201768915ac14a721ba36f20bc9c209b"

[[package]]
name = "ron"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "88073939a61e5b7680558e6be56b419e208420c2adb92be54921fa6b72283f1a"
dependencies = [
 "base64",
 "bitflags 1.3.2",
 "serde",
]

[[package]]
name = "rust-ini"
version = "0.18.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6d5f2436026b4f6e79dc829837d467cc7e9a55ee40e750d716713540715a2df"
dependencies = [
 "cfg-if",
 "ordered-multimap",
]

[[package]]
name = "rustc-demangle"
version = "0.1.24"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "719b953e2095829ee67db738b3bfa9fa368c94900df327b3f07fe6e794d2fe1f"

[[package]]
name = "rustix"
version = "0.38.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70dc5ec042f7a43c4a73241207cecc9873a06d45debb38b329f8541d85c2730f"
dependencies = [
 "bitflags 2.6.0",
 "errno",
 "libc",
 "linux-raw-sys",
 "windows-sys 0.52.0",
]

[[package]]
name = "ryu"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f3cb5ba0dc43242ce17de99c180e96db90b235b8a9fdc9543c96d2209116bd9f"

[[package]]
name = "schannel"
version = "0.1.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fbc91545643bcf3a0bbb6569265615222618bdf33ce4ffbbd13c4bbd4c093534"
dependencies = [
 "windows-sys 0.52.0",
]

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "security-framework"
version = "2.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "897b2245f0b511c87893af39b033e5ca9cce68824c4d7e7630b5a1d339658d02"
dependencies = [
 "bitflags 2.6.0",
 "core-foundation",
 "core-foundation-sys",
 "libc",
 "security-framework-sys",
]

[[package]]
name = "security-framework-sys"
version = "2.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75da29fe9b9b08fe9d6b22b5b4bcbc75d8db3aa31e639aa56bb62e9d46bfceaf"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "serde"
version = "1.0.208"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cff085d2cb684faa248efb494c39b68e522822ac0de72ccf08109abde717cfb2"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.208"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24008e81ff7613ed8e5ba0cfaf24e2c2f1e5b8a0495711e44fcd4882fca62bcf"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "serde_json"
version = "1.0.125"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "83c8e735a073ccf5be70aa8066aa984eaf2fa000db6c8d0100ae605b366d31ed"
dependencies = [
 "itoa",
 "memchr",
 "ryu",
 "serde",
]

[[package]]
name = "sha2"
version = "0.10.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "793db75ad2bcafc3ffa7c68b215fee268f537982cd901d132f89c6343f3a3dc8"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "signal-hook-registry"
version = "1.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a9e9e0b4211b72e7b8b6e85c807d36c212bdb33ea8587f7569562a84df5465b1"
dependencies = [
 "libc",
]

[[package]]
name = "smallvec"
version = "1.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c5e1a9a646d36c3599cd173a41282daf47c44583ad367b8e6837255952e5c67"

[[package]]
name = "socket2"
version = "0.5.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ce305eb0b4296696835b71df73eb912e0f1ffd2556a501fcede6e0c50349191c"
dependencies = [
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "syn"
version = "2.0.75"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6af063034fc1935ede7be0122941bafa9bacb949334d090b77ca98b5817c7d9"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "tempfile"
version = "3.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "04cbcdd0c794ebb0d4cf35e88edd2f7d2c4c3e9a5a6dab322839b321c6a87a64"
dependencies = [
 "cfg-if",
 "fastrand",
 "once_cell",
 "rustix",
 "windows-sys 0.59.0",
]

[[package]]
name = "termcolor"
version = "1.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06794f8f6c5c898b3275aebefa6b8a1cb24cd2c6c79397ab15774837a0bc5755"
dependencies = [
 "winapi-util",
]

[[package]]
name = "thiserror"
version = "1.0.63"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0342370b38b6a11b6cc11d6a805569958d54cfa061a29969c3b5ce2ea405724"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "1.0.63"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4558b58466b9ad7ca0f102865eccc95938dca1a74a856f2b57b6629050da261"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tokio"
version = "1.39.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9babc99b9923bfa4804bd74722ff02c0381021eafa4db9949217e3be8e84fff5"
dependencies = [
 "backtrace",
 "bytes",
 "libc",
 "mio",
 "parking_lot",
 "pin-project-lite",
 "signal-hook-registry",
 "socket2",
 "tokio-macros",
 "windows-sys 0.52.0",
]

[[package]]
name = "tokio-macros"
version = "2.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "693d596312e88961bc67d7f1f97af8a70227d9f90c31bba5806eec004978d752"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tokio-native-tls"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbae76ab933c85776efabc971569dd6119c580d8f5d448769dec1764bf796ef2"
dependencies = [
 "native-tls",
 "tokio",
]

[[package]]
name = "toml"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f4f7f0dd8d50a853a531c426359045b1998f04219d88799810762cd4ad314234"
dependencies = [
 "serde",
]

[[package]]
name = "typenum"
version = "1.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42ff0bf0c66b8238c6f3b578df37d0b7848e55df8577b3f74f92a69acceeb825"

[[package]]
name = "ucd-trie"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed646292ffc8188ef8ea4d1e0e0150fb15a5c2e12ad9b8fc191ae7a8a7f3c4b9"

[[package]]
name = "unicode-ident"
version = "1.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b"

[[package]]
name = "vcpkg"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "accd4ea62f7bb7a82fe23066fb0957d48ef677f6eeb8215f372f52e48bb32426"

[[package]]
name = "version_check"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"

[[package]]
name = "wasi"
version = "0.11.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"

[[package]]
name = "wasm-bindgen"
version = "0.2.93"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a82edfc16a6c469f5f44dc7b571814045d60404b55a0ee849f9bcfa2e63dd9b5"
dependencies = [
 "cfg-if",
 "once_cell",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.93"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9de396da306523044d3302746f1208fa71d7532227f15e347e2d93e4145dd77b"
dependencies = [
 "bumpalo",
 "log",
 "once_cell",
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.93"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "585c4c91a46b072c92e908d99cb1dcdf95c5218eeb6f3bf1efa991ee7a68cccf"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.93"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "afc340c74d9005395cf9dd098506f7f44e38f2b4a21c6aaacf9a105ea5e1e836"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.93"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c62a0a307cb4a311d3a07867860911ca130c3494e8c2719593806c08bc5d0484"

[[package]]
name = "winapi-util"
version = "0.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cf221c93e13a30d793f7645a0e7762c55d169dbb0a49671918a2319d289b10bb"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "windows-core"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33ab640c8d7e35bf8ba19b884ba838ceb4fba93a4e8c65a9059d08afcfc683d9"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm",
 "windows_aarch64_msvc",
 "windows_i686_gnu",
 "windows_i686_gnullvm",
 "windows_i686_msvc",
 "windows_x86_64_gnu",
 "windows_x86_64_gnullvm",
 "windows_x86_64_msvc",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "yaml-rust"
version = "0.4.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56c1936c4cc7a1c9ab21a1ebb602eb942ba868cbd44a99cb7cdc5892335e1c85"
dependencies = [
 "linked-hash-map",
]

[[package]]
name = "zerocopy"
version = "0.7.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b9b4fd18abc82b8136838da5d50bae7bdea537c574d8dc1a34ed098d6c166f0"
dependencies = [
 "byteorder",
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.7.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa4f8080344d4671fb4e831a13ad1e68092748387dfc4f55e356242fae12ce3e"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]



=== ./icn_core/Cargo.toml ===
[package]
name = "icn_core"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"  # Added serde_json dependency
tempfile = "3.2"
native-tls = "0.2"
tokio = { version = "1", features = ["full"] }
config = "0.13"
env_logger = "0.10"
log = "0.4"
icn_blockchain = { path = "../icn_blockchain" }
icn_consensus = { path = "../icn_consensus" }
icn_identity = { path = "../icn_identity" }
icn_governance = { path = "../icn_governance" }
icn_networking = { path = "../icn_networking" }
icn_shared = { path = "../icn_shared" }
toml = "0.5"
thiserror = "1.0"



=== ./icn_core/src/config/mod.rs ===
// File: icn_core/src/config/mod.rs

pub mod config_loader;

pub use config_loader::{Config, ConfigLoader};



=== ./icn_core/src/config/config_loader.rs ===
use std::fs;
use serde::Deserialize;
use icn_shared::{IcnError, IcnResult};

/// Represents the application configuration loaded from a TOML file.
///
/// This struct holds configuration details necessary for the server and database
/// components of the application. It is deserialized from a TOML file.
#[derive(Debug, Deserialize, Clone)]
pub struct Config {
    /// Configuration for the server, such as host, port, and TLS settings.
    pub server: ServerConfig,
    /// Configuration for the database, including connection URLs.
    pub database: DatabaseConfig,
}

/// Configuration for the server, including network and TLS settings.
///
/// This struct is used to configure the server's network-related parameters
/// and TLS (Transport Layer Security) settings for secure communication.
#[derive(Debug, Deserialize, Clone)]
pub struct ServerConfig {
    /// The host address where the server will run.
    ///
    /// This can be an IP address or a domain name. Use "0.0.0.0" to bind to all available interfaces.
    pub host: String,

    /// The port on which the server will listen for incoming connections.
    pub port: u16,

    /// Debug mode flag for enabling or disabling verbose output.
    ///
    /// When set to true, additional debug information will be logged.
    pub debug: bool,

    /// The file path to the TLS certificate.
    ///
    /// This should be the full path to the PEM-encoded certificate file.
    pub cert_file_path: String,

    /// The file path to the TLS private key.
    ///
    /// This should be the full path to the PEM-encoded private key file.
    pub key_file_path: String,

    /// The password for the TLS private key, if it is password-protected.
    ///
    /// Leave this empty if the private key is not password-protected.
    pub cert_password: String,
}

/// Configuration for the database, including connection URLs.
///
/// This struct holds the configuration required to connect to one or more databases.
#[derive(Debug, Deserialize, Clone)]
pub struct DatabaseConfig {
    /// A list of database connection URLs.
    pub urls: Vec<String>,
}

/// `ConfigLoader` handles the loading and parsing of TOML configuration files.
///
/// This struct is responsible for reading the configuration file from disk,
/// parsing its content, and providing access to the application's configuration.
#[derive(Debug, Clone)]
pub struct ConfigLoader {
    /// The application's configuration as loaded from the TOML file.
    config: Config,
}

impl ConfigLoader {
    /// Creates a new `ConfigLoader` instance by loading and parsing a TOML configuration file.
    ///
    /// # Arguments
    ///
    /// * `config_path` - The path to the TOML configuration file.
    ///
    /// # Returns
    ///
    /// * `IcnResult<Self>` - A new `ConfigLoader` instance if successful, otherwise an `IcnError`.
    ///
    /// # Errors
    ///
    /// * Returns an `IcnError::Config` if the file cannot be read or parsed.
    pub fn new(config_path: &str) -> IcnResult<Self> {
        // Read the contents of the configuration file
        let config_content = fs::read_to_string(config_path)
            .map_err(|e| IcnError::Config(format!("Failed to read config file '{}': {}", config_path, e)))?;
        
        // Parse the TOML content into a Config struct
        let config: Config = toml::from_str(&config_content)
            .map_err(|e| IcnError::Config(format!("Failed to parse TOML from '{}': {}", config_path, e)))?;
        
        Ok(ConfigLoader { config })
    }

    /// Returns a reference to the loaded configuration.
    ///
    /// # Returns
    ///
    /// * `&Config` - A reference to the configuration.
    ///
    /// # Example
    ///
    /// ```
    /// let config_loader = ConfigLoader::new("config.toml").unwrap();
    /// let config = config_loader.get_config();
    /// println!("Server host: {}", config.server.host);
    /// ```
    pub fn get_config(&self) -> &Config {
        &self.config
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::NamedTempFile;
    use std::io::Write;

    /// Helper function to create a temporary configuration file for testing.
    fn create_test_config() -> NamedTempFile {
        let mut file = NamedTempFile::new().unwrap();
        write!(file, r#"
            [server]
            host = "localhost"
            port = 8080
            debug = true
            cert_file_path = "/path/to/cert.pem"
            key_file_path = "/path/to/key.pem"
            cert_password = ""

            [database]
            urls = ["postgresql://user:pass@localhost/db1", "postgresql://user:pass@localhost/db2"]
        "#).unwrap();
        file
    }

    #[test]
    /// Tests the `ConfigLoader` by loading a test configuration and verifying its content.
    fn test_config_loader() {
        let test_config = create_test_config();
        let config_loader = ConfigLoader::new(test_config.path().to_str().unwrap()).unwrap();
        
        let config = config_loader.get_config();

        assert_eq!(config.server.host, "localhost");
        assert_eq!(config.server.port, 8080);
        assert!(config.server.debug);
        assert_eq!(config.server.cert_file_path, "/path/to/cert.pem");
        assert_eq!(config.server.key_file_path, "/path/to/key.pem");
        assert_eq!(config.server.cert_password, "");
        assert_eq!(
            config.database.urls,
            vec![
                "postgresql://user:pass@localhost/db1".to_string(),
                "postgresql://user:pass@localhost/db2".to_string()
            ]
        );
    }
}


=== ./icn_core/src/lib/mod.rs ===



=== ./icn_core/src/errors.rs ===
use std::fmt;
use std::error::Error;

/// Custom error type for the ICN project
#[derive(Debug)]
pub enum IcnError {
    /// Configuration error
    Config(String),

    /// IO error
    Io(std::io::Error),

    /// TOML parsing error
    Toml(toml::de::Error),

    /// Blockchain error
    Blockchain(String),

    /// Consensus error
    Consensus(String),

    /// Networking error
    Networking(String),

    /// Smart Contract error
    SmartContract(String),

    /// Virtual Machine error
    VirtualMachine(String),

    /// Storage error
    Storage(String),

    /// Other errors
    Other(String),
}

impl fmt::Display for IcnError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            IcnError::Config(msg) => write!(f, "Configuration error: {}", msg),
            IcnError::Io(err) => write!(f, "I/O error: {}", err),
            IcnError::Toml(err) => write!(f, "TOML parsing error: {}", err),
            IcnError::Blockchain(msg) => write!(f, "Blockchain error: {}", msg),
            IcnError::Consensus(msg) => write!(f, "Consensus error: {}", msg),
            IcnError::Networking(msg) => write!(f, "Networking error: {}", msg),
            IcnError::SmartContract(msg) => write!(f, "Smart Contract error: {}", msg),
            IcnError::VirtualMachine(msg) => write!(f, "Virtual Machine error: {}", msg),
            IcnError::Storage(msg) => write!(f, "Storage error: {}", msg),
            IcnError::Other(msg) => write!(f, "Other error: {}", msg),
        }
    }
}

impl Error for IcnError {}

impl From<std::io::Error> for IcnError {
    fn from(err: std::io::Error) -> Self {
        IcnError::Io(err)
    }
}

impl From<toml::de::Error> for IcnError {
    fn from(err: toml::de::Error) -> Self {
        IcnError::Toml(err)
    }
}



=== ./icn_core/src/main.rs ===
// File: icn_core/src/main.rs

use std::env;
use log::{error, info};
use std::sync::Arc;
use icn_core::config::ConfigLoader; // Correct import
use icn_core::coordinator::ModuleCoordinator;
use icn_consensus::ProofOfCooperation;
use icn_shared::IcnError;

/// The main entry point for the ICN Core module.
///
/// This function initializes the node by performing the following steps:
/// 1. Sets up logging.
/// 2. Loads the configuration file.
/// 3. Initializes the consensus mechanism (Proof of Cooperation).
/// 4. Initializes the `ModuleCoordinator`, which manages the various components of the node.
/// 5. Starts the coordinator, which is responsible for the node's lifecycle management.
///
/// # Command-Line Arguments
///
/// The program accepts an optional command-line argument:
/// - `config_path` (optional): The path to the configuration file. If not provided, the default
///   configuration file `config.toml` will be used.
///
/// # Error Handling
///
/// If any step fails, an error will be logged, and the program will exit gracefully.
#[tokio::main]
async fn main() -> Result<(), IcnError> {
    // Initialize logging
    env_logger::init();

    info!("Starting ICN Core...");

    let default_config_file = "config.toml";
    let config_path = env::args().nth(1).unwrap_or_else(|| default_config_file.to_string());

    // Load the configuration
    let config_loader = ConfigLoader::new(&config_path).map_err(|e| {
        error!("Failed to load configuration: {}", e);
        IcnError::Config(format!("Failed to load configuration: {}", e))
    })?;

    info!("Configuration loaded successfully from: {}", config_path);

    let consensus = Arc::new(ProofOfCooperation::new());
    let coordinator = ModuleCoordinator::new(Arc::clone(&consensus));

    coordinator.start(config_loader.get_config()).await.map_err(|e| {
        error!("Coordinator failed to start: {}", e);
        IcnError::Other(format!("Coordinator failed to start: {}", e))
    })?;

    info!("ICN Core started successfully");

    tokio::signal::ctrl_c().await.map_err(|e| {
        error!("Failed to listen for shutdown signal: {}", e);
        IcnError::Other(format!("Failed to listen for shutdown signal: {}", e))
    })?;

    info!("Shutting down ICN Core...");

    // Perform cleanup here

    Ok(())
}



=== ./icn_core/src/node/mod.rs ===
mod node_manager;
pub use node_manager::NodeManager;



=== ./icn_core/src/node/node_manager.rs ===
use crate::config::{ConfigLoader, config_loader}; // Ensure correct imports for ConfigLoader and config_loader
use crate::coordinator::ModuleCoordinator;
use icn_shared::IcnResult;
use config::Config;

pub struct NodeManager {
    config_loader: ConfigLoader,
    coordinator: ModuleCoordinator,
}

impl NodeManager {
    pub fn new(config_loader: ConfigLoader, coordinator: ModuleCoordinator) -> IcnResult<Self> {
        Ok(NodeManager {
            config_loader,
            coordinator,
        })
    }

    pub async fn start(&mut self) -> IcnResult<()> {
        let config = self.config_loader.get_config();  // Get the custom config
        let config_converted = self.convert_to_external_config(&config); // Convert to `config::Config` using reference
        self.coordinator.start(&config_converted).await?;
        Ok(())
    }

    fn convert_to_external_config(&self, config: &config_loader::Config) -> Config {
        let mut external_config = Config::builder();

        // Assuming that `host` and `port` are relevant fields you want to use for configuring
        external_config = external_config.set_override("server.host", config.server.host.clone()).unwrap();
        external_config = external_config.set_override("server.port", config.server.port.to_string()).unwrap();
        external_config = external_config.set_override("database.urls", config.database.urls.join(",")).unwrap();

        external_config.build().unwrap()
    }

    // Other methods...
}



=== ./icn_core/src/lib.rs ===
// /opt/InterCooperative-Network-Node/icn_core/src/lib.rs

pub mod config;
pub mod coordinator;
pub mod errors;

pub use config::ConfigLoader;
pub use coordinator::ModuleCoordinator;
pub use errors::IcnError;



=== ./icn_core/src/coordinator/module_coordinator.rs ===
// File: icn_core/src/coordinator/module_coordinator.rs

use std::sync::{Arc, Mutex};
use icn_blockchain::Chain;
use icn_consensus::{ProofOfCooperation, Consensus};
use icn_networking::Networking;
use icn_shared::{NodeState, IcnResult, IcnError, Block};
use crate::config::Config;
use log::info;

/// The `ModuleCoordinator` is responsible for coordinating various modules within the 
/// InterCooperative Network (ICN) node. It manages the blockchain, consensus, networking, 
/// and node state, providing a centralized interface for starting and stopping the node.
pub struct ModuleCoordinator {
    blockchain: Arc<Mutex<Chain<ProofOfCooperation>>>,
    consensus: Arc<ProofOfCooperation>,
    networking: Arc<Mutex<Networking>>,
    node_state: Arc<Mutex<NodeState>>,
}

impl ModuleCoordinator {
    /// Creates a new instance of `ModuleCoordinator`.
    ///
    /// # Arguments
    ///
    /// * `consensus` - The consensus mechanism to be used by the blockchain.
    ///
    /// # Returns
    ///
    /// * `ModuleCoordinator` - A new instance of `ModuleCoordinator`.
    pub fn new(consensus: Arc<ProofOfCooperation>) -> Self {
        info!("Initializing ModuleCoordinator");
        ModuleCoordinator {
            blockchain: Arc::new(Mutex::new(Chain::new(Arc::clone(&consensus)))),
            consensus: Arc::clone(&consensus),
            networking: Arc::new(Mutex::new(Networking::new())),
            node_state: Arc::new(Mutex::new(NodeState::Initializing)),
        }
    }

    /// Starts the node by loading the TLS identity and starting the networking server.
    ///
    /// # Arguments
    ///
    /// * `config` - The configuration object containing network and TLS settings.
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - Returns `Ok(())` if the node starts successfully, or an `IcnError` otherwise.
    pub async fn start(&self, config: &Config) -> IcnResult<()> {
        info!("Starting node");

        let identity = Networking::load_tls_identity(
            &config.server.cert_file_path,
            &config.server.key_file_path,
            &config.server.cert_password
        ).map_err(|e| IcnError::Network(format!("Failed to load TLS identity: {}", e)))?;

        let mut networking = self.networking.lock()
            .map_err(|_| IcnError::Network("Failed to acquire networking lock".to_string()))?;

        let mut port = config.server.port;
        let max_retry = 10;
        let mut retry_count = 0;

        while retry_count < max_retry {
            let address = format!("{}:{}", config.server.host, port);
            match networking.start_server(&address, identity.clone()).await {
                Ok(_) => {
                    info!("Server started on {}", address);
                    break;
                }
                Err(e) => {
                    if retry_count == max_retry - 1 {
                        return Err(IcnError::Network(format!("Failed to bind to any port after {} attempts: {}", max_retry, e)));
                    }
                    info!("Port {} is in use, trying next port", port);
                    port += 1;
                    retry_count += 1;
                }
            }
        }

        {
            let mut state = self.node_state.lock()
                .map_err(|_| IcnError::Other("Failed to acquire node state lock".to_string()))?;
            *state = NodeState::Operational;
        }

        info!("Node started successfully");
        Ok(())
    }

    /// Stops the node by shutting down the networking server and updating the node state.
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - Returns `Ok(())` if the node stops successfully, or an `IcnError` otherwise.
    pub async fn stop(&self) -> IcnResult<()> {
        info!("Stopping node");

        let networking = self.networking.lock()
            .map_err(|_| IcnError::Network("Failed to acquire networking lock".to_string()))?;

        networking.stop().await?;

        {
            let mut state = self.node_state.lock()
                .map_err(|_| IcnError::Other("Failed to acquire node state lock".to_string()))?;
            *state = NodeState::ShuttingDown;
        }

        info!("Node stopped successfully");
        Ok(())
    }

    /// Adds a new block to the blockchain with the provided transactions.
    ///
    /// # Arguments
    ///
    /// * `transactions` - A vector of `String` objects representing the transactions to include in the new block.
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - Returns `Ok(())` if the block is successfully added, or an `IcnError` otherwise.
    pub fn add_block(&self, transactions: Vec<String>) -> IcnResult<()> {
        info!("Adding new block to the blockchain");

        let mut blockchain = self.blockchain.lock()
            .map_err(|_| IcnError::Blockchain("Failed to acquire blockchain lock".to_string()))?;

        let previous_hash = blockchain.latest_block()
            .map(|block| block.hash.clone())
            .unwrap_or_else(|| "0".repeat(64));

        let proposer_id = self.consensus.select_proposer()
            .map_err(|e| IcnError::Consensus(format!("Failed to select proposer: {}", e)))?;

        blockchain.add_block(transactions, previous_hash, proposer_id)?;

        info!("New block added successfully");
        Ok(())
    }

    /// Validates the latest block in the blockchain.
    ///
    /// # Returns
    ///
    /// * `IcnResult<bool>` - Returns `Ok(true)` if the block is valid, or an `IcnError` if validation fails.
    pub fn validate_latest_block(&self) -> IcnResult<bool> {
        info!("Validating the latest block");

        let blockchain = self.blockchain.lock()
            .map_err(|_| IcnError::Blockchain("Failed to acquire blockchain lock".to_string()))?;

        let latest_block = blockchain.latest_block()
            .ok_or_else(|| IcnError::Blockchain("Blockchain is empty".to_string()))?;

        self.consensus.validate(latest_block)
    }

    /// Retrieves the current state of the node.
    ///
    /// # Returns
    ///
    /// * `IcnResult<NodeState>` - Returns the current `NodeState` if successful, or an `IcnError` otherwise.
    pub fn get_node_state(&self) -> IcnResult<NodeState> {
        let state = self.node_state.lock()
            .map_err(|_| IcnError::Other("Failed to acquire node state lock".to_string()))?;
        Ok(*state)
    }

    /// Retrieves the latest block from the blockchain.
    ///
    /// # Returns
    ///
    /// * `IcnResult<Option<Block>>` - Returns the latest `Block` if it exists, `None` if the blockchain is empty, or an `IcnError` otherwise.
    pub fn get_latest_block(&self) -> IcnResult<Option<Block>> {
        let blockchain = self.blockchain.lock()
            .map_err(|_| IcnError::Blockchain("Failed to acquire blockchain lock".to_string()))?;
        Ok(blockchain.latest_block().cloned())
    }

    /// Retrieves the blockchain length.
    ///
    /// # Returns
    ///
    /// * `IcnResult<usize>` - Returns the current length of the blockchain, or an `IcnError` if the operation fails.
    pub fn get_blockchain_length(&self) -> IcnResult<usize> {
        let blockchain = self.blockchain.lock()
            .map_err(|_| IcnError::Blockchain("Failed to acquire blockchain lock".to_string()))?;
        Ok(blockchain.blocks.len())
    }

    /// Broadcasts a message to all connected peers.
    ///
    /// # Arguments
    ///
    /// * `message` - The message to broadcast.
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - Returns `Ok(())` if the message was successfully broadcast, or an `IcnError` otherwise.
    pub async fn broadcast_message(&self, message: &str) -> IcnResult<()> {
        let networking = self.networking.lock()
            .map_err(|_| IcnError::Network("Failed to acquire networking lock".to_string()))?;
        networking.broadcast_message(message).await
    }

    /// Attempts to connect to a new peer.
    ///
    /// # Arguments
    ///
    /// * `address` - The address of the peer to connect to.
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - Returns `Ok(())` if the connection was successful, or an `IcnError` otherwise.
    pub async fn connect_to_peer(&self, address: &str) -> IcnResult<()> {
        let networking = self.networking.lock()
            .map_err(|_| IcnError::Network("Failed to acquire networking lock".to_string()))?;
        networking.connect_to_peer(address).await
    }

    /// Updates the node's configuration.
    ///
    /// # Arguments
    ///
    /// * `new_config` - The new configuration to apply.
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - Returns `Ok(())` if the configuration was successfully updated, or an `IcnError` otherwise.
    pub async fn update_config(&self, new_config: &Config) -> IcnResult<()> {
        info!("Updating node configuration");
        
        // Stop the current networking service
        self.stop().await?;

        // Start the networking service with the new configuration
        self.start(new_config).await?;

        info!("Node configuration updated successfully");
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::config_loader::{ServerConfig, DatabaseConfig};

    #[tokio::test]
    async fn test_module_coordinator_lifecycle() {
        let consensus = Arc::new(ProofOfCooperation::new());
        let coordinator = ModuleCoordinator::new(consensus);

        // Create a mock configuration
        let config = Config {
            server: ServerConfig {
                host: "127.0.0.1".to_string(),
                port: 8080,
                debug: true,
                cert_file_path: "/path/to/cert.pem".to_string(),
                key_file_path: "/path/to/key.pem".to_string(),
                cert_password: "".to_string(),
            },
            database: DatabaseConfig {
                urls: vec!["postgresql://user:pass@localhost/db1".to_string()],
            },
        };

        // Test starting the node
        assert!(coordinator.start(&config).await.is_ok());

        // Test adding a block
        let transactions = vec!["tx1".to_string(), "tx2".to_string()];
        assert!(coordinator.add_block(transactions).is_ok());

        // Test getting the blockchain length
        assert_eq!(coordinator.get_blockchain_length().unwrap(), 1);

        // Test stopping the node
        assert!(coordinator.stop().await.is_ok());
    }
}


=== ./icn_core/src/coordinator/mod.rs ===
mod module_coordinator;
pub use module_coordinator::ModuleCoordinator;



=== ./icn_storage/Cargo.toml ===
[package]
name = "icn_storage"
version = "0.1.0"
edition = "2018"

[dependencies]
icn_blockchain = { path = "../icn_blockchain" }
icn_shared = { path = "../icn_shared" }



=== ./icn_storage/src/lib/mod.rs ===



=== ./icn_storage/src/block_storage.rs ===
// file: icn_storage/src/block_storage.rs

use icn_shared::Block;  // Correctly reference Block from icn_shared
use std::collections::HashMap;

/// The `BlockStorage` struct is responsible for storing and retrieving blocks.
/// It uses an in-memory `HashMap` to store blocks by their hash.
pub struct BlockStorage {
    storage: HashMap<String, Block>,
}

impl BlockStorage {
    /// Creates a new `BlockStorage` instance.
    ///
    /// # Returns
    ///
    /// * `BlockStorage` - A new instance of `BlockStorage`.
    pub fn new() -> Self {
        BlockStorage {
            storage: HashMap::new(),
        }
    }

    /// Adds a new block to the storage.
    ///
    /// # Arguments
    ///
    /// * `block` - The `Block` to be added to the storage.
    ///
    /// # Returns
    ///
    /// * `Result<(), String>` - Returns `Ok(())` if the block is successfully added,
    ///   or an error message if a block with the same hash already exists.
    ///
    /// # Errors
    ///
    /// * Returns an error if a block with the same hash already exists in the storage.
    pub fn add_block(&mut self, block: Block) -> Result<(), String> {
        let hash = block.hash.clone();
        if self.storage.contains_key(&hash) {
            return Err("Block with this hash already exists.".to_string());
        }
        self.storage.insert(hash, block);
        Ok(())
    }

    /// Retrieves a block by its hash.
    ///
    /// # Arguments
    ///
    /// * `hash` - A string representing the hash of the block to be retrieved.
    ///
    /// # Returns
    ///
    /// * `Option<Block>` - Returns `Some(Block)` if a block with the given hash is found,
    ///   or `None` if no such block exists.
    ///
    /// # Example
    ///
    /// ```
    /// let storage = BlockStorage::new();
    /// let block = Block::new(...);
    /// storage.add_block(block.clone()).unwrap();
    /// let retrieved_block = storage.get_block(&block.hash);
    /// assert_eq!(retrieved_block, Some(block));
    /// ```
    pub fn get_block(&self, hash: &str) -> Option<Block> {
        self.storage.get(hash).cloned()
    }
}



=== ./icn_storage/src/state_storage.rs ===
// file: icn_storage/src/state_storage.rs

use std::collections::HashMap;

/// The `StateStorage` struct is responsible for managing the state of the blockchain.
/// It uses an in-memory `HashMap` to store key-value pairs representing the state.
pub struct StateStorage {
    storage: HashMap<String, String>,
}

impl StateStorage {
    /// Creates a new `StateStorage` instance.
    pub fn new() -> Self {
        StateStorage {
            storage: HashMap::new(),
        }
    }

    /// Updates the state storage with a new key-value pair.
    ///
    /// # Arguments
    ///
    /// * `key` - A string slice that holds the key.
    /// * `value` - A string slice that holds the value.
    ///
    /// # Returns
    ///
    /// * `Result<(), String>` - Returns `Ok(())` if the state is successfully updated.
    pub fn update_state(&mut self, key: &str, value: &str) -> Result<(), String> {
        self.storage.insert(key.to_string(), value.to_string());
        Ok(())
    }

    /// Retrieves a value from the state storage by its key.
    ///
    /// # Arguments
    ///
    /// * `key` - A string slice that holds the key.
    ///
    /// # Returns
    ///
    /// * `Option<String>` - Returns an `Option` containing the value associated with the key,
    ///   or `None` if the key does not exist.
    pub fn get_state(&self, key: &str) -> Option<String> {
        self.storage.get(key).cloned()
    }
}



=== ./icn_storage/src/lib.rs ===
// file: icn_storage/src/lib.rs

pub mod block_storage;
pub mod state_storage;

use icn_shared::Block;  // Correctly reference Block from icn_shared
use block_storage::BlockStorage;
use state_storage::StateStorage;
use std::sync::{Arc, RwLock};

/// The `Storage` struct provides an interface to the underlying storage systems
/// for blocks and state. It ensures thread-safe access and modification.
pub struct Storage {
    block_storage: Arc<RwLock<BlockStorage>>,
    state_storage: Arc<RwLock<StateStorage>>,
}

impl Storage {
    /// Creates a new instance of the `Storage` struct with initialized
    /// block and state storage systems.
    ///
    /// # Returns
    ///
    /// * `Storage` - A new instance of `Storage`.
    pub fn new() -> Self {
        Storage {
            block_storage: Arc::new(RwLock::new(BlockStorage::new())),
            state_storage: Arc::new(RwLock::new(StateStorage::new())),
        }
    }

    /// Adds a new block to the block storage.
    ///
    /// # Arguments
    ///
    /// * `block` - The `Block` to be added to the storage.
    ///
    /// # Returns
    ///
    /// * `Result<(), String>` - Returns `Ok(())` if the block is successfully added,
    ///   or an error message if a block with the same hash already exists.
    pub fn add_block(&self, block: Block) -> Result<(), String> {
        let mut storage = self.block_storage.write().unwrap();
        storage.add_block(block)
    }

    /// Retrieves a block by its hash.
    ///
    /// # Arguments
    ///
    /// * `hash` - A string representing the hash of the block to be retrieved.
    ///
    /// # Returns
    ///
    /// * `Option<Block>` - Returns `Some(Block)` if a block with the given hash is found,
    ///   or `None` if no such block exists.
    pub fn get_block(&self, hash: &str) -> Option<Block> {
        let storage = self.block_storage.read().unwrap();
        storage.get_block(hash)
    }

    /// Updates the state storage with the latest state.
    ///
    /// # Arguments
    ///
    /// * `key` - The key under which the state is stored.
    /// * `value` - The value of the state to be stored.
    ///
    /// # Returns
    ///
    /// * `Result<(), String>` - Returns `Ok(())` if the state is successfully updated,
    ///   or an error message if the update fails.
    pub fn update_state(&self, key: &str, value: &str) -> Result<(), String> {
        let mut storage = self.state_storage.write().unwrap();
        storage.update_state(key, value)
    }

    /// Retrieves a value from the state storage by its key.
    ///
    /// # Arguments
    ///
    /// * `key` - The key of the state to retrieve.
    ///
    /// # Returns
    ///
    /// * `Option<String>` - Returns `Some(String)` if the value is found,
    ///   or `None` if no value is found for the given key.
    pub fn get_state(&self, key: &str) -> Option<String> {
        let storage = self.state_storage.read().unwrap();
        storage.get_state(key)
    }
}



=== ./config.toml ===
# Server configuration
[server]
# The host address where the server will run
host = "127.0.0.1"
# The port on which the server will listen
port = 8080
# Enable debug mode for verbose output
debug = true
# Path to the TLS certificate file
cert_file_path = "/opt/InterCooperative-Network-Node/cert.pem"
# Path to the TLS private key file
key_file_path = "/opt/InterCooperative-Network-Node/key.pem"
# Password for the TLS private key (leave empty if not password-protected)
cert_password = ""

# Database configuration
[database]
# List of database connection URLs
urls = ["postgresql://user:password@localhost/db1", "postgresql://user:password@localhost/db2"]


=== ./icn_identity/Cargo.toml ===
[package]
name = "icn_identity"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_shared = { path = "../icn_shared" }




=== ./icn_identity/src/lib/mod.rs ===



=== ./icn_identity/src/lib.rs ===
// icn_identity/src/lib.rs

/// The Identity module manages node identity within the ICN.
/// It holds basic identity information like node ID and name.
pub struct Identity {
    /// The unique identifier for the node.
    pub id: String,
    /// The name associated with the node.
    pub name: String,
}

impl Identity {
    /// Creates a new instance of Identity.
    pub fn new(id: &str, name: &str) -> Self {
        Identity {
            id: id.to_string(),
            name: name.to_string(),
        }
    }

    /// Initializes the identity module.
    ///
    /// # Returns
    /// * `IcnResult<()>` - An empty result indicating success or failure.
    pub fn initialize(&self) -> Result<(), String> {
        // Initialization logic here (if any)
        Ok(())
    }
}



=== ./update_project.sh ===
#!/bin/bash

# Generate the latest project state before committing
./generate_project_state.sh

# Check if the project state was generated successfully
if [[ $? -ne 0 ]]; then
    echo "Error: Failed to generate project state."
    exit 1
fi

# Prompt the user to enter a commit message
echo "Enter the commit message (end input with a single period on a new line):"

# Read the commit message, allowing for multi-line input until a period on its own line
COMMIT_MSG=""
while IFS= read -r line; do
    if [[ "$line" == "." ]]; then
        break
    fi
    COMMIT_MSG+="$line"$'\n'
done

# Ensure the commit message is not empty
if [[ -z "$COMMIT_MSG" ]]; then
    echo "Error: Commit message cannot be empty!"
    exit 1
fi

# Stage all changes for commit
git add .

# Commit the changes with the provided message
git commit -m "$COMMIT_MSG"

# Check if the commit was successful
if [[ $? -ne 0 ]]; then
    echo "Error: Commit failed."
    exit 1
fi

# Push the changes to the remote repository
git push origin main

# Check if the push was successful
if [[ $? -ne 0 ]]; then
    echo "Error: Push failed."
    exit 1
fi

echo "Changes have been successfully committed and pushed."



=== ./.gitignore ===
/target
**/*.rs.bk
Cargo.lock



=== ./icn_smart_contracts/Cargo.toml ===
[package]
name = "icn_smart_contracts"
version = "0.1.0"
edition = "2021"

[dependencies]



=== ./icn_smart_contracts/src/lib/mod.rs ===



=== ./icn_smart_contracts/src/lib.rs ===
// icn_smart_contracts/src/lib.rs

use std::collections::HashMap;

// Define our own error type for this crate
#[derive(Debug)]
pub enum SmartContractError {
    InvalidArguments(String),
    ContractNotFound(u32),
    KeyNotFound(String),
    UnknownFunction(String),
}

pub type SmartContractResult<T> = Result<T, SmartContractError>;

pub struct SmartContract {
    pub id: u32,
    pub code: String,
    pub state: HashMap<String, String>,
}

impl SmartContract {
    pub fn new(id: u32, code: &str) -> Self {
        SmartContract {
            id,
            code: code.to_string(),
            state: HashMap::new(),
        }
    }

    pub fn execute(&mut self, function: &str, args: Vec<String>) -> SmartContractResult<String> {
        match function {
            "set" => {
                if args.len() != 2 {
                    return Err(SmartContractError::InvalidArguments("'set' requires 2 arguments".to_string()));
                }
                self.state.insert(args[0].clone(), args[1].clone());
                Ok("Value set successfully".to_string())
            }
            "get" => {
                if args.len() != 1 {
                    return Err(SmartContractError::InvalidArguments("'get' requires 1 argument".to_string()));
                }
                self.state.get(&args[0])
                    .cloned()
                    .ok_or_else(|| SmartContractError::KeyNotFound(args[0].clone()))
            }
            _ => Err(SmartContractError::UnknownFunction(function.to_string())),
        }
    }
}

pub struct SmartContractEngine {
    contracts: HashMap<u32, SmartContract>,
}

impl SmartContractEngine {
    pub fn new() -> Self {
        SmartContractEngine {
            contracts: HashMap::new(),
        }
    }

    pub fn deploy_contract(&mut self, code: &str) -> SmartContractResult<u32> {
        let id = self.contracts.len() as u32 + 1;
        let contract = SmartContract::new(id, code);
        self.contracts.insert(id, contract);
        Ok(id)
    }

    pub fn call_contract(&mut self, id: u32, function: &str, args: Vec<String>) -> SmartContractResult<String> {
        self.contracts.get_mut(&id)
            .ok_or_else(|| SmartContractError::ContractNotFound(id))?
            .execute(function, args)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_smart_contract_execution() {
        let mut contract = SmartContract::new(1, "sample code");
        
        let result = contract.execute("set", vec!["key".to_string(), "value".to_string()]);
        assert!(result.is_ok());

        let result = contract.execute("get", vec!["key".to_string()]);
        assert_eq!(result.unwrap(), "value");

        let result = contract.execute("unknown", vec![]);
        assert!(result.is_err());
    }

    #[test]
    fn test_smart_contract_engine() {
        let mut engine = SmartContractEngine::new();

        let contract_id = engine.deploy_contract("sample code").unwrap();
        assert_eq!(contract_id, 1);

        let result = engine.call_contract(contract_id, "set", vec!["key".to_string(), "value".to_string()]);
        assert!(result.is_ok());

        let result = engine.call_contract(contract_id, "get", vec!["key".to_string()]);
        assert_eq!(result.unwrap(), "value");

        let result = engine.call_contract(999, "get", vec!["key".to_string()]);
        assert!(result.is_err());
    }
}


=== ./key.pem ===
-----BEGIN PRIVATE KEY-----
MIIJQQIBADANBgkqhkiG9w0BAQEFAASCCSswggknAgEAAoICAQCyX/kj6bH9NeS4
RZjWVQslhM2W0TctsvFZ2hw6tK3bdmTmZX+KLejd+0FGTRTcInspbIkIedCeqsgB
YoJie4/PvECG9OFN0unremCJZ0OY54VsTur2RX0JbwjS2cmKQvK7Ex7xHndWckEP
omRONEbFpUY0+S0ZQs2Qxw4LDI83TJNM1s7mzjHGXXERg7rnuA4A4zDD0wkZ73Z1
rGEFQ1cSs92KfSRYB3B0FVrXCtVaVoFxTPscGQOX7w2AG98P2sla6uao/set3NEj
2ZYOAYiF81PMNHRqR46Ecenm6Ao4L+m+f7tUqViWtzm9/uThl8ekkzAZV5orLMqK
qnlfcJlsmDNr2QquCxjPsmvXi3/1TusmP6la/hgQ/0orbVVZQXg00xbziBIuFiix
MkhPcn972mVbIQfEbcntGo/54shYcvrrAPedBOGHuOhfvp50rA9Sp7kiIsxfxum5
4QyUAJBjx2d7DV0Qgzhbo8mCUDQhHycNVJJlnZlE8TuelvXoG4N1DYxV21w2hy98
YVnkSdaYB02dCiEMlczo6mSmVJHPbt9t+/ODSRP+g7GurMTZXMcd4UeNDViuZy8S
53ym6fbkLZNcrZ6Fk41o/3EbwZkFalORB4xE3fTIacQes2ctc34b9rVYeZ5zXWwU
4wPuE5EFD5R7Hs6Iw/rp8+4CDXePXwIDAQABAoICABRfLf2XhEVL1pY4a0xYmcrM
VYya0rH3RLrt1EPc0cRa9mAdNHPsFV3mLbN2keIoVVJK+9rfdV+XAqZXLAFND696
gRDIvpicSiyjeotcI1YUZGJqdZ7wcGeCP7WREQRSQWrzM+6he6CrBi+KbOlE7YDy
L3KqXf0LakiAK2RAqB9Ohr4uWaKg5wIQNvMjTSvcvfYE/H3znWT8ZSuVpzOqLV4h
87SMNqPlHvHrDx0N4YW36SsETzjgyc5xi2RXtTdC1gn6V6NHtzdt8jwlbrlPxy9W
iySrKFE2YJpTcOghv9ULR9ICwDra58Fi0LHt1BHIZhEvjD1AtNynI29d0+R+Cs+G
zUPxdWmgaa5/khk6LC4Zvc3uwcC1SdqS0LeH+0mBz/ZJV1d833hOXf7MaoWH0tal
UcHuk0ihUGGJiL6G+nkwWzsYiTb8vfLbnpKCLesg0b35Tk/f7HCy2aRucqEMKCXv
eM7nxClOXbPZi+JarH0CZ+jy4JJ73VQELtfFqlEle4pxTwlGkXCm4zUPbyYoghD+
mTUrB9/L/mKYGjtHw2AMBeZYi9o8soEmTGN4T9yFpGGPXWUp8b2/80LEaamqC8E9
cPQLt/YCfoWdevWQHGzyDvCrtRHItoAivbf4w7k3+Bepb3n7FIelx0tbK6HRHNi9
2OMlhbX2D7xYFjTp/XvlAoIBAQDlbLXD96RIWWMpp0HHaEkdxwMGnpAlErxZML/P
cPDNIYV5u1jewuBLyMoVcRUiIQx4UuS6W+19ZooC0IljgPtsW0VhPnmOQo8+MyTq
utQ/KfPpmvKRo+BnccrLusNfM5u33Qdjcep+F4LdWJYew7bmFKoy1R7H0YuxH455
s5pGHg/6QKoaN+dIDyGu/ZfWFwLUf0BYu7LUmU5e85jtIc1B7FWXtRp2juWp6ftC
zSxdnOPX277aqKqoAeI4rU4TJOusWM5Ttth3W7GrREb9Eh4OV3+sKGg/1M5FxWTS
XgDH+EDltHRX6PtB3QoumY1VjjF10leP1W+S954FvanMSQzbAoIBAQDHCXL1PJ0y
UqbS4xm+gOeE1Qy9AB3fdc359afP5B4hBzBz/0fFHLZWBkZxmcX/HSqXPM1jsacX
kpAoTy3VqDsEboRHXKAsP/VXfj6yA5tcaLtbDU/lvdmYSjxGdfeYI16TeuNfTD3B
cPbmJ+pDr5MyCNmGe2s5Fn2IUN+GDuAoogKJlHfR8eqCT4P/QfiQrQ5t5TkY22Ug
NzEjgwqK6V8EG6E1iJLWog94By1cnf8t9RA7ocUz2RXPgI0jPkwb0iBSOlcC6SOc
pum292wlQfpjSnDRG1vF3Tr8aR35JcqJVSE556n5Xdzy6TwiXwvAhmiXarHZhD2N
AVJgwoDeegzNAoIBADrGzRJ1oVr/u43yUcHaj9DXKYlKmjdFQ4e+G4Xzs116Vw3G
14/KcVg5CrzPidCCkwVIh1zPLFrSKE1sS6Z4ZvFtuKqfLNkraDNROwX/81xzTQ/u
KHLzfwxBdOkY4fDD8gL612e8yYygTWCTz3H2RidP6AK54vbiUl2Abinzv3RzQzij
1HB/HfuyFLkWMw4gOxNhvoR9IeWhmRhuZCFsZX+cIpmJRkxVc7VCQqLsmY8qIJ0u
qQiv6Xi9cs1+aOAyt0YiQknkMDT0AuKTzXQMbjLSa90ZRQwFYwsw9RGID78rdMTk
pGHZSHWpQXCK2lCu6zD6QICS99C5K3zhCF1T4b0CggEAMyojqhUF19zVU5rbkFQ0
r7nQx3kTNNFkvJ/AnrlmYVkmxHrYKTyDRsPgMe20rysBOtV/euQ9LtsXQbVw896G
JVJ/oJSX/CgI2o/yb/JraqrllrdqVYWjPPnAWuCSYEKfWkwZzPKdYW+3mFykZPfq
X89Uk7SAULGOXY9klmKWjvtuqY1H6+lDPnJQXTrJOe+yqN9m+RPVAB4P/K//8suh
CD5OB6PvE0ufrFwz9f4LjfXUUW/5cKWabLgAEBJAoFo4wsqKeY4TAH8Lz2P1IfK+
+e016RseUVPYiPBAqz5ivUDsBKWf1SGi3bLFKZTDQZ+LnXjo9SCAbhHr6kG1vPsk
9QKCAQAL8PwaPMKnNY+58JL9B/uQkk4rrMnUnJqD/jgVTAQrOfdsgM5k7MqoxaZt
XCDoVbgxDc+IkTmqpRtUnl3CvnBIMV+2GVUD3agi9Cr70Mg1ZraUNYD131o/6lBf
R8U7hJesISmIPErQIGYKsTI2tfwszzSP+ZoBJUuA3XlmkG1kQKpBaCftP8wWLLv2
DvOE/0r8rI4fBicfW+GCv6rsZ7YfenNLpZDWA9XItcDcXaw3M1Ynnmxf3hQQ32gx
UInf0U7QexJAscq4oinryX97YsW1lJgr6oNKUrOEHYm7toNRPC51oqNsosbQUqbl
lOPY2ph9WIs4o1YpwEzHTl0BThZX
-----END PRIVATE KEY-----



=== ./icn_api/Cargo.toml ===
[package]
name = "icn_api"
version = "0.1.0"
edition = "2021"

[dependencies]



=== ./icn_api/src/lib/mod.rs ===



=== ./icn_api/src/lib.rs ===
pub fn add(left: u64, right: u64) -> u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}



