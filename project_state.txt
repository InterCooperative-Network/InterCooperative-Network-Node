=== ./generate_project_state.sh ===
#!/bin/bash

# Define the output file
output_file="project_state.txt"

# Clear the output file if it exists
> $output_file

# Function to write file contents to the output file
write_file_content() {
    local file_path="$1"
    echo "=== $file_path ===" >> $output_file
    cat "$file_path" >> $output_file
    echo -e "\n\n" >> $output_file
}

# Recursively list all files and append their content, excluding build artifacts and temporary files
find . -type f \
    -not -path "./.git/*" \
    -not -path "./target/*" \
    -not -path "./**/node_modules/*" \
    -not -path "./**/*.o" \
    -not -path "./**/*.rs.bk" \
    -not -path "./**/*.log" \
    -not -name "*.txt" \
    -not -name "*.md" | while read file; do
    write_file_content "$file"
done

echo "Project state saved to $output_file"



=== ./icn_networking/Cargo.toml ===
[package]
name = "icn_networking"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1.0", features = ["full"] }
tokio-native-tls = "0.3"
native-tls = "0.2"
log = "0.4"
icn_shared = { path = "../icn_shared" }



=== ./icn_networking/src/lib/mod.rs ===



=== ./icn_networking/src/lib.rs ===
// File: icn_networking/src/lib.rs

use std::sync::{Arc, Mutex};
use tokio::net::{TcpListener, TcpStream};
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio_native_tls::TlsAcceptor;
use native_tls::{Identity, TlsAcceptor as NativeTlsAcceptor};
use icn_shared::{IcnError, IcnResult};
use log::{info, error};

/// Represents the networking component of the ICN node
pub struct Networking {
    /// A list of connected peers, protected by a Mutex for thread-safety
    peers: Arc<Mutex<Vec<tokio_native_tls::TlsStream<TcpStream>>>>,
}

impl Networking {
    /// Creates a new Networking instance
    pub fn new() -> Self {
        Networking {
            peers: Arc::new(Mutex::new(vec![])),
        }
    }

    /// Starts a TLS server to accept incoming connections from peers
    ///
    /// # Arguments
    ///
    /// * `address` - The address to bind the server to (e.g., "127.0.0.1:8080")
    /// * `identity` - The TLS identity for the server, containing the certificate and private key
    pub async fn start_server(&self, address: &str, identity: Identity) -> IcnResult<()> {
        let acceptor = TlsAcceptor::from(
            NativeTlsAcceptor::new(identity)
                .map_err(|e| IcnError::Network(format!("Failed to create TLS acceptor: {}", e)))?
        );

        let listener = TcpListener::bind(address).await
            .map_err(|e| IcnError::Network(format!("Failed to bind to address: {}", e)))?;
        info!("Server started on {}", address);

        loop {
            match listener.accept().await {
                Ok((stream, _)) => {
                    let acceptor = acceptor.clone();
                    let peers = Arc::clone(&self.peers);

                    tokio::spawn(async move {
                        match acceptor.accept(stream).await {
                            Ok(tls_stream) => {
                                if let Err(e) = handle_client(tls_stream, peers).await {
                                    error!("Error handling client: {:?}", e);
                                }
                            }
                            Err(e) => error!("Failed to accept TLS connection: {:?}", e),
                        }
                    });
                }
                Err(e) => error!("Failed to accept TCP connection: {:?}", e),
            }
        }
    }

    /// Establishes a TLS connection to a peer at the specified address
    ///
    /// # Arguments
    ///
    /// * `address` - The address of the peer to connect to (e.g., "127.0.0.1:8080")
    pub async fn connect_to_peer(&self, address: &str) -> IcnResult<()> {
        let connector = tokio_native_tls::TlsConnector::from(
            native_tls::TlsConnector::new()
                .map_err(|e| IcnError::Network(format!("Failed to create TLS connector: {}", e)))?
        );

        let stream = TcpStream::connect(address).await
            .map_err(|e| IcnError::Network(format!("Failed to connect to peer: {}", e)))?;

        let tls_stream = connector.connect(address, stream).await
            .map_err(|e| IcnError::Network(format!("Failed to establish TLS connection: {}", e)))?;

        // Add the connected peer to the list
        self.peers.lock().unwrap().push(tls_stream);
        info!("Connected to peer at {}", address);
        Ok(())
    }

    /// Broadcasts a message to all connected peers
    ///
    /// # Arguments
    ///
    /// * `message` - The message to broadcast
    pub async fn broadcast_message(&self, message: &str) -> IcnResult<()> {
        let mut peers = self.peers.lock().unwrap();
        for peer in peers.iter_mut() {
            peer.write_all(message.as_bytes()).await
                .map_err(|e| IcnError::Network(format!("Failed to send message: {}", e)))?;
        }
        Ok(())
    }

    /// Initializes the networking component
    pub async fn initialize(&self) -> IcnResult<()> {
        // Initialization logic here (e.g., loading peer addresses from configuration)
        Ok(())
    }

    /// Stops the networking component, closing all connections
    pub async fn stop(&self) -> IcnResult<()> {
        // Stop logic here (e.g., gracefully closing connections to peers)
        Ok(())
    }
}

/// Handles incoming client connections, processes received messages, and manages peer disconnections
///
/// # Arguments
///
/// * `stream` - The TLS stream representing the connection to the client
/// * `peers` - A shared list of connected peers
async fn handle_client(mut stream: tokio_native_tls::TlsStream<TcpStream>, peers: Arc<Mutex<Vec<tokio_native_tls::TlsStream<TcpStream>>>>) -> IcnResult<()> {
    let mut buffer = [0; 1024];
    loop {
        match stream.read(&mut buffer).await {
            Ok(0) => {
                // Connection closed gracefully
                break;
            }
            Ok(n) => {
                let message = String::from_utf8_lossy(&buffer[..n]);
                info!("Received message: {}", message);

                // TODO: Process the message here
                // This could involve:
                // - Parsing the message based on a defined protocol
                // - Routing the message to the appropriate module (e.g., consensus, blockchain)
                // - Taking corresponding actions based on the message content
            }
            Err(e) => {
                error!("Error reading from stream: {:?}", e);
                break;
            }
        }
    }

    // Remove the disconnected peer from the list
    let mut peers = peers.lock().unwrap();
    peers.retain(|p| !std::ptr::eq(p.get_ref(), stream.get_ref()));
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use tokio::runtime::Runtime;

    #[test]
    fn test_networking_creation() {
        let networking = Networking::new();
        assert_eq!(networking.peers.lock().unwrap().len(), 0);
    }

    #[test]
    fn test_connect_to_peer() {
        let runtime = Runtime::new().unwrap();
        let networking = Networking::new();

        // This test requires a running TLS server to connect to
        // For a real test, you'd need to set up a mock TLS server
        // Here, we'll just test that the method doesn't panic
        runtime.block_on(async {
            let result = networking.connect_to_peer("localhost:8080").await;
            assert!(result.is_err()); // Expect an error since we're not actually connecting
        });
    }

    // Add more tests for other methods
}


=== ./icn_shared/Cargo.toml ===
[package]
name = "icn_shared"
version = "0.1.0"
edition = "2018"

[dependencies]
serde = "1.0"
serde_json = "1.0"
log = "0.4"
native-tls = "0.2"  # Add this line



=== ./icn_shared/src/lib.rs ===
// File: icn_shared/src/lib.rs

use std::error::Error;
use std::fmt;
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum IcnError {
    Config(String),
    Blockchain(String),
    Consensus(String),
    Network(String),
    SmartContract(String),
    Storage(String),
    Io(String),
    Other(String),
}

impl fmt::Display for IcnError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            IcnError::Config(msg) => write!(f, "Configuration error: {}", msg),
            IcnError::Blockchain(msg) => write!(f, "Blockchain error: {}", msg),
            IcnError::Consensus(msg) => write!(f, "Consensus error: {}", msg),
            IcnError::Network(msg) => write!(f, "Network error: {}", msg),
            IcnError::SmartContract(msg) => write!(f, "Smart contract error: {}", msg),
            IcnError::Storage(msg) => write!(f, "Storage error: {}", msg),
            IcnError::Io(msg) => write!(f, "I/O error: {}", msg),
            IcnError::Other(msg) => write!(f, "Other error: {}", msg),
        }
    }
}

impl Error for IcnError {}

impl From<std::io::Error> for IcnError {
    fn from(err: std::io::Error) -> Self {
        IcnError::Io(err.to_string())
    }
}

pub type IcnResult<T> = Result<T, IcnError>;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum NodeState {
    Initializing,
    Operational,
    ShuttingDown,
}

// Add any other shared types or constants here


=== ./config/default_config.toml ===
[node]
name = "MyNode"



=== ./project_parts/core_files_00 ===
./icn_networking/Cargo.toml
./icn_networking/src/lib/mod.rs
./icn_networking/src/lib.rs
./icn_blockchain/Cargo.toml
./icn_blockchain/src/lib/mod.rs
./icn_blockchain/src/transaction/mod.rs
./icn_blockchain/src/lib.rs
./icn_blockchain/src/block/mod.rs
./icn_blockchain/src/chain/mod.rs
./.github/workflows/ci.yml
./.github/workflows/static.yml
./.github/FUNDING.yml
./.vscode/settings.json
./icn_virtual_machine/Cargo.toml
./icn_virtual_machine/src/lib/mod.rs
./icn_virtual_machine/src/lib.rs
./icn_consensus/Cargo.toml
./icn_consensus/src/lib/mod.rs
./icn_consensus/src/lib.rs
./icn_consensus/src/proof_of_cooperation.rs
./icn_governance/Cargo.toml
./icn_governance/src/lib/mod.rs
./icn_governance/src/lib.rs
./Cargo.toml
./icn_core/Cargo.toml
./icn_core/src/config/mod.rs
./icn_core/src/config/config_loader.rs
./icn_core/src/lib/mod.rs
./icn_core/src/main.rs
./icn_core/src/node/mod.rs
./icn_core/src/node/node_manager.rs
./icn_core/src/lib.rs
./icn_core/src/coordinator/module_coordinator.rs
./icn_core/src/coordinator/mod.rs
./icn_storage/Cargo.toml
./icn_storage/src/lib/mod.rs
./icn_storage/src/lib.rs
./icn_identity/Cargo.toml
./icn_identity/src/lib/mod.rs
./icn_identity/src/lib.rs
./icn_smart_contracts/Cargo.toml
./icn_smart_contracts/src/lib/mod.rs
./icn_smart_contracts/src/lib.rs
./icn_api/Cargo.toml
./icn_api/src/lib/mod.rs
./icn_api/src/lib.rs



=== ./icn_blockchain/Cargo.toml ===
[package]
name = "icn_blockchain"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
sha2 = "0.10"
chrono = "0.4"



=== ./icn_blockchain/src/lib/mod.rs ===



=== ./icn_blockchain/src/transaction/mod.rs ===
// icn_blockchain/src/transaction/mod.rs

use serde::{Serialize, Deserialize};

/// Represents the different types of transactions supported by the blockchain
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)] 
pub enum TransactionType {
    Transfer,
    DeployContract,
    // Add more variants as needed
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Transaction {
    pub sender: String,
    pub receiver: String,
    pub amount: u64,
    pub transaction_type: TransactionType, 
}

impl Transaction {
    pub fn new(sender: &str, receiver: &str, amount: u64) -> Self {
        Transaction {
            sender: sender.to_string(),
            receiver: receiver.to_string(),
            amount,
            transaction_type: TransactionType::Transfer, 
        }
    }

    pub fn validate_transaction(&self) -> bool {
        match self.transaction_type {
            TransactionType::Transfer => {
                !self.sender.is_empty() && !self.receiver.is_empty() && self.amount > 0
            }
            TransactionType::DeployContract => {
                // Validation logic specific to DeployContract transactions
                // Add your validation logic here
                false // Placeholder for now
            }
            // Add more match arms for other transaction types as needed
        }
    }
}



=== ./icn_blockchain/src/transaction/transaction_type.rs ===
/// Represents the different types of transactions supported by the blockchain
#[derive(Debug, Clone, PartialEq, Eq)] // Add necessary derives based on your project's requirements
pub enum TransactionType {
    Transfer,
    DeployContract,
    // Add more variants as needed
}



=== ./icn_blockchain/src/lib.rs ===
// icn_blockchain/src/lib.rs

pub mod block;
pub mod chain;
pub mod transaction; // Ensure this line is included to expose the transaction module

pub use block::Block;
pub use chain::Chain;
pub use transaction::Transaction; // Add this to expose Transaction if needed



=== ./icn_blockchain/src/block/mod.rs ===
// icn_blockchain/src/block/mod.rs

use serde::{Serialize, Deserialize};
use sha2::{Sha256, Digest};
use chrono::Utc;
use crate::transaction::Transaction; // Corrected import path

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Block {
    pub index: u64,
    pub timestamp: i64,
    pub transactions: Vec<Transaction>,
    pub previous_hash: String,
    pub hash: String,
    pub proposer_id: String,
    pub nonce: u64,
}

impl Block {
    pub fn new(
        index: u64,
        transactions: Vec<Transaction>,
        previous_hash: String,
        proposer_id: String,
    ) -> Self {
        let mut block = Block {
            index,
            timestamp: Utc::now().timestamp(),
            transactions,
            previous_hash,
            hash: String::new(),
            proposer_id,
            nonce: 0,
        };
        block.hash = block.calculate_hash();
        block
    }


    pub fn calculate_hash(&self) -> String {
        let mut hasher = Sha256::new();
        hasher.update(format!(
            "{}{}{}{}{}{}", // Fixed formatting by adding the missing placeholder
            self.index,
            self.timestamp,
            serde_json::to_string(&self.transactions).unwrap(),
            self.previous_hash,
            self.proposer_id,
            self.nonce
        ));
        format!("{:x}", hasher.finalize())
    }

    pub fn mine(&mut self, difficulty: usize) {
        let target = vec![0; difficulty];
        let target_str = String::from_utf8(target).unwrap(); // Moved outside the loop

        while !self.hash.starts_with(&target_str) {
            self.nonce += 1;
            self.hash = self.calculate_hash();
        }
    }

    pub fn is_valid(&self) -> bool {
        self.hash == self.calculate_hash()
    }
}



=== ./icn_blockchain/src/chain/mod.rs ===
// icn_blockchain/src/chain/mod.rs

use crate::block::Block;
use crate::transaction::Transaction;

pub struct Chain {
    pub blocks: Vec<Block>,
}

impl Chain {
    pub fn new() -> Self {
        let genesis_block = Block::new(
            0, 
            vec![], 
            String::from("0"), 
            String::from("genesis_proposer")
        );

        Chain {
            blocks: vec![genesis_block],
        }
    }

    pub fn add_block(&mut self, transactions: Vec<Transaction>, previous_hash: String, proposer_id: String) {
        let previous_block = self.blocks.last().unwrap();
        let new_block = Block::new(
            previous_block.index + 1,
            transactions,
            previous_hash,
            proposer_id
        );
        self.blocks.push(new_block);
    }
}



=== ./.github/workflows/ci.yml ===
# name: Rust CI

# on:
#   push:
#     branches: [ main ]
#   pull_request:
#     branches: [ main ]

# env:
#   CARGO_TERM_COLOR: always

# jobs:
#   build:
#     runs-on: ubuntu-latest
#     steps:
#     - uses: actions/checkout@v2
#     - name: Build
#       run: cargo build --verbose
#     - name: Run tests
#       run: cargo test --verbose


=== ./.github/workflows/static.yml ===
# Simple workflow for deploying static content to GitHub Pages
name: Deploy static content to Pages

on:
  # Runs on pushes targeting the default branch
  push:
    branches: ["main"]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # Single deploy job since we're just deploying
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Pages
        uses: actions/configure-pages@v5
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          # Upload entire repository
          path: '.'
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4



=== ./.github/FUNDING.yml ===
#github: [fahertym]
#patreon: InterCooperativeNetwork
open_collective: intercooperative-network



=== ./.vscode/settings.json ===
{
    "liveServer.settings.port": 5501
}


=== ./icn_virtual_machine/Cargo.toml ===
[package]
name = "icn_virtual_machine"
version = "0.1.0"
edition = "2021"

[dependencies]



=== ./icn_virtual_machine/src/lib/mod.rs ===



=== ./icn_virtual_machine/src/bytecode.rs ===
// icn_virtual_machine/src/bytecode.rs

/// The `Bytecode` struct represents the compiled code of a smart contract.
/// It contains a vector of bytes that the virtual machine can execute.
pub struct Bytecode {
    pub code: Vec<u8>,
}

impl Bytecode {
    /// Creates a new instance of `Bytecode`.
    pub fn new(code: Vec<u8>) -> Self {
        Bytecode { code }
    }
}



=== ./icn_virtual_machine/src/lib.rs ===
// icn_virtual_machine/src/lib.rs
pub mod bytecode;
pub mod execution_engine;

use bytecode::Bytecode;
use execution_engine::ExecutionEngine;

/// The `VirtualMachine` struct is responsible for executing smart contracts.
/// It processes bytecode using an execution engine.
pub struct VirtualMachine {
    engine: ExecutionEngine,
}

impl VirtualMachine {
    /// Creates a new instance of the `VirtualMachine`.
    pub fn new() -> Self {
        VirtualMachine {
            engine: ExecutionEngine::new(),
        }
    }

    /// Executes a smart contract represented by bytecode.
    ///
    /// # Arguments
    ///
    /// * `bytecode` - The bytecode to be executed.
    ///
    /// # Returns
    ///
    /// * `Result<(), String>` - `Ok` if execution succeeds, otherwise an error message.
    pub fn execute(&mut self, bytecode: Bytecode) -> Result<(), String> {
        self.engine.execute(bytecode)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_virtual_machine_execution() {
        let mut vm = VirtualMachine::new();
        let bytecode = Bytecode::new(vec![0x01, 0x02, 0x03]);

        // Test execution with non-empty bytecode
        assert!(vm.execute(bytecode).is_ok());

        // Test execution with empty bytecode
        let empty_bytecode = Bytecode::new(vec![]);
        assert!(vm.execute(empty_bytecode).is_err());
    }
}



=== ./icn_virtual_machine/src/execution_engine.rs ===
// icn_virtual_machine/src/execution_engine.rs

use crate::bytecode::Bytecode;

/// The `ExecutionEngine` struct is responsible for processing bytecode
/// and executing smart contracts.
pub struct ExecutionEngine;

impl ExecutionEngine {
    /// Creates a new `ExecutionEngine` instance.
    pub fn new() -> Self {
        ExecutionEngine
    }

    /// Executes the provided bytecode.
    /// The logic here will interpret and run the bytecode.
    pub fn execute(&self, bytecode: Bytecode) -> Result<(), String> {
        if bytecode.code.is_empty() {
            return Err("Bytecode is empty".to_string());
        }

        // Example: Interpreting and executing the bytecode
        // This is a placeholder, actual implementation should parse and execute bytecode instructions.
        for instruction in bytecode.code {
            match instruction {
                0x01 => println!("Instruction: 0x01 - No-op"),
                _ => return Err(format!("Unknown instruction: 0x{:x}", instruction)),
            }
        }

        Ok(())
    }
}



=== ./.gitmodules ===



=== ./icn_consensus/Cargo.toml ===
[package]
name = "icn_consensus"
version = "0.1.0"
edition = "2018"

[dependencies]
icn_shared = { path = "../icn_shared" }
icn_blockchain = { path = "../icn_blockchain" }
log = "0.4"
rand = "0.8"  # Add this line



=== ./icn_consensus/src/lib/mod.rs ===



=== ./icn_consensus/src/lib.rs ===
// icn_consensus/src/lib.rs

use std::collections::{HashMap, HashSet};
use icn_blockchain::block::Block;
use icn_shared::{IcnError, IcnResult};
use rand::Rng;
use std::time::{SystemTime, UNIX_EPOCH};
use log::info;

pub struct ProofOfCooperation {
    known_peers: HashSet<String>,
    cooperation_scores: HashMap<String, f64>,
    last_block_time: u64,
}

impl ProofOfCooperation {
    pub fn new() -> Self {
        ProofOfCooperation {
            known_peers: HashSet::new(),
            cooperation_scores: HashMap::new(),
            last_block_time: 0,
        }
    }

    pub fn register_peer(&mut self, peer_id: &str) {
        self.known_peers.insert(peer_id.to_string());
        self.cooperation_scores.insert(peer_id.to_string(), 1.0);
        info!("Registered peer: {}", peer_id);
    }

    pub fn is_registered(&self, peer_id: &str) -> bool {
        self.known_peers.contains(peer_id)
    }

    pub fn validate(&mut self, block: &Block) -> IcnResult<bool> {
        if !self.is_registered(&block.proposer_id) {
            return Err(IcnError::Consensus(format!("Unknown proposer: {}", block.proposer_id)));
        }

        let current_time = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .map_err(|e| IcnError::Consensus(format!("System time error: {}", e)))?
            .as_secs();

        if current_time < self.last_block_time + 10 {
            return Err(IcnError::Consensus("Block proposed too soon".to_string()));
        }

        // Update last block time
        self.last_block_time = current_time;

        // Implement additional validation logic here
        // For example, check block signature, transaction validity, etc.

        Ok(true)
    }

    pub fn select_proposer(&self) -> IcnResult<String> {
        let mut rng = rand::thread_rng();
        let total_score: f64 = self.cooperation_scores.values().sum();
        let random_value: f64 = rng.gen::<f64>() * total_score;

        let mut cumulative_score = 0.0;
        for (peer_id, score) in &self.cooperation_scores {
            cumulative_score += score;
            if cumulative_score >= random_value {
                return Ok(peer_id.clone());
            }
        }

        Err(IcnError::Consensus("Failed to select a proposer".to_string()))
    }

    pub fn update_cooperation_score(&mut self, peer_id: &str, performance: f64) -> IcnResult<()> {
        let score = self.cooperation_scores
            .get_mut(peer_id)
            .ok_or_else(|| IcnError::Consensus(format!("Unknown peer: {}", peer_id)))?;
        
        *score = (*score * performance).max(0.1).min(2.0);
        Ok(())
    }

    pub fn handle_fork<'a>(&self, chain_a: &'a [Block], chain_b: &'a [Block]) -> &'a [Block] {
        // Simple longest chain rule for now
        if chain_a.len() >= chain_b.len() {
            chain_a
        } else {
            chain_b
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_blockchain::block::Block;

    #[test]
    fn test_register_and_validate_peer() {
        let mut poc = ProofOfCooperation::new();
        poc.register_peer("peer1");
        
        let block = Block::new(0, vec![], "0".to_string(), "peer1".to_string());
        assert!(poc.validate(&block).is_ok());

        let invalid_block = Block::new(0, vec![], "0".to_string(), "unknown_peer".to_string());
        assert!(poc.validate(&invalid_block).is_err());
    }

    #[test]
    fn test_select_proposer() {
        let mut poc = ProofOfCooperation::new();
        poc.register_peer("peer1");
        poc.register_peer("peer2");
        
        let proposer = poc.select_proposer().unwrap();
        assert!(vec!["peer1", "peer2"].contains(&proposer.as_str()));
    }

    #[test]
    fn test_update_cooperation_score() {
        let mut poc = ProofOfCooperation::new();
        poc.register_peer("peer1");
        
        poc.update_cooperation_score("peer1", 1.5).unwrap();
        assert!(poc.cooperation_scores["peer1"] > 1.0);

        poc.update_cooperation_score("peer1", 0.5).unwrap();
        assert!(poc.cooperation_scores["peer1"] < 1.0);
    }
}



=== ./icn_consensus/src/proof_of_cooperation.rs ===
use std::collections::{HashMap, HashSet};
use icn_blockchain::block::Block;
use icn_shared::{IcnError, IcnResult};
use rand::Rng;
use std::time::{SystemTime, UNIX_EPOCH};

/// The `ProofOfCooperation` struct implements the Proof of Cooperation consensus mechanism.
pub struct ProofOfCooperation {
    known_peers: HashSet<String>,
    cooperation_scores: HashMap<String, f64>,
    last_block_time: u64,
}

impl ProofOfCooperation {
    /// Creates a new `ProofOfCooperation` instance.
    pub fn new() -> Self {
        ProofOfCooperation {
            known_peers: HashSet::new(),
            cooperation_scores: HashMap::new(),
            last_block_time: 0,
        }
    }

    /// Registers a peer in the consensus mechanism.
    ///
    /// # Arguments
    ///
    /// * `peer_id` - The ID of the peer to register.
    pub fn register_peer(&mut self, peer_id: &str) {
        self.known_peers.insert(peer_id.to_string());
        self.cooperation_scores.insert(peer_id.to_string(), 1.0);
    }

    /// Checks if a peer is registered in the consensus mechanism.
    ///
    /// # Arguments
    ///
    /// * `peer_id` - The ID of the peer to check.
    ///
    /// # Returns
    ///
    /// * `bool` - `true` if the peer is registered, otherwise `false`.
    pub fn is_registered(&self, peer_id: &str) -> bool {
        self.known_peers.contains(peer_id)
    }

    /// Validates a block according to the Proof of Cooperation consensus mechanism.
    ///
    /// # Arguments
    ///
    /// * `block` - The block to validate.
    ///
    /// # Returns
    ///
    /// * `IcnResult<bool>` - `true` if the block is valid, otherwise an `IcnError`.
    pub fn validate(&mut self, block: &Block) -> IcnResult<bool> {
        if !self.is_registered(&block.proposer_id) {
            return Err(IcnError::Consensus(format!("Unknown proposer: {}", block.proposer_id)));
        }

        let current_time = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .map_err(|e| IcnError::Other(format!("System time error: {}", e)))?
            .as_secs();

        if current_time < self.last_block_time + 10 {
            return Err(IcnError::Consensus("Block proposed too soon".to_string()));
        }

        // Update last block time
        self.last_block_time = current_time;

        // Additional validation logic here (e.g., checking signatures, ensuring cooperation)
        Ok(true)
    }

    /// Selects a proposer based on cooperation scores.
    ///
    /// # Returns
    ///
    /// * `IcnResult<String>` - The selected proposer ID or an `IcnError` if selection fails.
    pub fn select_proposer(&self) -> IcnResult<String> {
        let mut rng = rand::thread_rng();
        let total_score: f64 = self.cooperation_scores.values().sum();
        let random_value: f64 = rng.gen::<f64>() * total_score;

        let mut cumulative_score = 0.0;
        for (peer_id, score) in &self.cooperation_scores {
            cumulative_score += score;
            if cumulative_score >= random_value {
                return Ok(peer_id.clone());
            }
        }

        Err(IcnError::Consensus("Failed to select a proposer".to_string()))
    }

    /// Updates the cooperation score of a peer.
    ///
    /// # Arguments
    ///
    /// * `peer_id` - The ID of the peer.
    /// * `performance` - The performance factor to update the score with.
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - An empty result indicating success or an `IcnError` if the peer is unknown.
    pub fn update_cooperation_score(&mut self, peer_id: &str, performance: f64) -> IcnResult<()> {
        let score = self.cooperation_scores
            .get_mut(peer_id)
            .ok_or_else(|| IcnError::Consensus(format!("Unknown peer: {}", peer_id)))?;
        
        *score = (*score * performance).max(0.1).min(2.0);
        Ok(())
    }

    /// Handles a blockchain fork by selecting the most valid chain.
    ///
    /// # Arguments
    ///
    /// * `chain_a` - The first chain to compare.
    /// * `chain_b` - The second chain to compare.
    ///
    /// # Returns
    ///
    /// * `&[Block]` - The selected chain.
    pub fn handle_fork<'a>(&self, chain_a: &'a [Block], chain_b: &'a [Block]) -> &'a [Block] {
        // Simple longest chain rule for now
        if chain_a.len() >= chain_b.len() {
            chain_a
        } else {
            chain_b
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_blockchain::block::Block;

    #[test]
    fn test_register_and_validate_peer() {
        let mut poc = ProofOfCooperation::new();
        poc.register_peer("peer1");
        
        let block = Block::new(0, 0, vec![], "peer1".to_string(), "hash".to_string(), "peer1".to_string());
        assert!(poc.validate(&block).is_ok());

        let invalid_block = Block::new(0, 0, vec![], "unknown_peer".to_string(), "hash".to_string(), "unknown_peer".to_string());
        assert!(poc.validate(&invalid_block).is_err());
    }

    #[test]
    fn test_select_proposer() {
        let mut poc = ProofOfCooperation::new();
        poc.register_peer("peer1");
        poc.register_peer("peer2");
        
        let proposer = poc.select_proposer().unwrap();
        assert!(vec!["peer1", "peer2"].contains(&proposer.as_str()));
    }

    #[test]
    fn test_update_cooperation_score() {
        let mut poc = ProofOfCooperation::new();
        poc.register_peer("peer1");
        
        poc.update_cooperation_score("peer1", 1.5).unwrap();
        assert!(poc.cooperation_scores["peer1"] > 1.0);

        poc.update_cooperation_score("peer1", 0.5).unwrap();
        assert!(poc.cooperation_scores["peer1"] < 1.0);
    }
}



=== ./icn_governance/Cargo.toml ===
[package]
name = "icn_governance"
version = "0.1.0"
edition = "2021"

[dependencies]



=== ./icn_governance/src/lib/mod.rs ===



=== ./icn_governance/src/lib.rs ===
pub struct Proposal {
    pub id: u32,
    pub description: String,
    pub votes_for: u32,
    pub votes_against: u32,
}

impl Proposal {
    pub fn new(id: u32, description: &str) -> Self {
        Proposal {
            id,
            description: description.to_string(),
            votes_for: 0,
            votes_against: 0,
        }
    }

    pub fn vote_for(&mut self) {
        self.votes_for += 1;
    }

    pub fn vote_against(&mut self) {
        self.votes_against += 1;
    }
}



=== ./ca-bundle.crt ===



=== ./private.key ===
-----BEGIN PRIVATE KEY-----
MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCimkgO66phw4qN
6+fC37JTRI91L8Efir0T+Q7yHYUU2R1LKfIyHxY1CZzxb0JGi7VTI1Ps5kH7pzfw
s++wyWDo6by1byJMW8ngiP0fLTe1iRfnQWw7bV36ndh0rFakfw9EmmCuWSHuMDcI
YwJ2JUG3XHh7NXc4vls3J2SYF3/aq5/Ak++Ga4/OOJDRlGILaidw3whc0zB7K4JV
p5yqHYoMq2cjwtBFpElvzVp/TDwd25JBXug/d5W1aIi7KPWYJzQL4Nf2ZL/P8kEv
tRi2TkLIRawTl9Wdf6YT87Up9qYQDhu/n4GzVExJbc0wFP130pUW/pvsuksef0cy
wB/FvA3pAgMBAAECggEADG8WzolH5KTyzep5tQWtGb/25mOp9XMDBWl4spv+RrtZ
iZtiCWImLRUYmr/Cxik9yuc7LjTnW8qMNQxVamPj1Lu28frXGRa1x8VB8eXfyjJ7
EPSIRb0VwCnc2QMqtvZ+YOUbOonXVeL6+lmz4Pv1XAOmtOlAPicUS5HoF9dIMBzr
Z174rfyYKMMLacxxj293Vtg8PnkZeoOXZfK23I7z4QFubAvDR/RBsNq7kQvis5Hr
VxRFB/lr47jqvsFWm12MsELaqkY7DNQEtadsANEE256SZqivveXV3xSk3kvYbkTE
fRHoytV06VUxo1d4BHBMcFmkpp+aLT8TVKKK2DxXGQKBgQDTubwByvbwsp0zg7K3
qufMqxG49eW4WDe5fRxJTdD7yJMRDNgM65k9zpMisfqUOrq/3c6Vd35bOQh2FTM8
blbvMizZTB0odNuG25C6skVFFwdNTcZb92s4OK9N58M+PWIKo4y1iLHCdJVqT3Ed
qH/Ya88JmvHCLmSg1k757XUvlQKBgQDEmtyGAufuzcw90eLSdRgWxBZAX4dVEAXL
rc7XRGbkV5e9YSfxd9kNxQO+FWyj57GlNN5luGVTdTVEcecLSymVfmqeV68/IiDX
GtinqiD3HwYGcHR1gbsL6Ptot6398tgPsAoEs9Ru+QgmXlK8pO8h4Y8Yhm+8+SIA
dbv8GKGgBQKBgCQTjtyDWAZ1eOHRO/+dyHeQYqmwhJ8fsQcTMWGwN77fU2fhV2ME
Ng1ZCKstxnPBeha9VbkULlye4Dk2rY9LgdaqJwgztvgwyUM2YHffbnwyS1U5vmXn
R8bBqeVNa3BMh0smyRAZpahrsxX1SWHzVy1qWVHaq/0ZaJ4bRkPB2WjtAoGABDud
UdlQKwkNQ6t4KbXRrfPM0tf7ru4oYck9Mc9MM9Ba+P3VgVJmPvCl8vq9Gw5K+daY
jzIYJGLaob2eDtUwcQKGwx/6Ku7OLDNsxLdZ/FgTpiHXsAv5/finKQsDWPtYgYX1
wUIp6bW84i6Xs24No/oaPZnvX+8xNzdRs8zH9g0CgYA8R6Agf9A2xki3oUQQoOAP
IjQW43RvN5HsD5UW5UqLJEMgf1hOyh0jwDAYVIxya+36yRnLxtePh1C8W8+3xeod
q8lbFk+CJMNprbCliRm7vlUAlK9c9ddUGuuCxjQ5QihGLHh/MdKmdLdD4VNqt4cO
dQTRbDPlNRzDQQfAqfQYMw==
-----END PRIVATE KEY-----



=== ./Cargo.toml ===
[workspace]
members = [
    "icn_core",
    "icn_blockchain",
    "icn_consensus",
    "icn_networking",
    "icn_identity",
    "icn_governance",
    "icn_smart_contracts",
    "icn_virtual_machine",
    "icn_api",
    "icn_storage",
    "icn_shared"
]
default-run = "icn_core"

resolver = "2"


=== ./Cargo.lock ===
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "addr2line"
version = "0.22.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e4503c46a5c0c7844e948c9a4d6acd9f50cccb4de1c48eb9e291ea17470c678"
dependencies = [
 "gimli",
]

[[package]]
name = "adler"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe"

[[package]]
name = "ahash"
version = "0.7.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "891477e0c6a8957309ee5c45a6368af3ae14bb510732d2684ffa19af310920f9"
dependencies = [
 "getrandom",
 "once_cell",
 "version_check",
]

[[package]]
name = "aho-corasick"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
dependencies = [
 "memchr",
]

[[package]]
name = "android-tzdata"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0"

[[package]]
name = "android_system_properties"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
dependencies = [
 "libc",
]

[[package]]
name = "async-trait"
version = "0.1.81"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e0c28dcc82d7c8ead5cb13beb15405b57b8546e93215673ff8ca0349a028107"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "autocfg"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0c4b4d0bd25bd0b74681c0ad21497610ce1b7c91b1022cd21c80c6fbdd9476b0"

[[package]]
name = "backtrace"
version = "0.3.73"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5cc23269a4f8976d0a4d2e7109211a419fe30e8d88d677cd60b6bc79c5732e0a"
dependencies = [
 "addr2line",
 "cc",
 "cfg-if",
 "libc",
 "miniz_oxide",
 "object",
 "rustc-demangle",
]

[[package]]
name = "base64"
version = "0.13.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e1b586273c5702936fe7b7d6896644d8be71e6314cfe09d3167c95f712589e8"

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b048fb63fd8b5923fc5aa7b340d8e156aec7ec02f0c78fa8a6ddc2613f6f71de"

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array",
]

[[package]]
name = "bumpalo"
version = "3.16.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "79296716171880943b8470b5f8d03aa55eb2e645a4874bdbb28adb49162e012c"

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "bytes"
version = "1.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8318a53db07bb3f8dca91a600466bdb3f2eaadeedfdbcf02e1accbad9271ba50"

[[package]]
name = "cc"
version = "1.1.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72db2f7947ecee9b03b510377e8bb9077afa27176fdbff55c51027e976fdcc48"
dependencies = [
 "shlex",
]

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "chrono"
version = "0.4.38"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a21f936df1771bf62b77f047b726c4625ff2e8aa607c01ec06e5a05bd8463401"
dependencies = [
 "android-tzdata",
 "iana-time-zone",
 "js-sys",
 "num-traits",
 "wasm-bindgen",
 "windows-targets",
]

[[package]]
name = "config"
version = "0.13.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "23738e11972c7643e4ec947840fc463b6a571afcd3e735bdfce7d03c7a784aca"
dependencies = [
 "async-trait",
 "json5",
 "lazy_static",
 "nom",
 "pathdiff",
 "ron",
 "rust-ini",
 "serde",
 "serde_json",
 "toml",
 "yaml-rust",
]

[[package]]
name = "core-foundation"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "91e195e091a93c46f7102ec7818a2aa394e1e1771c3ab4825963fa03e45afb8f"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "core-foundation-sys"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"

[[package]]
name = "cpufeatures"
version = "0.2.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "51e852e6dc9a5bed1fae92dd2375037bf2b768725bf3be87811edee3249d09ad"
dependencies = [
 "libc",
]

[[package]]
name = "crypto-common"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
dependencies = [
 "generic-array",
 "typenum",
]

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer",
 "crypto-common",
]

[[package]]
name = "dlv-list"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0688c2a7f92e427f44895cd63841bff7b29f8d7a1648b9e7e07a4a365b2e1257"

[[package]]
name = "env_logger"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4cd405aab171cb85d6735e5c8d9db038c17d3ca007a4d2c25f337935c3d90580"
dependencies = [
 "humantime",
 "is-terminal",
 "log",
 "regex",
 "termcolor",
]

[[package]]
name = "errno"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "534c5cf6194dfab3db3242765c03bbe257cf92f22b38f6bc0c58d59108a820ba"
dependencies = [
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "fastrand"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fc0510504f03c51ada170672ac806f1f105a88aa97a5281117e1ddc3368e51a"

[[package]]
name = "foreign-types"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6f339eb8adc052cd2ca78910fda869aefa38d22d5cb648e6485e4d3fc06f3b1"
dependencies = [
 "foreign-types-shared",
]

[[package]]
name = "foreign-types-shared"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00b0228411908ca8685dba7fc2cdd70ec9990a6e753e89b6ac91a84c40fbaf4b"

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "typenum",
 "version_check",
]

[[package]]
name = "getrandom"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c4567c8db10ae91089c99af84c68c38da3ec2f087c3f82960bcdbf3656b6f4d7"
dependencies = [
 "cfg-if",
 "libc",
 "wasi",
]

[[package]]
name = "gimli"
version = "0.29.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "40ecd4077b5ae9fd2e9e169b102c6c330d0605168eb0e8bf79952b256dbefffd"

[[package]]
name = "hashbrown"
version = "0.12.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888"
dependencies = [
 "ahash",
]

[[package]]
name = "hermit-abi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d231dfb89cfffdbc30e7fc41579ed6066ad03abda9e567ccafae602b97ec5024"

[[package]]
name = "hermit-abi"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fbf6a919d6cf397374f7dfeeea91d974c7c0a7221d0d0f4f20d859d329e53fcc"

[[package]]
name = "humantime"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a3a5bfb195931eeb336b2a7b4d761daec841b97f947d34394601737a7bba5e4"

[[package]]
name = "iana-time-zone"
version = "0.1.60"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7ffbb5a1b541ea2561f8c41c087286cc091e21e556a4f09a8f6cbf17b69b141"
dependencies = [
 "android_system_properties",
 "core-foundation-sys",
 "iana-time-zone-haiku",
 "js-sys",
 "wasm-bindgen",
 "windows-core",
]

[[package]]
name = "iana-time-zone-haiku"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
dependencies = [
 "cc",
]

[[package]]
name = "icn_api"
version = "0.1.0"

[[package]]
name = "icn_blockchain"
version = "0.1.0"
dependencies = [
 "chrono",
 "serde",
 "serde_json",
 "sha2",
]

[[package]]
name = "icn_consensus"
version = "0.1.0"
dependencies = [
 "icn_blockchain",
 "icn_shared",
 "log",
 "rand",
]

[[package]]
name = "icn_core"
version = "0.1.0"
dependencies = [
 "config",
 "env_logger",
 "icn_blockchain",
 "icn_consensus",
 "icn_governance",
 "icn_identity",
 "icn_networking",
 "icn_shared",
 "log",
 "native-tls",
 "tempfile",
 "tokio",
 "toml",
]

[[package]]
name = "icn_governance"
version = "0.1.0"

[[package]]
name = "icn_identity"
version = "0.1.0"
dependencies = [
 "icn_shared",
]

[[package]]
name = "icn_networking"
version = "0.1.0"
dependencies = [
 "icn_shared",
 "log",
 "native-tls",
 "tokio",
 "tokio-native-tls",
]

[[package]]
name = "icn_shared"
version = "0.1.0"
dependencies = [
 "log",
 "native-tls",
 "serde",
 "serde_json",
]

[[package]]
name = "icn_smart_contracts"
version = "0.1.0"

[[package]]
name = "icn_storage"
version = "0.1.0"
dependencies = [
 "icn_blockchain",
]

[[package]]
name = "icn_virtual_machine"
version = "0.1.0"

[[package]]
name = "is-terminal"
version = "0.4.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "261f68e344040fbd0edea105bef17c66edf46f984ddb1115b775ce31be948f4b"
dependencies = [
 "hermit-abi 0.4.0",
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "itoa"
version = "1.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49f1f14873335454500d59611f1cf4a4b0f786f9ac11f4312a78e4cf2566695b"

[[package]]
name = "js-sys"
version = "0.3.70"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1868808506b929d7b0cfa8f75951347aa71bb21144b7791bae35d9bccfcfe37a"
dependencies = [
 "wasm-bindgen",
]

[[package]]
name = "json5"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96b0db21af676c1ce64250b5f40f3ce2cf27e4e47cb91ed91eb6fe9350b430c1"
dependencies = [
 "pest",
 "pest_derive",
 "serde",
]

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"

[[package]]
name = "libc"
version = "0.2.158"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d8adc4bb1803a324070e64a98ae98f38934d91957a99cfb3a43dcbc01bc56439"

[[package]]
name = "linked-hash-map"
version = "0.5.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0717cef1bc8b636c6e1c1bbdefc09e6322da8a9321966e8928ef80d20f7f770f"

[[package]]
name = "linux-raw-sys"
version = "0.4.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78b3ae25bc7c8c38cec158d1f2757ee79e9b3740fbc7ccf0e59e4b08d793fa89"

[[package]]
name = "lock_api"
version = "0.4.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07af8b9cdd281b7915f413fa73f29ebd5d55d0d3f0155584dade1ff18cea1b17"
dependencies = [
 "autocfg",
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7a70ba024b9dc04c27ea2f0c0548feb474ec5c54bba33a7f72f873a39d07b24"

[[package]]
name = "memchr"
version = "2.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3"

[[package]]
name = "minimal-lexical"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"

[[package]]
name = "miniz_oxide"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b8a240ddb74feaf34a79a7add65a741f3167852fba007066dcac1ca548d89c08"
dependencies = [
 "adler",
]

[[package]]
name = "mio"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "80e04d1dcff3aae0704555fe5fee3bcfaf3d1fdf8a7e521d5b9d2b42acb52cec"
dependencies = [
 "hermit-abi 0.3.9",
 "libc",
 "wasi",
 "windows-sys 0.52.0",
]

[[package]]
name = "native-tls"
version = "0.2.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8614eb2c83d59d1c8cc974dd3f920198647674a0a035e1af1fa58707e317466"
dependencies = [
 "libc",
 "log",
 "openssl",
 "openssl-probe",
 "openssl-sys",
 "schannel",
 "security-framework",
 "security-framework-sys",
 "tempfile",
]

[[package]]
name = "nom"
version = "7.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
dependencies = [
 "memchr",
 "minimal-lexical",
]

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
]

[[package]]
name = "object"
version = "0.36.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "27b64972346851a39438c60b341ebc01bba47464ae329e55cf343eb93964efd9"
dependencies = [
 "memchr",
]

[[package]]
name = "once_cell"
version = "1.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3fdb12b2476b595f9358c5161aa467c2438859caa136dec86c26fdd2efe17b92"

[[package]]
name = "openssl"
version = "0.10.66"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9529f4786b70a3e8c61e11179af17ab6188ad8d0ded78c5529441ed39d4bd9c1"
dependencies = [
 "bitflags 2.6.0",
 "cfg-if",
 "foreign-types",
 "libc",
 "once_cell",
 "openssl-macros",
 "openssl-sys",
]

[[package]]
name = "openssl-macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a948666b637a0f465e8564c73e89d4dde00d72d4d473cc972f390fc3dcee7d9c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "openssl-probe"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ff011a302c396a5197692431fc1948019154afc178baf7d8e37367442a4601cf"

[[package]]
name = "openssl-sys"
version = "0.9.103"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f9e8deee91df40a943c71b917e5874b951d32a802526c85721ce3b776c929d6"
dependencies = [
 "cc",
 "libc",
 "pkg-config",
 "vcpkg",
]

[[package]]
name = "ordered-multimap"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ccd746e37177e1711c20dd619a1620f34f5c8b569c53590a72dedd5344d8924a"
dependencies = [
 "dlv-list",
 "hashbrown",
]

[[package]]
name = "parking_lot"
version = "0.12.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f1bf18183cf54e8d6059647fc3063646a1801cf30896933ec2311622cc4b9a27"
dependencies = [
 "lock_api",
 "parking_lot_core",
]

[[package]]
name = "parking_lot_core"
version = "0.9.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e401f977ab385c9e4e3ab30627d6f26d00e2c73eef317493c4ec6d468726cf8"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall",
 "smallvec",
 "windows-targets",
]

[[package]]
name = "pathdiff"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8835116a5c179084a830efb3adc117ab007512b535bc1a21c991d3b32a6b44dd"

[[package]]
name = "pest"
version = "2.7.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cd53dff83f26735fdc1ca837098ccf133605d794cdae66acfc2bfac3ec809d95"
dependencies = [
 "memchr",
 "thiserror",
 "ucd-trie",
]

[[package]]
name = "pest_derive"
version = "2.7.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2a548d2beca6773b1c244554d36fcf8548a8a58e74156968211567250e48e49a"
dependencies = [
 "pest",
 "pest_generator",
]

[[package]]
name = "pest_generator"
version = "2.7.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c93a82e8d145725dcbaf44e5ea887c8a869efdcc28706df2d08c69e17077183"
dependencies = [
 "pest",
 "pest_meta",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "pest_meta"
version = "2.7.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a941429fea7e08bedec25e4f6785b6ffaacc6b755da98df5ef3e7dcf4a124c4f"
dependencies = [
 "once_cell",
 "pest",
 "sha2",
]

[[package]]
name = "pin-project-lite"
version = "0.2.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bda66fc9667c18cb2758a2ac84d1167245054bcf85d5d1aaa6923f45801bdd02"

[[package]]
name = "pkg-config"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d231b230927b5e4ad203db57bbcbee2802f6bce620b1e4a9024a07d94e2907ec"

[[package]]
name = "ppv-lite86"
version = "0.2.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77957b295656769bb8ad2b6a6b09d897d94f05c41b069aede1fcdaa675eaea04"
dependencies = [
 "zerocopy",
]

[[package]]
name = "proc-macro2"
version = "1.0.86"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e719e8df665df0d1c8fbfd238015744736151d4445ec0836b8e628aae103b77"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.36"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fa76aaf39101c457836aec0ce2316dbdc3ab723cdda1c6bd4e6ad4208acaca7"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "libc",
 "rand_chacha",
 "rand_core",
]

[[package]]
name = "rand_chacha"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
dependencies = [
 "ppv-lite86",
 "rand_core",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom",
]

[[package]]
name = "redox_syscall"
version = "0.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2a908a6e00f1fdd0dfd9c0eb08ce85126f6d8bbda50017e74bc4a4b7d4a926a4"
dependencies = [
 "bitflags 2.6.0",
]

[[package]]
name = "regex"
version = "1.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4219d74c6b67a3654a9fbebc4b419e22126d13d2f3c4a07ee0cb61ff79a79619"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata",
 "regex-syntax",
]

[[package]]
name = "regex-automata"
version = "0.4.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38caf58cc5ef2fed281f89292ef23f6365465ed9a41b7a7754eb4e26496c92df"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax",
]

[[package]]
name = "regex-syntax"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a66a03ae7c801facd77a29370b4faec201768915ac14a721ba36f20bc9c209b"

[[package]]
name = "ron"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "88073939a61e5b7680558e6be56b419e208420c2adb92be54921fa6b72283f1a"
dependencies = [
 "base64",
 "bitflags 1.3.2",
 "serde",
]

[[package]]
name = "rust-ini"
version = "0.18.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6d5f2436026b4f6e79dc829837d467cc7e9a55ee40e750d716713540715a2df"
dependencies = [
 "cfg-if",
 "ordered-multimap",
]

[[package]]
name = "rustc-demangle"
version = "0.1.24"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "719b953e2095829ee67db738b3bfa9fa368c94900df327b3f07fe6e794d2fe1f"

[[package]]
name = "rustix"
version = "0.38.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70dc5ec042f7a43c4a73241207cecc9873a06d45debb38b329f8541d85c2730f"
dependencies = [
 "bitflags 2.6.0",
 "errno",
 "libc",
 "linux-raw-sys",
 "windows-sys 0.52.0",
]

[[package]]
name = "ryu"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f3cb5ba0dc43242ce17de99c180e96db90b235b8a9fdc9543c96d2209116bd9f"

[[package]]
name = "schannel"
version = "0.1.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fbc91545643bcf3a0bbb6569265615222618bdf33ce4ffbbd13c4bbd4c093534"
dependencies = [
 "windows-sys 0.52.0",
]

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "security-framework"
version = "2.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "897b2245f0b511c87893af39b033e5ca9cce68824c4d7e7630b5a1d339658d02"
dependencies = [
 "bitflags 2.6.0",
 "core-foundation",
 "core-foundation-sys",
 "libc",
 "security-framework-sys",
]

[[package]]
name = "security-framework-sys"
version = "2.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75da29fe9b9b08fe9d6b22b5b4bcbc75d8db3aa31e639aa56bb62e9d46bfceaf"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "serde"
version = "1.0.208"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cff085d2cb684faa248efb494c39b68e522822ac0de72ccf08109abde717cfb2"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.208"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24008e81ff7613ed8e5ba0cfaf24e2c2f1e5b8a0495711e44fcd4882fca62bcf"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "serde_json"
version = "1.0.125"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "83c8e735a073ccf5be70aa8066aa984eaf2fa000db6c8d0100ae605b366d31ed"
dependencies = [
 "itoa",
 "memchr",
 "ryu",
 "serde",
]

[[package]]
name = "sha2"
version = "0.10.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "793db75ad2bcafc3ffa7c68b215fee268f537982cd901d132f89c6343f3a3dc8"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "signal-hook-registry"
version = "1.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a9e9e0b4211b72e7b8b6e85c807d36c212bdb33ea8587f7569562a84df5465b1"
dependencies = [
 "libc",
]

[[package]]
name = "smallvec"
version = "1.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c5e1a9a646d36c3599cd173a41282daf47c44583ad367b8e6837255952e5c67"

[[package]]
name = "socket2"
version = "0.5.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ce305eb0b4296696835b71df73eb912e0f1ffd2556a501fcede6e0c50349191c"
dependencies = [
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "syn"
version = "2.0.75"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6af063034fc1935ede7be0122941bafa9bacb949334d090b77ca98b5817c7d9"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "tempfile"
version = "3.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "04cbcdd0c794ebb0d4cf35e88edd2f7d2c4c3e9a5a6dab322839b321c6a87a64"
dependencies = [
 "cfg-if",
 "fastrand",
 "once_cell",
 "rustix",
 "windows-sys 0.59.0",
]

[[package]]
name = "termcolor"
version = "1.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06794f8f6c5c898b3275aebefa6b8a1cb24cd2c6c79397ab15774837a0bc5755"
dependencies = [
 "winapi-util",
]

[[package]]
name = "thiserror"
version = "1.0.63"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0342370b38b6a11b6cc11d6a805569958d54cfa061a29969c3b5ce2ea405724"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "1.0.63"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4558b58466b9ad7ca0f102865eccc95938dca1a74a856f2b57b6629050da261"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tokio"
version = "1.39.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9babc99b9923bfa4804bd74722ff02c0381021eafa4db9949217e3be8e84fff5"
dependencies = [
 "backtrace",
 "bytes",
 "libc",
 "mio",
 "parking_lot",
 "pin-project-lite",
 "signal-hook-registry",
 "socket2",
 "tokio-macros",
 "windows-sys 0.52.0",
]

[[package]]
name = "tokio-macros"
version = "2.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "693d596312e88961bc67d7f1f97af8a70227d9f90c31bba5806eec004978d752"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tokio-native-tls"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbae76ab933c85776efabc971569dd6119c580d8f5d448769dec1764bf796ef2"
dependencies = [
 "native-tls",
 "tokio",
]

[[package]]
name = "toml"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f4f7f0dd8d50a853a531c426359045b1998f04219d88799810762cd4ad314234"
dependencies = [
 "serde",
]

[[package]]
name = "typenum"
version = "1.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42ff0bf0c66b8238c6f3b578df37d0b7848e55df8577b3f74f92a69acceeb825"

[[package]]
name = "ucd-trie"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed646292ffc8188ef8ea4d1e0e0150fb15a5c2e12ad9b8fc191ae7a8a7f3c4b9"

[[package]]
name = "unicode-ident"
version = "1.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b"

[[package]]
name = "vcpkg"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "accd4ea62f7bb7a82fe23066fb0957d48ef677f6eeb8215f372f52e48bb32426"

[[package]]
name = "version_check"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"

[[package]]
name = "wasi"
version = "0.11.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"

[[package]]
name = "wasm-bindgen"
version = "0.2.93"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a82edfc16a6c469f5f44dc7b571814045d60404b55a0ee849f9bcfa2e63dd9b5"
dependencies = [
 "cfg-if",
 "once_cell",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.93"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9de396da306523044d3302746f1208fa71d7532227f15e347e2d93e4145dd77b"
dependencies = [
 "bumpalo",
 "log",
 "once_cell",
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.93"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "585c4c91a46b072c92e908d99cb1dcdf95c5218eeb6f3bf1efa991ee7a68cccf"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.93"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "afc340c74d9005395cf9dd098506f7f44e38f2b4a21c6aaacf9a105ea5e1e836"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.93"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c62a0a307cb4a311d3a07867860911ca130c3494e8c2719593806c08bc5d0484"

[[package]]
name = "winapi-util"
version = "0.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cf221c93e13a30d793f7645a0e7762c55d169dbb0a49671918a2319d289b10bb"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "windows-core"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33ab640c8d7e35bf8ba19b884ba838ceb4fba93a4e8c65a9059d08afcfc683d9"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm",
 "windows_aarch64_msvc",
 "windows_i686_gnu",
 "windows_i686_gnullvm",
 "windows_i686_msvc",
 "windows_x86_64_gnu",
 "windows_x86_64_gnullvm",
 "windows_x86_64_msvc",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "yaml-rust"
version = "0.4.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56c1936c4cc7a1c9ab21a1ebb602eb942ba868cbd44a99cb7cdc5892335e1c85"
dependencies = [
 "linked-hash-map",
]

[[package]]
name = "zerocopy"
version = "0.7.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b9b4fd18abc82b8136838da5d50bae7bdea537c574d8dc1a34ed098d6c166f0"
dependencies = [
 "byteorder",
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.7.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa4f8080344d4671fb4e831a13ad1e68092748387dfc4f55e356242fae12ce3e"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]



=== ./icn_core/Cargo.toml ===
[package]
name = "icn_core"
version = "0.1.0"
edition = "2021"

[dependencies]
tempfile = "3.2"
native-tls = "0.2"
tokio = { version = "1", features = ["full"] }
config = "0.13"
env_logger = "0.10"
log = "0.4"
icn_consensus = { path = "../icn_consensus" }
icn_blockchain = { path = "../icn_blockchain" }
icn_identity = { path = "../icn_identity" }
icn_governance = { path = "../icn_governance" }
icn_networking = { path = "../icn_networking" }
icn_shared = { path = "../icn_shared" }
toml = "0.5"



=== ./icn_core/src/config/mod.rs ===
// icn_core/src/config/mod.rs

use icn_shared::IcnResult;

pub struct ConfigLoader {
    config_path: String,
    // Add other necessary fields here
}

impl ConfigLoader {
    pub fn new(config_path: &str) -> IcnResult<Self> {
        // Initialize the ConfigLoader with the provided config path
        Ok(ConfigLoader {
            config_path: config_path.to_string(),
            // Initialize other fields as needed
        })
    }

    // Use the config_path to avoid the dead code warning
    pub fn load(&self) -> IcnResult<()> {
        println!("Loading configuration from path: {}", self.config_path);
        // Implement the configuration loading logic here using config_path
        Ok(())
    }
}



=== ./icn_core/src/config/config_loader.rs ===
// File: icn_core/src/config/config_loader.rs

/// Represents a configuration loader for the ICN node.
pub struct ConfigLoader {
    config: config::Config,
}

impl ConfigLoader {
    /// Creates a new instance of `ConfigLoader` by loading the configuration from a file.
    ///
    /// # Arguments
    ///
    /// * `config_path` - The path to the configuration file.
    ///
    /// # Returns
    ///
    /// * `IcnResult<ConfigLoader>` - An instance of `ConfigLoader` or an `IcnError`.
    pub fn new(config_path: &str) -> IcnResult<Self> {
        let mut config = config::Config::default();
        config
            .merge(config::File::with_name(config_path))
            .map_err(|e| IcnError::Config(format!("Failed to load config: {}", e)))?;

        Ok(ConfigLoader { config })
    }

    /// Retrieves a value from the configuration as a string.
    ///
    /// # Arguments
    ///
    /// * `key` - The configuration key to retrieve.
    ///
    /// # Returns
    ///
    /// * `IcnResult<String>` - The configuration value as a string or an `IcnError`.
    pub fn get_value_as_string(&self, key: &str) -> IcnResult<String> {
        self.config
            .get_str(key)
            .map_err(|e| IcnError::Config(format!("Failed to get string value: {}", e)))
    }

    /// Retrieves a value from the configuration as an integer.
    ///
    /// # Arguments
    ///
    /// * `key` - The configuration key to retrieve.
    ///
    /// # Returns
    ///
    /// * `IcnResult<i64>` - The configuration value as an integer or an `IcnError`.
    pub fn get_value_as_int(&self, key: &str) -> IcnResult<i64> {
        self.config
            .get_int(key)
            .map_err(|e| IcnError::Config(format!("Failed to get int value: {}", e)))
    }

    // Add more methods for other types as needed (e.g., boolean, float)
}



=== ./icn_core/src/lib/mod.rs ===



=== ./icn_core/src/errors.rs ===
// icn_core/src/errors.rs

use std::error::Error;
use std::fmt;
use thiserror::Error;

/// Custom error type for the ICN project
#[derive(Error, Debug)]
pub enum IcnError {
    /// Configuration error
    #[error("Configuration error: {0}")]
    Config(String),

    /// IO error
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    /// TOML parsing error
    #[error("TOML parsing error: {0}")]
    Toml(#[from] toml::de::Error),

    /// Blockchain error
    #[error("Blockchain error: {0}")]
    Blockchain(String),

    /// Consensus error
    #[error("Consensus error: {0}")]
    Consensus(String),

    /// Networking error
    #[error("Networking error: {0}")]
    Networking(String),

    /// Smart Contract error
    #[error("Smart Contract error: {0}")]
    SmartContract(String),

    /// Virtual Machine error
    #[error("Virtual Machine error: {0}")]
    VirtualMachine(String),

    /// Storage error
    #[error("Storage error: {0}")]
    Storage(String),

    /// Other errors
    #[error("Other error: {0}")]
    Other(String),
}

// Implementing the `Error` trait allows our custom error to be used in the `?` operator
impl Error for IcnError {}

// Implementing the `Display` trait allows our custom error to be formatted and printed
impl fmt::Display for IcnError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self) // Use the `Error` trait's implementation for formatting
    }
}


=== ./icn_core/src/main.rs ===
// icn_core/src/main.rs

use icn_core::config::ConfigLoader;
use icn_core::node::NodeManager;
use icn_core::coordinator::ModuleCoordinator;
use std::env;
use icn_shared::IcnResult;
use log::error;

#[tokio::main]
async fn main() {
    // Default configuration file name
    let default_config_file = "config.toml";

    // Obtain config_path from command-line arguments or use the default
    let args: Vec<String> = env::args().collect();
    let config_path = if args.len() > 1 {
        &args[1]
    } else {
        default_config_file
    };

    // Initialize the ConfigLoader and handle potential errors
    let config_loader = match ConfigLoader::new(config_path) {
        Ok(loader) => loader,
        Err(e) => {
            error!("Failed to load configuration: {}", e);
            return; // Exit the program if configuration loading fails
        }
    };

    // Initialize the ModuleCoordinator
    let coordinator = ModuleCoordinator::new();

    // Create a NodeManager
    let mut node = NodeManager::new(config_loader, coordinator).expect("Failed to create NodeManager");

    // Start the node manager and handle potential errors
    if let Err(e) = node.start().await {
        error!("Node manager failed to start: {}", e);
    }
}


=== ./icn_core/src/node/mod.rs ===
mod node_manager;
pub use node_manager::NodeManager;



=== ./icn_core/src/node/node_manager.rs ===
// File: icn_core/src/node/node_manager.rs

use crate::config::ConfigLoader; // Import ConfigLoader from the config module
use crate::coordinator::ModuleCoordinator;
use icn_shared::IcnResult;

pub struct NodeManager {
    config_loader: ConfigLoader,
    coordinator: ModuleCoordinator,
    // Other fields...
}

impl NodeManager {
    /// Creates a new `NodeManager` instance.
    ///
    /// # Arguments
    ///
    /// * `config_loader` - The loader for configuration data.
    /// * `coordinator` - The module coordinator for handling interactions between modules.
    ///
    /// # Returns
    ///
    /// * `IcnResult<Self>` - A new `NodeManager` instance if successful.
    pub fn new(config_loader: ConfigLoader, coordinator: ModuleCoordinator) -> IcnResult<Self> {
        // Initialize the NodeManager with the provided config_loader and coordinator
        Ok(NodeManager {
            config_loader,
            coordinator,
            // Other initializations...
        })
    }

    /// Starts the NodeManager, initializing all necessary components.
    ///
    /// # Returns
    ///
    /// * `IcnResult<()>` - Ok(()) if successful, or an `IcnError` if an error occurs.
    pub async fn start(&mut self) -> IcnResult<()> {
        // Logic to start the node manager
        self.coordinator.start(&self.config_loader).await?;
        Ok(())
    }

    // Other methods...
}



=== ./icn_core/src/lib.rs ===
// /opt/InterCooperative-Network-Node/icn_core/src/lib.rs

pub mod config;
pub mod coordinator;
pub mod node;

// Remove the unused imports
// use icn_shared::{IcnError, IcnResult};



=== ./icn_core/src/coordinator/module_coordinator.rs ===
// File: icn_core/src/coordinator/module_coordinator.rs

use std::sync::{Arc, Mutex};
use icn_blockchain::Chain;
use icn_consensus::ProofOfCooperation;
use icn_networking::Networking;
use icn_shared::{NodeState, IcnResult};
use crate::config::ConfigLoader;

/// `ModuleCoordinator` coordinates the interactions between various modules of the node.
pub struct ModuleCoordinator {
    blockchain: Arc<Mutex<Chain>>,
    consensus: Arc<Mutex<ProofOfCooperation>>,
    networking: Arc<Mutex<Networking>>,
    node_state: Arc<Mutex<NodeState>>,
}

impl ModuleCoordinator {
    /// Creates a new `ModuleCoordinator` instance.
    pub fn new() -> Self {
        let blockchain = Arc::new(Mutex::new(Chain::new()));
        let consensus = Arc::new(Mutex::new(ProofOfCooperation::new()));
        let networking = Arc::new(Mutex::new(Networking::new()));
        let node_state = Arc::new(Mutex::new(NodeState::Initializing));

        ModuleCoordinator {
            blockchain,
            consensus,
            networking,
            node_state,
        }
    }

    /// Starts the coordinator and its associated modules.
    ///
    /// This function reads necessary configurations (e.g. certificate path, password) from the `ConfigLoader`,
    /// initializes the `Networking` module, and sets the node state to `Operational`.
    ///
    /// # Arguments
    ///
    /// * `config_loader` - A reference to the `ConfigLoader` for accessing configurations.
    ///
    /// # Returns
    /// 
    /// * `IcnResult<()>` - Ok(()) if successful, or an `IcnError` if an error occurs.
    pub async fn start(&self, config_loader: &ConfigLoader) -> IcnResult<()> {
        let cert_file_path = config_loader.get_string("network.cert_file_path")?;
        let cert_password = config_loader.get_string("network.cert_password")?;

        // Initialize the Networking module using the cert_file_path and cert_password
        self.networking
            .lock()
            .unwrap()
            .initialize().await?;
        
        // ... other module initializations (blockchain, consensus) ...

        // Update node state to Operational
        *self.node_state.lock().unwrap() = NodeState::Operational;

        Ok(())
    }

    // ... other methods for module interactions ...
}



=== ./icn_core/src/coordinator/mod.rs ===
mod module_coordinator;
pub use module_coordinator::ModuleCoordinator;



=== ./icn_storage/Cargo.toml ===
[package]
name = "icn_storage"
version = "0.1.0"
edition = "2018"

[dependencies]
icn_blockchain = { path = "../icn_blockchain" }



=== ./icn_storage/src/lib/mod.rs ===



=== ./icn_storage/src/block_storage.rs ===
// icn_storage/src/block_storage.rs

use icn_blockchain::block::Block;  // Correctly reference icn_blockchain

use std::collections::HashMap;

/// The `BlockStorage` struct is responsible for storing and retrieving blocks.
/// It uses an in-memory `HashMap` to store blocks by their hash.
pub struct BlockStorage {
    storage: HashMap<String, Block>,
}

impl BlockStorage {
    /// Creates a new `BlockStorage` instance.
    pub fn new() -> Self {
        BlockStorage {
            storage: HashMap::new(),
        }
    }

    /// Adds a new block to the storage.
    pub fn add_block(&mut self, block: Block) -> Result<(), String> {
        let hash = block.hash.clone();
        if self.storage.contains_key(&hash) {
            return Err("Block with this hash already exists.".to_string());
        }
        self.storage.insert(hash, block);
        Ok(())
    }

    /// Retrieves a block by its hash.
    pub fn get_block(&self, hash: &str) -> Option<Block> {
        self.storage.get(hash).cloned()
    }
}



=== ./icn_storage/src/state_storage.rs ===
// icn_storage/src/state_storage.rs

use std::collections::HashMap;

/// The `StateStorage` struct is responsible for managing the state of the blockchain.
/// It uses an in-memory `HashMap` to store key-value pairs representing the state.
pub struct StateStorage {
    storage: HashMap<String, String>,
}

impl StateStorage {
    /// Creates a new `StateStorage` instance.
    pub fn new() -> Self {
        StateStorage {
            storage: HashMap::new(),
        }
    }

    /// Updates the state storage with a new key-value pair.
    pub fn update_state(&mut self, key: &str, value: &str) -> Result<(), String> {
        self.storage.insert(key.to_string(), value.to_string());
        Ok(())
    }

    /// Retrieves a value from the state storage by its key.
    pub fn get_state(&self, key: &str) -> Option<String> {
        self.storage.get(key).cloned()
    }
}



=== ./icn_storage/src/lib.rs ===
// icn_storage/src/lib.rs

pub mod block_storage;
pub mod state_storage;

use icn_blockchain::block::Block;  // Correctly reference icn_blockchain
use block_storage::BlockStorage;
use state_storage::StateStorage;
use std::sync::{Arc, RwLock};

/// The `Storage` struct provides an interface to the underlying storage systems
/// for blocks and state. It ensures thread-safe access and modification.
pub struct Storage {
    block_storage: Arc<RwLock<BlockStorage>>,
    state_storage: Arc<RwLock<StateStorage>>,
}

impl Storage {
    /// Creates a new instance of the `Storage` struct with initialized
    /// block and state storage systems.
    pub fn new() -> Self {
        Storage {
            block_storage: Arc::new(RwLock::new(BlockStorage::new())),
            state_storage: Arc::new(RwLock::new(StateStorage::new())),
        }
    }

    /// Adds a new block to the block storage.
    pub fn add_block(&self, block: Block) -> Result<(), String> {
        let mut storage = self.block_storage.write().unwrap();
        storage.add_block(block)
    }

    /// Retrieves a block by its hash.
    pub fn get_block(&self, hash: &str) -> Option<Block> {
        let storage = self.block_storage.read().unwrap();
        storage.get_block(hash)
    }

    /// Updates the state storage with the latest state.
    pub fn update_state(&self, key: &str, value: &str) -> Result<(), String> {
        let mut storage = self.state_storage.write().unwrap();
        storage.update_state(key, value)
    }

    /// Retrieves a value from the state storage by its key.
    pub fn get_state(&self, key: &str) -> Option<String> {
        let storage = self.state_storage.read().unwrap();
        storage.get_state(key)
    }
}



=== ./icn_identity/Cargo.toml ===
[package]
name = "icn_identity"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_shared = { path = "../icn_shared" }




=== ./icn_identity/src/lib/mod.rs ===



=== ./icn_identity/src/lib.rs ===
// icn_identity/src/lib.rs

/// The Identity module manages node identity within the ICN.
/// It holds basic identity information like node ID and name.
pub struct Identity {
    /// The unique identifier for the node.
    pub id: String,
    /// The name associated with the node.
    pub name: String,
}

impl Identity {
    /// Creates a new instance of Identity.
    pub fn new(id: &str, name: &str) -> Self {
        Identity {
            id: id.to_string(),
            name: name.to_string(),
        }
    }

    /// Initializes the identity module.
    ///
    /// # Returns
    /// * `IcnResult<()>` - An empty result indicating success or failure.
    pub fn initialize(&self) -> Result<(), String> {
        // Initialization logic here (if any)
        Ok(())
    }
}



=== ./update_project.sh ===
#!/bin/bash

# Generate the latest project state before committing
./generate_project_state.sh

# Check if the project state was generated successfully
if [[ $? -ne 0 ]]; then
    echo "Error: Failed to generate project state."
    exit 1
fi

# Prompt the user to enter a commit message
echo "Enter the commit message:"
read -r COMMIT_MSG

# Ensure the commit message is not empty
if [[ -z "$COMMIT_MSG" ]]; then
    echo "Error: Commit message cannot be empty!"
    exit 1
fi

# Stage all changes for commit
git add .

# Commit the changes with the provided message
git commit -m "$COMMIT_MSG"

# Check if the commit was successful
if [[ $? -ne 0 ]]; then
    echo "Error: Commit failed."
    exit 1
fi

# Push the changes to the remote repository
git push origin main

# Check if the push was successful
if [[ $? -ne 0 ]]; then
    echo "Error: Push failed."
    exit 1
fi

echo "Changes have been successfully committed and pushed."



=== ./.gitignore ===
/target
**/*.rs.bk
Cargo.lock



=== ./cert.crt ===
-----BEGIN CERTIFICATE-----
MIIDazCCAlOgAwIBAgIUJ7jodMjKnM44chKNoNnbLAu4dtgwDQYJKoZIhvcNAQEL
BQAwRTELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUxITAfBgNVBAoM
GEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDAeFw0yNDA4MjAwOTQ5NThaFw0yNTA4
MjAwOTQ5NThaMEUxCzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEw
HwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQwggEiMA0GCSqGSIb3DQEB
AQUAA4IBDwAwggEKAoIBAQCimkgO66phw4qN6+fC37JTRI91L8Efir0T+Q7yHYUU
2R1LKfIyHxY1CZzxb0JGi7VTI1Ps5kH7pzfws++wyWDo6by1byJMW8ngiP0fLTe1
iRfnQWw7bV36ndh0rFakfw9EmmCuWSHuMDcIYwJ2JUG3XHh7NXc4vls3J2SYF3/a
q5/Ak++Ga4/OOJDRlGILaidw3whc0zB7K4JVp5yqHYoMq2cjwtBFpElvzVp/TDwd
25JBXug/d5W1aIi7KPWYJzQL4Nf2ZL/P8kEvtRi2TkLIRawTl9Wdf6YT87Up9qYQ
Dhu/n4GzVExJbc0wFP130pUW/pvsuksef0cywB/FvA3pAgMBAAGjUzBRMB0GA1Ud
DgQWBBTfzrbbJMAfLYUPJ6jK56a7o67KaDAfBgNVHSMEGDAWgBTfzrbbJMAfLYUP
J6jK56a7o67KaDAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEBCwUAA4IBAQAd
WjR2E/VjWEZevLwg2o/U61TgTT998xoNBRkUnxQtMr65+c1vaHri8Pup5UdL78DY
HWbDSWRhdOXwgkKfVO/nra2q7wuKhzhtc93UJmMIpX6y/6n4rfiDPxhoTsvQFFbR
SbM5unhTC3z8YRtpviH3uNpV9MLUl97WjnGtyO8JmeQJpShg+7QfODh9qeQdGhZE
44w3iKwfxFh7QkrC1uxtJSNOEDojqd764jutLzkIwqGLmrTE8hdqsp0K1b4ndnr3
HdblGrbmmRMcvNXnQBHuqGWisBJwyBOXe8xdrp2G6p+ugQwwjfYxQ84hARb4yfsV
opofgoP+yqNGPhtUGpOJ
-----END CERTIFICATE-----



=== ./icn_smart_contracts/Cargo.toml ===
[package]
name = "icn_smart_contracts"
version = "0.1.0"
edition = "2021"

[dependencies]



=== ./icn_smart_contracts/src/lib/mod.rs ===



=== ./icn_smart_contracts/src/lib.rs ===
// icn_smart_contracts/src/lib.rs

use std::collections::HashMap;

// Define our own error type for this crate
#[derive(Debug)]
pub enum SmartContractError {
    InvalidArguments(String),
    ContractNotFound(u32),
    KeyNotFound(String),
    UnknownFunction(String),
}

pub type SmartContractResult<T> = Result<T, SmartContractError>;

pub struct SmartContract {
    pub id: u32,
    pub code: String,
    pub state: HashMap<String, String>,
}

impl SmartContract {
    pub fn new(id: u32, code: &str) -> Self {
        SmartContract {
            id,
            code: code.to_string(),
            state: HashMap::new(),
        }
    }

    pub fn execute(&mut self, function: &str, args: Vec<String>) -> SmartContractResult<String> {
        match function {
            "set" => {
                if args.len() != 2 {
                    return Err(SmartContractError::InvalidArguments("'set' requires 2 arguments".to_string()));
                }
                self.state.insert(args[0].clone(), args[1].clone());
                Ok("Value set successfully".to_string())
            }
            "get" => {
                if args.len() != 1 {
                    return Err(SmartContractError::InvalidArguments("'get' requires 1 argument".to_string()));
                }
                self.state.get(&args[0])
                    .cloned()
                    .ok_or_else(|| SmartContractError::KeyNotFound(args[0].clone()))
            }
            _ => Err(SmartContractError::UnknownFunction(function.to_string())),
        }
    }
}

pub struct SmartContractEngine {
    contracts: HashMap<u32, SmartContract>,
}

impl SmartContractEngine {
    pub fn new() -> Self {
        SmartContractEngine {
            contracts: HashMap::new(),
        }
    }

    pub fn deploy_contract(&mut self, code: &str) -> SmartContractResult<u32> {
        let id = self.contracts.len() as u32 + 1;
        let contract = SmartContract::new(id, code);
        self.contracts.insert(id, contract);
        Ok(id)
    }

    pub fn call_contract(&mut self, id: u32, function: &str, args: Vec<String>) -> SmartContractResult<String> {
        self.contracts.get_mut(&id)
            .ok_or_else(|| SmartContractError::ContractNotFound(id))?
            .execute(function, args)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_smart_contract_execution() {
        let mut contract = SmartContract::new(1, "sample code");
        
        let result = contract.execute("set", vec!["key".to_string(), "value".to_string()]);
        assert!(result.is_ok());

        let result = contract.execute("get", vec!["key".to_string()]);
        assert_eq!(result.unwrap(), "value");

        let result = contract.execute("unknown", vec![]);
        assert!(result.is_err());
    }

    #[test]
    fn test_smart_contract_engine() {
        let mut engine = SmartContractEngine::new();

        let contract_id = engine.deploy_contract("sample code").unwrap();
        assert_eq!(contract_id, 1);

        let result = engine.call_contract(contract_id, "set", vec!["key".to_string(), "value".to_string()]);
        assert!(result.is_ok());

        let result = engine.call_contract(contract_id, "get", vec!["key".to_string()]);
        assert_eq!(result.unwrap(), "value");

        let result = engine.call_contract(999, "get", vec!["key".to_string()]);
        assert!(result.is_err());
    }
}


=== ./icn_api/Cargo.toml ===
[package]
name = "icn_api"
version = "0.1.0"
edition = "2021"

[dependencies]



=== ./icn_api/src/lib/mod.rs ===



=== ./icn_api/src/lib.rs ===
pub fn add(left: u64, right: u64) -> u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}



