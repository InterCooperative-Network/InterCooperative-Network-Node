=== ./test_cert.crt ===
-----BEGIN CERTIFICATE-----
MIIDuTCCAqGgAwIBAgIUVXSz9n9sUkgSDhnyLuGmVcZRNK8wDQYJKoZIhvcNAQEL
BQAwbDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5ZMRAwDgYDVQQHDAdQYWxteXJh
MSEwHwYDVQQKDBhJbnRlckNvb3BlcmF0aXZlIE5ldHdvcmsxDTALBgNVBAsMBE5v
ZGUxDDAKBgNVBAMMA0lDTjAeFw0yNDA4MjAwNzM5NDBaFw0yNTA4MjAwNzM5NDBa
MGwxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJOWTEQMA4GA1UEBwwHUGFsbXlyYTEh
MB8GA1UECgwYSW50ZXJDb29wZXJhdGl2ZSBOZXR3b3JrMQ0wCwYDVQQLDAROb2Rl
MQwwCgYDVQQDDANJQ04wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCq
iABpZtwNQC0vdQxFvm4uQsNQgRDL/90jRgrsm8AYWcKRDWpoExi/aiYT1FrFo2rs
PM7kqzaIb7xiPtJIhzOJg4qNc5Gi6/wSJ4A/qYkRuAGznWkp735moKLmhbn0vRq3
KWNUk7QN7cbQOww50Td25Omo0TZOrwXbGFdeit8WyjAaUxuXaFINnptga+v7PUhf
DNbTh+TWqpUlc+sWQ/mjW7hXfTZrsfNRfU8dd+v2U9gS5DjJ8BsekHgUrdVJc0WG
MeX4S5IIChV4vmf15XLayiQ1zY+SLwcg3u1eOHifmBJNX5YZlzYBknU5mOcR5mC/
L8K6hfF1zFcjH+CPx5StAgMBAAGjUzBRMB0GA1UdDgQWBBRBUbpVIhBpqrVqPbWL
/EhJ/b256jAfBgNVHSMEGDAWgBRBUbpVIhBpqrVqPbWL/EhJ/b256jAPBgNVHRMB
Af8EBTADAQH/MA0GCSqGSIb3DQEBCwUAA4IBAQB/AFohJ7yOexdrCebW+BNvxER9
i7zZN1HskiXEyW/st5L612vJMESQYj9cJBeg1j8L9X/5LitWjfZb/+KsFwglKOQa
uoygrOUlhlnfLJYQeXHtG8wr/pVaYCGUWtd7S1ZlDe2gfCrZGRZRoZ1GvaO2FOKk
EsAUy9UUeplYaSH/nrtVb2Af7bwnlSdOh0RnElUYpp0QYaynLWAZCXO8z9xyMlnd
KOIMTYIMQ7eSe0UDH70LUNeroUuqCC/31MEKJERfLkVMrZLmsqA7Nj/yd+mh1ULx
VRMUSGAQpVE/bUaHxN1MIKmzrh1CheXjShgHvkPxAlF1YOcvxfJgyXjbTuxf
-----END CERTIFICATE-----



=== ./generate_project_state.sh ===
#!/bin/bash

# Define the output file
output_file="project_state.txt"

# Clear the output file if it exists
> $output_file

# Function to write file contents to the output file
write_file_content() {
    local file_path="$1"
    echo "=== $file_path ===" >> $output_file
    cat "$file_path" >> $output_file
    echo -e "\n\n" >> $output_file
}

# Recursively list all files and append their content, excluding build artifacts and temporary files
find . -type f \
    -not -path "./.git/*" \
    -not -path "./target/*" \
    -not -path "./**/node_modules/*" \
    -not -path "./**/*.o" \
    -not -path "./**/*.rs.bk" \
    -not -path "./**/*.log" \
    -not -name "*.txt" \
    -not -name "*.md" | while read file; do
    write_file_content "$file"
done

echo "Project state saved to $output_file"



=== ./icn_networking/Cargo.toml ===
[package]
name = "icn_networking"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1.0", features = ["full"] }
tokio-native-tls = "0.3"
native-tls = "0.2"
log = "0.4"
icn_shared = { path = "../icn_shared" }



=== ./icn_networking/src/lib/mod.rs ===



=== ./icn_networking/src/lib.rs ===
use tokio::net::{TcpListener, TcpStream};
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::sync::Mutex;
use std::sync::Arc;
use log::{info, error};
use native_tls::{TlsAcceptor, TlsConnector, Identity};
use tokio_native_tls::{TlsAcceptor as TokioTlsAcceptor, TlsStream};
use icn_shared::{IcnError, IcnResult};

pub struct Networking {
    peers: Arc<Mutex<Vec<TlsStream<TcpStream>>>>,
}

impl Networking {
    pub fn new() -> Self {
        Networking {
            peers: Arc::new(Mutex::new(vec![])),
        }
    }

    pub async fn start_server(&self, address: &str, identity: Identity) -> IcnResult<()> {
        let acceptor = TlsAcceptor::new(identity)
            .map_err(|e| IcnError::Network(format!("Failed to create TLS acceptor: {}", e)))?;
        let acceptor = TokioTlsAcceptor::from(acceptor);

        let listener = TcpListener::bind(address).await
            .map_err(|e| IcnError::Network(format!("Failed to bind to address: {}", e)))?;
        info!("Server started on {}", address);

        loop {
            let (stream, _) = listener.accept().await
                .map_err(|e| IcnError::Network(format!("Failed to accept connection: {}", e)))?;
            let acceptor = acceptor.clone();
            let peers = Arc::clone(&self.peers);

            tokio::spawn(async move {
                match acceptor.accept(stream).await {
                    Ok(tls_stream) => handle_client(tls_stream, peers).await,
                    Err(e) => error!("Failed to accept TLS connection: {:?}", e),
                }
            });
        }
    }

    pub async fn connect_to_peer(&self, address: &str) -> IcnResult<()> {
        let connector = TlsConnector::new()
            .map_err(|e| IcnError::Network(format!("Failed to create TLS connector: {}", e)))?;
        let connector = tokio_native_tls::TlsConnector::from(connector);

        let stream = TcpStream::connect(address).await
            .map_err(|e| IcnError::Network(format!("Failed to connect to peer: {}", e)))?;
        let tls_stream = connector.connect(address, stream).await
            .map_err(|e| IcnError::Network(format!("Failed to establish TLS connection: {}", e)))?;

        self.peers.lock().await.push(tls_stream);
        info!("Connected to peer at {}", address);
        Ok(())
    }

    pub async fn broadcast_message(&self, message: &str) -> IcnResult<()> {
        let mut peers = self.peers.lock().await;
        for peer in peers.iter_mut() {
            if let Err(e) = peer.write_all(message.as_bytes()).await {
                error!("Failed to send message: {:?}", e);
            }
        }
        Ok(())
    }

    pub fn stop_server(&self) -> IcnResult<()> {
        // Add your server stopping logic here
        Ok(())
    }
}

async fn handle_client(mut tls_stream: TlsStream<TcpStream>, peers: Arc<Mutex<Vec<TlsStream<TcpStream>>>>) {
    let mut buf = vec![0; 1024];
    loop {
        let n = match tls_stream.read(&mut buf).await {
            Ok(n) if n == 0 => break, // Connection closed
            Ok(n) => n,
            Err(e) => {
                error!("Failed to read from client: {:?}", e);
                break;
            }
        };

        let message = String::from_utf8_lossy(&buf[..n]);
        info!("Received message: {}", message);

        // Broadcast message to all peers
        let mut peers = peers.lock().await;
        for peer in peers.iter_mut() {
            if let Err(e) = peer.write_all(message.as_bytes()).await {
                error!("Failed to send message to peer: {:?}", e);
            }
        }
    }
}



=== ./icn_shared/Cargo.toml ===
[package]
name = "icn_shared"
version = "0.1.0"
edition = "2018"

[dependencies]
serde = "1.0"
serde_json = "1.0"
log = "0.4"
native-tls = "0.2"  # Add this line



=== ./icn_shared/src/lib.rs ===
// icn_shared/src/lib.rs

use std::fmt;
use std::error::Error;

#[derive(Debug)]
pub enum IcnError {
    Io(std::io::Error),
    Tls(native_tls::Error),
    Config(String),
    Consensus(String),
    Network(String),
    SmartContract(String),
    Database(String),
    Validation(String),
    NotFound(String),
    Unauthorized(String),
    Other(String),
}

impl fmt::Display for IcnError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            IcnError::Io(e) => write!(f, "I/O error: {}", e),
            IcnError::Tls(e) => write!(f, "TLS error: {}", e),
            IcnError::Config(e) => write!(f, "Configuration error: {}", e),
            IcnError::Consensus(e) => write!(f, "Consensus error: {}", e),
            IcnError::Network(e) => write!(f, "Network error: {}", e),
            IcnError::SmartContract(e) => write!(f, "Smart contract error: {}", e),
            IcnError::Database(e) => write!(f, "Database error: {}", e),
            IcnError::Validation(e) => write!(f, "Validation error: {}", e),
            IcnError::NotFound(e) => write!(f, "Not found: {}", e),
            IcnError::Unauthorized(e) => write!(f, "Unauthorized: {}", e),
            IcnError::Other(e) => write!(f, "Other error: {}", e),
        }
    }
}

impl Error for IcnError {}

impl From<std::io::Error> for IcnError {
    fn from(error: std::io::Error) -> Self {
        IcnError::Io(error)
    }
}

impl From<native_tls::Error> for IcnError {
    fn from(error: native_tls::Error) -> Self {
        IcnError::Tls(error)
    }
}

pub type IcnResult<T> = Result<T, IcnError>;


=== ./test_cert.p12 ===
0Ç
è0Ç
E	*ÜHÜ˜†Ç
6Ç
20Ç
.0Ç¢	*ÜHÜ˜†Çì0Çè 0Çà	*ÜHÜ˜0W	*ÜHÜ˜0J0)	*ÜHÜ˜0‚“˘|Çí* 0*ÜHÜ˜	 0	`ÜHe*.B©ÆùÒy˘˜ª}Ã ÄÇ ÿæ‰ODÏËKÎ÷û—√´rìf¡çı√#∞˛í/Ià°øçòa8√º6ˆB˛ !GDFÚn¢CaOôu´·Ô?á«Í/>NBÕˆˇ/18Gb†-Ωt](¸àœ·≥Y™	3Áh…]	≠ÌìG}Øøˆ_ÓM¬F"<M™ú£Y/yåª¨àúÙ¨≥e¸ﬁ'tjåg≥ÿ™\¶L·”Ö∫ó&™oØy)ãŸvXÙn˚-«^| ∞Ú‰ÊXísÂ˘hô¡èZ0©9~0aà˝≤
xl!år?¡"Âä?¿˝vî˛sÒEÄéMÖ≥K‰„§“˛Â˝ÚÀ“ ºí¿<ÈÜ'Z•A≤ä\Y^êàá•ËAw&¸ËÃ"\è¸ˇÏJ’	HÌ§%Vt9:ØqÈ,f√üÿ·m•≠IRhôÖDDÍApˇßEÑ'˙
*™dfµÔqJ;!‰Ë∞∂ï≈—ÄÏF◊0≈·S8ÓÉ™?q◊z)Æù%ÿıîi<ïBîR 2úãlÉ1>Ge–êB$Ï¡næ“G§H3v º˙õ…aΩ[´	j‡⁄ΩPÌ¨>¨î_Î/eï-U¡Jò[™O⁄7Eå¬ïê 6ZS}ÕoåÛíÜ∞Ì∫éßsÌ£?ßõøO* ˇÙI√'◊BuÎ‡ìlÙÚ5ÃO∂õÜÀvHKV7 3≠ìEj€Õı-Ö®‡! ≈Ω≈-[àΩÜGÁÏ…3ç9.ñò{Çj\ª*≠mÓ<£A≥ÙÊÜËY6Ë<Ì˚‘1≈Òlô%™∫ñﬂ±g-3tI˘^}∏¨`Àbπ≥¨!=^Ú`TGåœò¬cwö‡N√Ü-´ÌÒöÊ”9Ω˛œL”8<∫3§_Ûº'[G≥Ä¢¸¯πÏº'ﬁ≤F√ykÑp-⁄4àÖæ˝HVﬂ'cﬂÃü0FÊ◊çãÚ[4‹5¢™~»ë‹º8ã{â¡ÈŒﬂü,ø¨µƒ#(û¸jdÁ6ƒmBWπF≈÷ö“„ˇ.◊ˆ˜Ω•GJ6¸…Á§ú…Ë∂Ìô*¥ëmÛÆ&Ô˘´€[Ç®¬•eë(p≥E´i’À81ŒÃ>S<ì-∫¨Ê6‰[[‹ÅiÛıŸ(“Áö»)Û€ﬁÑ…ö¢|JÜçÅidw¸ƒÒÂœ˘zπïÄÕFñõ{¢"	SıáÉ˝ôJ≈"‘ﬂ$Ì›63.ØÙ^·…Kûoﬂ≈∫qˆ76q¸“npSKÒÇeã…<dêwCëqpß∑îÆ8xc›‚=K%MjR˛NH…ç‹Ræ…˜˜©ôäûH–ùcÖI@Q2ºÛÁ“Øî◊{¯œ=ZÎπe˚%^…
∞⁄vt€=@Ã1~ôvÄˆ«ÈcÃ«ı6≤fà√
R)ûK[h.TSFÍ◊Qı„ ŒÛU0ÇÑ	*ÜHÜ˜†ÇuÇq0Çm0Çi*ÜHÜ˜
†Ç10Ç-0W	*ÜHÜ˜0J0)	*ÜHÜ˜0‡™.R4# 0*ÜHÜ˜	 0	`ÜHe*œøsH/Eı√†]/L?^Ç–‡ö˙Ì‚h»öp5ùÁ≥Ü˝N'°<OÖ∏pfïË0.íï«Î¡[ïìÎ±ΩxÓ–#éûœhH√Ó™æûU(Gõ‚é|6∫‰#o!*À[ÿçπ[xn …˛∂ÂÁók±“!ûç–Ú¯Î∫QØ–°fsE.‡lpÕ•ÌaÌ¢!∏4>ó˚ŸΩ°√√≥cŸ~îèƒ∏)s“ûÌÉ€©œ3Æ≠0N”püø„fÏÁŸÙ[¡–#ï!·Q‹SÈ¸∆º.˙î9Î∆¡ç\ú€—ÃfP“‘OÜ öê@µJ∏«vy¡;¡x†C∆_’ö≠6@Œ»9y…n{ÛYm∂6÷∑BMõü!‘ñÊ´˙√qÛnP:ﬂ‘∂:Yä0nÂuWmÑ7A∂û¨˜’ wóX6G)"h†eÀ—âπã=|•±tCäÂ˛@?‹ÀËÄy”t>ı=À©
f$DUÕÿb4˚≠J"=˛@–`i…ŒÀ'ª˚‡)∑8‘ÉË∏+CIãZA6WLı§ùpÇ{è|˝p¬ﬂi`ŸPµ’¡üWm‚≥ÿ±/Óˆ£5EH^oΩ=®"˛cê‹(ŒËCåofbÁc˝sWZOì∞=«»@¿î◊⁄ÎˆCònBıƒ$≈OK7u¶©L#ZMˇmW[îÒâ)+—<Á+°k≤ˇ$6TÙbiíü_ÿˆ!Wù˛ÑçÁ˘≈ÀÙ]N§‡1p—z›˘{X”+ÏªY∑]„≤i2PoR¬/ÜHôê §“é¡eÏ<¯—:IÓñ%ÙÂÓ5sxä«ßÚú‡X¸ÒÕÔ“IO.l“ÏÏ≥]\Aï ’Ç≈•l∞Å_9…≈˜_Õ1ı ∏d¿åUkñˇdöˆy"[…¡*¸Õ◊Èåø`C6‡#”"µ	“˘âvÂ'cQˆFI:Æ˝‡' B√epk*9Wó˜‰óu0yn‘∏5(ÿ\m±IÿŸÂéó93®2˚BRfÛé2£B‚lHO ™VY.<T‰Eïü>y®Ù(˛uxY"(ﬁñ›ûcrÊö¯Ú(	 Y¢S$6†Ö¸ÉÒ;øæËËº‘¥h∂˚˜f∑™óN%%•¨¶C$ûÆ©Í∏Vg<_≤h÷‚uÊqEJ%Í´¥.Á∑”˝KHπ"÷:≠ì;Ë¯£Ò ŸiBÈY˙°ÑE6¨µ‘)’IÃ\ÉÁ†¿‘%t¿Q°¯F ◊G˝`	È˛~N okà}j·π¯rΩÃ≠FCo»ü∏T¢€a94∑òÿxéÅ …ô¶ÕUP∑≤∑∂òŒÆy˛~¸é¶Bh7Nõä±‰,-ò∑∞n◊ºà{¡_≠‹zíÀ1iä
._~	µtC  t©á‰4©’òÕ¨Qﬂ}2·N @œ„,ı·€d_TàÔPëheÚáÀŒ´·y¯vH∞ ⁄⁄>QÉ™¥ó‡!nra]& "ÖKªh|dø·bNÙ#u3€Üˇ/åú•µ¬ˆÃ(fAÓ”±ﬁUQìë&ØX"%1’ïŸºÕíl–Î]≤Æ¿‹∑Gèæ-ÍL(ìxƒ†=ÊÔÛ‘p¶ Ònôûﬁ4€~œ@De°QZÜÁ6îZXC_™‚ß‘€é1%0#	*ÜHÜ˜	1qÉ¶Œ˚Ÿ=¥ÀVéN*Ñ®L°5¥0A010	`ÜHe  /¡Õ,¸Üúj0ö÷TÂ±f‚®∂Wmî2¬÷i‹Á≥Ú¨\¶–ß¥õ 


=== ./config/default_config.toml ===
[node]
name = "MyNode"



=== ./project_parts/core_files_00 ===
./icn_networking/Cargo.toml
./icn_networking/src/lib/mod.rs
./icn_networking/src/lib.rs
./icn_blockchain/Cargo.toml
./icn_blockchain/src/lib/mod.rs
./icn_blockchain/src/transaction/mod.rs
./icn_blockchain/src/lib.rs
./icn_blockchain/src/block/mod.rs
./icn_blockchain/src/chain/mod.rs
./.github/workflows/ci.yml
./.github/workflows/static.yml
./.github/FUNDING.yml
./.vscode/settings.json
./icn_virtual_machine/Cargo.toml
./icn_virtual_machine/src/lib/mod.rs
./icn_virtual_machine/src/lib.rs
./icn_consensus/Cargo.toml
./icn_consensus/src/lib/mod.rs
./icn_consensus/src/lib.rs
./icn_consensus/src/proof_of_cooperation.rs
./icn_governance/Cargo.toml
./icn_governance/src/lib/mod.rs
./icn_governance/src/lib.rs
./Cargo.toml
./icn_core/Cargo.toml
./icn_core/src/config/mod.rs
./icn_core/src/config/config_loader.rs
./icn_core/src/lib/mod.rs
./icn_core/src/main.rs
./icn_core/src/node/mod.rs
./icn_core/src/node/node_manager.rs
./icn_core/src/lib.rs
./icn_core/src/coordinator/module_coordinator.rs
./icn_core/src/coordinator/mod.rs
./icn_storage/Cargo.toml
./icn_storage/src/lib/mod.rs
./icn_storage/src/lib.rs
./icn_identity/Cargo.toml
./icn_identity/src/lib/mod.rs
./icn_identity/src/lib.rs
./icn_smart_contracts/Cargo.toml
./icn_smart_contracts/src/lib/mod.rs
./icn_smart_contracts/src/lib.rs
./icn_api/Cargo.toml
./icn_api/src/lib/mod.rs
./icn_api/src/lib.rs



=== ./icn_blockchain/Cargo.toml ===
[package]
name = "icn_blockchain"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
sha2 = "0.10"
chrono = "0.4"



=== ./icn_blockchain/src/lib/mod.rs ===



=== ./icn_blockchain/src/transaction/mod.rs ===
use serde::{Serialize, Deserialize};

/// Represents the different types of transactions supported by the blockchain
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)] 
pub enum TransactionType {
    Transfer,
    DeployContract,
    // Add more variants as needed
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Transaction {
    pub sender: String,
    pub receiver: String,
    pub amount: u64,
    pub transaction_type: TransactionType, 
}

impl Transaction {
    pub fn new(sender: &str, receiver: &str, amount: u64) -> Self {
        Transaction {
            sender: sender.to_string(),
            receiver: receiver.to_string(),
            amount,
            transaction_type: TransactionType::Transfer, 
        }
    }

    pub fn validate_transaction(&self) -> bool {
        match self.transaction_type {
            TransactionType::Transfer => {
                !self.sender.is_empty() && !self.receiver.is_empty() && self.amount > 0
            }
            TransactionType::DeployContract => {
                // Validation logic specific to DeployContract transactions
                // ... (Add your validation logic here)
                false // Placeholder for now
            }
            // Add more match arms for other transaction types as needed
        }
    }
}



=== ./icn_blockchain/src/transaction/transaction_type.rs ===
/// Represents the different types of transactions supported by the blockchain
#[derive(Debug, Clone, PartialEq, Eq)] // Add necessary derives based on your project's requirements
pub enum TransactionType {
    Transfer,
    DeployContract,
    // Add more variants as needed
}



=== ./icn_blockchain/src/lib.rs ===
// icn_blockchain/src/lib.rs
pub mod block;
pub mod chain;

pub use block::Block;
pub use chain::Chain;



=== ./icn_blockchain/src/block/mod.rs ===
// icn_blockchain/src/block/mod.rs

#[derive(Clone)] // Added Clone derive
/// The `Block` struct represents a block in the blockchain.
/// It contains essential data such as index, timestamp, transactions, and hashes.
pub struct Block {
    pub index: u64,
    pub timestamp: u64,
    pub transactions: Vec<String>,  // Placeholder for actual transactions
    pub previous_hash: String,
    pub hash: String,
    pub proposer_id: String,  // Added field for proposer ID
}

impl Block {
    /// Creates a new block with the given parameters.
    pub fn new(
        index: u64,
        timestamp: u64,
        transactions: Vec<String>,
        previous_hash: String,
        hash: String,
        proposer_id: String,
    ) -> Self {
        Block {
            index,
            timestamp,
            transactions,
            previous_hash,
            hash,
            proposer_id,
        }
    }

    /// Placeholder method for validating transactions in a block.
    pub fn validate_transactions(&self) -> bool {
        !self.transactions.is_empty()
    }
}



=== ./icn_blockchain/src/chain/mod.rs ===
// icn_blockchain/src/chain/mod.rs

use crate::block::Block;
use std::collections::VecDeque;

pub struct Chain {
    blocks: VecDeque<Block>,
}

impl Chain {
    pub fn new() -> Self {
        let genesis_block = create_genesis_block();
        let mut blocks = VecDeque::new();
        blocks.push_back(genesis_block);
        Chain { blocks }
    }

    pub fn add_block(&mut self, block: Block) {
        self.blocks.push_back(block);
    }

    pub fn get_latest_block(&self) -> Option<&Block> {
        self.blocks.back()
    }

    pub fn len(&self) -> usize {
        self.blocks.len()
    }
}

fn create_genesis_block() -> Block {
    let transactions = vec![];
    Block::new(0, 0, transactions, String::from("0"), String::from("genesis_hash"), String::from("genesis_proposer"))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_chain_creation() {
        let chain = Chain::new();
        assert_eq!(chain.len(), 1);
        assert!(chain.get_latest_block().is_some());
    }

    #[test]
    fn test_add_block() {
        let mut chain = Chain::new();
        let new_block = Block::new(1, 0, vec![], String::from("prev_hash"), String::from("new_hash"), String::from("proposer"));
        chain.add_block(new_block);
        assert_eq!(chain.len(), 2);
    }
}


=== ./.github/workflows/ci.yml ===
# name: Rust CI

# on:
#   push:
#     branches: [ main ]
#   pull_request:
#     branches: [ main ]

# env:
#   CARGO_TERM_COLOR: always

# jobs:
#   build:
#     runs-on: ubuntu-latest
#     steps:
#     - uses: actions/checkout@v2
#     - name: Build
#       run: cargo build --verbose
#     - name: Run tests
#       run: cargo test --verbose


=== ./.github/workflows/static.yml ===
# Simple workflow for deploying static content to GitHub Pages
name: Deploy static content to Pages

on:
  # Runs on pushes targeting the default branch
  push:
    branches: ["main"]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # Single deploy job since we're just deploying
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Pages
        uses: actions/configure-pages@v5
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          # Upload entire repository
          path: '.'
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4



=== ./.github/FUNDING.yml ===
#github: [fahertym]
#patreon: InterCooperativeNetwork
open_collective: intercooperative-network



=== ./.vscode/settings.json ===
{
    "liveServer.settings.port": 5501
}


=== ./icn_virtual_machine/Cargo.toml ===
[package]
name = "icn_virtual_machine"
version = "0.1.0"
edition = "2021"

[dependencies]



=== ./icn_virtual_machine/src/lib/mod.rs ===



=== ./icn_virtual_machine/src/bytecode.rs ===
// icn_virtual_machine/src/bytecode.rs

/// The `Bytecode` struct represents the compiled code of a smart contract.
/// It contains a vector of bytes that the virtual machine can execute.
pub struct Bytecode {
    pub code: Vec<u8>,
}

impl Bytecode {
    /// Creates a new instance of `Bytecode`.
    pub fn new(code: Vec<u8>) -> Self {
        Bytecode { code }
    }
}



=== ./icn_virtual_machine/src/lib.rs ===
// icn_virtual_machine/src/lib.rs

pub mod bytecode;
pub mod execution_engine;

use bytecode::Bytecode;
use execution_engine::ExecutionEngine;

/// The `VirtualMachine` struct is responsible for executing smart contracts.
/// It processes bytecode using an execution engine.
pub struct VirtualMachine {
    engine: ExecutionEngine,
}

impl VirtualMachine {
    /// Creates a new instance of the `VirtualMachine`.
    pub fn new() -> Self {
        VirtualMachine {
            engine: ExecutionEngine::new(),
        }
    }

    /// Executes a smart contract represented by bytecode.
    pub fn execute(&mut self, bytecode: Bytecode) -> Result<(), String> {
        self.engine.execute(bytecode)
    }
}



=== ./icn_virtual_machine/src/execution_engine.rs ===
// icn_virtual_machine/src/execution_engine.rs

use crate::bytecode::Bytecode;

/// The `ExecutionEngine` struct is responsible for processing bytecode
/// and executing smart contracts.
pub struct ExecutionEngine;

impl ExecutionEngine {
    /// Creates a new `ExecutionEngine` instance.
    pub fn new() -> Self {
        ExecutionEngine
    }

    /// Executes the provided bytecode.
    /// Currently, this is a placeholder for future implementation.
    pub fn execute(&self, bytecode: Bytecode) -> Result<(), String> {
        // Placeholder logic for executing bytecode
        if bytecode.code.is_empty() {
            return Err("Bytecode is empty".to_string());
        }
        // Here we would parse and execute the bytecode
        println!("Executing bytecode: {:?}", bytecode.code);
        Ok(())
    }
}



=== ./.gitmodules ===



=== ./icn_consensus/Cargo.toml ===
[package]
name = "icn_consensus"
version = "0.1.0"
edition = "2018"

[dependencies]
icn_shared = { path = "../icn_shared" }
icn_blockchain = { path = "../icn_blockchain" }
log = "0.4"
rand = "0.8"  # Add this line



=== ./icn_consensus/src/lib/mod.rs ===



=== ./icn_consensus/src/lib.rs ===
// icn_consensus/src/lib.rs

use icn_blockchain::block::Block;
use icn_shared::{IcnError, IcnResult};

pub mod proof_of_cooperation;
use proof_of_cooperation::ProofOfCooperation;

/// The Consensus struct manages the consensus mechanism for the blockchain.
pub struct Consensus {
    proof_of_cooperation: ProofOfCooperation,
}

impl Consensus {
    /// Creates a new Consensus instance.
    pub fn new() -> Self {
        Consensus {
            proof_of_cooperation: ProofOfCooperation::new(),
        }
    }

    /// Validates a block using the current consensus mechanism.
    pub fn validate_block(&self, block: &Block) -> IcnResult<bool> {
        self.proof_of_cooperation.validate(block)
    }

    /// Handles a potential fork by comparing two chains.
    pub fn handle_fork(&self, chain_a: &[Block], chain_b: &[Block]) -> IcnResult<Vec<Block>> {
        let chosen_chain = self.proof_of_cooperation.handle_fork(chain_a, chain_b);
        Ok(chosen_chain.to_vec())
    }

    /// Registers a new peer in the consensus mechanism.
    pub fn register_peer(&mut self, peer_id: &str) -> IcnResult<()> {
        self.proof_of_cooperation.register_peer(peer_id);
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_blockchain::block::Block;

    #[test]
    fn test_consensus_creation() {
        let mut consensus = Consensus::new();
        let proposer_id = "peer1".to_string();
        
        consensus.register_peer(&proposer_id).unwrap();

        let block = Block::new(0, 0, vec![], proposer_id.clone(), String::new(), String::new());
        assert!(consensus.validate_block(&block).unwrap());
    }

    #[test]
    fn test_handle_fork() {
        let consensus = Consensus::new();
        let chain_a = vec![Block::new(0, 0, vec![], String::new(), String::new(), String::new())];
        let chain_b = vec![
            Block::new(0, 0, vec![], String::new(), String::new(), String::new()),
            Block::new(1, 0, vec![], String::new(), String::new(), String::new()),
        ];
        let result = consensus.handle_fork(&chain_a, &chain_b).unwrap();
        assert_eq!(result.len(), 2);
    }

    #[test]
    fn test_register_peer() {
        let mut consensus = Consensus::new();
        assert!(consensus.register_peer("peer1").is_ok());
    }
}


=== ./icn_consensus/src/proof_of_cooperation.rs ===
// icn_consensus/src/proof_of_cooperation.rs

use std::collections::{HashMap, HashSet};
use icn_blockchain::block::Block;
use icn_shared::{IcnError, IcnResult};
use rand::Rng;
use std::time::{SystemTime, UNIX_EPOCH};

pub struct ProofOfCooperation {
    known_peers: HashSet<String>,
    cooperation_scores: HashMap<String, f64>,
    last_block_time: u64,
}

impl ProofOfCooperation {
    pub fn new() -> Self {
        ProofOfCooperation {
            known_peers: HashSet::new(),
            cooperation_scores: HashMap::new(),
            last_block_time: 0,
        }
    }

    pub fn register_peer(&mut self, peer_id: &str) {
        self.known_peers.insert(peer_id.to_string());
        self.cooperation_scores.insert(peer_id.to_string(), 1.0);
    }

    pub fn validate(&self, block: &Block) -> IcnResult<bool> {
        if !self.known_peers.contains(&block.proposer_id) {
            return Err(IcnError::Consensus(format!("Unknown proposer: {}", block.proposer_id)));
        }

        let current_time = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .map_err(|e| IcnError::Other(format!("System time error: {}", e)))?
            .as_secs();

        if current_time < self.last_block_time + 10 {
            return Err(IcnError::Consensus("Block proposed too soon".to_string()));
        }

        // Additional validation logic here (e.g., checking signatures, ensuring cooperation)
        Ok(true)
    }

    pub fn select_proposer(&self) -> IcnResult<String> {
        let mut rng = rand::thread_rng();
        let total_score: f64 = self.cooperation_scores.values().sum();
        let random_value: f64 = rng.gen::<f64>() * total_score;

        let mut cumulative_score = 0.0;
        for (peer_id, score) in &self.cooperation_scores {
            cumulative_score += score;
            if cumulative_score >= random_value {
                return Ok(peer_id.clone());
            }
        }

        Err(IcnError::Consensus("Failed to select a proposer".to_string()))
    }

    pub fn update_cooperation_score(&mut self, peer_id: &str, performance: f64) -> IcnResult<()> {
        let score = self.cooperation_scores
            .get_mut(peer_id)
            .ok_or_else(|| IcnError::Consensus(format!("Unknown peer: {}", peer_id)))?;
        
        *score = score.max(0.1).min(2.0) * performance;
        Ok(())
    }

    pub fn handle_fork<'a>(&self, chain_a: &'a [Block], chain_b: &'a [Block]) -> &'a [Block] {
        // Simple longest chain rule for now
        if chain_a.len() >= chain_b.len() {
            chain_a
        } else {
            chain_b
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_blockchain::block::Block;

    #[test]
    fn test_register_and_validate_peer() {
        let mut poc = ProofOfCooperation::new();
        poc.register_peer("peer1");
        
        let block = Block::new(0, 0, vec![], "peer1".to_string(), "hash".to_string(), "peer1".to_string());
        assert!(poc.validate(&block).is_ok());

        let invalid_block = Block::new(0, 0, vec![], "unknown_peer".to_string(), "hash".to_string(), "unknown_peer".to_string());
        assert!(poc.validate(&invalid_block).is_err());
    }

    #[test]
    fn test_select_proposer() {
        let mut poc = ProofOfCooperation::new();
        poc.register_peer("peer1");
        poc.register_peer("peer2");
        
        let proposer = poc.select_proposer().unwrap();
        assert!(vec!["peer1", "peer2"].contains(&proposer.as_str()));
    }

    #[test]
    fn test_update_cooperation_score() {
        let mut poc = ProofOfCooperation::new();
        poc.register_peer("peer1");
        
        poc.update_cooperation_score("peer1", 1.5).unwrap();
        assert!(poc.cooperation_scores["peer1"] > 1.0);

        poc.update_cooperation_score("peer1", 0.5).unwrap();
        assert!(poc.cooperation_scores["peer1"] < 1.0);
    }
}


=== ./icn_governance/Cargo.toml ===
[package]
name = "icn_governance"
version = "0.1.0"
edition = "2021"

[dependencies]



=== ./icn_governance/src/lib/mod.rs ===



=== ./icn_governance/src/lib.rs ===
pub struct Proposal {
    pub id: u32,
    pub description: String,
    pub votes_for: u32,
    pub votes_against: u32,
}

impl Proposal {
    pub fn new(id: u32, description: &str) -> Self {
        Proposal {
            id,
            description: description.to_string(),
            votes_for: 0,
            votes_against: 0,
        }
    }

    pub fn vote_for(&mut self) {
        self.votes_for += 1;
    }

    pub fn vote_against(&mut self) {
        self.votes_against += 1;
    }
}



=== ./Cargo.toml ===
[workspace]
members = [
    "icn_core",
    "icn_blockchain",
    "icn_consensus",
    "icn_networking",
    "icn_identity",
    "icn_governance",
    "icn_smart_contracts",
    "icn_virtual_machine",
    "icn_api",
    "icn_storage",
    "icn_shared"
]
default-run = "icn_core"

resolver = "2"


=== ./Cargo.lock ===
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "addr2line"
version = "0.22.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e4503c46a5c0c7844e948c9a4d6acd9f50cccb4de1c48eb9e291ea17470c678"
dependencies = [
 "gimli",
]

[[package]]
name = "adler"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe"

[[package]]
name = "ahash"
version = "0.7.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "891477e0c6a8957309ee5c45a6368af3ae14bb510732d2684ffa19af310920f9"
dependencies = [
 "getrandom",
 "once_cell",
 "version_check",
]

[[package]]
name = "aho-corasick"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
dependencies = [
 "memchr",
]

[[package]]
name = "android-tzdata"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0"

[[package]]
name = "android_system_properties"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
dependencies = [
 "libc",
]

[[package]]
name = "async-trait"
version = "0.1.81"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e0c28dcc82d7c8ead5cb13beb15405b57b8546e93215673ff8ca0349a028107"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "autocfg"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0c4b4d0bd25bd0b74681c0ad21497610ce1b7c91b1022cd21c80c6fbdd9476b0"

[[package]]
name = "backtrace"
version = "0.3.73"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5cc23269a4f8976d0a4d2e7109211a419fe30e8d88d677cd60b6bc79c5732e0a"
dependencies = [
 "addr2line",
 "cc",
 "cfg-if",
 "libc",
 "miniz_oxide",
 "object",
 "rustc-demangle",
]

[[package]]
name = "base64"
version = "0.13.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e1b586273c5702936fe7b7d6896644d8be71e6314cfe09d3167c95f712589e8"

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b048fb63fd8b5923fc5aa7b340d8e156aec7ec02f0c78fa8a6ddc2613f6f71de"

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array",
]

[[package]]
name = "bumpalo"
version = "3.16.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "79296716171880943b8470b5f8d03aa55eb2e645a4874bdbb28adb49162e012c"

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "bytes"
version = "1.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8318a53db07bb3f8dca91a600466bdb3f2eaadeedfdbcf02e1accbad9271ba50"

[[package]]
name = "cc"
version = "1.1.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72db2f7947ecee9b03b510377e8bb9077afa27176fdbff55c51027e976fdcc48"
dependencies = [
 "shlex",
]

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "chrono"
version = "0.4.38"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a21f936df1771bf62b77f047b726c4625ff2e8aa607c01ec06e5a05bd8463401"
dependencies = [
 "android-tzdata",
 "iana-time-zone",
 "js-sys",
 "num-traits",
 "wasm-bindgen",
 "windows-targets",
]

[[package]]
name = "config"
version = "0.13.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "23738e11972c7643e4ec947840fc463b6a571afcd3e735bdfce7d03c7a784aca"
dependencies = [
 "async-trait",
 "json5",
 "lazy_static",
 "nom",
 "pathdiff",
 "ron",
 "rust-ini",
 "serde",
 "serde_json",
 "toml",
 "yaml-rust",
]

[[package]]
name = "core-foundation"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "91e195e091a93c46f7102ec7818a2aa394e1e1771c3ab4825963fa03e45afb8f"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "core-foundation-sys"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"

[[package]]
name = "cpufeatures"
version = "0.2.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "51e852e6dc9a5bed1fae92dd2375037bf2b768725bf3be87811edee3249d09ad"
dependencies = [
 "libc",
]

[[package]]
name = "crypto-common"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
dependencies = [
 "generic-array",
 "typenum",
]

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer",
 "crypto-common",
]

[[package]]
name = "dlv-list"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0688c2a7f92e427f44895cd63841bff7b29f8d7a1648b9e7e07a4a365b2e1257"

[[package]]
name = "env_logger"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4cd405aab171cb85d6735e5c8d9db038c17d3ca007a4d2c25f337935c3d90580"
dependencies = [
 "humantime",
 "is-terminal",
 "log",
 "regex",
 "termcolor",
]

[[package]]
name = "errno"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "534c5cf6194dfab3db3242765c03bbe257cf92f22b38f6bc0c58d59108a820ba"
dependencies = [
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "fastrand"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fc0510504f03c51ada170672ac806f1f105a88aa97a5281117e1ddc3368e51a"

[[package]]
name = "foreign-types"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6f339eb8adc052cd2ca78910fda869aefa38d22d5cb648e6485e4d3fc06f3b1"
dependencies = [
 "foreign-types-shared",
]

[[package]]
name = "foreign-types-shared"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00b0228411908ca8685dba7fc2cdd70ec9990a6e753e89b6ac91a84c40fbaf4b"

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "typenum",
 "version_check",
]

[[package]]
name = "getrandom"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c4567c8db10ae91089c99af84c68c38da3ec2f087c3f82960bcdbf3656b6f4d7"
dependencies = [
 "cfg-if",
 "libc",
 "wasi",
]

[[package]]
name = "gimli"
version = "0.29.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "40ecd4077b5ae9fd2e9e169b102c6c330d0605168eb0e8bf79952b256dbefffd"

[[package]]
name = "hashbrown"
version = "0.12.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888"
dependencies = [
 "ahash",
]

[[package]]
name = "hermit-abi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d231dfb89cfffdbc30e7fc41579ed6066ad03abda9e567ccafae602b97ec5024"

[[package]]
name = "hermit-abi"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fbf6a919d6cf397374f7dfeeea91d974c7c0a7221d0d0f4f20d859d329e53fcc"

[[package]]
name = "humantime"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a3a5bfb195931eeb336b2a7b4d761daec841b97f947d34394601737a7bba5e4"

[[package]]
name = "iana-time-zone"
version = "0.1.60"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7ffbb5a1b541ea2561f8c41c087286cc091e21e556a4f09a8f6cbf17b69b141"
dependencies = [
 "android_system_properties",
 "core-foundation-sys",
 "iana-time-zone-haiku",
 "js-sys",
 "wasm-bindgen",
 "windows-core",
]

[[package]]
name = "iana-time-zone-haiku"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
dependencies = [
 "cc",
]

[[package]]
name = "icn_api"
version = "0.1.0"

[[package]]
name = "icn_blockchain"
version = "0.1.0"
dependencies = [
 "chrono",
 "serde",
 "serde_json",
 "sha2",
]

[[package]]
name = "icn_consensus"
version = "0.1.0"
dependencies = [
 "icn_blockchain",
 "icn_shared",
 "log",
 "rand",
]

[[package]]
name = "icn_core"
version = "0.1.0"
dependencies = [
 "config",
 "env_logger",
 "icn_blockchain",
 "icn_consensus",
 "icn_governance",
 "icn_identity",
 "icn_networking",
 "icn_shared",
 "log",
 "native-tls",
 "tempfile",
 "tokio",
 "toml",
]

[[package]]
name = "icn_governance"
version = "0.1.0"

[[package]]
name = "icn_identity"
version = "0.1.0"
dependencies = [
 "icn_shared",
]

[[package]]
name = "icn_networking"
version = "0.1.0"
dependencies = [
 "icn_shared",
 "log",
 "native-tls",
 "tokio",
 "tokio-native-tls",
]

[[package]]
name = "icn_shared"
version = "0.1.0"
dependencies = [
 "log",
 "native-tls",
 "serde",
 "serde_json",
]

[[package]]
name = "icn_smart_contracts"
version = "0.1.0"

[[package]]
name = "icn_storage"
version = "0.1.0"
dependencies = [
 "icn_blockchain",
]

[[package]]
name = "icn_virtual_machine"
version = "0.1.0"

[[package]]
name = "is-terminal"
version = "0.4.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "261f68e344040fbd0edea105bef17c66edf46f984ddb1115b775ce31be948f4b"
dependencies = [
 "hermit-abi 0.4.0",
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "itoa"
version = "1.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49f1f14873335454500d59611f1cf4a4b0f786f9ac11f4312a78e4cf2566695b"

[[package]]
name = "js-sys"
version = "0.3.70"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1868808506b929d7b0cfa8f75951347aa71bb21144b7791bae35d9bccfcfe37a"
dependencies = [
 "wasm-bindgen",
]

[[package]]
name = "json5"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96b0db21af676c1ce64250b5f40f3ce2cf27e4e47cb91ed91eb6fe9350b430c1"
dependencies = [
 "pest",
 "pest_derive",
 "serde",
]

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"

[[package]]
name = "libc"
version = "0.2.158"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d8adc4bb1803a324070e64a98ae98f38934d91957a99cfb3a43dcbc01bc56439"

[[package]]
name = "linked-hash-map"
version = "0.5.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0717cef1bc8b636c6e1c1bbdefc09e6322da8a9321966e8928ef80d20f7f770f"

[[package]]
name = "linux-raw-sys"
version = "0.4.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78b3ae25bc7c8c38cec158d1f2757ee79e9b3740fbc7ccf0e59e4b08d793fa89"

[[package]]
name = "lock_api"
version = "0.4.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07af8b9cdd281b7915f413fa73f29ebd5d55d0d3f0155584dade1ff18cea1b17"
dependencies = [
 "autocfg",
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7a70ba024b9dc04c27ea2f0c0548feb474ec5c54bba33a7f72f873a39d07b24"

[[package]]
name = "memchr"
version = "2.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3"

[[package]]
name = "minimal-lexical"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"

[[package]]
name = "miniz_oxide"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b8a240ddb74feaf34a79a7add65a741f3167852fba007066dcac1ca548d89c08"
dependencies = [
 "adler",
]

[[package]]
name = "mio"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "80e04d1dcff3aae0704555fe5fee3bcfaf3d1fdf8a7e521d5b9d2b42acb52cec"
dependencies = [
 "hermit-abi 0.3.9",
 "libc",
 "wasi",
 "windows-sys 0.52.0",
]

[[package]]
name = "native-tls"
version = "0.2.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8614eb2c83d59d1c8cc974dd3f920198647674a0a035e1af1fa58707e317466"
dependencies = [
 "libc",
 "log",
 "openssl",
 "openssl-probe",
 "openssl-sys",
 "schannel",
 "security-framework",
 "security-framework-sys",
 "tempfile",
]

[[package]]
name = "nom"
version = "7.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
dependencies = [
 "memchr",
 "minimal-lexical",
]

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
]

[[package]]
name = "object"
version = "0.36.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "27b64972346851a39438c60b341ebc01bba47464ae329e55cf343eb93964efd9"
dependencies = [
 "memchr",
]

[[package]]
name = "once_cell"
version = "1.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3fdb12b2476b595f9358c5161aa467c2438859caa136dec86c26fdd2efe17b92"

[[package]]
name = "openssl"
version = "0.10.66"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9529f4786b70a3e8c61e11179af17ab6188ad8d0ded78c5529441ed39d4bd9c1"
dependencies = [
 "bitflags 2.6.0",
 "cfg-if",
 "foreign-types",
 "libc",
 "once_cell",
 "openssl-macros",
 "openssl-sys",
]

[[package]]
name = "openssl-macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a948666b637a0f465e8564c73e89d4dde00d72d4d473cc972f390fc3dcee7d9c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "openssl-probe"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ff011a302c396a5197692431fc1948019154afc178baf7d8e37367442a4601cf"

[[package]]
name = "openssl-sys"
version = "0.9.103"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f9e8deee91df40a943c71b917e5874b951d32a802526c85721ce3b776c929d6"
dependencies = [
 "cc",
 "libc",
 "pkg-config",
 "vcpkg",
]

[[package]]
name = "ordered-multimap"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ccd746e37177e1711c20dd619a1620f34f5c8b569c53590a72dedd5344d8924a"
dependencies = [
 "dlv-list",
 "hashbrown",
]

[[package]]
name = "parking_lot"
version = "0.12.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f1bf18183cf54e8d6059647fc3063646a1801cf30896933ec2311622cc4b9a27"
dependencies = [
 "lock_api",
 "parking_lot_core",
]

[[package]]
name = "parking_lot_core"
version = "0.9.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e401f977ab385c9e4e3ab30627d6f26d00e2c73eef317493c4ec6d468726cf8"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall",
 "smallvec",
 "windows-targets",
]

[[package]]
name = "pathdiff"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8835116a5c179084a830efb3adc117ab007512b535bc1a21c991d3b32a6b44dd"

[[package]]
name = "pest"
version = "2.7.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cd53dff83f26735fdc1ca837098ccf133605d794cdae66acfc2bfac3ec809d95"
dependencies = [
 "memchr",
 "thiserror",
 "ucd-trie",
]

[[package]]
name = "pest_derive"
version = "2.7.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2a548d2beca6773b1c244554d36fcf8548a8a58e74156968211567250e48e49a"
dependencies = [
 "pest",
 "pest_generator",
]

[[package]]
name = "pest_generator"
version = "2.7.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c93a82e8d145725dcbaf44e5ea887c8a869efdcc28706df2d08c69e17077183"
dependencies = [
 "pest",
 "pest_meta",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "pest_meta"
version = "2.7.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a941429fea7e08bedec25e4f6785b6ffaacc6b755da98df5ef3e7dcf4a124c4f"
dependencies = [
 "once_cell",
 "pest",
 "sha2",
]

[[package]]
name = "pin-project-lite"
version = "0.2.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bda66fc9667c18cb2758a2ac84d1167245054bcf85d5d1aaa6923f45801bdd02"

[[package]]
name = "pkg-config"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d231b230927b5e4ad203db57bbcbee2802f6bce620b1e4a9024a07d94e2907ec"

[[package]]
name = "ppv-lite86"
version = "0.2.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77957b295656769bb8ad2b6a6b09d897d94f05c41b069aede1fcdaa675eaea04"
dependencies = [
 "zerocopy",
]

[[package]]
name = "proc-macro2"
version = "1.0.86"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e719e8df665df0d1c8fbfd238015744736151d4445ec0836b8e628aae103b77"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.36"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fa76aaf39101c457836aec0ce2316dbdc3ab723cdda1c6bd4e6ad4208acaca7"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "libc",
 "rand_chacha",
 "rand_core",
]

[[package]]
name = "rand_chacha"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
dependencies = [
 "ppv-lite86",
 "rand_core",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom",
]

[[package]]
name = "redox_syscall"
version = "0.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2a908a6e00f1fdd0dfd9c0eb08ce85126f6d8bbda50017e74bc4a4b7d4a926a4"
dependencies = [
 "bitflags 2.6.0",
]

[[package]]
name = "regex"
version = "1.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4219d74c6b67a3654a9fbebc4b419e22126d13d2f3c4a07ee0cb61ff79a79619"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata",
 "regex-syntax",
]

[[package]]
name = "regex-automata"
version = "0.4.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38caf58cc5ef2fed281f89292ef23f6365465ed9a41b7a7754eb4e26496c92df"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax",
]

[[package]]
name = "regex-syntax"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a66a03ae7c801facd77a29370b4faec201768915ac14a721ba36f20bc9c209b"

[[package]]
name = "ron"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "88073939a61e5b7680558e6be56b419e208420c2adb92be54921fa6b72283f1a"
dependencies = [
 "base64",
 "bitflags 1.3.2",
 "serde",
]

[[package]]
name = "rust-ini"
version = "0.18.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6d5f2436026b4f6e79dc829837d467cc7e9a55ee40e750d716713540715a2df"
dependencies = [
 "cfg-if",
 "ordered-multimap",
]

[[package]]
name = "rustc-demangle"
version = "0.1.24"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "719b953e2095829ee67db738b3bfa9fa368c94900df327b3f07fe6e794d2fe1f"

[[package]]
name = "rustix"
version = "0.38.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70dc5ec042f7a43c4a73241207cecc9873a06d45debb38b329f8541d85c2730f"
dependencies = [
 "bitflags 2.6.0",
 "errno",
 "libc",
 "linux-raw-sys",
 "windows-sys 0.52.0",
]

[[package]]
name = "ryu"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f3cb5ba0dc43242ce17de99c180e96db90b235b8a9fdc9543c96d2209116bd9f"

[[package]]
name = "schannel"
version = "0.1.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fbc91545643bcf3a0bbb6569265615222618bdf33ce4ffbbd13c4bbd4c093534"
dependencies = [
 "windows-sys 0.52.0",
]

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "security-framework"
version = "2.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "897b2245f0b511c87893af39b033e5ca9cce68824c4d7e7630b5a1d339658d02"
dependencies = [
 "bitflags 2.6.0",
 "core-foundation",
 "core-foundation-sys",
 "libc",
 "security-framework-sys",
]

[[package]]
name = "security-framework-sys"
version = "2.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75da29fe9b9b08fe9d6b22b5b4bcbc75d8db3aa31e639aa56bb62e9d46bfceaf"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "serde"
version = "1.0.208"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cff085d2cb684faa248efb494c39b68e522822ac0de72ccf08109abde717cfb2"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.208"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24008e81ff7613ed8e5ba0cfaf24e2c2f1e5b8a0495711e44fcd4882fca62bcf"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "serde_json"
version = "1.0.125"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "83c8e735a073ccf5be70aa8066aa984eaf2fa000db6c8d0100ae605b366d31ed"
dependencies = [
 "itoa",
 "memchr",
 "ryu",
 "serde",
]

[[package]]
name = "sha2"
version = "0.10.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "793db75ad2bcafc3ffa7c68b215fee268f537982cd901d132f89c6343f3a3dc8"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "signal-hook-registry"
version = "1.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a9e9e0b4211b72e7b8b6e85c807d36c212bdb33ea8587f7569562a84df5465b1"
dependencies = [
 "libc",
]

[[package]]
name = "smallvec"
version = "1.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c5e1a9a646d36c3599cd173a41282daf47c44583ad367b8e6837255952e5c67"

[[package]]
name = "socket2"
version = "0.5.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ce305eb0b4296696835b71df73eb912e0f1ffd2556a501fcede6e0c50349191c"
dependencies = [
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "syn"
version = "2.0.75"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6af063034fc1935ede7be0122941bafa9bacb949334d090b77ca98b5817c7d9"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "tempfile"
version = "3.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "04cbcdd0c794ebb0d4cf35e88edd2f7d2c4c3e9a5a6dab322839b321c6a87a64"
dependencies = [
 "cfg-if",
 "fastrand",
 "once_cell",
 "rustix",
 "windows-sys 0.59.0",
]

[[package]]
name = "termcolor"
version = "1.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06794f8f6c5c898b3275aebefa6b8a1cb24cd2c6c79397ab15774837a0bc5755"
dependencies = [
 "winapi-util",
]

[[package]]
name = "thiserror"
version = "1.0.63"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0342370b38b6a11b6cc11d6a805569958d54cfa061a29969c3b5ce2ea405724"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "1.0.63"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4558b58466b9ad7ca0f102865eccc95938dca1a74a856f2b57b6629050da261"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tokio"
version = "1.39.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9babc99b9923bfa4804bd74722ff02c0381021eafa4db9949217e3be8e84fff5"
dependencies = [
 "backtrace",
 "bytes",
 "libc",
 "mio",
 "parking_lot",
 "pin-project-lite",
 "signal-hook-registry",
 "socket2",
 "tokio-macros",
 "windows-sys 0.52.0",
]

[[package]]
name = "tokio-macros"
version = "2.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "693d596312e88961bc67d7f1f97af8a70227d9f90c31bba5806eec004978d752"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tokio-native-tls"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbae76ab933c85776efabc971569dd6119c580d8f5d448769dec1764bf796ef2"
dependencies = [
 "native-tls",
 "tokio",
]

[[package]]
name = "toml"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f4f7f0dd8d50a853a531c426359045b1998f04219d88799810762cd4ad314234"
dependencies = [
 "serde",
]

[[package]]
name = "typenum"
version = "1.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42ff0bf0c66b8238c6f3b578df37d0b7848e55df8577b3f74f92a69acceeb825"

[[package]]
name = "ucd-trie"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed646292ffc8188ef8ea4d1e0e0150fb15a5c2e12ad9b8fc191ae7a8a7f3c4b9"

[[package]]
name = "unicode-ident"
version = "1.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b"

[[package]]
name = "vcpkg"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "accd4ea62f7bb7a82fe23066fb0957d48ef677f6eeb8215f372f52e48bb32426"

[[package]]
name = "version_check"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"

[[package]]
name = "wasi"
version = "0.11.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"

[[package]]
name = "wasm-bindgen"
version = "0.2.93"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a82edfc16a6c469f5f44dc7b571814045d60404b55a0ee849f9bcfa2e63dd9b5"
dependencies = [
 "cfg-if",
 "once_cell",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.93"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9de396da306523044d3302746f1208fa71d7532227f15e347e2d93e4145dd77b"
dependencies = [
 "bumpalo",
 "log",
 "once_cell",
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.93"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "585c4c91a46b072c92e908d99cb1dcdf95c5218eeb6f3bf1efa991ee7a68cccf"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.93"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "afc340c74d9005395cf9dd098506f7f44e38f2b4a21c6aaacf9a105ea5e1e836"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.93"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c62a0a307cb4a311d3a07867860911ca130c3494e8c2719593806c08bc5d0484"

[[package]]
name = "winapi-util"
version = "0.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cf221c93e13a30d793f7645a0e7762c55d169dbb0a49671918a2319d289b10bb"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "windows-core"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33ab640c8d7e35bf8ba19b884ba838ceb4fba93a4e8c65a9059d08afcfc683d9"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm",
 "windows_aarch64_msvc",
 "windows_i686_gnu",
 "windows_i686_gnullvm",
 "windows_i686_msvc",
 "windows_x86_64_gnu",
 "windows_x86_64_gnullvm",
 "windows_x86_64_msvc",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "yaml-rust"
version = "0.4.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56c1936c4cc7a1c9ab21a1ebb602eb942ba868cbd44a99cb7cdc5892335e1c85"
dependencies = [
 "linked-hash-map",
]

[[package]]
name = "zerocopy"
version = "0.7.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b9b4fd18abc82b8136838da5d50bae7bdea537c574d8dc1a34ed098d6c166f0"
dependencies = [
 "byteorder",
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.7.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa4f8080344d4671fb4e831a13ad1e68092748387dfc4f55e356242fae12ce3e"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]



=== ./icn_core/Cargo.toml ===
[package]
name = "icn_core"
version = "0.1.0"
edition = "2021"

[dependencies]
tempfile = "3.2"
native-tls = "0.2"
tokio = { version = "1.28", features = ["full"] }
config = "0.13"
env_logger = "0.10"
log = "0.4"
icn_consensus = { path = "../icn_consensus" }
icn_blockchain = { path = "../icn_blockchain" }
icn_identity = { path = "../icn_identity" }
icn_governance = { path = "../icn_governance" }
icn_networking = { path = "../icn_networking" }
icn_shared = { path = "../icn_shared" }
toml = "0.5"



=== ./icn_core/src/config/mod.rs ===
// icn_core/src/config/mod.rs

pub mod config_loader;  // This should match the file name where ConfigLoader is defined

pub use config_loader::ConfigLoader;  // Re-export ConfigLoader for easier access



=== ./icn_core/src/config/config_loader.rs ===
use std::fs;
use toml::{Value, map::Map};
use icn_shared::IcnError;

#[derive(Debug, Clone)]
pub struct ConfigLoader {
    config: Map<String, Value>,
}

impl ConfigLoader {
    pub fn new(config_path: &str) -> Result<Self, IcnError> {
        let config_content = fs::read_to_string(config_path)
            .map_err(|e| IcnError::Config(format!("Failed to read config file: {}", e)))?;

        let config: Map<String, Value> = toml::from_str(&config_content)
            .map_err(|e| IcnError::Config(format!("Failed to parse config file: {}", e)))?;

        Ok(ConfigLoader { config })
    }

    pub fn get_config(&self) -> &Map<String, Value> {
        &self.config
    }

    pub fn get_string(&self, key: &str) -> Result<String, IcnError> {
        self.get_nested_value(key)?
            .as_str()
            .map(|s| s.to_string())
            .ok_or_else(|| IcnError::Config(format!("Value for key '{}' is not a string", key)))
    }

    pub fn get_int(&self, key: &str) -> Result<i64, IcnError> {
        self.get_nested_value(key)?
            .as_integer()
            .ok_or_else(|| IcnError::Config(format!("Value for key '{}' is not an integer", key)))
    }

    pub fn get_bool(&self, key: &str) -> Result<bool, IcnError> {
        self.get_nested_value(key)?
            .as_bool()
            .ok_or_else(|| IcnError::Config(format!("Value for key '{}' is not a boolean", key)))
    }

    fn get_nested_value(&self, key: &str) -> Result<&Value, IcnError> {
        let parts: Vec<&str> = key.split('.').collect();
        let mut current = &self.config;

        for (i, &part) in parts.iter().enumerate() {
            if i == parts.len() - 1 {
                return current.get(part).ok_or_else(|| IcnError::Config(format!("Key '{}' not found", key)));
            }
            current = current.get(part)
                .and_then(|v| v.as_table())
                .ok_or_else(|| IcnError::Config(format!("Invalid nested key: {}", key)))?;
        }

        unreachable!()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::NamedTempFile;

    #[test]
    fn test_config_loader() {
        let config_content = r#"
            [server]
            host = "localhost"
            port = 8080

            [database]
            url = "postgres://user:pass@localhost/dbname"
            max_connections = 100

            [features]
            enable_caching = true
        "#;

        let mut config_file = NamedTempFile::new().unwrap();
        config_file.write_all(config_content.as_bytes()).unwrap();

        let config_loader = ConfigLoader::new(config_file.path().to_str().unwrap()).unwrap();

        assert_eq!(config_loader.get_string("server.host").unwrap(), "localhost");
        assert_eq!(config_loader.get_int("server.port").unwrap(), 8080);
        assert_eq!(config_loader.get_string("database.url").unwrap(), "postgres://user:pass@localhost/dbname");
        assert_eq!(config_loader.get_int("database.max_connections").unwrap(), 100);
        assert_eq!(config_loader.get_bool("features.enable_caching").unwrap(), true);

        assert!(config_loader.get_string("nonexistent.key").is_err());
    }
}



=== ./icn_core/src/lib/mod.rs ===



=== ./icn_core/src/errors.rs ===
// icn_core/src/errors.rs

use std::fmt;

/// `IcnError` defines custom errors for the ICN project.
/// This is used throughout the project for consistent error handling.
#[derive(Debug)]
pub enum IcnError {
    ConfigError(config::ConfigError),
    IoError(std::io::Error),
    TlsError(native_tls::Error),
    Other(String),
}

impl fmt::Display for IcnError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            IcnError::ConfigError(ref e) => write!(f, "Configuration error: {}", e),
            IcnError::IoError(ref e) => write!(f, "I/O error: {}", e),
            IcnError::TlsError(ref e) => write!(f, "TLS error: {}", e),
            IcnError::Other(ref s) => write!(f, "{}", s),
        }
    }
}

// Implement `From` trait to allow automatic conversion from other error types to `IcnError`.
impl From<config::ConfigError> for IcnError {
    fn from(err: config::ConfigError) -> IcnError {
        IcnError::ConfigError(err)
    }
}

impl From<std::io::Error> for IcnError {
    fn from(err: std::io::Error) -> IcnError {
        IcnError::IoError(err)
    }
}

impl From<native_tls::Error> for IcnError {
    fn from(err: native_tls::Error) -> IcnError {
        IcnError::TlsError(err)
    }
}

/// `IcnResult` is a custom result type that wraps around `Result` using the `IcnError`.
pub type IcnResult<T> = Result<T, IcnError>;



=== ./icn_core/src/main.rs ===
// /opt/InterCooperative-Network-Node/icn_core/src/main.rs

use icn_core::node::NodeManager;
use log::{error, info};
use std::env;
use std::process::exit;

#[tokio::main]
async fn main() {
    // Initialize logging
    env_logger::init();

    // Handle command-line arguments for config file path
    let args: Vec<String> = env::args().collect();
    let config_path = if args.len() > 1 {
        &args[1]
    } else {
        "config/default_config.toml" // Update this path to your actual config file location
    };

    // Create a new NodeManager instance, handling any potential errors
    let mut node = match NodeManager::new(config_path) {
        Ok(n) => n,
        Err(e) => {
            error!("Failed to initialize NodeManager: {:?}", e);
            exit(1); // Exit with an error code
        }
    };

    // Start the node, handling any errors during startup
    match node.start().await {
        Ok(_) => {
            info!("Node started successfully");
        }
        Err(e) => {
            error!("Failed to start node: {:?}", e);
            exit(1); // Exit with an error code
        }
    }

    // Signal handling for graceful shutdown
    if let Err(e) = tokio::signal::ctrl_c().await {
        error!("Failed to listen for shutdown signal: {:?}", e);
    }

    // Stop the node when receiving a shutdown signal
    if let Err(e) = node.stop().await {
        error!("Failed to stop node: {:?}", e);
    } else {
        info!("Node stopped gracefully");
    }
}



=== ./icn_core/src/node/mod.rs ===
mod node_manager;
pub use node_manager::NodeManager;



=== ./icn_core/src/node/node_manager.rs ===
use crate::config::ConfigLoader;  // Use `crate` instead of `icn_core`
use icn_shared::IcnResult;
use crate::coordinator::ModuleCoordinator;

pub struct NodeManager {
    config: ConfigLoader,
    coordinator: ModuleCoordinator,
}

impl NodeManager {
    pub fn new(config_loader: ConfigLoader, coordinator: ModuleCoordinator) -> Self {
        NodeManager {
            config: config_loader,
            coordinator,
        }
    }

    pub fn load_configuration(&self) -> IcnResult<()> {
        println!("Loaded full configuration: {:#?}", self.config.get_config());

        if let Some(_node_table) = self.config.get_config().get("node") {
            // Handle node table...
        }

        Ok(())
    }

    pub async fn start(&mut self) -> IcnResult<()> {
        self.coordinator.start().await?; // Async function, use await
        Ok(())
    }

    pub async fn stop(&mut self) -> IcnResult<()> {
        self.coordinator.stop()?; // No await needed as this is not async
        Ok(())
    }
}



=== ./icn_core/src/lib.rs ===
// /opt/InterCooperative-Network-Node/icn_core/src/lib.rs

pub mod config;
pub mod coordinator;
pub mod node;

// Remove the unused imports
// use icn_shared::{IcnError, IcnResult};



=== ./icn_core/src/coordinator/module_coordinator.rs ===
use icn_networking::Networking;
use native_tls::Identity; // Correct import
use std::fs::File;
use std::io::Read;
use icn_shared::IcnResult;

pub struct ModuleCoordinator {
    networking: Networking,
    // Other fields...
}

impl ModuleCoordinator {
    pub fn new() -> Self {
        // Initialize the Networking module and other fields
        ModuleCoordinator {
            networking: Networking::new(),
            // Other initializations...
        }
    }

    pub async fn start(&mut self) -> IcnResult<()> {
        // Load the identity from the certificate file
        let mut cert_file = File::open("test_cert.p12")?;
        let mut cert_data = Vec::new();
        cert_file.read_to_end(&mut cert_data)?;
        let identity = Identity::from_pkcs12(&cert_data, "password")?;

        // Start the networking server with the loaded identity
        self.networking.start_server("127.0.0.1:8080", identity).await?;

        // Other startup tasks...
        Ok(())
    }

    pub fn stop(&mut self) -> IcnResult<()> {
        // Logic to stop the networking or other modules
        // For now, just a placeholder implementation
        Ok(())
    }
}



=== ./icn_core/src/coordinator/mod.rs ===
mod module_coordinator;
pub use module_coordinator::ModuleCoordinator;



=== ./icn_storage/Cargo.toml ===
[package]
name = "icn_storage"
version = "0.1.0"
edition = "2018"

[dependencies]
icn_blockchain = { path = "../icn_blockchain" }



=== ./icn_storage/src/lib/mod.rs ===



=== ./icn_storage/src/block_storage.rs ===
// icn_storage/src/block_storage.rs

use icn_blockchain::block::Block;  // Correctly reference icn_blockchain

use std::collections::HashMap;

/// The `BlockStorage` struct is responsible for storing and retrieving blocks.
/// It uses an in-memory `HashMap` to store blocks by their hash.
pub struct BlockStorage {
    storage: HashMap<String, Block>,
}

impl BlockStorage {
    /// Creates a new `BlockStorage` instance.
    pub fn new() -> Self {
        BlockStorage {
            storage: HashMap::new(),
        }
    }

    /// Adds a new block to the storage.
    pub fn add_block(&mut self, block: Block) -> Result<(), String> {
        let hash = block.hash.clone();
        if self.storage.contains_key(&hash) {
            return Err("Block with this hash already exists.".to_string());
        }
        self.storage.insert(hash, block);
        Ok(())
    }

    /// Retrieves a block by its hash.
    pub fn get_block(&self, hash: &str) -> Option<Block> {
        self.storage.get(hash).cloned()
    }
}



=== ./icn_storage/src/state_storage.rs ===
// icn_storage/src/state_storage.rs

use std::collections::HashMap;

/// The `StateStorage` struct is responsible for managing the state of the blockchain.
/// It uses an in-memory `HashMap` to store key-value pairs representing the state.
pub struct StateStorage {
    storage: HashMap<String, String>,
}

impl StateStorage {
    /// Creates a new `StateStorage` instance.
    pub fn new() -> Self {
        StateStorage {
            storage: HashMap::new(),
        }
    }

    /// Updates the state storage with a new key-value pair.
    pub fn update_state(&mut self, key: &str, value: &str) -> Result<(), String> {
        self.storage.insert(key.to_string(), value.to_string());
        Ok(())
    }

    /// Retrieves a value from the state storage by its key.
    pub fn get_state(&self, key: &str) -> Option<String> {
        self.storage.get(key).cloned()
    }
}



=== ./icn_storage/src/lib.rs ===
// icn_storage/src/lib.rs

pub mod block_storage;
pub mod state_storage;

use icn_blockchain::block::Block;  // Correctly reference icn_blockchain
use block_storage::BlockStorage;
use state_storage::StateStorage;
use std::sync::{Arc, RwLock};

/// The `Storage` struct provides an interface to the underlying storage systems
/// for blocks and state. It ensures thread-safe access and modification.
pub struct Storage {
    block_storage: Arc<RwLock<BlockStorage>>,
    state_storage: Arc<RwLock<StateStorage>>,
}

impl Storage {
    /// Creates a new instance of the `Storage` struct with initialized
    /// block and state storage systems.
    pub fn new() -> Self {
        Storage {
            block_storage: Arc::new(RwLock::new(BlockStorage::new())),
            state_storage: Arc::new(RwLock::new(StateStorage::new())),
        }
    }

    /// Adds a new block to the block storage.
    pub fn add_block(&self, block: Block) -> Result<(), String> {
        let mut storage = self.block_storage.write().unwrap();
        storage.add_block(block)
    }

    /// Retrieves a block by its hash.
    pub fn get_block(&self, hash: &str) -> Option<Block> {
        let storage = self.block_storage.read().unwrap();
        storage.get_block(hash)
    }

    /// Updates the state storage with the latest state.
    pub fn update_state(&self, key: &str, value: &str) -> Result<(), String> {
        let mut storage = self.state_storage.write().unwrap();
        storage.update_state(key, value)
    }

    /// Retrieves a value from the state storage by its key.
    pub fn get_state(&self, key: &str) -> Option<String> {
        let storage = self.state_storage.read().unwrap();
        storage.get_state(key)
    }
}



=== ./test_cert.key ===
-----BEGIN PRIVATE KEY-----
MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCqiABpZtwNQC0v
dQxFvm4uQsNQgRDL/90jRgrsm8AYWcKRDWpoExi/aiYT1FrFo2rsPM7kqzaIb7xi
PtJIhzOJg4qNc5Gi6/wSJ4A/qYkRuAGznWkp735moKLmhbn0vRq3KWNUk7QN7cbQ
Oww50Td25Omo0TZOrwXbGFdeit8WyjAaUxuXaFINnptga+v7PUhfDNbTh+TWqpUl
c+sWQ/mjW7hXfTZrsfNRfU8dd+v2U9gS5DjJ8BsekHgUrdVJc0WGMeX4S5IIChV4
vmf15XLayiQ1zY+SLwcg3u1eOHifmBJNX5YZlzYBknU5mOcR5mC/L8K6hfF1zFcj
H+CPx5StAgMBAAECggEAE8qQ8aqkY01NcTKOaBG/y9KnxFIWVvas/YkFf4xb8PeJ
4zfBX67Hsn9pR+ffWQysPhqYkGVmgNMm8+gCk7RNQOppTB1bi6MDsD+xXLIaXFoU
qHneWKWY7+Q4w7RFbqf7z8IX6xrxTKSJ7GTN+G/VlhDfJV6ShPM/JLxgd3J6jbRc
29qmdsypcvmpEFgfMHtMgD8q0sSyiQkAa6LxYMBUSP8R52AafgTQ0BNzfS9UNTFA
WH1Bgig+GaSoXjZBwCQbIP4+KN+1GHN3NUJGT0010GeAydS9qUWTJMKDN2kweANr
dUXBX+QKtD3gld91sK1Og7mx7do7JwPoqBpYVtveAQKBgQDg0zgZZhadLK6+3oJM
C/zwzKxC18hOBdmiMkCOJWSj2NGNv1/RsckaVpsP9DvzYCPHxuw3QjNR5KLE2bbE
tFUtuJxIO1RYtapH4nEkXywjHwjznshsAEKNnJg5OkBMy9WM0PwW1BDv3xgTJdsx
0FeNyZNqhYOHaZ2lFReRMNT5wQKBgQDCLXmTaQSwg+/tZ0h8188m6wrqwUR+L/LC
diZ4wJ4BIZmeXIphoCaurQ71be+FdcKOqACOGrHwitDjiI7/ImrKJsxfO2NmjWQO
L3Yjj5rHs8Rhe7S22vyMjkAbihKyjUjVTGtZ7GsxdZfFpRK972ZT1VwR8fVBArj4
3r5Qz7Gd7QKBgFfedZiHq+L2Kb3znR03uj4q4FCnoWPNKYgY994Wg0T+YrhxyXNd
dunSW3xaymuOca2M85mNSB2DrJIfPS2YBYp/EqWweoDJT6oUuH+sqsV3RbphnpeH
anuKbnw/Zg4dxHLq4vvRGmWF3hTtwMOxV+bUl8cUM5njD3gLzFA0s6iBAoGAE0zV
0rMThj/27w/fApmou2ONWDwRhMFbTbzUohfzHIWscTMdhgqXDbGh1P8yWX+U8Pz9
4SICIbiKfrMqE23mU2V71tNeU+kl0ssg4PP7HHJfyJi1I5+sjoPtF0+oABtO6/SG
jw+Sr/3SMhDwRfSvpRGF7zqvd+C/Ze0t2XZrXxkCgYBbidECfw6P3CQ6zSkN5l6T
hFVItDrTiTyjqZS+mOptNJZBxbGPWkzLq/ZB7kUXMjnkc4eZqWRPvd9LquV7mLX1
x0EGqev4/XUVu0SkNRTRaUX7Ellgoj/r7CWsy/ks5Km+QgS9T8nZs73kuxBMKH5X
vs6ws3SO/YqC7FK/w9y2Yw==
-----END PRIVATE KEY-----



=== ./icn_identity/Cargo.toml ===
[package]
name = "icn_identity"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_shared = { path = "../icn_shared" }




=== ./icn_identity/src/lib/mod.rs ===



=== ./icn_identity/src/lib.rs ===
// icn_identity/src/lib.rs

/// The Identity module manages node identity within the ICN.
/// It holds basic identity information like node ID and name.
pub struct Identity {
    /// The unique identifier for the node.
    pub id: String,
    /// The name associated with the node.
    pub name: String,
}

impl Identity {
    /// Creates a new instance of Identity.
    pub fn new(id: &str, name: &str) -> Self {
        Identity {
            id: id.to_string(),
            name: name.to_string(),
        }
    }

    /// Initializes the identity module.
    ///
    /// # Returns
    /// * `IcnResult<()>` - An empty result indicating success or failure.
    pub fn initialize(&self) -> Result<(), String> {
        // Initialization logic here (if any)
        Ok(())
    }
}



=== ./update_project.sh ===
#!/bin/bash

# Generate the latest project state before committing
./generate_project_state.sh

# Check if the project state was generated successfully
if [[ $? -ne 0 ]]; then
    echo "Error: Failed to generate project state."
    exit 1
fi

# Prompt the user to enter a commit message
echo "Enter the commit message:"
read -r COMMIT_MSG

# Ensure the commit message is not empty
if [[ -z "$COMMIT_MSG" ]]; then
    echo "Error: Commit message cannot be empty!"
    exit 1
fi

# Stage all changes for commit
git add .

# Commit the changes with the provided message
git commit -m "$COMMIT_MSG"

# Check if the commit was successful
if [[ $? -ne 0 ]]; then
    echo "Error: Commit failed."
    exit 1
fi

# Push the changes to the remote repository
git push origin main

# Check if the push was successful
if [[ $? -ne 0 ]]; then
    echo "Error: Push failed."
    exit 1
fi

echo "Changes have been successfully committed and pushed."



=== ./.gitignore ===
/target
**/*.rs.bk
Cargo.lock



=== ./icn_smart_contracts/Cargo.toml ===
[package]
name = "icn_smart_contracts"
version = "0.1.0"
edition = "2021"

[dependencies]



=== ./icn_smart_contracts/src/lib/mod.rs ===



=== ./icn_smart_contracts/src/lib.rs ===
// icn_smart_contracts/src/lib.rs

use std::collections::HashMap;

// Define our own error type for this crate
#[derive(Debug)]
pub enum SmartContractError {
    InvalidArguments(String),
    ContractNotFound(u32),
    KeyNotFound(String),
    UnknownFunction(String),
}

pub type SmartContractResult<T> = Result<T, SmartContractError>;

pub struct SmartContract {
    pub id: u32,
    pub code: String,
    pub state: HashMap<String, String>,
}

impl SmartContract {
    pub fn new(id: u32, code: &str) -> Self {
        SmartContract {
            id,
            code: code.to_string(),
            state: HashMap::new(),
        }
    }

    pub fn execute(&mut self, function: &str, args: Vec<String>) -> SmartContractResult<String> {
        match function {
            "set" => {
                if args.len() != 2 {
                    return Err(SmartContractError::InvalidArguments("'set' requires 2 arguments".to_string()));
                }
                self.state.insert(args[0].clone(), args[1].clone());
                Ok("Value set successfully".to_string())
            }
            "get" => {
                if args.len() != 1 {
                    return Err(SmartContractError::InvalidArguments("'get' requires 1 argument".to_string()));
                }
                self.state.get(&args[0])
                    .cloned()
                    .ok_or_else(|| SmartContractError::KeyNotFound(args[0].clone()))
            }
            _ => Err(SmartContractError::UnknownFunction(function.to_string())),
        }
    }
}

pub struct SmartContractEngine {
    contracts: HashMap<u32, SmartContract>,
}

impl SmartContractEngine {
    pub fn new() -> Self {
        SmartContractEngine {
            contracts: HashMap::new(),
        }
    }

    pub fn deploy_contract(&mut self, code: &str) -> SmartContractResult<u32> {
        let id = self.contracts.len() as u32 + 1;
        let contract = SmartContract::new(id, code);
        self.contracts.insert(id, contract);
        Ok(id)
    }

    pub fn call_contract(&mut self, id: u32, function: &str, args: Vec<String>) -> SmartContractResult<String> {
        self.contracts.get_mut(&id)
            .ok_or_else(|| SmartContractError::ContractNotFound(id))?
            .execute(function, args)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_smart_contract_execution() {
        let mut contract = SmartContract::new(1, "sample code");
        
        let result = contract.execute("set", vec!["key".to_string(), "value".to_string()]);
        assert!(result.is_ok());

        let result = contract.execute("get", vec!["key".to_string()]);
        assert_eq!(result.unwrap(), "value");

        let result = contract.execute("unknown", vec![]);
        assert!(result.is_err());
    }

    #[test]
    fn test_smart_contract_engine() {
        let mut engine = SmartContractEngine::new();

        let contract_id = engine.deploy_contract("sample code").unwrap();
        assert_eq!(contract_id, 1);

        let result = engine.call_contract(contract_id, "set", vec!["key".to_string(), "value".to_string()]);
        assert!(result.is_ok());

        let result = engine.call_contract(contract_id, "get", vec!["key".to_string()]);
        assert_eq!(result.unwrap(), "value");

        let result = engine.call_contract(999, "get", vec!["key".to_string()]);
        assert!(result.is_err());
    }
}


=== ./icn_api/Cargo.toml ===
[package]
name = "icn_api"
version = "0.1.0"
edition = "2021"

[dependencies]



=== ./icn_api/src/lib/mod.rs ===



=== ./icn_api/src/lib.rs ===
pub fn add(left: u64, right: u64) -> u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}



