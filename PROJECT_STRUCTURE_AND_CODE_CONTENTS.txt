===== START OF FILE STRUCTURE =====
/home/matt/InterCooperative-Network
├── Cargo.lock
├── Cargo.toml
├── CHANGELOG.md
├── cliff.toml
├── crates
│   ├── icn_api
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── lib.rs
│   ├── icn_blockchain
│   │   ├── Cargo.toml
│   │   ├── README.md
│   │   └── src
│   │       ├── asset_tokenization.rs
│   │       ├── blockchain.rs
│   │       ├── lib.rs
│   │       └── transaction_validator.rs
│   ├── icn_common
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── error.rs
│   │       ├── lib.rs
│   │       └── main.rs
│   ├── icn_consensus
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── bft_poc.rs
│   │       ├── consensus.rs
│   │       ├── lib.rs
│   │       └── proof_of_cooperation.rs
│   ├── icn_core
│   │   ├── Cargo.toml
│   │   ├── src
│   │   │   ├── cli
│   │   │   │   └── mod.rs
│   │   │   ├── config.rs
│   │   │   ├── error.rs
│   │   │   ├── lib.rs
│   │   │   ├── logging
│   │   │   │   └── mod.rs
│   │   │   ├── main.rs
│   │   │   └── security
│   │   │       └── mod.rs
│   │   └── tests
│   │       ├── blockchain_and_consensus_tests.rs
│   │       ├── blockchain_tests.rs
│   │       ├── icn_node_tests.rs
│   │       ├── integration_tests.rs
│   │       ├── mod.rs
│   │       └── smart_contract_tests.rs
│   ├── icn_currency
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── asset_token.rs
│   │       ├── bond.rs
│   │       ├── currency.rs
│   │       ├── lib.rs
│   │       └── wallet.rs
│   ├── icn_governance
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── democracy.rs
│   │       ├── lib.rs
│   │       ├── proposal.rs
│   │       └── voting.rs
│   ├── icn_identity
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── did.rs
│   │       ├── identity_manager.rs
│   │       └── lib.rs
│   ├── icn_incentives
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── lib.rs
│   ├── icn_market
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── lib.rs
│   ├── icn_network
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── discovery.rs
│   │       ├── lib.rs
│   │       ├── naming.rs
│   │       ├── network.rs
│   │       ├── node.rs
│   │       ├── packet.rs
│   │       ├── protocol.rs
│   │       ├── routing.rs
│   │       └── security.rs
│   ├── icn_node_management
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── content_store.rs
│   │       ├── fib.rs
│   │       ├── icn_node.rs
│   │       ├── lib.rs
│   │       ├── node.rs
│   │       └── pit.rs
│   ├── icn_reputation
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── lib.rs
│   ├── icn_sharding
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── cross_shard_communication.rs
│   │       ├── cross_shard_sync.rs
│   │       ├── cross_shard_transaction_manager.rs
│   │       └── lib.rs
│   ├── icn_smart_contracts
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── contract.pest
│   │       └── lib.rs
│   ├── icn_storage
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── lib.rs
│   │       ├── storage_manager.rs
│   │       └── storage_node.rs
│   ├── icn_testnet
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── main.rs
│   ├── icn_utils
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── error.rs
│   │       ├── lib.rs
│   │       ├── types
│   │       │   ├── block.rs
│   │       │   ├── mod.rs
│   │       │   └── transaction.rs
│   │       └── utils.rs
│   ├── icn_vm
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── compiler.rs
│   │       ├── coop_vm.rs
│   │       ├── lib.rs
│   │       ├── opcode.rs
│   │       ├── smart_contract.rs
│   │       ├── templates.rs
│   │       └── vm.rs
│   └── icn_zkp
│       ├── Cargo.toml
│       └── src
│           ├── circuits.rs
│           └── lib.rs
├── docs
│   ├── API.md
│   ├── ARCHITECTURE.md
│   ├── CONTRIBUTING.md
│   └── README.md
├── examples
│   └── voting_contract.coop
├── PROJECT_STRUCTURE_AND_CODE_CONTENTS.txt
├── README.md
└── update_project.sh

49 directories, 113 files
===== END OF FILE STRUCTURE =====

===== START OF /home/matt/InterCooperative-Network/Cargo.toml =====
[workspace]
members = [
    "crates/icn_common",
    "crates/icn_blockchain",
    "crates/icn_consensus",
    "crates/icn_currency",
    "crates/icn_governance",
    "crates/icn_identity",
    "crates/icn_network",
    "crates/icn_sharding",
    "crates/icn_storage",
    "crates/icn_vm",
    "crates/icn_api",
    "crates/icn_testnet",
    "crates/icn_core", 
    "crates/icn_zkp", 
    "crates/icn_smart_contracts",
    "crates/icn_reputation",
    "crates/icn_market",
    "crates/icn_incentives",
]

resolver = "2"

[workspace.dependencies]
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
chrono = { version = "0.4", features = ["serde"] }
thiserror = "1.0"
log = "0.4"
env_logger = "0.9"
===== END OF /home/matt/InterCooperative-Network/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_api/Cargo.toml =====
[package]
name = "icn_api"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
icn_blockchain = { path = "../icn_blockchain" }
icn_consensus = { path = "../icn_consensus" }
icn_currency = { path = "../icn_currency" }
icn_governance = { path = "../icn_governance" }
icn_identity = { path = "../icn_identity" }
icn_network = { path = "../icn_network" }
icn_sharding = { path = "../icn_sharding" }
icn_storage = { path = "../icn_storage" }
icn_vm = { path = "../icn_vm" }
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
log = "0.4"
thiserror = "1.0"

[dev-dependencies]
tokio-test = "0.4"
===== END OF /home/matt/InterCooperative-Network/crates/icn_api/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_api/src/lib.rs =====
use icn_common::{Block, Transaction, Proposal, ProposalStatus, CurrencyType};
use icn_common::{CommonError, CommonResult};
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};
use std::sync::Arc;
use tokio::sync::RwLock;

/// A generic API response structure.
#[derive(Serialize, Deserialize)]
pub struct ApiResponse<T> {
    pub success: bool,
    pub data: Option<T>,
    pub error: Option<String>,
}

/// API Layer struct to manage different modules.
pub struct ApiLayer {
    blockchain: Arc<RwLock<dyn BlockchainInterface>>,
    consensus: Arc<RwLock<dyn ConsensusInterface>>,
    currency_system: Arc<RwLock<dyn CurrencySystemInterface>>,
    governance: Arc<RwLock<dyn GovernanceInterface>>,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct BlockchainInfo {
    pub block_count: usize,
    pub last_block_hash: Option<String>,
}

#[derive(Serialize, Deserialize)]
pub struct Vote {
    pub voter: String,
    pub proposal_id: String,
    pub in_favor: bool,
    pub weight: f64,
}

impl ApiLayer {
    /// Creates a new instance of ApiLayer.
    ///
    /// # Arguments
    ///
    /// * `blockchain` - Arc to the blockchain interface.
    /// * `consensus` - Arc to the consensus interface.
    /// * `currency_system` - Arc to the currency system interface.
    /// * `governance` - Arc to the governance interface.
    ///
    /// # Returns
    ///
    /// * `ApiLayer` - A new instance of ApiLayer.
    pub fn new(
        blockchain: Arc<RwLock<dyn BlockchainInterface>>,
        consensus: Arc<RwLock<dyn ConsensusInterface>>,
        currency_system: Arc<RwLock<dyn CurrencySystemInterface>>,
        governance: Arc<RwLock<dyn GovernanceInterface>>,
    ) -> Self {
        ApiLayer {
            blockchain,
            consensus,
            currency_system,
            governance,
        }
    }

    /// Fetches information about the blockchain.
    ///
    /// # Returns
    ///
    /// * `CommonResult<ApiResponse<BlockchainInfo>>` - The blockchain information wrapped in a CommonResult.
    pub async fn get_blockchain_info(&self) -> CommonResult<ApiResponse<BlockchainInfo>> {
        let blockchain = self.blockchain.read().await;
        let info = blockchain.get_info().await?;
        Ok(ApiResponse {
            success: true,
            data: Some(info),
            error: None,
        })
    }

    /// Submits a transaction to the blockchain.
    ///
    /// # Arguments
    ///
    /// * `transaction` - The transaction to be submitted.
    ///
    /// # Returns
    ///
    /// * `CommonResult<ApiResponse<String>>` - The result of the transaction submission.
    pub async fn submit_transaction(&self, transaction: Transaction) -> CommonResult<ApiResponse<String>> {
        let mut blockchain = self.blockchain.write().await;
        blockchain.add_transaction(transaction).await?;
        Ok(ApiResponse {
            success: true,
            data: Some("Transaction submitted successfully".to_string()),
            error: None,
        })
    }

    /// Fetches the balance for a given address and currency type.
    ///
    /// # Arguments
    ///
    /// * `address` - The address to fetch the balance for.
    /// * `currency_type` - The type of currency to fetch the balance of.
    ///
    /// # Returns
    ///
    /// * `CommonResult<ApiResponse<f64>>` - The balance wrapped in a CommonResult.
    pub async fn get_balance(&self, address: &str, currency_type: &CurrencyType) -> CommonResult<ApiResponse<f64>> {
        let currency_system = self.currency_system.read().await;
        let balance = currency_system.get_balance(address, currency_type).await?;
        Ok(ApiResponse {
            success: true,
            data: Some(balance),
            error: None,
        })
    }

    /// Creates a new proposal in the governance system.
    ///
    /// # Arguments
    ///
    /// * `proposal` - The proposal to be created.
    ///
    /// # Returns
    ///
    /// * `CommonResult<ApiResponse<String>>` - The result of the proposal creation.
    pub async fn create_proposal(&self, proposal: Proposal) -> CommonResult<ApiResponse<String>> {
        let mut governance = self.governance.write().await;
        let proposal_id = governance.create_proposal(proposal).await?;
        Ok(ApiResponse {
            success: true,
            data: Some(proposal_id),
            error: None,
        })
    }

    /// Votes on an existing proposal.
    ///
    /// # Arguments
    ///
    /// * `vote` - The vote to be cast.
    ///
    /// # Returns
    ///
    /// * `CommonResult<ApiResponse<String>>` - The result of the voting process.
    pub async fn vote_on_proposal(&self, vote: Vote) -> CommonResult<ApiResponse<String>> {
        let mut governance = self.governance.write().await;
        governance.vote_on_proposal(vote).await?;
        Ok(ApiResponse {
            success: true,
            data: Some("Vote recorded successfully".to_string()),
            error: None,
        })
    }

    /// Fetches the status of a given proposal.
    ///
    /// # Arguments
    ///
    /// * `proposal_id` - The ID of the proposal to fetch the status of.
    ///
    /// # Returns
    ///
    /// * `CommonResult<ApiResponse<ProposalStatus>>` - The proposal status wrapped in a CommonResult.
    pub async fn get_proposal_status(&self, proposal_id: &str) -> CommonResult<ApiResponse<ProposalStatus>> {
        let governance = self.governance.read().await;
        let status = governance.get_proposal_status(proposal_id).await?;
        Ok(ApiResponse {
            success: true,
            data: Some(status),
            error: None,
        })
    }
}

#[async_trait::async_trait]
pub trait BlockchainInterface {
    /// Fetches blockchain information.
    ///
    /// # Returns
    ///
    /// * `CommonResult<BlockchainInfo>` - The blockchain information.
    async fn get_info(&self) -> CommonResult<BlockchainInfo>;

    /// Adds a transaction to the blockchain.
    ///
    /// # Arguments
    ///
    /// * `transaction` - The transaction to be added.
    ///
    /// # Returns
    ///
    /// * `CommonResult<()>` - The result of the transaction addition.
    async fn add_transaction(&mut self, transaction: Transaction) -> CommonResult<()>;
}

#[async_trait::async_trait]
pub trait ConsensusInterface {
    /// Validates a block.
    ///
    /// # Arguments
    ///
    /// * `block` - The block to be validated.
    ///
    /// # Returns
    ///
    /// * `CommonResult<()>` - The result of the block validation.
    async fn validate_block(&self, block: &Block) -> CommonResult<()>;
}

#[async_trait::async_trait]
pub trait CurrencySystemInterface {
    /// Fetches the balance for a given address and currency type.
    ///
    /// # Arguments
    ///
    /// * `address` - The address to fetch the balance for.
    /// * `currency_type` - The type of currency to fetch the balance of.
    ///
    /// # Returns
    ///
    /// * `CommonResult<f64>` - The balance.
    async fn get_balance(&self, address: &str, currency_type: &CurrencyType) -> CommonResult<f64>;
}

#[async_trait::async_trait]
pub trait GovernanceInterface {
    /// Creates a new proposal.
    ///
    /// # Arguments
    ///
    /// * `proposal` - The proposal to be created.
    ///
    /// # Returns
    ///
    /// * `CommonResult<String>` - The ID of the created proposal.
    async fn create_proposal(&mut self, proposal: Proposal) -> CommonResult<String>;

    /// Votes on an existing proposal.
    ///
    /// # Arguments
    ///
    /// * `vote` - The vote to be cast.
    ///
    /// # Returns
    ///
    /// * `CommonResult<()>` - The result of the voting process.
    async fn vote_on_proposal(&mut self, vote: Vote) -> CommonResult<()>;

    /// Fetches the status of a given proposal.
    ///
    /// # Arguments
    ///
    /// * `proposal_id` - The ID of the proposal to fetch the status of.
    ///
    /// # Returns
    ///
    /// * `CommonResult<ProposalStatus>` - The status of the proposal.
    async fn get_proposal_status(&self, proposal_id: &str) -> CommonResult<ProposalStatus>;
}

#[cfg(test)]
mod tests {
    use super::*;
    use tokio;

    // Implement mock structures for testing.
    struct MockBlockchain;
    struct MockConsensus;
    struct MockCurrencySystem;
    struct MockGovernance;

    #[async_trait::async_trait]
    impl BlockchainInterface for MockBlockchain {
        async fn get_info(&self) -> CommonResult<BlockchainInfo> {
            Ok(BlockchainInfo {
                block_count: 1,
                last_block_hash: Some("0000000000000000000000000000000000000000000000000000000000000000".to_string()),
            })
        }

        async fn add_transaction(&mut self, _transaction: Transaction) -> CommonResult<()> {
            Ok(())
        }
    }

    #[async_trait::async_trait]
    impl ConsensusInterface for MockConsensus {
        async fn validate_block(&self, _block: &Block) -> CommonResult<()> {
            Ok(())
        }
    }

    #[async_trait::async_trait]
    impl CurrencySystemInterface for MockCurrencySystem {
        async fn get_balance(&self, _address: &str, _currency_type: &CurrencyType) -> CommonResult<f64> {
            Ok(100.0)
        }
    }

    #[async_trait::async_trait]
    impl GovernanceInterface for MockGovernance {
        async fn create_proposal(&mut self, _proposal: Proposal) -> CommonResult<String> {
            Ok("new_proposal_id".to_string())
        }

        async fn vote_on_proposal(&mut self, _vote: Vote) -> CommonResult<()> {
            Ok(())
        }

        async fn get_proposal_status(&self, _proposal_id: &str) -> CommonResult<ProposalStatus> {
            Ok(ProposalStatus::Active)
        }
    }

    #[tokio::test]
    async fn test_api_layer() {
        let api = ApiLayer::new(
            Arc::new(RwLock::new(MockBlockchain)),
            Arc::new(RwLock::new(MockConsensus)),
            Arc::new(RwLock::new(MockCurrencySystem)),
            Arc::new(RwLock::new(MockGovernance)),
        );

        // Test get_blockchain_info.
        let blockchain_info = api.get_blockchain_info().await.unwrap();
        assert!(blockchain_info.success);
        assert_eq!(blockchain_info.data.unwrap().block_count, 1);

        // Test submit_transaction.
        let transaction = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 50.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: Utc::now().timestamp(),
            signature: None,
        };
        let submit_result = api.submit_transaction(transaction).await.unwrap();
        assert!(submit_result.success);

        // Test get_balance.
        let balance_result = api.get_balance("Alice", &CurrencyType::BasicNeeds).await.unwrap();
        assert!(balance_result.success);
        assert_eq!(balance_result.data.unwrap(), 100.0);

        // Test create_proposal.
        let proposal = Proposal {
            id: "".to_string(),
            title: "Test Proposal".to_string(),
            description: "This is a test proposal".to_string(),
            proposer: "Alice".to_string(),
            created_at: Utc::now(),
            voting_ends_at: Utc::now() + chrono::Duration::days(7),
            status: ProposalStatus::Active,
            proposal_type: ProposalType::Constitutional,
            category: ProposalCategory::Economic,
            required_quorum: 0.66,
            execution_timestamp: None,
        };
        let create_proposal_result = api.create_proposal(proposal).await.unwrap();
        assert!(create_proposal_result.success);

        // Test vote_on_proposal.
        let vote = Vote {
            voter: "Bob".to_string(),
            proposal_id: "new_proposal_id".to_string(),
            in_favor: true,
            weight: 1.0,
        };
        let vote_result = api.vote_on_proposal(vote).await.unwrap();
        assert!(vote_result.success);

        // Test get_proposal_status.
        let status_result = api.get_proposal_status("new_proposal_id").await.unwrap();
        assert!(status_result.success);
        assert_eq!(status_result.data.unwrap(), ProposalStatus::Active);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_api/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_blockchain/Cargo.toml =====
[package]
name = "icn_blockchain"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
sha2 = "0.10"
log = "0.4"
thiserror = "1.0"

[dev-dependencies]
tokio-test = "0.4"
===== END OF /home/matt/InterCooperative-Network/crates/icn_blockchain/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_blockchain/src/asset_tokenization.rs =====
use crate::{Transaction, Blockchain};
use icn_common::error::{IcnError, IcnResult};

/// A struct for validating transactions.
pub struct TransactionValidator;

impl TransactionValidator {
    /// Validates a transaction within the context of a blockchain.
    ///
    /// # Arguments
    ///
    /// * `transaction` - The transaction to validate.
    /// * `blockchain` - The blockchain context.
    ///
    /// # Returns
    ///
    /// `IcnResult<()>` indicating whether the transaction is valid.
    pub fn validate_transaction(transaction: &Transaction, blockchain: &Blockchain) -> IcnResult<()> {
        if Self::is_double_spend(transaction, blockchain)? {
            return Err(IcnError::Blockchain("Double spend detected".to_string()));
        }

        if !Self::validate_currency_and_amount(transaction) {
            return Err(IcnError::Currency("Invalid currency or amount".to_string()));
        }

        if !Self::check_sufficient_balance(transaction, blockchain)? {
            return Err(IcnError::Currency("Insufficient balance".to_string()));
        }

        if !Self::validate_signature(transaction)? {
            return Err(IcnError::Identity("Invalid signature".to_string()));
        }

        Ok(())
    }

    fn is_double_spend(transaction: &Transaction, blockchain: &Blockchain) -> IcnResult<bool> {
        for block in &blockchain.chain {
            for tx in &block.transactions {
                if tx == transaction {
                    return Ok(true);
                }
            }
        }
        Ok(false)
    }

    fn validate_currency_and_amount(transaction: &Transaction) -> bool {
        transaction.amount > 0.0
    }

    fn check_sufficient_balance(transaction: &Transaction, blockchain: &Blockchain) -> IcnResult<bool> {
        let balance = blockchain.get_balance(&transaction.from, &transaction.currency_type)?;
        Ok(balance >= transaction.amount + transaction.get_fee())
    }

    fn validate_signature(transaction: &Transaction) -> IcnResult<bool> {
        transaction.verify().map_err(|e| IcnError::Identity(format!("Signature verification failed: {}", e)))
    }

    /// Checks if a transaction can be processed by the blockchain.
    ///
    /// # Arguments
    ///
    /// * `transaction` - The transaction to check.
    /// * `blockchain` - The blockchain context.
    ///
    /// # Returns
    ///
    /// `IcnResult<()>` indicating whether the transaction can be processed.
    pub fn can_process_transaction(transaction: &Transaction, blockchain: &Blockchain) -> IcnResult<()> {
        Self::validate_transaction(transaction, blockchain)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::currency::CurrencyType;
    use icn_common::{Transaction, Blockchain};
    use ed25519_dalek::Keypair;
    use rand::rngs::OsRng;

    fn create_signed_transaction(from: &str, to: &str, amount: f64) -> Transaction {
        let mut tx = Transaction::new(
            from.to_string(),
            to.to_string(),
            amount,
            CurrencyType::BasicNeeds,
            1000,
        );
        let mut csprng = OsRng{};
        let keypair: Keypair = Keypair::generate(&mut csprng);
        tx.sign(&keypair).unwrap();
        tx
    }

    #[test]
    fn test_validate_transaction() {
        let mut blockchain = Blockchain::new(Box::new(MockTransactionValidator));
        let tx = create_signed_transaction("Alice", "Bob", 50.0);

        // Add some balance to Alice's account
        blockchain.add_transaction(create_signed_transaction("Genesis", "Alice", 100.0)).unwrap();
        blockchain.create_block().unwrap();

        assert!(TransactionValidator::validate_transaction(&tx, &blockchain).is_ok());
    }

    #[test]
    fn test_insufficient_balance() {
        let mut blockchain = Blockchain::new(Box::new(MockTransactionValidator));
        let tx = create_signed_transaction("Alice", "Bob", 150.0);

        // Add some balance to Alice's account, but not enough
        blockchain.add_transaction(create_signed_transaction("Genesis", "Alice", 100.0)).unwrap();
        blockchain.create_block().unwrap();

        assert!(TransactionValidator::validate_transaction(&tx, &blockchain).is_err());
    }

    #[test]
    fn test_double_spend() {
        let mut blockchain = Blockchain::new(Box::new(MockTransactionValidator));
        let tx = create_signed_transaction("Alice", "Bob", 50.0);

        // Add some balance to Alice's account
        blockchain.add_transaction(create_signed_transaction("Genesis", "Alice", 100.0)).unwrap();
        blockchain.create_block().unwrap();

        // Add the transaction to the blockchain
        blockchain.add_transaction(tx.clone()).unwrap();
        blockchain.create_block().unwrap();

        // Try to validate the same transaction again
        assert!(TransactionValidator::validate_transaction(&tx, &blockchain).is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_blockchain/src/asset_tokenization.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_blockchain/src/blockchain.rs =====
use icn_common::{Block, Transaction, IcnResult, IcnError, Hashable};
use std::collections::HashMap;
use chrono::Utc;
use log::{info, warn, error};
use std::sync::{Arc, RwLock};
use crate::consensus::ConsensusAlgorithm;

/// Represents a blockchain, maintaining a list of blocks and pending transactions.
pub struct Blockchain {
    chain: Vec<Block>,
    pending_transactions: Vec<Transaction>,
    transaction_validator: Arc<dyn TransactionValidator>,
    consensus: Arc<RwLock<dyn ConsensusAlgorithm>>,
}

/// A trait for validating transactions within a blockchain.
pub trait TransactionValidator: Send + Sync {
    /// Validates a transaction within the context of a blockchain.
    ///
    /// # Arguments
    ///
    /// * `transaction` - The transaction to validate.
    /// * `blockchain` - The blockchain context.
    ///
    /// # Returns
    ///
    /// `true` if the transaction is valid, `false` otherwise.
    fn validate(&self, transaction: &Transaction, blockchain: &Blockchain) -> bool;
}

impl Blockchain {
    /// Creates a new blockchain with a genesis block.
    ///
    /// # Arguments
    ///
    /// * `transaction_validator` - A validator for verifying transactions.
    /// * `consensus` - The consensus algorithm.
    pub fn new(transaction_validator: Arc<dyn TransactionValidator>, consensus: Arc<RwLock<dyn ConsensusAlgorithm>>) -> Self {
        Blockchain {
            chain: vec![Block::genesis()],
            pending_transactions: Vec::new(),
            transaction_validator,
            consensus,
        }
    }

    /// Adds a new transaction to the list of pending transactions.
    ///
    /// # Arguments
    ///
    /// * `transaction` - The transaction to add.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Blockchain` if the transaction is invalid.
    pub fn add_transaction(&mut self, transaction: Transaction) -> IcnResult<()> {
        if self.transaction_validator.validate(&transaction, self) {
            self.pending_transactions.push(transaction);
            Ok(())
        } else {
            Err(IcnError::Blockchain("Invalid transaction".to_string()))
        }
    }

    /// Creates a new block with all pending transactions.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Blockchain` if no previous block is found or if `calculate_hash` fails.
    pub fn create_block(&mut self) -> IcnResult<Block> {
        let previous_block = self.chain.last()
            .ok_or_else(|| IcnError::Blockchain("No previous block found".to_string()))?;

        let new_block = Block {
            index: self.chain.len() as u64,
            timestamp: Utc::now().timestamp(),
            transactions: self.pending_transactions.clone(),
            previous_hash: previous_block.hash.clone(),
            hash: String::new(), // Will be set in calculate_hash
        };

        let new_block = self.calculate_hash(new_block)?;
        self.consensus.read().unwrap().validate_block(&new_block)?;

        self.chain.push(new_block.clone());
        self.pending_transactions.clear();

        Ok(new_block)
    }

    fn calculate_hash(&self, mut block: Block) -> IcnResult<Block> {
        block.hash = block.hash();
        Ok(block)
    }

    /// Validates the integrity of the blockchain.
    ///
    /// # Returns
    ///
    /// `true` if the blockchain is valid, `false` otherwise.
    pub fn validate_chain(&self) -> bool {
        for i in 1..self.chain.len() {
            let current_block = &self.chain[i];
            let previous_block = &self.chain[i - 1];

            if current_block.hash != current_block.hash() {
                return false;
            }

            if current_block.previous_hash != previous_block.hash {
                return false;
            }
        }
        true
    }

    /// Returns the latest block in the blockchain.
    pub fn get_latest_block(&self) -> Option<&Block> {
        self.chain.last()
    }

    /// Returns a block by its index.
    ///
    /// # Arguments
    ///
    /// * `index` - The index of the block.
    ///
    /// # Returns
    ///
    /// The block if found, `None` otherwise.
    pub fn get_block_by_index(&self, index: u64) -> Option<&Block> {
        self.chain.get(index as usize)
    }

    /// Returns a block by its hash.
    ///
    /// # Arguments
    ///
    /// * `hash` - The hash of the block.
    ///
    /// # Returns
    ///
    /// The block if found, `None` otherwise.
    pub fn get_block_by_hash(&self, hash: &str) -> Option<&Block> {
        self.chain.iter().find(|block| block.hash == hash)
    }

    /// Starts the blockchain.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn start(&self) -> IcnResult<()> {
        info!("Blockchain started");
        Ok(())
    }

    /// Stops the blockchain.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn stop(&self) -> IcnResult<()> {
        info!("Blockchain stopped");
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_common::CurrencyType;
    use std::sync::Arc;
    use crate::consensus::PoCConsensus;

    struct MockTransactionValidator;

    impl TransactionValidator for MockTransactionValidator {
        fn validate(&self, _transaction: &Transaction, _blockchain: &Blockchain) -> bool {
            true
        }
    }

    #[test]
    fn test_blockchain_creation() {
        let consensus = Arc::new(RwLock::new(PoCConsensus::new(0.66, 0.51).unwrap()));
        let blockchain = Blockchain::new(Arc::new(MockTransactionValidator), consensus);
        assert_eq!(blockchain.chain.len(), 1);
        assert_eq!(blockchain.chain[0].index, 0);
    }

    #[test]
    fn test_add_block() {
        let consensus = Arc::new(RwLock::new(PoCConsensus::new(0.66, 0.51).unwrap()));
        let mut blockchain = Blockchain::new(Arc::new(MockTransactionValidator), consensus);
        let transaction = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            100.0,
            CurrencyType::BasicNeeds,
            Utc::now().timestamp(),
        );
        blockchain.add_transaction(transaction).unwrap();
        assert!(blockchain.create_block().is_ok());
        assert_eq!(blockchain.chain.len(), 2);
    }

    #[test]
    fn test_blockchain_validity() {
        let consensus = Arc::new(RwLock::new(PoCConsensus::new(0.66, 0.51).unwrap()));
        let mut blockchain = Blockchain::new(Arc::new(MockTransactionValidator), consensus);
        let transaction = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            100.0,
            CurrencyType::BasicNeeds,
            Utc::now().timestamp(),
        );
        blockchain.add_transaction(transaction).unwrap();
        blockchain.create_block().unwrap();
        assert!(blockchain.validate_chain());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_blockchain/src/blockchain.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_blockchain/src/lib.rs =====
use icn_common::{Block, Transaction, IcnResult, IcnError, Hashable};
use std::collections::HashMap;
use chrono::Utc;
use log::{info, warn, error};
use std::sync::{Arc, RwLock};

/// Represents a blockchain, maintaining a list of blocks and pending transactions.
pub struct Blockchain {
    chain: Vec<Block>,
    pending_transactions: Vec<Transaction>,
    transaction_validator: Arc<dyn TransactionValidator>,
}

/// A trait for validating transactions within a blockchain.
pub trait TransactionValidator: Send + Sync {
    /// Validates a transaction within the context of a blockchain.
    ///
    /// # Arguments
    ///
    /// * `transaction` - The transaction to validate.
    /// * `blockchain` - The blockchain context.
    ///
    /// # Returns
    ///
    /// `true` if the transaction is valid, `false` otherwise.
    fn validate(&self, transaction: &Transaction, blockchain: &Blockchain) -> bool;
}

impl Blockchain {
    /// Creates a new blockchain with a genesis block.
    ///
    /// # Arguments
    ///
    /// * `transaction_validator` - A validator for verifying transactions.
    pub fn new(transaction_validator: Arc<dyn TransactionValidator>) -> Self {
        Blockchain {
            chain: vec![Block::genesis()],
            pending_transactions: Vec::new(),
            transaction_validator,
        }
    }

    /// Adds a new transaction to the list of pending transactions.
    ///
    /// # Arguments
    ///
    /// * `transaction` - The transaction to add.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Blockchain` if the transaction is invalid.
    pub fn add_transaction(&mut self, transaction: Transaction) -> IcnResult<()> {
        if self.transaction_validator.validate(&transaction, self) {
            self.pending_transactions.push(transaction);
            Ok(())
        } else {
            Err(IcnError::Blockchain("Invalid transaction".to_string()))
        }
    }

    /// Creates a new block with all pending transactions.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Blockchain` if no previous block is found or if `calculate_hash` fails.
    pub fn create_block(&mut self) -> IcnResult<Block> {
        let previous_block = self.chain.last()
            .ok_or_else(|| IcnError::Blockchain("No previous block found".to_string()))?;

        let new_block = Block {
            index: self.chain.len() as u64,
            timestamp: Utc::now().timestamp(),
            transactions: self.pending_transactions.clone(),
            previous_hash: previous_block.hash.clone(),
            hash: String::new(), // Will be set in calculate_hash
        };

        let new_block = self.calculate_hash(new_block)?;
        self.chain.push(new_block.clone());
        self.pending_transactions.clear();

        Ok(new_block)
    }

    fn calculate_hash(&self, mut block: Block) -> IcnResult<Block> {
        block.hash = block.hash();
        Ok(block)
    }

    /// Validates the integrity of the blockchain.
    ///
    /// # Returns
    ///
    /// `true` if the blockchain is valid, `false` otherwise.
    pub fn validate_chain(&self) -> bool {
        for i in 1..self.chain.len() {
            let current_block = &self.chain[i];
            let previous_block = &self.chain[i - 1];

            if current_block.hash != current_block.hash() {
                return false;
            }

            if current_block.previous_hash != previous_block.hash {
                return false;
            }
        }
        true
    }

    /// Returns the latest block in the blockchain.
    pub fn get_latest_block(&self) -> Option<&Block> {
        self.chain.last()
    }

    /// Returns a block by its index.
    ///
    /// # Arguments
    ///
    /// * `index` - The index of the block.
    ///
    /// # Returns
    ///
    /// The block if found, `None` otherwise.
    pub fn get_block_by_index(&self, index: u64) -> Option<&Block> {
        self.chain.get(index as usize)
    }

    /// Returns a block by its hash.
    ///
    /// # Arguments
    ///
    /// * `hash` - The hash of the block.
    ///
    /// # Returns
    ///
    /// The block if found, `None` otherwise.
    pub fn get_block_by_hash(&self, hash: &str) -> Option<&Block> {
        self.chain.iter().find(|block| block.hash == hash)
    }

    /// Starts the blockchain.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn start(&self) -> IcnResult<()> {
        info!("Blockchain started");
        Ok(())
    }

    /// Stops the blockchain.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn stop(&self) -> IcnResult<()> {
        info!("Blockchain stopped");
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_common::CurrencyType;
    use std::sync::Arc;

    struct MockTransactionValidator;

    impl TransactionValidator for MockTransactionValidator {
        fn validate(&self, _transaction: &Transaction, _blockchain: &Blockchain) -> bool {
            true
        }
    }

    #[test]
    fn test_blockchain_creation() {
        let blockchain = Blockchain::new(Arc::new(MockTransactionValidator));
        assert_eq!(blockchain.chain.len(), 1);
        assert_eq!(blockchain.chain[0].index, 0);
    }

    #[test]
    fn test_add_block() {
        let mut blockchain = Blockchain::new(Arc::new(MockTransactionValidator));
        let transaction = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            100.0,
            CurrencyType::BasicNeeds,
            Utc::now().timestamp(),
        );
        blockchain.add_transaction(transaction).unwrap();
        assert!(blockchain.create_block().is_ok());
        assert_eq!(blockchain.chain.len(), 2);
    }

    #[test]
    fn test_blockchain_validity() {
        let mut blockchain = Blockchain::new(Arc::new(MockTransactionValidator));
        let transaction = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            100.0,
            CurrencyType::BasicNeeds,
            Utc::now().timestamp(),
        );
        blockchain.add_transaction(transaction).unwrap();
        blockchain.create_block().unwrap();
        assert!(blockchain.validate_chain());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_blockchain/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_blockchain/src/transaction_validator.rs =====
use crate::{Transaction, Blockchain};
use icn_common::error::{IcnError, IcnResult};
use chrono::{DateTime, Utc};

pub struct TransactionValidator;

impl TransactionValidator {
    /// Validates a transaction within the context of a blockchain.
    ///
    /// # Arguments
    ///
    /// * `transaction` - The transaction to validate.
    /// * `blockchain` - The blockchain context.
    ///
    /// # Returns
    ///
    /// Returns `IcnResult` if the transaction is valid, otherwise an error.
    pub fn validate_transaction(transaction: &Transaction, blockchain: &Blockchain) -> IcnResult<()> {
        if Self::is_double_spend(transaction, blockchain)? {
            return Err(IcnError::Blockchain("Double spend detected".to_string()));
        }

        if !Self::validate_currency_and_amount(transaction) {
            return Err(IcnError::Currency("Invalid currency or amount".to_string()));
        }

        if !Self::check_sufficient_balance(transaction, blockchain)? {
            return Err(IcnError::Currency("Insufficient balance".to_string()));
        }

        if !Self::validate_signature(transaction)? {
            return Err(IcnError::Identity("Invalid signature".to_string()));
        }

        if !Self::validate_timestamp(transaction) {
            return Err(IcnError::Blockchain("Transaction timestamp is not valid".to_string()));
        }

        Ok(())
    }

    fn is_double_spend(transaction: &Transaction, blockchain: &Blockchain) -> IcnResult<bool> {
        for block in &blockchain.chain {
            for tx in &block.transactions {
                if tx == transaction {
                    return Ok(true);
                }
            }
        }
        Ok(false)
    }

    fn validate_currency_and_amount(transaction: &Transaction) -> bool {
        transaction.amount > 0.0
    }

    fn check_sufficient_balance(transaction: &Transaction, blockchain: &Blockchain) -> IcnResult<bool> {
        let balance = blockchain.get_balance(&transaction.from, &transaction.currency_type)?;
        Ok(balance >= transaction.amount + transaction.get_fee())
    }

    fn validate_signature(transaction: &Transaction) -> IcnResult<bool> {
        transaction.verify().map_err(|e| IcnError::Identity(format!("Signature verification failed: {}", e)))
    }

    fn validate_timestamp(transaction: &Transaction) -> bool {
        let current_time = Utc::now().timestamp();
        transaction.timestamp <= current_time && transaction.timestamp >= (current_time - 60 * 60) // within the last hour
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_common::{Transaction, Blockchain};
    use ed25519_dalek::Keypair;
    use rand::rngs::OsRng;
    use std::sync::Arc;

    fn create_signed_transaction(from: &str, to: &str, amount: f64) -> Transaction {
        let mut tx = Transaction::new(
            from.to_string(),
            to.to_string(),
            amount,
            CurrencyType::BasicNeeds,
            1000,
        );
        let mut csprng = OsRng{};
        let keypair: Keypair = Keypair::generate(&mut csprng);
        tx.sign(&keypair).unwrap();
        tx
    }

    #[test]
    fn test_validate_transaction() {
        let mut blockchain = Blockchain::new(Arc::new(TransactionValidator));
        let tx = create_signed_transaction("Alice", "Bob", 50.0);

        // Add some balance to Alice's account
        blockchain.add_transaction(create_signed_transaction("Genesis", "Alice", 100.0)).unwrap();
        blockchain.create_block().unwrap();

        assert!(TransactionValidator::validate_transaction(&tx, &blockchain).is_ok());
    }

    #[test]
    fn test_insufficient_balance() {
        let mut blockchain = Blockchain::new(Arc::new(TransactionValidator));
        let tx = create_signed_transaction("Alice", "Bob", 150.0);

        // Add some balance to Alice's account, but not enough
        blockchain.add_transaction(create_signed_transaction("Genesis", "Alice", 100.0)).unwrap();
        blockchain.create_block().unwrap();

        assert!(TransactionValidator::validate_transaction(&tx, &blockchain).is_err());
    }

    #[test]
    fn test_double_spend() {
        let mut blockchain = Blockchain::new(Arc::new(TransactionValidator));
        let tx = create_signed_transaction("Alice", "Bob", 50.0);

        // Add some balance to Alice's account
        blockchain.add_transaction(create_signed_transaction("Genesis", "Alice", 100.0)).unwrap();
        blockchain.create_block().unwrap();

        // Add the transaction to the blockchain
        blockchain.add_transaction(tx.clone()).unwrap();
        blockchain.create_block().unwrap();

        // Try to validate the same transaction again
        assert!(TransactionValidator::validate_transaction(&tx, &blockchain).is_err());
    }

    #[test]
    fn test_invalid_timestamp() {
        let mut blockchain = Blockchain::new(Arc::new(TransactionValidator));
        let mut tx = create_signed_transaction("Alice", "Bob", 50.0);
        tx.timestamp = Utc::now().timestamp() + 60 * 60; // Set to future time

        assert!(TransactionValidator::validate_transaction(&tx, &blockchain).is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_blockchain/src/transaction_validator.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_common/Cargo.toml =====
[package]
name = "icn_common"
version = "0.1.0"
authors = ["Your Name <your.email@example.com>"]
edition = "2018"

[dependencies]
chrono = "0.4"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
sha2 = "0.9"
rand = "0.8"
rand_chacha = "0.3"
ed25519-dalek = "1.0"
thiserror = "1.0"

[dev-dependencies]
rand = "0.8"
rand_chacha = "0.3"
===== END OF /home/matt/InterCooperative-Network/crates/icn_common/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_common/src/error.rs =====
use thiserror::Error;

/// Custom error type for the ICN project.
#[derive(Error, Debug)]
pub enum IcnError {
    #[error("Blockchain error: {0}")]
    Blockchain(String),

    #[error("Consensus error: {0}")]
    Consensus(String),

    #[error("Currency error: {0}")]
    Currency(String),

    #[error("Governance error: {0}")]
    Governance(String),

    #[error("Identity error: {0}")]
    Identity(String),

    #[error("Network error: {0}")]
    Network(String),

    #[error("Node management error: {0}")]
    NodeManagement(String),

    #[error("Sharding error: {0}")]
    Sharding(String),

    #[error("Storage error: {0}")]
    Storage(String),

    #[error("VM error: {0}")]
    Vm(String),

    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),

    #[error("Serialization error: {0}")]
    Serialization(#[from] serde_json::Error),

    #[error("Database error: {0}")]
    Database(String),

    #[error("Configuration error: {0}")]
    Config(String),

    #[error("Unknown error: {0}")]
    Unknown(String),
}

/// Result type for the ICN project.
pub type IcnResult<T> = std::result::Result<T, IcnError>;
===== END OF /home/matt/InterCooperative-Network/crates/icn_common/src/error.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_common/src/lib.rs =====
/// Module for common types and utilities used across the ICN project.
use chrono::{DateTime, Utc};
use rand_chacha::ChaChaRng;
use rand_chacha::rand_core::SeedableRng;
use rand::RngCore;
use ed25519_dalek::Keypair;
use bellman::{Circuit, ConstraintSystem, SynthesisError};
use bls12_381::Bls12;

pub mod error;
pub use error::{IcnError, IcnResult};

/// Enumeration representing different types of currencies.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum CurrencyType {
    BasicNeeds,
    Education,
    Environmental,
    Community,
    Volunteer,
    Storage,
    Processing,
    Energy,
    Luxury,
    Service,
    Custom(String),
    AssetToken(String),
    Bond(String),
}

/// Structure representing a transaction.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Transaction {
    pub from: String,
    pub to: String,
    pub amount: f64,
    pub currency_type: CurrencyType,
    pub timestamp: i64,
    pub signature: Option<Vec<u8>>,
    pub zkp: Option<ZKProof>,
}

/// Structure representing a block in the blockchain.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Block {
    pub index: u64,
    pub timestamp: i64,
    pub transactions: Vec<Transaction>,
    pub previous_hash: String,
    pub hash: String,
    pub zkp_accumulator: Option<ZKAccumulator>,
}

/// Structure representing a proposal for governance.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proposal {
    pub id: String,
    pub title: String,
    pub description: String,
    pub proposer: String,
    pub created_at: DateTime<Utc>,
    pub voting_ends_at: DateTime<Utc>,
    pub status: ProposalStatus,
    pub proposal_type: ProposalType,
    pub category: ProposalCategory,
    pub required_quorum: f64,
    pub execution_timestamp: Option<DateTime<Utc>>,
}

/// Enumeration representing the status of a proposal.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProposalStatus {
    Active,
    Passed,
    Rejected,
    Implemented,
}

/// Enumeration representing the type of a proposal.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProposalType {
    Constitutional,
    EconomicAdjustment,
    NetworkUpgrade,
}

/// Enumeration representing the category of a proposal.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProposalCategory {
    Constitutional,
    Economic,
    Technical,
}

/// Structure representing a vote on a proposal.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vote {
    pub voter: String,
    pub proposal_id: String,
    pub in_favor: bool,
    pub weight: f64,
    pub timestamp: DateTime<Utc>,
    pub zkp: Option<ZKProof>,
}

/// Trait defining an object that can be hashed.
pub trait Hashable {
    fn hash(&self) -> String;
}

/// Structure representing a zero-knowledge proof.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ZKProof {
    pub proof: Vec<u8>,
    pub public_inputs: Vec<Vec<u8>>,
}

/// Structure representing a zero-knowledge proof accumulator.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ZKAccumulator {
    pub value: Vec<u8>,
}

/// Trait for synthesizing zero-knowledge circuits.
pub trait ZKCircuit<E: bellman::Engine> {
    fn synthesize<CS: ConstraintSystem<E>>(self, cs: &mut CS) -> Result<(), SynthesisError>;
}

/// Implementation of the Hashable trait for Block.
impl Hashable for Block {
    fn hash(&self) -> String {
        use sha2::{Sha256, Digest};
        let mut hasher = Sha256::new();
        hasher.update(self.index.to_string());
        hasher.update(&self.timestamp.to_string());
        for transaction in &self.transactions {
            hasher.update(&transaction.hash());
        }
        hasher.update(&self.previous_hash);
        format!("{:x}", hasher.finalize())
    }
}

/// Implementation of the Hashable trait for Transaction.
impl Hashable for Transaction {
    fn hash(&self) -> String {
        use sha2::{Sha256, Digest};
        let mut hasher = Sha256::new();
        hasher.update(&self.from);
        hasher.update(&self.to);
        hasher.update(self.amount.to_string().as_bytes());
        hasher.update(format!("{:?}", self.currency_type).as_bytes());
        hasher.update(self.timestamp.to_string().as_bytes());
        if let Some(signature) = &self.signature {
            hasher.update(signature);
        }
        if let Some(zkp) = &self.zkp {
            hasher.update(&zkp.proof);
            for input in &zkp.public_inputs {
                hasher.update(input);
            }
        }
        format!("{:x}", hasher.finalize())
    }
}

/// Implementation of methods for Transaction.
impl Transaction {
    /// Creates a new transaction
    pub fn new(from: String, to: String, amount: f64, currency_type: CurrencyType, timestamp: i64) -> Self {
        Transaction {
            from,
            to,
            amount,
            currency_type,
            timestamp,
            signature: None,
            zkp: None,
        }
    }

    /// Signs the transaction using the provided private key
    pub fn sign(&mut self, private_key: &[u8]) -> IcnResult<()> {
        use ed25519_dalek::{Keypair, Signer};
        let keypair = Keypair::from_bytes(private_key)
            .map_err(|e| IcnError::Identity(format!("Invalid private key: {}", e)))?;
        let message = self.hash().as_bytes().to_vec();
        let signature = keypair.sign(&message);
        self.signature = Some(signature.to_bytes().to_vec());
        Ok(())
    }

    /// Verifies the transaction using the provided public key
    pub fn verify(&self, public_key: &[u8]) -> IcnResult<bool> {
        use ed25519_dalek::{PublicKey, Verifier};
        let public_key = PublicKey::from_bytes(public_key)
            .map_err(|e| IcnError::Identity(format!("Invalid public key: {}", e)))?;
        let message = self.hash().as_bytes().to_vec();
        if let Some(signature) = &self.signature {
            let signature = ed25519_dalek::Signature::from_bytes(signature)
                .map_err(|e| IcnError::Identity(format!("Invalid signature: {}", e)))?;
            Ok(public_key.verify(&message, &signature).is_ok())
        } else {
            Ok(false)
        }
    }

    /// Adds a zero-knowledge proof to the transaction
    pub fn add_zkp(&mut self, proof: Vec<u8>, public_inputs: Vec<Vec<u8>>) {
        self.zkp = Some(ZKProof {
            proof,
            public_inputs,
        });
    }

    /// Verifies the zero-knowledge proof of the transaction
    pub fn verify_zkp<E: bellman::Engine, C: ZKCircuit<E>>(&self, circuit: C, verifying_key: &bellman::groth16::VerifyingKey<E>) -> IcnResult<bool> {
        if let Some(zkp) = &self.zkp {
            let proof = bellman::groth16::Proof::<E>::read(&zkp.proof[..])
                .map_err(|e| IcnError::ZKP(format!("Invalid ZKP: {}", e)))?;
            
            let public_inputs: Vec<E::Fr> = zkp.public_inputs.iter()
                .map(|input| E::Fr::from_str(&hex::encode(input)).unwrap())
                .collect();

            Ok(bellman::groth16::verify_proof(verifying_key, &proof, &public_inputs)
                .map_err(|e| IcnError::ZKP(format!("ZKP verification failed: {}", e)))?)
        } else {
            Ok(false)
        }
    }
}

/// Implementation of methods for Block.
impl Block {
    /// Creates a new block
    pub fn new(index: u64, transactions: Vec<Transaction>, previous_hash: String) -> Self {
        let timestamp = Utc::now().timestamp();
        let mut block = Block {
            index,
            timestamp,
            transactions,
            previous_hash,
            hash: String::new(),
            zkp_accumulator: None,
        };
        block.hash = block.hash();
        block
    }

    /// Creates a genesis block
    pub fn genesis() -> Self {
        Block::new(0, Vec::new(), "0".repeat(64))
    }

    /// Adds a zero-knowledge proof accumulator to the block
    pub fn add_zkp_accumulator(&mut self, accumulator: ZKAccumulator) {
        self.zkp_accumulator = Some(accumulator);
    }
}

/// Structure representing a ZK accumulator circuit.
pub struct ZKAccumulatorCircuit<E: bellman::Engine> {
    pub transactions: Vec<Transaction>,
    pub previous_accumulator: Option<E::Fr>,
}

/// Implementation of the ZKCircuit trait for ZKAccumulatorCircuit.
impl<E: bellman::Engine> ZKCircuit<E> for ZKAccumulatorCircuit<E> {
    fn synthesize<CS: ConstraintSystem<E>>(
        self,
        cs: &mut CS
    ) -> Result<(), SynthesisError> {
        // Implementation of the ZKP circuit for accumulating transactions
        // This is a placeholder and should be implemented based on the specific requirements
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand::rngs::OsRng;
    use rand::SeedableRng;
    use rand_chacha::ChaChaRng;

    #[test]
    fn test_transaction_hash() {
        let tx = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            100.0,
            CurrencyType::BasicNeeds,
            1234567890,
        );
        let hash = tx.hash();
        assert!(!hash.is_empty());
        assert_eq!(hash.len(), 64);
    }

    #[test]
    fn test_block_hash() {
        let tx = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            100.0,
            CurrencyType::BasicNeeds,
            1234567890,
        );
        let block = Block::new(1, vec![tx], "previous_hash".to_string());
        let hash = block.hash();
        assert!(!hash.is_empty());
        assert_eq!(hash.len(), 64);
        assert_eq!(block.hash, hash);
    }

    #[test]
    fn test_transaction_sign_and_verify() {
        use ed25519_dalek::{Keypair, Signer};

        let mut rng = ChaChaRng::from_entropy();
        let keypair: Keypair = Keypair::generate(&mut rng);

        let mut tx = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            100.0,
            CurrencyType::BasicNeeds,
            1234567890,
        );

        tx.sign(keypair.to_bytes().as_ref()).unwrap();
        assert!(tx.verify(keypair.public.as_bytes()).unwrap());

        // Test with wrong public key
        let wrong_keypair: Keypair = Keypair::generate(&mut rng);
        assert!(!tx.verify(wrong_keypair.public.as_bytes()).unwrap());
    }

    #[test]
    fn test_zkp_integration() {
        use bellman::groth16;
        use bls12_381::Bls12;

        // This is a dummy circuit for testing purposes
        struct DummyCircuit;
        impl ZKCircuit<Bls12> for DummyCircuit {
            fn synthesize<CS: ConstraintSystem<Bls12>>(
                self,
                _cs: &mut CS
            ) -> Result<(), SynthesisError> {
                Ok(())
            }
        }

        let mut rng = ChaChaRng::from_entropy();
        let params = groth16::generate_random_parameters::<Bls12, _, _>(DummyCircuit, &mut rng).unwrap();
        let pvk = groth16::prepare_verifying_key(&params.vk);

        let mut tx = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            100.0,
            CurrencyType::BasicNeeds,
            1234567890,
        );

        let proof = groth16::create_random_proof(DummyCircuit, &params, &mut rng).unwrap();
        let proof_vec = proof.write(&mut vec![]).unwrap();
        tx.add_zkp(proof_vec, vec![]);

        assert!(tx.verify_zkp(DummyCircuit, &pvk).unwrap());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_common/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_common/src/main.rs =====
fn main() {
    println!("Hello, world!");
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_common/src/main.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_consensus/Cargo.toml =====
[package]
name = "icn_consensus"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
icn_blockchain = { path = "../icn_blockchain" }
serde = { version = "1.0", features = ["derive"] }
log = "0.4"
thiserror = "1.0"
chrono = { version = "0.4", features = ["serde"] }
rand = "0.8"

[dev-dependencies]
tokio = { version = "1.0", features = ["full"] }
===== END OF /home/matt/InterCooperative-Network/crates/icn_consensus/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_consensus/src/bft_poc.rs =====
use icn_utils::{error::IcnError, IcnResult};
use serde::{Serialize, Deserialize};

#[derive(Debug)]
pub enum ProposalStatus {
    Pending,
    Approved,
    Rejected,
}

impl Clone for ProposalStatus {
    fn clone(&self) -> Self {
        match self {
            ProposalStatus::Pending => ProposalStatus::Pending,
            ProposalStatus::Approved => ProposalStatus::Approved,
            ProposalStatus::Rejected => ProposalStatus::Rejected,
        }
    }
}

#[derive(Debug)]
pub struct Proposal {
    pub id: String,
    pub status: ProposalStatus,
    pub votes: Vec<Vote>,
}

#[derive(Clone)]
pub struct Vote {
    pub member_id: String,
    pub vote: bool,
}

pub struct BFTPoC {
    pub proposals: Vec<Proposal>,
}

impl BFTPoC {
    pub fn new() -> Self {
        BFTPoC {
            proposals: Vec::new(),
        }
    }

    pub fn create_proposal(&mut self, proposal_id: String) -> IcnResult<()> {
        if self.proposals.iter().any(|p| p.id == proposal_id) {
            return Err(IcnError::Governance("Proposal already exists".to_string()));
        }

        let proposal = Proposal {
            id: proposal_id,
            status: ProposalStatus::Pending,
            votes: Vec::new(),
        };

        self.proposals.push(proposal);
        Ok(())
    }

    pub fn vote_on_proposal(&mut self, proposal_id: &str, member_id: String, vote: bool) -> IcnResult<()> {
        let proposal = self.proposals.iter_mut().find(|p| p.id == proposal_id).ok_or_else(|| IcnError::Governance("Proposal not found".to_string()))?;

        if proposal.votes.iter().any(|v| v.member_id == member_id) {
            return Err(IcnError::Governance("Member has already voted".to_string()));
        }

        // Validate the member ID
        if member_id.is_empty() {
            return Err(IcnError::Governance("Invalid member ID".to_string()));
        }

        proposal.votes.push(Vote { member_id, vote });
        Ok(())
    }

    pub fn finalize_proposal(&mut self, proposal_id: &str) -> IcnResult<ProposalStatus> {
        let proposal = self.proposals.iter_mut().find(|p| p.id == proposal_id).ok_or_else(|| IcnError::Governance("Proposal not found".to_string()))?;

        let positive_votes = proposal.votes.iter().filter(|v| v.vote).count();
        let negative_votes = proposal.votes.len() - positive_votes;

        proposal.status = if positive_votes > negative_votes {
            ProposalStatus::Approved
        } else {
            ProposalStatus::Rejected
        };

        Ok(proposal.status.clone())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_proposal() {
        let mut bft_poc = BFTPoC::new();

        assert!(bft_poc.create_proposal("proposal1".to_string()).is_ok());
        assert_eq!(bft_poc.proposals.len(), 1);

        assert!(bft_poc.create_proposal("proposal1".to_string()).is_err());
    }

    #[test]
    fn test_vote_on_proposal() {
        let mut bft_poc = BFTPoC::new();
        bft_poc.create_proposal("proposal1".to_string()).unwrap();

        assert!(bft_poc.vote_on_proposal("proposal1", "member1".to_string(), true).is_ok());
        assert_eq!(bft_poc.proposals[0].votes.len(), 1);

        assert!(bft_poc.vote_on_proposal("proposal1", "member1".to_string(), false).is_err());
    }

    #[test]
    fn test_finalize_proposal() {
        let mut bft_poc = BFTPoC::new();
        bft_poc.create_proposal("proposal1".to_string()).unwrap();

        bft_poc.vote_on_proposal("proposal1", "member1".to_string(), true).unwrap();
        bft_poc.vote_on_proposal("proposal1", "member2".to_string(), false).unwrap();

        let status = bft_poc.finalize_proposal("proposal1").unwrap();
        assert_eq!(status, ProposalStatus::Rejected);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_consensus/src/bft_poc.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_consensus/src/consensus.rs =====
use icn_common::{IcnResult, IcnError, Block, Transaction, CurrencyType};
use std::collections::HashMap;
use log::{info, warn};
use rand::Rng;

/// Represents a member of the consensus network.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Member {
    pub id: String,
    pub reputation: f64,
    pub is_validator: bool,
}

/// Proof of Cooperation (PoC) consensus mechanism.
#[derive(Debug, Serialize, Deserialize)]
pub struct PoCConsensus {
    pub members: HashMap<String, Member>,
    pub threshold: f64,
    pub quorum: f64,
}

impl PoCConsensus {
    /// Creates a new PoCConsensus with the specified threshold and quorum.
    ///
    /// # Arguments
    ///
    /// * `threshold` - The threshold for consensus.
    /// * `quorum` - The quorum for consensus.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Consensus` if the threshold or quorum values are invalid.
    pub fn new(threshold: f64, quorum: f64) -> IcnResult<Self> {
        if threshold <= 0.0 || threshold > 1.0 || quorum <= 0.0 || quorum > 1.0 {
            return Err(IcnError::Consensus("Invalid threshold or quorum value".into()));
        }

        Ok(PoCConsensus {
            members: HashMap::new(),
            threshold,
            quorum,
        })
    }

    /// Adds a new member to the consensus network.
    ///
    /// # Arguments
    ///
    /// * `id` - The ID of the new member.
    /// * `is_validator` - Whether the new member is a validator.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Consensus` if the member already exists.
    pub fn add_member(&mut self, id: String, is_validator: bool) -> IcnResult<()> {
        if self.members.contains_key(&id) {
            return Err(IcnError::Consensus("Member already exists".into()));
        }
        self.members.insert(id.clone(), Member {
            id,
            reputation: 1.0,
            is_validator,
        });
        Ok(())
    }

    /// Removes a member from the consensus network.
    ///
    /// # Arguments
    ///
    /// * `id` - The ID of the member to remove.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Consensus` if the member is not found.
    pub fn remove_member(&mut self, id: &str) -> IcnResult<()> {
        if self.members.remove(id).is_none() {
            return Err(IcnError::Consensus("Member not found".into()));
        }
        Ok(())
    }

    /// Updates the reputation of a member.
    ///
    /// # Arguments
    ///
    /// * `id` - The ID of the member.
    /// * `change` - The amount to change the reputation by.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Consensus` if the member is not found.
    pub fn update_reputation(&mut self, id: &str, change: f64) -> IcnResult<()> {
        let member = self.members.get_mut(id).ok_or_else(|| IcnError::Consensus("Member not found".into()))?;
        member.reputation += change;
        member.reputation = member.reputation.max(0.0); // Ensure reputation doesn't go negative
        Ok(())
    }

    /// Validates a block.
    ///
    /// # Arguments
    ///
    /// * `block` - The block to validate.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Consensus` if the block is invalid.
    pub fn validate_block(&self, block: &Block) -> IcnResult<bool> {
        // In a real implementation, this would involve more complex validation logic
        if block.transactions.is_empty() {
            return Err(IcnError::Consensus("Block has no transactions".into()));
        }
        Ok(true)
    }

    /// Reaches consensus on a block.
    ///
    /// # Arguments
    ///
    /// * `block` - The block to reach consensus on.
    /// * `votes` - The votes for the block.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Consensus` if consensus is not reached.
    pub fn reach_consensus(&self, block: &Block, votes: &[(&str, bool)]) -> IcnResult<bool> {
        let total_reputation: f64 = self.members.values().filter(|m| m.is_validator).map(|m| m.reputation).sum();

        let mut positive_reputation = 0.0;
        let mut participating_reputation = 0.0;

        for (member_id, vote) in votes {
            if let Some(member) = self.members.get(*member_id) {
                if member.is_validator {
                    participating_reputation += member.reputation;
                    if *vote {
                        positive_reputation += member.reputation;
                    }
                }
            } else {
                return Err(IcnError::Consensus("Invalid member in votes".into()));
            }
        }

        if participating_reputation / total_reputation < self.quorum {
            return Err(IcnError::Consensus("Quorum not reached".into()));
        }

        Ok(positive_reputation / participating_reputation >= self.threshold)
    }

    /// Returns a list of all validators.
    pub fn get_validators(&self) -> Vec<&Member> {
        self.members.values().filter(|m| m.is_validator).collect()
    }

    /// Selects a proposer for the next block.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Consensus` if no validators are available.
    pub fn select_proposer(&self) -> IcnResult<&Member> {
        let validators: Vec<&Member> = self.get_validators();
        if validators.is_empty() {
            return Err(IcnError::Consensus("No validators available".into()));
        }

        let total_reputation: f64 = validators.iter().map(|m| m.reputation).sum();
        let mut rng = rand::thread_rng();
        let random_point = rng.gen::<f64>() * total_reputation;

        let mut cumulative_reputation = 0.0;
        for validator in &validators {
            cumulative_reputation += validator.reputation;
            if cumulative_reputation > random_point {
                return Ok(validator);
            }
        }

        // This should never happen, but we'll return the last validator if it does
        Ok(validators.last().unwrap())
    }

    /// Starts the PoC consensus mechanism.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn start(&self) -> IcnResult<()> {
        info!("PoC Consensus mechanism started");
        Ok(())
    }

    /// Stops the PoC consensus mechanism.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn stop(&self) -> IcnResult<()> {
        info!("PoC Consensus mechanism stopped");
        Ok(())
    }
}

/// Trait defining the methods required for a consensus algorithm.
pub trait ConsensusAlgorithm {
    fn validate_block(&self, block: &Block) -> IcnResult<bool>;
    fn reach_consensus(&self, block: &Block, votes: &[(&str, bool)]) -> IcnResult<bool>;
}

impl ConsensusAlgorithm for PoCConsensus {
    fn validate_block(&self, block: &Block) -> IcnResult<bool> {
        self.validate_block(block)
    }

    fn reach_consensus(&self, block: &Block, votes: &[(&str, bool)]) -> IcnResult<bool> {
        self.reach_consensus(block, votes)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_common::CurrencyType;

    #[test]
    fn test_add_and_remove_member() {
        let mut consensus = PoCConsensus::new(0.66, 0.51).unwrap();
        assert!(consensus.add_member("Alice".to_string(), true).is_ok());
        assert!(consensus.add_member("Bob".to_string(), false).is_ok());
        assert_eq!(consensus.members.len(), 2);
        assert!(consensus.remove_member("Alice").is_ok());
        assert_eq!(consensus.members.len(), 1);
        assert!(consensus.remove_member("Charlie").is_err());
    }

    #[test]
    fn test_update_reputation() {
        let mut consensus = PoCConsensus::new(0.66, 0.51).unwrap();
        consensus.add_member("Alice".to_string(), true).unwrap();
        assert!(consensus.update_reputation("Alice", 0.5).is_ok());
        assert_eq!(consensus.members.get("Alice").unwrap().reputation, 1.5);
        assert!(consensus.update_reputation("Bob", 1.0).is_err());
    }

    #[test]
    fn test_reach_consensus() {
        let mut consensus = PoCConsensus::new(0.66, 0.51).unwrap();
        consensus.add_member("Alice".to_string(), true).unwrap();
        consensus.add_member("Bob".to_string(), true).unwrap();
        consensus.add_member("Charlie".to_string(), true).unwrap();

        let block = Block {
            index: 1,
            timestamp: chrono::Utc::now().timestamp(),
            transactions: vec![Transaction::new(
                "Alice".to_string(),
                "Bob".to_string(),
                100.0,
                CurrencyType::BasicNeeds,
                1000,
            )],
            previous_hash: "previous_hash".to_string(),
            hash: "hash".to_string(),
        };

        let votes = vec![
            ("Alice", true),
            ("Bob", true),
            ("Charlie", false),
        ];

        assert!(consensus.reach_consensus(&block, &votes).unwrap());

        let insufficient_votes = vec![
            ("Alice", true),
            ("Bob", true),
        ];

        assert!(consensus.reach_consensus(&block, &insufficient_votes).is_err());
    }

    #[test]
    fn test_select_proposer() {
        let mut consensus = PoCConsensus::new(0.66, 0.51).unwrap();
        consensus.add_member("Alice".to_string(), true).unwrap();
        consensus.add_member("Bob".to_string(), true).unwrap();
        consensus.add_member("Charlie".to_string(), false).unwrap();

        let proposer = consensus.select_proposer().unwrap();
        assert!(proposer.is_validator);
        assert!(proposer.id == "Alice" || proposer.id == "Bob");

        // Test when there are no validators
        let mut consensus_no_validators = PoCConsensus::new(0.66, 0.51).unwrap();
        consensus_no_validators.add_member("Dave".to_string(), false).unwrap();
        assert!(consensus_no_validators.select_proposer().is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_consensus/src/consensus.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_consensus/src/lib.rs =====
use icn_common::{IcnResult, IcnError, Block, Transaction, CurrencyType};
use std::collections::HashMap;
use log::{info, warn};
use rand::Rng;

#[derive(Debug, Clone)]
pub struct Member {
    pub id: String,
    pub reputation: f64,
    pub is_validator: bool,
}

pub struct PoCConsensus {
    pub members: HashMap<String, Member>,
    pub threshold: f64,
    pub quorum: f64,
}

impl PoCConsensus {
    pub fn new(threshold: f64, quorum: f64) -> IcnResult<Self> {
        if threshold <= 0.0 || threshold > 1.0 || quorum <= 0.0 || quorum > 1.0 {
            return Err(IcnError::Consensus("Invalid threshold or quorum value".into()));
        }

        Ok(PoCConsensus {
            members: HashMap::new(),
            threshold,
            quorum,
        })
    }

    pub fn add_member(&mut self, id: String, is_validator: bool) -> IcnResult<()> {
        if self.members.contains_key(&id) {
            return Err(IcnError::Consensus("Member already exists".into()));
        }
        self.members.insert(id.clone(), Member {
            id,
            reputation: 1.0,
            is_validator,
        });
        Ok(())
    }

    pub fn remove_member(&mut self, id: &str) -> IcnResult<()> {
        if self.members.remove(id).is_none() {
            return Err(IcnError::Consensus("Member not found".into()));
        }
        Ok(())
    }

    pub fn update_reputation(&mut self, id: &str, change: f64) -> IcnResult<()> {
        let member = self.members.get_mut(id).ok_or_else(|| IcnError::Consensus("Member not found".into()))?;
        member.reputation += change;
        member.reputation = member.reputation.max(0.0); // Ensure reputation doesn't go negative
        Ok(())
    }

    pub fn validate_block(&self, block: &Block) -> IcnResult<bool> {
        // In a real implementation, this would involve more complex validation logic
        if block.transactions.is_empty() {
            return Err(IcnError::Consensus("Block has no transactions".into()));
        }
        Ok(true)
    }

    pub fn reach_consensus(&self, _block: &Block, votes: &[(&str, bool)]) -> IcnResult<bool> {
        let total_reputation: f64 = self.members.values().filter(|m| m.is_validator).map(|m| m.reputation).sum();

        let mut positive_reputation = 0.0;
        let mut participating_reputation = 0.0;

        for (member_id, vote) in votes {
            if let Some(member) = self.members.get(*member_id) {
                if member.is_validator {
                    participating_reputation += member.reputation;
                    if *vote {
                        positive_reputation += member.reputation;
                    }
                }
            } else {
                return Err(IcnError::Consensus("Invalid member in votes".into()));
            }
        }

        if participating_reputation / total_reputation < self.quorum {
            return Err(IcnError::Consensus("Quorum not reached".into()));
        }

        Ok(positive_reputation / participating_reputation >= self.threshold)
    }

    pub fn get_validators(&self) -> Vec<&Member> {
        self.members.values().filter(|m| m.is_validator).collect()
    }

    pub fn select_proposer(&self) -> IcnResult<&Member> {
        let validators: Vec<&Member> = self.get_validators();
        if validators.is_empty() {
            return Err(IcnError::Consensus("No validators available".into()));
        }

        let total_reputation: f64 = validators.iter().map(|m| m.reputation).sum();
        let mut rng = rand::thread_rng();
        let random_point = rng.gen::<f64>() * total_reputation;

        let mut cumulative_reputation = 0.0;
        for validator in &validators {
            cumulative_reputation += validator.reputation;
            if cumulative_reputation > random_point {
                return Ok(validator);
            }
        }

        // This should never happen, but we'll return the last validator if it does
        Ok(validators.last().unwrap())
    }

    pub fn start(&self) -> IcnResult<()> {
        info!("PoC Consensus mechanism started");
        Ok(())
    }

    pub fn stop(&self) -> IcnResult<()> {
        info!("PoC Consensus mechanism stopped");
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add_and_remove_member() {
        let mut consensus = PoCConsensus::new(0.66, 0.51).unwrap();
        assert!(consensus.add_member("Alice".to_string(), true).is_ok());
        assert!(consensus.add_member("Bob".to_string(), false).is_ok());
        assert_eq!(consensus.members.len(), 2);
        assert!(consensus.remove_member("Alice").is_ok());
        assert_eq!(consensus.members.len(), 1);
        assert!(consensus.remove_member("Charlie").is_err());
    }

    #[test]
    fn test_update_reputation() {
        let mut consensus = PoCConsensus::new(0.66, 0.51).unwrap();
        consensus.add_member("Alice".to_string(), true).unwrap();
        assert!(consensus.update_reputation("Alice", 0.5).is_ok());
        assert_eq!(consensus.members.get("Alice").unwrap().reputation, 1.5);
        assert!(consensus.update_reputation("Bob", 1.0).is_err());
    }

    #[test]
    fn test_reach_consensus() {
        let mut consensus = PoCConsensus::new(0.66, 0.51).unwrap();
        consensus.add_member("Alice".to_string(), true).unwrap();
        consensus.add_member("Bob".to_string(), true).unwrap();
        consensus.add_member("Charlie".to_string(), true).unwrap();

        let block = Block {
            index: 1,
            timestamp: chrono::Utc::now().timestamp(),
            transactions: vec![Transaction::new(
                "Alice".to_string(),
                "Bob".to_string(),
                100.0,
                CurrencyType::BasicNeeds,
                1000,
            )],
            previous_hash: "previous_hash".to_string(),
            hash: "hash".to_string(),
        };

        let votes = vec![
            ("Alice", true),
            ("Bob", true),
            ("Charlie", false),
        ];

        assert!(consensus.reach_consensus(&block, &votes).unwrap());

        let insufficient_votes = vec![
            ("Alice", true),
            ("Bob", true),
        ];

        assert!(consensus.reach_consensus(&block, &insufficient_votes).is_err());
    }

    #[test]
    fn test_select_proposer() {
        let mut consensus = PoCConsensus::new(0.66, 0.51).unwrap();
        consensus.add_member("Alice".to_string(), true).unwrap();
        consensus.add_member("Bob".to_string(), true).unwrap();
        consensus.add_member("Charlie".to_string(), false).unwrap();

        let proposer = consensus.select_proposer().unwrap();
        assert!(proposer.is_validator);
        assert!(proposer.id == "Alice" || proposer.id == "Bob");

        // Test when there are no validators
        let mut consensus_no_validators = PoCConsensus::new(0.66, 0.51).unwrap();
        consensus_no_validators.add_member("Dave".to_string(), false).unwrap();
        assert!(consensus_no_validators.select_proposer().is_err());
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_consensus/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_consensus/src/proof_of_cooperation.rs =====
use icn_utils::{error::IcnError, IcnResult};
use sha2::{Sha256, Digest};
use serde::{Serialize, Deserialize};
use chrono::Utc;

#[derive(Debug, Serialize, Deserialize)]
pub struct ProofOfCooperation {
    pub blocks: Vec<Block>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Block {
    pub index: u64,
    pub previous_hash: String,
    pub timestamp: u64,
    pub data: String,
    pub hash: String,
}

impl Block {
    pub fn new(index: u64, previous_hash: String, timestamp: u64, data: String) -> Self {
        let mut block = Block {
            index,
            previous_hash,
            timestamp,
            data,
            hash: String::new(),
        };
        block.hash = block.calculate_hash();
        block
    }

    pub fn calculate_hash(&self) -> String {
        let input = format!("{}{}{}{}", self.index, self.previous_hash, self.timestamp, self.data);
        let mut hasher = Sha256::new();
        hasher.update(input.as_bytes());
        format!("{:x}", hasher.finalize())
    }
}

impl ProofOfCooperation {
    pub fn new() -> Self {
        ProofOfCooperation {
            blocks: Vec::new(),
        }
    }

    pub fn add_block(&mut self, data: String) -> IcnResult<()> {
        let previous_hash = if let Some(last_block) = self.blocks.last() {
            last_block.hash.clone()
        } else {
            String::new()
        };

        let new_block = Block::new(
            self.blocks.len() as u64,
            previous_hash,
            Utc::now().timestamp_millis() as u64,
            data,
        );

        self.blocks.push(new_block);
        Ok(())
    }

    pub fn validate_chain(&self) -> IcnResult<()> {
        for i in 1..self.blocks.len() {
            let previous_block = &self.blocks[i - 1];
            let current_block = &self.blocks[i];

            if current_block.previous_hash != previous_block.hash {
                return Err(IcnError::Blockchain("Invalid previous hash".to_string()));
            }

            if current_block.hash != current_block.calculate_hash() {
                return Err(IcnError::Blockchain("Invalid block hash".to_string()));
            }
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add_and_validate_blocks() {
        let mut poc = ProofOfCooperation::new();
        
        poc.add_block("Block 1 Data".to_string()).unwrap();
        poc.add_block("Block 2 Data".to_string()).unwrap();

        assert_eq!(poc.blocks.len(), 2);
        assert!(poc.validate_chain().is_ok());

        // Tamper with a block
        poc.blocks[1].data = "Tampered Data".to_string();
        assert!(poc.validate_chain().is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_consensus/src/proof_of_cooperation.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/Cargo.toml =====
[package]
name = "icn_core"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
icn_blockchain = { path = "../icn_blockchain" }
icn_consensus = { path = "../icn_consensus" }
icn_currency = { path = "../icn_currency" }
icn_governance = { path = "../icn_governance" }
icn_identity = { path = "../icn_identity" }
icn_network = { path = "../icn_network" }
icn_sharding = { path = "../icn_sharding" }
icn_vm = { path = "../icn_vm" }
tokio = { version = "1.0", features = ["full"] }
log = "0.4"
thiserror = "1.0"
chrono = { version = "0.4", features = ["serde"] }

[dev-dependencies]
tokio-test = "0.4"===== END OF /home/matt/InterCooperative-Network/crates/icn_core/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/src/config.rs =====
// icn_core/src/config.rs

use serde::{Deserialize, Serialize};
use serde_json;
use std::fs;
use icn_types::{IcnResult, IcnError};

#[derive(Debug, Serialize, Deserialize)]
pub struct Config {
    pub shard_count: u64,
    pub consensus_threshold: f64,
    pub consensus_quorum: f64,
    pub network_port: u16,
}

impl Config {
    pub fn load(path: &str) -> IcnResult<Self> {
        let config_str = fs::read_to_string(path).map_err(|e| IcnError::ConfigError(e.to_string()))?;
        let config: Config = serde_json::from_str(&config_str).map_err(|e| IcnError::ConfigError(e.to_string()))?;
        Ok(config)
    }

    pub fn save(&self, path: &str) -> IcnResult<()> {
        let config_str = serde_json::to_string_pretty(self).map_err(|e| IcnError::ConfigError(e.to_string()))?;
        fs::write(path, config_str).map_err(|e| IcnError::ConfigError(e.to_string()))?;
        Ok(())
    }
}

impl Default for Config {
    fn default() -> Self {
        Config {
            shard_count: 4,
            consensus_threshold: 0.66,
            consensus_quorum: 0.51,
            network_port: 8080,
        }
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_core/src/config.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/src/error.rs =====
use thiserror::Error;

#[derive(Error, Debug)]
pub enum Error {
    #[error("Blockchain error: {0}")]
    BlockchainError(String),
    
    #[error("Consensus error: {0}")]
    ConsensusError(String),
    
    #[error("Sharding error: {0}")]
    ShardingError(String),
    
    #[error("VM error: {0}")]
    VmError(String),
    
    #[error("Network error: {0}")]
    NetworkError(String),
    
    #[error("Smart contract error: {0}")]
    SmartContractError(String),
    
    #[error("I/O error: {0}")]
    IoError(#[from] std::io::Error),

    #[error("Lock error: {0}")]
    LockError(String),

    #[error("Communication error: {0}")]
    CommunicationError(String),

    #[error("Transaction failed: {0}")]
    TransactionFailed(String),

    #[error("Timeout: {0}")]
    Timeout(String),

    #[error("Currency error: {0}")]
    CurrencyError(String),

    #[error("Identity error: {0}")]
    IdentityError(String),

    #[error("Governance error: {0}")]
    GovernanceError(String),
}

pub type Result<T> = std::result::Result<T, Error>;===== END OF /home/matt/InterCooperative-Network/crates/icn_core/src/error.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/src/lib.rs =====
use icn_blockchain::Blockchain;
use icn_consensus::PoCConsensus;
use icn_currency::CurrencySystem;
use icn_governance::GovernanceSystem;
use icn_identity::IdentityManager;
use icn_network::Network;
use icn_sharding::ShardingManager;
use icn_storage::StorageManager;
use icn_vm::CoopVM;
use icn_zkp::ZKPManager;

use icn_common::{Block, Transaction, Proposal, IcnResult, IcnError, CurrencyType};
use std::sync::{Arc, RwLock};
use tokio::sync::Mutex as AsyncMutex;

/// Configuration for the ICN Node
pub struct Config {
    pub shard_count: u64,
    pub consensus_threshold: f64,
    pub consensus_quorum: f64,
    pub network_port: u16,
}

/// The main struct representing an InterCooperative Network node
pub struct IcnNode {
    blockchain: Arc<RwLock<Blockchain>>,
    consensus: Arc<RwLock<PoCConsensus>>,
    currency_system: Arc<RwLock<CurrencySystem>>,
    governance: Arc<RwLock<GovernanceSystem>>,
    identity_manager: Arc<RwLock<IdentityManager>>,
    network: Arc<AsyncMutex<Network>>,
    sharding_manager: Arc<RwLock<ShardingManager>>,
    storage_manager: Arc<RwLock<StorageManager>>,
    vm: Arc<RwLock<CoopVM>>,
    zkp_manager: Arc<RwLock<ZKPManager>>,
}

impl IcnNode {
    /// Create a new ICN Node with the given configuration
    pub fn new(config: Config) -> IcnResult<Self> {
        let blockchain = Arc::new(RwLock::new(Blockchain::new()?));
        let consensus = Arc::new(RwLock::new(PoCConsensus::new(config.consensus_threshold, config.consensus_quorum)?));
        let currency_system = Arc::new(RwLock::new(CurrencySystem::new()));
        let governance = Arc::new(RwLock::new(GovernanceSystem::new(
            Arc::clone(&blockchain),
            Arc::clone(&consensus),
        )));
        let identity_manager = Arc::new(RwLock::new(IdentityManager::new()));
        let network = Arc::new(AsyncMutex::new(Network::new(format!("127.0.0.1:{}", config.network_port).parse().map_err(|e| IcnError::Network(e.to_string()))?)));
        let sharding_manager = Arc::new(RwLock::new(ShardingManager::new(config.shard_count)));
        let storage_manager = Arc::new(RwLock::new(StorageManager::new(3))); // Replication factor of 3
        let vm = Arc::new(RwLock::new(CoopVM::new(Vec::new()))); // Empty program for now
        let zkp_manager = Arc::new(RwLock::new(ZKPManager::new()?));

        Ok(IcnNode {
            blockchain,
            consensus,
            currency_system,
            governance,
            identity_manager,
            network,
            sharding_manager,
            storage_manager,
            vm,
            zkp_manager,
        })
    }

    /// Start the ICN Node
    pub async fn start(&self) -> IcnResult<()> {
        // Start all components
        self.blockchain.read().unwrap().start()?;
        self.consensus.read().unwrap().start()?;
        self.network.lock().await.start().await?;
        
        // Start listening for network events
        self.listen_for_network_events();

        Ok(())
    }

    /// Stop the ICN Node
    pub async fn stop(&self) -> IcnResult<()> {
        // Stop all components
        self.blockchain.read().unwrap().stop()?;
        self.consensus.read().unwrap().stop()?;
        self.network.lock().await.stop().await?;

        Ok(())
    }

    /// Process a new transaction
    pub async fn process_transaction(&self, transaction: Transaction) -> IcnResult<()> {
        // Verify the transaction
        self.verify_transaction(&transaction)?;

        // If it's a cross-shard transaction, handle it accordingly
        let from_shard = self.sharding_manager.read().unwrap().get_shard_for_address(&transaction.from);
        let to_shard = self.sharding_manager.read().unwrap().get_shard_for_address(&transaction.to);

        if from_shard != to_shard {
            self.process_cross_shard_transaction(transaction, from_shard, to_shard).await?;
        } else {
            // Add the transaction to the blockchain
            self.blockchain.write().unwrap().add_transaction(transaction)?;
        }

        Ok(())
    }

    /// Verify a transaction
    fn verify_transaction(&self, transaction: &Transaction) -> IcnResult<()> {
        // Check if the sender has sufficient balance
        let balance = self.get_balance(&transaction.from, &transaction.currency_type)?;
        if balance < transaction.amount {
            return Err(IcnError::InsufficientFunds);
        }

        // Verify the transaction signature
        if !transaction.verify()? {
            return Err(IcnError::InvalidSignature);
        }

        Ok(())
    }

    /// Process a cross-shard transaction
    async fn process_cross_shard_transaction(&self, transaction: Transaction, from_shard: u64, to_shard: u64) -> IcnResult<()> {
        // Lock funds in the source shard
        self.sharding_manager.write().unwrap().lock_funds(from_shard, &transaction.from, transaction.amount)?;

        // Create a cross-shard transaction record
        let cross_shard_tx = self.sharding_manager.write().unwrap().create_cross_shard_transaction(transaction.clone(), from_shard, to_shard)?;

        // Broadcast the cross-shard transaction to the network
        self.network.lock().await.broadcast_cross_shard_transaction(cross_shard_tx).await?;

        Ok(())
    }

    /// Create a new proposal
    pub fn create_proposal(&self, proposal: Proposal) -> IcnResult<String> {
        self.governance.write().unwrap().create_proposal(proposal)
    }

    /// Vote on a proposal
    pub fn vote_on_proposal(&self, proposal_id: &str, voter: &str, vote: bool) -> IcnResult<()> {
        self.governance.write().unwrap().vote_on_proposal(proposal_id, voter, vote)
    }

   /// Get the balance of an address
   pub fn get_balance(&self, address: &str, currency_type: &CurrencyType) -> IcnResult<f64> {
    self.currency_system.read().unwrap().get_balance(address, currency_type)
}

/// Create a new identity
pub fn create_identity(&self, attributes: std::collections::HashMap<String, String>) -> IcnResult<DecentralizedIdentity> {
    self.identity_manager.write().unwrap().create_identity(attributes)
}

/// Allocate a resource
pub fn allocate_resource(&self, resource_id: &str, amount: u64) -> IcnResult<()> {
    // In a real implementation, this would interact with a resource management system
    // For now, we'll just log the allocation
    log::info!("Allocating {} units of resource {}", amount, resource_id);
    Ok(())
}

/// Get network statistics
pub async fn get_network_stats(&self) -> IcnResult<NetworkStats> {
    let network = self.network.lock().await;
    Ok(NetworkStats {
        connected_peers: network.get_connected_peers().len() as u32,
        total_transactions: self.blockchain.read().unwrap().get_total_transactions(),
        uptime: network.get_uptime(),
    })
}

/// Execute a smart contract
pub fn execute_smart_contract(&self, contract: &str) -> IcnResult<Value> {
    let mut vm = self.vm.write().unwrap();
    let compiled_contract = vm.compile(contract)?;
    vm.execute(&compiled_contract)
}

/// Create a zero-knowledge proof
pub fn create_zkproof(&self, statement: &str, witness: &[u8]) -> IcnResult<ZKProof> {
    self.zkp_manager.read().unwrap().create_proof(statement, witness)
}

/// Verify a zero-knowledge proof
pub fn verify_zkproof(&self, proof: &ZKProof, statement: &str) -> IcnResult<bool> {
    self.zkp_manager.read().unwrap().verify_proof(proof, statement)
}

/// Listen for network events
fn listen_for_network_events(&self) {
    let blockchain = Arc::clone(&self.blockchain);
    let consensus = Arc::clone(&self.consensus);
    let network = Arc::clone(&self.network);

    tokio::spawn(async move {
        loop {
            let event = network.lock().await.receive_event().await;
            match event {
                NetworkEvent::NewTransaction(transaction) => {
                    if let Err(e) = blockchain.write().unwrap().add_transaction(transaction) {
                        log::error!("Failed to add transaction: {:?}", e);
                    }
                }
                NetworkEvent::NewBlock(block) => {
                    if let Err(e) = consensus.write().unwrap().process_new_block(block) {
                        log::error!("Failed to process new block: {:?}", e);
                    }
                }
                NetworkEvent::ConsensusMessage(message) => {
                    if let Err(e) = consensus.write().unwrap().handle_consensus_message(message) {
                        log::error!("Failed to handle consensus message: {:?}", e);
                    }
                }
                NetworkEvent::PeerConnected(peer_id) => {
                    log::info!("New peer connected: {:?}", peer_id);
                }
                NetworkEvent::PeerDisconnected(peer_id) => {
                    log::info!("Peer disconnected: {:?}", peer_id);
                }
            }
        }
    });
}
}

/// Network statistics
pub struct NetworkStats {
pub connected_peers: u32,
pub total_transactions: u64,
pub uptime: std::time::Duration,
}

/// Network events
enum NetworkEvent {
NewTransaction(Transaction),
NewBlock(Block),
ConsensusMessage(ConsensusMessage),
PeerConnected(String),
PeerDisconnected(String),
}

/// Consensus messages
enum ConsensusMessage {
// Define consensus message types here
// For example: Proposal, Vote, Commit, etc.
}

/// Value returned by smart contract execution
pub enum Value {
Int(i64),
Float(f64),
Bool(bool),
String(String),
List(Vec<Value>),
}

/// Zero-knowledge proof
pub struct ZKProof {
// Define ZKProof structure here
}

#[cfg(test)]
mod tests {
use super::*;

#[tokio::test]
async fn test_icn_node() {
    let config = Config {
        shard_count: 4,
        consensus_threshold: 0.66,
        consensus_quorum: 0.51,
        network_port: 8080,
    };

    let node = IcnNode::new(config).unwrap();
    
    // Test starting and stopping the node
    assert!(node.start().await.is_ok());
    assert!(node.stop().await.is_ok());

    // Test creating a new identity
    let mut attributes = std::collections::HashMap::new();
    attributes.insert("name".to_string(), "Alice".to_string());
    let identity = node.create_identity(attributes).unwrap();
    assert_eq!(identity.attributes.get("name"), Some(&"Alice".to_string()));

    // Test processing a transaction
    let transaction = Transaction {
        from: "Alice".to_string(),
        to: "Bob".to_string(),
        amount: 100.0,
        currency_type: CurrencyType::BasicNeeds,
        timestamp: chrono::Utc::now().timestamp(),
        signature: None, // In a real scenario, this should be properly signed
    };
    assert!(node.process_transaction(transaction).await.is_ok());

    // Test creating a proposal
    let proposal = Proposal {
        id: "proposal1".to_string(),
        title: "Test Proposal".to_string(),
        description: "This is a test proposal".to_string(),
        proposer: "Alice".to_string(),
        created_at: chrono::Utc::now(),
        voting_ends_at: chrono::Utc::now() + chrono::Duration::days(7),
        status: ProposalStatus::Active,
        proposal_type: ProposalType::Constitutional,
        category: ProposalCategory::Economic,
        required_quorum: 0.66,
        execution_timestamp: None,
    };
    let proposal_id = node.create_proposal(proposal).unwrap();
    assert!(!proposal_id.is_empty());

    // Test voting on a proposal
    assert!(node.vote_on_proposal(&proposal_id, "Alice", true).is_ok());

    // Test getting network stats
    let stats = node.get_network_stats().await.unwrap();
    assert_eq!(stats.connected_peers, 0); // No peers in test environment
    assert_eq!(stats.total_transactions, 1);

    // Test executing a smart contract
    let contract = "function add(a, b) { return a + b; }";
    let result = node.execute_smart_contract(contract).unwrap();
    assert!(matches!(result, Value::Int(_)));

    // Test creating and verifying a ZK proof
    let statement = "I know the factors of N";
    let witness = &[1, 2, 3, 4]; // Some dummy witness data
    let proof = node.create_zkproof(statement, witness).unwrap();
    assert!(node.verify_zkproof(&proof, statement).unwrap());

    // Test allocating a resource
    assert!(node.allocate_resource("computing_power", 100).is_ok());

    // Test getting balance
    let balance = node.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap();
    assert!(balance >= 0.0);

    // Test cross-shard transaction
    node.sharding_manager.write().unwrap().add_address_to_shard("Alice".to_string(), 0).unwrap();
    node.sharding_manager.write().unwrap().add_address_to_shard("Bob".to_string(), 1).unwrap();
    let cross_shard_tx = Transaction {
        from: "Alice".to_string(),
        to: "Bob".to_string(),
        amount: 50.0,
        currency_type: CurrencyType::BasicNeeds,
        timestamp: chrono::Utc::now().timestamp(),
        signature: None, // In a real scenario, this should be properly signed
    };
    assert!(node.process_transaction(cross_shard_tx).await.is_ok());

    // Test handling network events
    let blockchain = Arc::clone(&node.blockchain);
    let consensus = Arc::clone(&node.consensus);
    
    // Simulate receiving a new transaction
    let new_tx = Transaction {
        from: "Charlie".to_string(),
        to: "Dave".to_string(),
        amount: 25.0,
        currency_type: CurrencyType::Education,
        timestamp: chrono::Utc::now().timestamp(),
        signature: None,
    };
    blockchain.write().unwrap().add_transaction(new_tx.clone()).unwrap();
    
    // Simulate receiving a new block
    let new_block = Block {
        index: blockchain.read().unwrap().chain().len() as u64,
        timestamp: chrono::Utc::now().timestamp(),
        transactions: vec![new_tx],
        previous_hash: "previous_hash".to_string(),
        hash: "new_block_hash".to_string(),
    };
    consensus.write().unwrap().process_new_block(new_block.clone()).unwrap();

    // Verify that the new block was added to the blockchain
    assert_eq!(blockchain.read().unwrap().chain().last().unwrap().hash, new_block.hash);

    // Test handling consensus messages
    let consensus_message = ConsensusMessage::Proposal(new_block.clone());
    consensus.write().unwrap().handle_consensus_message(consensus_message).unwrap();

    // Test peer connection events
    let peer_id = "peer1".to_string();
    node.network.lock().await.add_peer(peer_id.clone()).await.unwrap();
    assert!(node.network.lock().await.get_connected_peers().contains(&peer_id));

    // Test peer disconnection
    node.network.lock().await.remove_peer(&peer_id).await.unwrap();
    assert!(!node.network.lock().await.get_connected_peers().contains(&peer_id));
}

#[tokio::test]
async fn test_concurrent_transactions() {
    let config = Config {
        shard_count: 4,
        consensus_threshold: 0.66,
        consensus_quorum: 0.51,
        network_port: 8081,
    };

    let node = Arc::new(IcnNode::new(config).unwrap());
    node.start().await.unwrap();

    let mut handles = vec![];

    for i in 0..100 {
        let node_clone = Arc::clone(&node);
        let handle = tokio::spawn(async move {
            let tx = Transaction {
                from: format!("User{}", i),
                to: format!("User{}", (i + 1) % 100),
                amount: 1.0,
                currency_type: CurrencyType::BasicNeeds,
                timestamp: chrono::Utc::now().timestamp(),
                signature: None,
            };
            node_clone.process_transaction(tx).await.unwrap();
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.await.unwrap();
    }

    let total_transactions = node.blockchain.read().unwrap().get_total_transactions();
    assert_eq!(total_transactions, 100);

    node.stop().await.unwrap();
}

#[tokio::test]
async fn test_governance_workflow() {
    let config = Config {
        shard_count: 4,
        consensus_threshold: 0.66,
        consensus_quorum: 0.51,
        network_port: 8082,
    };

    let node = IcnNode::new(config).unwrap();
    node.start().await.unwrap();

    // Create a proposal
    let proposal = Proposal {
        id: "gov_proposal1".to_string(),
        title: "Increase Education Currency Supply".to_string(),
        description: "Proposal to increase the supply of Education currency by 10%".to_string(),
        proposer: "Alice".to_string(),
        created_at: chrono::Utc::now(),
        voting_ends_at: chrono::Utc::now() + chrono::Duration::days(7),
        status: ProposalStatus::Active,
        proposal_type: ProposalType::EconomicAdjustment,
        category: ProposalCategory::Economic,
        required_quorum: 0.75,
        execution_timestamp: None,
    };

    let proposal_id = node.create_proposal(proposal).unwrap();

    // Simulate voting
    for i in 0..10 {
        let voter = format!("Voter{}", i);
        let vote = i % 2 == 0; // Alternating yes/no votes
        node.vote_on_proposal(&proposal_id, &voter, vote).unwrap();
    }

    // Fast-forward time to end of voting period
    // In a real scenario, you'd use a time mocking library
    node.governance.write().unwrap().update_proposal_status(&proposal_id).unwrap();

    // Check proposal status
    let final_status = node.governance.read().unwrap().get_proposal_status(&proposal_id).unwrap();
    assert_eq!(final_status, ProposalStatus::Passed);

    // Execute the proposal
    node.governance.write().unwrap().execute_proposal(&proposal_id).unwrap();

    // Verify the outcome (in this case, check if Education currency supply increased)
    let education_supply = node.currency_system.read().unwrap().get_total_supply(&CurrencyType::Education).unwrap();
    assert!(education_supply > 0.0); // Assuming initial supply was 0

    node.stop().await.unwrap();
}
}===== END OF /home/matt/InterCooperative-Network/crates/icn_core/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/src/logging/mod.rs =====
use log::{info, warn, error, debug};

pub fn log_info(message: &str) {
    info!("{}", message);
}

pub fn log_warn(message: &str) {
    warn!("{}", message);
}

pub fn log_error(message: &str) {
    error!("{}", message);
}

pub fn log_debug(message: &str) {
    debug!("{}", message);
}===== END OF /home/matt/InterCooperative-Network/crates/icn_core/src/logging/mod.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/src/main.rs =====
// icn_core/src/main.rs

use icn_core::{IcnNode, Config};
use icn_types::{IcnResult, IcnError, Transaction, Proposal, ProposalType, ProposalCategory, CurrencyType, ProposalStatus};
use std::io::{self, Write};
use chrono::{Duration, Utc};
use log::{info, warn, error};
use uuid::Uuid;

fn main() -> IcnResult<()> {
    env_logger::init();

    let config = Config::load("config.json").unwrap_or_else(|_| {
        warn!("Failed to load config.json, using default configuration");
        Config::default()
    });

    info!("Starting InterCooperative Network node...");
    let node = IcnNode::new(config)?;
    node.start()?;

    info!("Node started successfully. Type 'help' for available commands.");

    loop {
        print!("> ");
        io::stdout().flush().unwrap();

        let mut input = String::new();
        io::stdin().read_line(&mut input).unwrap();
        let input = input.trim();

        match input {
            "help" => print_help(),
            "exit" => break,
            "transaction" => process_transaction(&node)?,
            "proposal" => create_proposal(&node)?,
            "balance" => check_balance(&node)?,
            _ => println!("Unknown command. Type 'help' for available commands."),
        }
    }

    info!("Stopping node...");
    node.stop()?;
    info!("Node stopped. Goodbye!");

    Ok(())
}

fn print_help() {
    println!("Available commands:");
    println!("  help        - Show this help message");
    println!("  transaction - Create a new transaction");
    println!("  proposal    - Create a new proposal");
    println!("  balance     - Check account balance");
    println!("  exit        - Exit the application");
}

fn process_transaction(node: &IcnNode) -> IcnResult<()> {
    info!("Processing a new transaction");
    
    print!("From: ");
    io::stdout().flush().unwrap();
    let mut from = String::new();
    io::stdin().read_line(&mut from).unwrap();
    
    print!("To: ");
    io::stdout().flush().unwrap();
    let mut to = String::new();
    io::stdin().read_line(&mut to).unwrap();
    
    print!("Amount: ");
    io::stdout().flush().unwrap();
    let mut amount_str = String::new();
    io::stdin().read_line(&mut amount_str).unwrap();
    let amount: f64 = amount_str.trim().parse().map_err(|_| IcnError::InvalidInput("Invalid amount".to_string()))?;

    let transaction = Transaction {
        from: from.trim().to_string(),
        to: to.trim().to_string(),
        amount,
        currency_type: CurrencyType::BasicNeeds,
        timestamp: Utc::now().timestamp(),
        signature: None,
    };

    node.process_transaction(transaction)?;
    info!("Transaction processed successfully");
    Ok(())
}

fn create_proposal(node: &IcnNode) -> IcnResult<()> {
    info!("Creating a new proposal");
    
    print!("Title: ");
    io::stdout().flush().unwrap();
    let mut title = String::new();
    io::stdin().read_line(&mut title).unwrap();
    
    print!("Description: ");
    io::stdout().flush().unwrap();
    let mut description = String::new();
    io::stdin().read_line(&mut description).unwrap();
    
    print!("Proposer: ");
    io::stdout().flush().unwrap();
    let mut proposer = String::new();
    io::stdin().read_line(&mut proposer).unwrap();

    let proposal = Proposal {
        id: Uuid::new_v4().to_string(),
        title: title.trim().to_string(),
        description: description.trim().to_string(),
        proposer: proposer.trim().to_string(),
        created_at: Utc::now(),
        voting_ends_at: Utc::now() + Duration::days(7),
        status: ProposalStatus::Active,
        proposal_type: ProposalType::Constitutional,
        category: ProposalCategory::Economic,
        required_quorum: 0.66,
        execution_timestamp: None,
    };

    node.create_proposal(proposal)?;
    info!("Proposal created successfully");
    Ok(())
}

fn check_balance(node: &IcnNode) -> IcnResult<()> {
    info!("Checking balance");
    
    print!("Address: ");
    io::stdout().flush().unwrap();
    let mut address = String::new();
    io::stdin().read_line(&mut address).unwrap();
    
    let balance = node.get_balance(address.trim(), &CurrencyType::BasicNeeds)?;
    println!("Balance: {}", balance);
    Ok(())
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_core/src/main.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/src/security/mod.rs =====
use crate::error::Result;
use ed25519_dalek::{Keypair, PublicKey, Signature, Verifier};

pub struct SecurityManager {
    // Add fields as needed
}

impl SecurityManager {
    pub fn new() -> Self {
        SecurityManager {
            // Initialize fields
        }
    }

    pub fn verify_signature(&self, public_key: &PublicKey, message: &[u8], signature: &Signature) -> Result<bool> {
        Ok(public_key.verify(message, signature).is_ok())
    }

    pub fn generate_keypair() -> Keypair {
        Keypair::generate(&mut rand::thread_rng())
    }

    // Add more security-related methods as needed
}===== END OF /home/matt/InterCooperative-Network/crates/icn_core/src/security/mod.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/tests/blockchain_and_consensus_tests.rs =====
// Filename: src/tests/blockchain_and_consensus_tests.rs

use crate::blockchain::{Blockchain, Transaction};
use crate::currency::CurrencyType;
use crate::consensus::Consensus;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_blockchain_creation() {
        let blockchain = Blockchain::new();
        assert_eq!(blockchain.chain.len(), 1, "Blockchain should be initialized with one genesis block");
        assert_eq!(blockchain.chain[0].index, 0, "Genesis block should have index 0");
    }

    #[test]
    fn test_block_creation() {
        let mut blockchain = Blockchain::new();
        blockchain.consensus.add_member("Alice".to_string());
        let transactions = vec![
            Transaction::new("Alice".to_string(), "Bob".to_string(), 100.0, CurrencyType::BasicNeeds, 1000),
            Transaction::new("Bob".to_string(), "Charlie".to_string(), 50.0, CurrencyType::Education, 1000),
        ];
        let result = blockchain.create_block("Alice".to_string());
        assert!(result.is_ok(), "Block creation failed: {:?}", result.err());
        assert_eq!(blockchain.chain.len(), 2, "Blockchain should have two blocks after creation");
    }

    #[test]
    fn test_reputation_update() {
        let mut blockchain = Blockchain::new();
        blockchain.consensus.add_member("Alice".to_string());
        blockchain.consensus.update_reputation("Alice", 0.5);
        assert_eq!(blockchain.consensus.get_reputation("Alice"), Some(1.5), 
                   "Alice's reputation should be updated to 1.5");
    }

    #[test]
    fn test_voting() {
        let mut blockchain = Blockchain::new();
        blockchain.consensus.add_member("Alice".to_string());
        blockchain.consensus.add_member("Bob".to_string());
        blockchain.consensus.add_member("Charlie".to_string());
        
        let transactions = vec![
            Transaction::new("Alice".to_string(), "Bob".to_string(), 100.0, CurrencyType::BasicNeeds, 1000),
        ];
        blockchain.create_block("Alice".to_string()).expect("Block creation should succeed");
        
        assert!(blockchain.vote_on_block("Alice", 1, true).is_ok(), "Alice should be able to vote");
        assert!(blockchain.vote_on_block("Bob", 1, true).is_ok(), "Bob should be able to vote");
        assert!(blockchain.vote_on_block("Charlie", 1, true).is_ok(), "Charlie should be able to vote");
        
        assert!(blockchain.consensus.is_block_valid(1), "Block should be valid after voting");
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_core/tests/blockchain_and_consensus_tests.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/tests/blockchain_tests.rs =====
// Filename: src/tests/blockchain_tests.rs

use crate::blockchain::{Blockchain, Transaction};
use crate::currency::CurrencyType;

#[test]
fn test_blockchain_creation() {
    let blockchain = Blockchain::new();
    assert_eq!(blockchain.chain.len(), 1);
    assert_eq!(blockchain.chain[0].index, 0);
}

#[test]
fn test_add_block() {
    let mut blockchain = Blockchain::new();
    let transaction = Transaction::new(
        "Alice".to_string(),
        "Bob".to_string(),
        100.0,
        CurrencyType::BasicNeeds,
        1000,
    );
    blockchain.add_transaction(transaction);
    assert!(blockchain.create_block("Node1".to_string()).is_ok());
    assert_eq!(blockchain.chain.len(), 2);
}

#[test]
fn test_blockchain_validity() {
    let mut blockchain = Blockchain::new();
    let transaction = Transaction::new(
        "Alice".to_string(),
        "Bob".to_string(),
        100.0,
        CurrencyType::BasicNeeds,
        1000,
    );
    blockchain.add_transaction(transaction);
    assert!(blockchain.create_block("Node1".to_string()).is_ok());
    assert!(blockchain.is_chain_valid());
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_core/tests/blockchain_tests.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/tests/icn_node_tests.rs =====
// Filename: src/tests/icn_node_tests.rs

// Import necessary modules and types
use crate::icn_node::{IcnNode, Packet, PacketType};
use std::net::SocketAddr;

#[test]
fn test_fib_functionality() {
    let mut node = IcnNode::new();
    let addr1: SocketAddr = "127.0.0.1:8000".parse().unwrap();
    let addr2: SocketAddr = "127.0.0.1:8001".parse().unwrap();

    node.fib.add_entry("/example/path".to_string(), addr1);
    node.fib.add_entry("/example/path".to_string(), addr2);

    let next_hops = node.fib.get_next_hops("/example/path");
    assert!(next_hops.is_some());
    assert_eq!(next_hops.unwrap().len(), 2);
    assert!(next_hops.unwrap().contains(&addr1));
    assert!(next_hops.unwrap().contains(&addr2));

    let longest_match = node.fib.longest_prefix_match("/example/path/subpath");
    assert!(longest_match.is_some());
    assert_eq!(longest_match.unwrap().name, "/example/path");
}

#[test]
fn test_content_store() {
    let mut node = IcnNode::new();
    let packet = Packet {
        packet_type: PacketType::Data,
        name: "/test/data".to_string(),
        content: vec![1, 2, 3, 4],
    };

    node.content_store.add(packet.name.clone(), packet.clone());
    let retrieved = node.content_store.get(&packet.name);
    assert!(retrieved.is_some());
    assert_eq!(retrieved.unwrap().content, vec![1, 2, 3, 4]);
}

#[test]
fn test_packet_processing() {
    let mut node = IcnNode::new();
    let addr: SocketAddr = "127.0.0.1:8000".parse().unwrap();
    node.add_interface("eth0".to_string(), addr);
    node.fib.add_entry("/test".to_string(), addr);

    let interest_packet = Packet {
        packet_type: PacketType::Interest,
        name: "/test/data".to_string(),
        content: vec![],
    };

    node.process_packet(interest_packet.clone(), "eth0");
    assert!(node.pit.has_pending_interest(&interest_packet.name));

    let data_packet = Packet {
        packet_type: PacketType::Data,
        name: "/test/data".to_string(),
        content: vec![1, 2, 3, 4],
    };

    node.process_packet(data_packet.clone(), "eth0");
    assert!(!node.pit.has_pending_interest(&data_packet.name));
    assert!(node.content_store.get(&data_packet.name).is_some());
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_core/tests/icn_node_tests.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/tests/integration_tests.rs =====
// icn_core/tests/integration_tests.rs

use icn_core::{IcnNode, Config};
use icn_common::{Transaction, Proposal, ProposalType, ProposalCategory, CurrencyType, ProposalStatus};
use chrono::Duration;
use log::info;
use uuid::Uuid;

#[cfg(test)]
mod tests {
    use super::*;

    fn setup() -> IcnResult<IcnNode> {
        let config = Config::default();
        let node = IcnNode::new(config)?;
        node.start()?;
        Ok(node)
    }

    fn teardown(node: &IcnNode) -> IcnResult<()> {
        node.stop()
    }

    #[test]
    fn test_node_initialization() {
        let config = Config::default();
        let node = IcnNode::new(config);
        assert!(node.is_ok());
    }

    #[test]
    fn test_node_start_stop() {
        let config = Config::default();
        let node = IcnNode::new(config).unwrap();
        assert!(node.start().is_ok());
        assert!(node.stop().is_ok());
    }

    #[test]
    fn test_process_transaction() {
        let config = Config::default();
        let node = IcnNode::new(config).unwrap();
        node.start().unwrap();

        let transaction = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 100.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: chrono::Utc::now().timestamp(),
            signature: None,
        };

        assert!(node.process_transaction(transaction).is_ok());
        node.stop().unwrap();
    }

    #[test]
    fn test_create_proposal() {
        let config = Config::default();
        let node = IcnNode::new(config).unwrap();
        node.start().unwrap();

        let proposal = Proposal {
            id: Uuid::new_v4().to_string(),
            title: "Test Proposal".to_string(),
            description: "This is a test proposal".to_string(),
            proposer: "Alice".to_string(),
            created_at: chrono::Utc::now(),
            voting_ends_at: chrono::Utc::now() + Duration::days(7),
            status: ProposalStatus::Active,
            proposal_type: ProposalType::Constitutional,
            category: ProposalCategory::Economic,
            required_quorum: 0.66,
            execution_timestamp: None,
        };

        assert!(node.create_proposal(proposal).is_ok());
        node.stop().unwrap();
    }

    #[test]
    fn test_get_balance() {
        let node = setup().unwrap();

        // First, we need to add some balance to an account
        let deposit_transaction = Transaction {
            from: "Genesis".to_string(),
            to: "Alice".to_string(),
            amount: 1000.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: chrono::Utc::now().timestamp(),
            signature: None,
        };

        node.process_transaction(deposit_transaction).unwrap();

        // Now, let's check the balance
        let balance = node.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap();
        assert_eq!(balance, 1000.0, "Balance should be 1000.0 after deposit");

        teardown(&node).unwrap();
    }

    #[test]
    fn test_cross_shard_transaction() {
        let node = setup().unwrap();

        // Assume Alice and Bob are on different shards
        // First, add balance to Alice's account
        let deposit_transaction = Transaction {
            from: "Genesis".to_string(),
            to: "Alice".to_string(),
            amount: 1000.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: chrono::Utc::now().timestamp(),
            signature: None,
        };

        node.process_transaction(deposit_transaction).unwrap();

        // Now, perform a cross-shard transaction from Alice to Bob
        let cross_shard_transaction = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 500.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: chrono::Utc::now().timestamp(),
            signature: None,
        };

        node.process_transaction(cross_shard_transaction).unwrap();

        // Check balances after the transaction
        let alice_balance = node.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap();
        let bob_balance = node.get_balance("Bob", &CurrencyType::BasicNeeds).unwrap();

        assert_eq!(alice_balance, 500.0, "Alice's balance should be 500.0 after transfer");
        assert_eq!(bob_balance, 500.0, "Bob's balance should be 500.0 after receiving transfer");

        teardown(&node).unwrap();
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_core/tests/integration_tests.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/tests/mod.rs =====
// ===============================================
// Tests Module
// ===============================================
// This module re-exports the contents of the tests submodules.
// The tests submodules contain various test cases to ensure
// the correctness and reliability of the blockchain implementation.

#[cfg(test)]
mod tests {
    use super::*;
    use crate::currency::CurrencyType;
    use ed25519_dalek::Keypair;
    use rand::rngs::OsRng;

    #[test]
    fn test_cross_shard_transaction() {
        let node = IcnNode::new();

        // Initialize balances
        {
            let mut sharding_manager = node.sharding_manager.write().unwrap();
            sharding_manager.add_address_to_shard("Alice".to_string(), 0);
            sharding_manager.add_address_to_shard("Bob".to_string(), 1);
            sharding_manager.initialize_balance("Alice".to_string(), CurrencyType::BasicNeeds, 1000.0);
        }

        let mut csprng = OsRng{};
        let keypair: Keypair = Keypair::generate(&mut csprng);

        let mut transaction = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            500.0,
            CurrencyType::BasicNeeds,
            1000,
        );
        if let Err(e) = transaction.sign(&keypair) {
            panic!("Failed to sign transaction: {}", e);
        }

        println!("Signed transaction: {:?}", transaction);

        assert!(node.process_cross_shard_transaction(&transaction).is_ok(), "Cross-shard transaction failed");

        // Check balances after transaction
        let sharding_manager = node.sharding_manager.read().unwrap();
        assert_eq!(sharding_manager.get_balance("Alice".to_string(), CurrencyType::BasicNeeds), 500.0);
        assert_eq!(sharding_manager.get_balance("Bob".to_string(), CurrencyType::BasicNeeds), 500.0);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_core/tests/mod.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/tests/smart_contract_tests.rs =====
// Filename: src/tests/smart_contract_tests.rs

use crate::blockchain::Blockchain;
use crate::smart_contract::{parse_contract, ContractType};

#[test]
fn test_smart_contract_integration() {
    let mut blockchain = Blockchain::new();

    // Deploy an asset transfer contract
    let contract_input = "Asset Transfer
Creator: Alice
From: Alice
To: Bob
Asset: ICN_TOKEN
Amount: 100.0";

    let contract = parse_contract(contract_input).unwrap();
    blockchain.deploy_smart_contract(contract).unwrap();

    // Deploy a proposal contract
    let proposal_input = "Proposal
Creator: Charlie
Title: New Community Project
Description: Implement a recycling program
Voting Period: 604800
Option 1: Approve
Option 2: Reject
Quorum: 0.5";

    let proposal_contract = parse_contract(proposal_input).unwrap();
    blockchain.deploy_smart_contract(proposal_contract).unwrap();

    // Execute smart contracts
    blockchain.execute_smart_contracts().unwrap();

    // Verify blockchain state
    assert_eq!(blockchain.chain.len(), 2); // Genesis block + 1 block with contracts
    assert_eq!(blockchain.chain.last().unwrap().smart_contracts.len(), 2);

    // Verify contract execution results
    let env = &blockchain.execution_environment;
    assert_eq!(env.balances.get("Bob").unwrap().get("ICN_TOKEN").unwrap(), &100.0);
    assert!(env.votes.contains_key(&blockchain.chain.last().unwrap().smart_contracts[1].id));
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_core/tests/smart_contract_tests.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_currency/Cargo.toml =====
[package]
name = "icn_currency"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
serde = { version = "1.0", features = ["derive"] }
log = "0.4"
thiserror = "1.0"
chrono = { version = "0.4", features = ["serde"] }

[dev-dependencies]
tokio = { version = "1.0", features = ["full"] }===== END OF /home/matt/InterCooperative-Network/crates/icn_currency/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_currency/src/asset_token.rs =====
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct AssetToken {
    pub asset_id: String,
    pub name: String,
    pub description: String,
    pub owner: String,
    pub value: f64,
}

impl AssetToken {
    pub fn new(asset_id: String, name: String, description: String, owner: String, value: f64) -> Self {
        AssetToken {
            asset_id,
            name,
            description,
            owner,
            value,
        }
    }

    pub fn transfer(&mut self, new_owner: String) {
        self.owner = new_owner;
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_currency/src/asset_token.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_currency/src/bond.rs =====
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Bond {
    pub bond_id: String,
    pub name: String,
    pub description: String,
    pub issuer: String,
    pub face_value: f64,
    pub maturity_date: DateTime<Utc>,
    pub interest_rate: f64,
    pub owner: String,
}

impl Bond {
    pub fn new(bond_id: String, name: String, description: String, issuer: String, face_value: f64, maturity_date: DateTime<Utc>, interest_rate: f64, owner: String) -> Self {
        Bond {
            bond_id,
            name,
            description,
            issuer,
            face_value,
            maturity_date,
            interest_rate,
            owner,
        }
    }

    pub fn transfer(&mut self, new_owner: String) {
        self.owner = new_owner;
    }

    pub fn calculate_current_value(&self, current_date: DateTime<Utc>) -> f64 {
        if current_date >= self.maturity_date {
            self.face_value
        } else {
            let years_to_maturity = (self.maturity_date - current_date).num_days() as f64 / 365.0;
            self.face_value * (1.0 + self.interest_rate).powf(years_to_maturity)
        }
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_currency/src/bond.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_currency/src/currency.rs =====
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use std::collections::HashMap;
use std::fmt;
use log::{info, error, debug, warn};
use icn_core::error::{Error, Result};

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, Hash)]
pub enum CurrencyType {
    BasicNeeds,
    Education,
    Environmental,
    Community,
    Volunteer,
    Storage,
    Processing,
    Energy,
    Luxury,
    Service,
    Custom(String),
    AssetToken(String),
    Bond(String),
}

impl fmt::Display for CurrencyType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            CurrencyType::Custom(name) => write!(f, "Custom({})", name),
            _ => write!(f, "{:?}", self),
        }
    }
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Currency {
    pub currency_type: CurrencyType,
    pub total_supply: f64,
    pub creation_date: DateTime<Utc>,
    pub last_issuance: DateTime<Utc>,
    pub issuance_rate: f64,
}

impl Currency {
    pub fn new(currency_type: CurrencyType, initial_supply: f64, issuance_rate: f64) -> Self {
        let now = Utc::now();
        debug!("Creating new currency: {:?}", currency_type);
        Currency {
            currency_type,
            total_supply: initial_supply,
            creation_date: now,
            last_issuance: now,
            issuance_rate,
        }
    }

    pub fn mint(&mut self, amount: f64) -> Result<()> {
        self.total_supply += amount;
        self.last_issuance = Utc::now();
        info!("Minted {} of {:?}. New total supply: {}", amount, self.currency_type, self.total_supply);
        Ok(())
    }

    pub fn burn(&mut self, amount: f64) -> Result<()> {
        if amount > self.total_supply {
            error!("Attempted to burn more {:?} than available. Requested: {}, Available: {}", self.currency_type, amount, self.total_supply);
            return Err(Error::CurrencyError("Insufficient supply to burn".to_string()));
        }
        self.total_supply -= amount;
        info!("Burned {} of {:?}. New total supply: {}", amount, self.currency_type, self.total_supply);
        Ok(())
    }
}

pub struct CurrencySystem {
    pub currencies: HashMap<CurrencyType, Currency>,
}

impl CurrencySystem {
    pub fn new() -> Self {
        debug!("Creating new CurrencySystem");
        let mut system = CurrencySystem {
            currencies: HashMap::new(),
        };
        
        system.add_currency(CurrencyType::BasicNeeds, 1_000_000.0, 0.01);
        system.add_currency(CurrencyType::Education, 500_000.0, 0.005);
        system.add_currency(CurrencyType::Environmental, 750_000.0, 0.008);
        system.add_currency(CurrencyType::Community, 250_000.0, 0.003);
        system.add_currency(CurrencyType::Volunteer, 100_000.0, 0.002);
        system.add_currency(CurrencyType::Storage, 1_000_000.0, 0.01);
        system.add_currency(CurrencyType::Processing, 500_000.0, 0.005);
        system.add_currency(CurrencyType::Energy, 750_000.0, 0.008);
        system.add_currency(CurrencyType::Luxury, 100_000.0, 0.001);
        system.add_currency(CurrencyType::Service, 200_000.0, 0.004);

        info!("CurrencySystem initialized with {} currencies", system.currencies.len());
        system
    }

    pub fn add_currency(&mut self, currency_type: CurrencyType, initial_supply: f64, issuance_rate: f64) {
        let currency = Currency::new(currency_type.clone(), initial_supply, issuance_rate);
        self.currencies.insert(currency_type.clone(), currency);
        info!("Added new currency: {:?}", currency_type);
    }

    pub fn get_currency(&self, currency_type: &CurrencyType) -> Option<&Currency> {
        self.currencies.get(currency_type)
    }

    pub fn get_currency_mut(&mut self, currency_type: &CurrencyType) -> Option<&mut Currency> {
        self.currencies.get_mut(currency_type)
    }

    pub fn create_custom_currency(&mut self, name: String, initial_supply: f64, issuance_rate: f64) -> Result<()> {
        let currency_type = CurrencyType::Custom(name.clone());
        if self.currencies.contains_key(&currency_type) {
            error!("Attempted to create duplicate custom currency: {}", name);
            return Err(Error::CurrencyError(format!("Currency '{}' already exists", name)));
        }
        self.add_currency(currency_type, initial_supply, issuance_rate);
        Ok(())
    }

    pub fn adaptive_issuance(&mut self) -> Result<()> {
        debug!("Performing adaptive issuance for all currencies");
        let now = Utc::now();
        for currency in self.currencies.values_mut() {
            let time_since_last_issuance = now.signed_duration_since(currency.last_issuance);
            let issuance_amount = currency.total_supply * currency.issuance_rate * time_since_last_issuance.num_milliseconds() as f64 / 86_400_000.0; // Daily rate
            currency.mint(issuance_amount)?;
            debug!("Adaptive issuance for {:?}: {}", currency.currency_type, issuance_amount);
        }
        info!("Adaptive issuance completed for all currencies");
        Ok(())
    }

    pub fn print_currency_supplies(&self) {
        info!("Current Currency Supplies:");
        for (currency_type, currency) in &self.currencies {
            info!("{:?}: {}", currency_type, currency.total_supply);
        }
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_currency/src/currency.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_currency/src/lib.rs =====
use icn_common::{IcnResult, IcnError, CurrencyType};
use std::collections::HashMap;
use chrono::{DateTime, Utc};

#[derive(Debug, Clone)]
pub struct Currency {
    pub currency_type: CurrencyType,
    pub total_supply: f64,
    pub creation_date: DateTime<Utc>,
    pub last_issuance: DateTime<Utc>,
    pub issuance_rate: f64,
}

impl Currency {
    pub fn new(currency_type: CurrencyType, initial_supply: f64, issuance_rate: f64) -> Self {
        let now = Utc::now();
        Currency {
            currency_type,
            total_supply: initial_supply,
            creation_date: now,
            last_issuance: now,
            issuance_rate,
        }
    }

    pub fn mint(&mut self, amount: f64) -> IcnResult<()> {
        self.total_supply += amount;
        self.last_issuance = Utc::now();
        Ok(())
    }

    pub fn burn(&mut self, amount: f64) -> IcnResult<()> {
        if amount > self.total_supply {
            return Err(IcnError::Currency("Insufficient supply to burn".to_string()));
        }
        self.total_supply -= amount;
        Ok(())
    }
}

pub struct CurrencySystem {
    pub currencies: HashMap<CurrencyType, Currency>,
    balances: HashMap<String, HashMap<CurrencyType, f64>>,
}

impl CurrencySystem {
    pub fn new() -> Self {
        let mut system = CurrencySystem {
            currencies: HashMap::new(),
            balances: HashMap::new(),
        };
        
        system.add_currency(CurrencyType::BasicNeeds, 1_000_000.0, 0.01);
        system.add_currency(CurrencyType::Education, 500_000.0, 0.005);
        system.add_currency(CurrencyType::Environmental, 750_000.0, 0.008);
        system.add_currency(CurrencyType::Community, 250_000.0, 0.003);
        system.add_currency(CurrencyType::Volunteer, 100_000.0, 0.002);

        system
    }

    pub fn add_currency(&mut self, currency_type: CurrencyType, initial_supply: f64, issuance_rate: f64) {
        let currency = Currency::new(currency_type.clone(), initial_supply, issuance_rate);
        self.currencies.insert(currency_type, currency);
    }

    pub fn get_balance(&self, address: &str, currency_type: &CurrencyType) -> f64 {
        self.balances
            .get(address)
            .and_then(|balances| balances.get(currency_type))
            .cloned()
            .unwrap_or(0.0)
    }

    pub fn update_balance(&mut self, address: &str, currency_type: &CurrencyType, amount: f64) -> IcnResult<()> {
        let balance = self.balances
            .entry(address.to_string())
            .or_insert_with(HashMap::new)
            .entry(currency_type.clone())
            .or_insert(0.0);
        *balance += amount;
        if *balance < 0.0 {
            return Err(IcnError::Currency("Insufficient balance".to_string()));
        }
        Ok(())
    }

    pub fn transfer(&mut self, from: &str, to: &str, currency_type: &CurrencyType, amount: f64) -> IcnResult<()> {
        self.update_balance(from, currency_type, -amount)?;
        self.update_balance(to, currency_type, amount)?;
        Ok(())
    }

    pub fn process_transaction(&mut self, from: &str, to: &str, currency_type: &CurrencyType, amount: f64) -> IcnResult<()> {
        self.transfer(from, to, currency_type, amount)
    }

    pub fn create_custom_currency(&mut self, name: String, initial_supply: f64, issuance_rate: f64) -> IcnResult<()> {
        let currency_type = CurrencyType::Custom(name.clone());
        if self.currencies.contains_key(&currency_type) {
            return Err(IcnError::Currency(format!("Currency '{}' already exists", name)));
        }
        self.add_currency(currency_type, initial_supply, issuance_rate);
        Ok(())
    }

    pub fn adaptive_issuance(&mut self) -> IcnResult<()> {
        let now = Utc::now();
        for currency in self.currencies.values_mut() {
            let time_since_last_issuance = now.signed_duration_since(currency.last_issuance);
            let issuance_amount = currency.total_supply * currency.issuance_rate * time_since_last_issuance.num_milliseconds() as f64 / 86_400_000.0; // Daily rate
            currency.mint(issuance_amount)?;
        }
        Ok(())
    }

    pub fn mint(&mut self, currency_type: &CurrencyType, amount: f64) -> IcnResult<()> {
        let currency = self.currencies.get_mut(currency_type)
            .ok_or_else(|| IcnError::Currency(format!("Currency {:?} not found", currency_type)))?;
        currency.mint(amount)
    }

    pub fn burn(&mut self, currency_type: &CurrencyType, amount: f64) -> IcnResult<()> {
        let currency = self.currencies.get_mut(currency_type)
            .ok_or_else(|| IcnError::Currency(format!("Currency {:?} not found", currency_type)))?;
        currency.burn(amount)
    }

    pub fn get_exchange_rate(&self, from: &CurrencyType, to: &CurrencyType) -> IcnResult<f64> {
        // This is a placeholder implementation. In a real-world scenario, 
        // exchange rates would be determined by market forces or a more complex algorithm.
        if from == to {
            return Ok(1.0);
        }
        
        let from_currency = self.currencies.get(from)
            .ok_or_else(|| IcnError::Currency(format!("Currency {:?} not found", from)))?;
        let to_currency = self.currencies.get(to)
            .ok_or_else(|| IcnError::Currency(format!("Currency {:?} not found", to)))?;

        Ok(from_currency.total_supply / to_currency.total_supply)
    }

    pub fn convert_currency(&mut self, from: &CurrencyType, to: &CurrencyType, amount: f64) -> IcnResult<f64> {
        let exchange_rate = self.get_exchange_rate(from, to)?;
        Ok(amount * exchange_rate)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_currency_system() {
        let mut system = CurrencySystem::new();
        
        // Test balance operations
        assert_eq!(system.get_balance("Alice", &CurrencyType::BasicNeeds), 0.0);
        system.update_balance("Alice", &CurrencyType::BasicNeeds, 100.0).unwrap();
        assert_eq!(system.get_balance("Alice", &CurrencyType::BasicNeeds), 100.0);

        // Test transfer
        system.transfer("Alice", "Bob", &CurrencyType::BasicNeeds, 50.0).unwrap();
        assert_eq!(system.get_balance("Alice", &CurrencyType::BasicNeeds), 50.0);
        assert_eq!(system.get_balance("Bob", &CurrencyType::BasicNeeds), 50.0);

        // Test custom currency creation
        system.create_custom_currency("LocalCoin".to_string(), 10_000.0, 0.005).unwrap();
        let local_coin = CurrencyType::Custom("LocalCoin".to_string());
        assert!(system.currencies.contains_key(&local_coin));

        // Test adaptive issuance
        let initial_supply = system.currencies[&CurrencyType::BasicNeeds].total_supply;
        system.adaptive_issuance().unwrap();
        assert!(system.currencies[&CurrencyType::BasicNeeds].total_supply > initial_supply);

        // Test mint and burn
        let mint_amount = 1000.0;
        system.mint(&CurrencyType::BasicNeeds, mint_amount).unwrap();
        let new_supply = system.currencies[&CurrencyType::BasicNeeds].total_supply;
        assert_eq!(new_supply, initial_supply + mint_amount);

        system.burn(&CurrencyType::BasicNeeds, 500.0).unwrap();
        let final_supply = system.currencies[&CurrencyType::BasicNeeds].total_supply;
        assert_eq!(final_supply, new_supply - 500.0);

        // Test insufficient balance error
        assert!(system.transfer("Alice", "Bob", &CurrencyType::BasicNeeds, 1000.0).is_err());

        // Test currency conversion
        let exchange_rate = system.get_exchange_rate(&CurrencyType::BasicNeeds, &CurrencyType::Education).unwrap();
        assert!(exchange_rate > 0.0);

        let converted_amount = system.convert_currency(&CurrencyType::BasicNeeds, &CurrencyType::Education, 100.0).unwrap();
        assert!(converted_amount > 0.0);
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_currency/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_currency/src/wallet.rs =====
use super::CurrencyType;
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use log::{info, error, debug};
use icn_core::error::{Error, Result};

#[derive(Debug, Serialize, Deserialize)]
pub struct Wallet {
    balances: HashMap<CurrencyType, f64>,
}

impl Wallet {
    pub fn new() -> Self {
        debug!("Creating new Wallet");
        Wallet {
            balances: HashMap::new(),
        }
    }

    pub fn deposit(&mut self, currency_type: CurrencyType, amount: f64) -> Result<()> {
        if amount < 0.0 {
            return Err(Error::CurrencyError("Cannot deposit negative amount".to_string()));
        }
        *self.balances.entry(currency_type.clone()).or_insert(0.0) += amount;
        info!("Deposited {} of {:?} into wallet", amount, currency_type);
        Ok(())
    }

    pub fn withdraw(&mut self, currency_type: CurrencyType, amount: f64) -> Result<()> {
        if amount < 0.0 {
            return Err(Error::CurrencyError("Cannot withdraw negative amount".to_string()));
        }
        let balance = self.balances.entry(currency_type.clone()).or_insert(0.0);
        if *balance < amount {
            error!("Insufficient balance for withdrawal. Requested: {}, Available: {}", amount, balance);
            return Err(Error::CurrencyError(format!("Insufficient balance for {:?}", currency_type)));
        }
        *balance -= amount;
        info!("Withdrawn {} of {:?} from wallet", amount, currency_type);
        Ok(())
    }

    pub fn get_balance(&self, currency_type: &CurrencyType) -> f64 {
        *self.balances.get(currency_type).unwrap_or(&0.0)
    }

    pub fn print_balances(&self) {
        info!("Wallet Balances:");
        for (currency_type, balance) in &self.balances {
            info!("{:?}: {}", currency_type, balance);
        }
    }

    pub fn transfer(&mut self, to: &mut Wallet, currency_type: CurrencyType, amount: f64) -> Result<()> {
        self.withdraw(currency_type.clone(), amount)?;
        to.deposit(currency_type, amount)?;
        Ok(())
    }
}


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_wallet_operations() {
        let mut wallet = Wallet::new();
        
        // Test deposit
        assert!(wallet.deposit(CurrencyType::BasicNeeds, 100.0).is_ok());
        assert_eq!(wallet.get_balance(&CurrencyType::BasicNeeds), 100.0);

        // Test withdraw
        assert!(wallet.withdraw(CurrencyType::BasicNeeds, 50.0).is_ok());
        assert_eq!(wallet.get_balance(&CurrencyType::BasicNeeds), 50.0);

        // Test insufficient balance
        assert!(wallet.withdraw(CurrencyType::BasicNeeds, 100.0).is_err());

        // Test transfer
        let mut wallet2 = Wallet::new();
        assert!(wallet.transfer(&mut wallet2, CurrencyType::BasicNeeds, 25.0).is_ok());
        assert_eq!(wallet.get_balance(&CurrencyType::BasicNeeds), 25.0);
        assert_eq!(wallet2.get_balance(&CurrencyType::BasicNeeds), 25.0);
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_currency/src/wallet.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_governance/Cargo.toml =====
[package]
name = "icn_governance"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
log = "0.4"
thiserror = "1.0"

[dev-dependencies]
tokio = { version = "1.0", features = ["full"] }===== END OF /home/matt/InterCooperative-Network/crates/icn_governance/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_governance/src/democracy.rs =====
use icn_utils::{Error, Result, Proposal, Vote};
use chrono::{DateTime, Utc, Duration};
use serde::{Serialize, Deserialize};
use std::collections::HashMap;
use log::{info, error, debug, warn};

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum ProposalCategory {
    Constitutional,
    Economic,
    Technical,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum ProposalStatus {
    Active,
    Passed,
    Rejected,
    Implemented,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum ProposalType {
    Constitutional,
    EconomicAdjustment,
    NetworkUpgrade,
}

pub struct DemocraticSystem {
    proposals: HashMap<String, Proposal>,
    votes: HashMap<String, Vec<Vote>>,
}

impl DemocraticSystem {
    pub fn new() -> Self {
        debug!("Creating new DemocraticSystem");
        DemocraticSystem {
            proposals: HashMap::new(),
            votes: HashMap::new(),
        }
    }

    pub fn create_proposal(
        &mut self,
        title: String,
        description: String,
        proposer: String,
        voting_period: Duration,
        proposal_type: ProposalType,
        category: ProposalCategory,
        required_quorum: f64,
        execution_timestamp: Option<DateTime<Utc>>,
    ) -> Result<String> {
        let id = format!("prop_{}", Utc::now().timestamp());
        let proposal = Proposal::new(
            id.clone(),
            title,
            description,
            proposer,
            voting_period,
            proposal_type,
            category,
            required_quorum,
            execution_timestamp,
        );
        self.proposals.insert(id.clone(), proposal);
        info!("New proposal created: {}", id);
        Ok(id)
    }

    pub fn vote(&mut self, voter: String, proposal_id: String, in_favor: bool, weight: f64) -> Result<()> {
        let proposal = self.proposals.get(&proposal_id).ok_or(Error::GovernanceError("Proposal not found".to_string()))?;
        
        if proposal.status != ProposalStatus::Active {
            error!("Attempted to vote on inactive proposal: {}", proposal_id);
            return Err(Error::GovernanceError("Voting is not active for this proposal".to_string()));
        }

        if Utc::now() > proposal.voting_ends_at {
            error!("Attempted to vote on expired proposal: {}", proposal_id);
            return Err(Error::GovernanceError("Voting period has ended".to_string()));
        }

        let vote = Vote::new(voter, proposal_id.clone(), in_favor, weight);
        self.votes.entry(proposal_id.clone()).or_insert_with(Vec::new).push(vote);
        info!("Vote recorded for proposal: {}", proposal_id);
        Ok(())
    }

    pub fn tally_votes(&mut self, proposal_id: &str) -> Result<()> {
        let proposal = self.proposals.get_mut(proposal_id).ok_or(Error::GovernanceError("Proposal not found".to_string()))?;
        
        if proposal.status != ProposalStatus::Active {
            error!("Attempted to tally votes for inactive proposal: {}", proposal_id);
            return Err(Error::GovernanceError("Proposal is not active".to_string()));
        }

        if Utc::now() < proposal.voting_ends_at {
            warn!("Attempted to tally votes before voting period ended: {}", proposal_id);
            return Err(Error::GovernanceError("Voting period has not ended yet".to_string()));
        }

        let votes = self.votes.get(proposal_id).ok_or(Error::GovernanceError("No votes found for this proposal".to_string()))?;
        
        let total_weight: f64 = votes.iter().map(|v| v.weight).sum();
        let weight_in_favor: f64 = votes.iter().filter(|v| v.in_favor).map(|v| v.weight).sum();

        if total_weight < proposal.required_quorum {
            proposal.status = ProposalStatus::Rejected;
            info!("Proposal {} rejected due to insufficient quorum", proposal_id);
            return Ok(());
        }

        if weight_in_favor / total_weight > 0.5 {
            proposal.status = ProposalStatus::Passed;
            info!("Proposal {} passed", proposal_id);
        } else {
            proposal.status = ProposalStatus::Rejected;
            info!("Proposal {} rejected", proposal_id);
        }

        Ok(())
    }

    pub fn get_proposal(&self, proposal_id: &str) -> Option<&Proposal> {
        self.proposals.get(proposal_id)
    }

    pub fn get_votes(&self, proposal_id: &str) -> Option<&Vec<Vote>> {
        self.votes.get(proposal_id)
    }

    pub fn list_active_proposals(&self) -> Vec<&Proposal> {
        self.proposals.values()
            .filter(|p| p.status == ProposalStatus::Active)
            .collect()
    }

    pub fn mark_as_implemented(&mut self, proposal_id: &str) -> Result<()> {
        let proposal = self.proposals.get_mut(proposal_id).ok_or(Error::GovernanceError("Proposal not found".to_string()))?;
        
        if proposal.status != ProposalStatus::Passed {
            error!("Attempted to mark non-passed proposal as implemented: {}", proposal_id);
            return Err(Error::GovernanceError("Proposal has not passed".to_string()));
        }

        proposal.status = ProposalStatus::Implemented;
        info!("Proposal {} marked as implemented", proposal_id);
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_utils::ProposalStatus;

    #[test]
    fn test_democratic_system() {
        let mut system = DemocraticSystem::new();
        
        // Create proposal
        let proposal_id = system.create_proposal(
            "Test Proposal".to_string(),
            "This is a test proposal".to_string(),
            "Alice".to_string(),
            Duration::days(7),
            ProposalType::Constitutional,
            ProposalCategory::Technical,
            0.5,
            None,
        ).unwrap();

        // Vote on proposal
        assert!(system.vote("Bob".to_string(), proposal_id.clone(), true, 1.0).is_ok());
        assert!(system.vote("Charlie".to_string(), proposal_id.clone(), false, 1.0).is_ok());
        assert!(system.vote("David".to_string(), proposal_id.clone(), true, 1.0).is_ok());

        // Try to tally votes before voting period ends (should fail)
        assert!(system.tally_votes(&proposal_id).is_err());

        // Simulate voting period end
        let proposal = system.proposals.get_mut(&proposal_id).unwrap();
        proposal.voting_ends_at = Utc::now() - Duration::hours(1);

        // Tally votes
        assert!(system.tally_votes(&proposal_id).is_ok());

        // Check proposal status
        let proposal = system.get_proposal(&proposal_id).unwrap();
        assert_eq!(proposal.status, ProposalStatus::Passed);

        // Mark as implemented
        assert!(system.mark_as_implemented(&proposal_id).is_ok());
        let updated_proposal = system.get_proposal(&proposal_id).unwrap();
        assert_eq!(updated_proposal.status, ProposalStatus::Implemented);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_governance/src/democracy.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_governance/src/lib.rs =====
// File: crates/icn_governance/src/lib.rs

use icn_common::{IcnResult, IcnError, Block, Transaction, CurrencyType};
use icn_blockchain::Blockchain;
use icn_reputation::ReputationSystem;
use icn_currency::CurrencySystem;
use chrono::{DateTime, Utc, Duration};
use serde::{Serialize, Deserialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proposal {
    pub id: String,
    pub title: String,
    pub description: String,
    pub proposer: String,
    pub created_at: DateTime<Utc>,
    pub voting_ends_at: DateTime<Utc>,
    pub status: ProposalStatus,
    pub proposal_type: ProposalType,
    pub category: ProposalCategory,
    pub required_quorum: f64,
    pub execution_timestamp: Option<DateTime<Utc>>,
    pub voting_system: VotingSystem,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vote {
    pub proposal_id: String,
    pub voter: String,
    pub vote_power: f64,
    pub in_favor: bool,
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum ProposalStatus {
    Active,
    Passed,
    Rejected,
    Implemented,
    Expired,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum ProposalType {
    Constitutional,
    EconomicAdjustment,
    NetworkUpgrade,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum ProposalCategory {
    Constitutional,
    Economic,
    Technical,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum VotingSystem {
    OnePersonOneVote,
    TokenWeighted { max_power: f64 },
    Quadratic { max_votes: u32 },
    ReputationWeighted,
    Hybrid { reputation_weight: f64, token_weight: f64, max_power: f64 },
}

pub struct GovernanceSystem {
    blockchain: Blockchain,
    reputation_system: ReputationSystem,
}

impl GovernanceSystem {
    pub fn new(blockchain: Blockchain, reputation_system: ReputationSystem) -> Self {
        GovernanceSystem {
            blockchain,
            reputation_system,
        }
    }

    pub fn create_proposal(
        &mut self,
        title: String,
        description: String,
        proposer: String,
        voting_period: Duration,
        proposal_type: ProposalType,
        category: ProposalCategory,
        required_quorum: f64,
        voting_system: VotingSystem,
    ) -> IcnResult<String> {
        let proposal_id = format!("prop_{}", Utc::now().timestamp());
        let proposal = Proposal {
            id: proposal_id.clone(),
            title,
            description,
            proposer,
            created_at: Utc::now(),
            voting_ends_at: Utc::now() + voting_period,
            status: ProposalStatus::Active,
            proposal_type,
            category,
            required_quorum,
            execution_timestamp: None,
            voting_system,
        };

        let transaction = Transaction::new_governance(
            "SYSTEM".to_string(),
            "CreateProposal".to_string(),
            serde_json::to_vec(&proposal).map_err(|e| IcnError::Serialization(e.to_string()))?
        );

        self.blockchain.add_transaction(transaction)?;
        Ok(proposal_id)
    }

    pub fn vote(&mut self, proposal_id: &str, voter: String, in_favor: bool, vote_power: Option<f64>, currency_system: &mut CurrencySystem) -> IcnResult<()> {
        let proposal = self.get_proposal(proposal_id)?;

        if proposal.status != ProposalStatus::Active {
            return Err(IcnError::Governance("Proposal is not active".into()));
        }

        if Utc::now() > proposal.voting_ends_at {
            return Err(IcnError::Governance("Voting period has ended".into()));
        }

        let calculated_vote_power = match proposal.voting_system {
            VotingSystem::OnePersonOneVote => 1.0,
            VotingSystem::TokenWeighted { max_power } => {
                let balance = currency_system.get_balance(&voter, &CurrencyType::Governance)?;
                balance.min(max_power)
            },
            VotingSystem::Quadratic { max_votes } => {
                let vote_count = vote_power.ok_or(IcnError::Governance("Vote power must be provided for quadratic voting".into()))? as u32;
                if vote_count > max_votes {
                    return Err(IcnError::Governance("Exceeded maximum allowed votes".into()));
                }
                let cost = (vote_count as f64).powi(2);
                let balance = currency_system.get_balance(&voter, &CurrencyType::Governance)?;
                if balance < cost {
                    return Err(IcnError::Governance("Insufficient balance for quadratic vote".into()));
                }
                currency_system.transfer(&voter, "GOVERNANCE_POOL", &CurrencyType::Governance, cost)?;
                (vote_count as f64).sqrt()
            },
            VotingSystem::ReputationWeighted => {
                self.reputation_system.get_score(&voter).unwrap_or(0.0)
            },
            VotingSystem::Hybrid { reputation_weight, token_weight, max_power } => {
                let reputation = self.reputation_system.get_score(&voter).unwrap_or(0.0);
                let balance = currency_system.get_balance(&voter, &CurrencyType::Governance)?;
                (reputation * reputation_weight + balance * token_weight).min(max_power)
            },
        };

        let vote = Vote {
            proposal_id: proposal_id.to_string(),
            voter: voter.clone(),
            vote_power: calculated_vote_power,
            in_favor,
            timestamp: Utc::now(),
        };

        let transaction = Transaction::new_governance(
            voter,
            "Vote".to_string(),
            serde_json::to_vec(&vote).map_err(|e| IcnError::Serialization(e.to_string()))?
        );

        self.blockchain.add_transaction(transaction)
    }

    pub fn tally_votes(&mut self, proposal_id: &str) -> IcnResult<ProposalStatus> {
        let mut proposal = self.get_proposal(proposal_id)?;

        if proposal.status != ProposalStatus::Active {
            return Ok(proposal.status.clone());
        }

        if Utc::now() < proposal.voting_ends_at {
            return Err(IcnError::Governance("Voting period has not ended yet".into()));
        }

        let votes = self.get_votes(proposal_id)?;

        let mut total_power = 0.0;
        let mut in_favor_power = 0.0;

        for vote in votes {
            total_power += vote.vote_power;
            if vote.in_favor {
                in_favor_power += vote.vote_power;
            }
        }

        if total_power < proposal.required_quorum {
            proposal.status = ProposalStatus::Rejected;
        } else if in_favor_power > total_power / 2.0 {
            proposal.status = ProposalStatus::Passed;
        } else {
            proposal.status = ProposalStatus::Rejected;
        }

        let transaction = Transaction::new_governance(
            "SYSTEM".to_string(),
            "TallyVotes".to_string(),
            serde_json::to_vec(&proposal).map_err(|e| IcnError::Serialization(e.to_string()))?
        );

        self.blockchain.add_transaction(transaction)?;

        Ok(proposal.status)
    }

    pub fn get_proposal(&self, proposal_id: &str) -> IcnResult<Proposal> {
        for block in self.blockchain.chain().iter().rev() {
            for transaction in &block.transactions {
                if transaction.transaction_type == "CreateProposal" {
                    let proposal: Proposal = serde_json::from_slice(&transaction.data)
                        .map_err(|e| IcnError::Serialization(e.to_string()))?;
                    if proposal.id == proposal_id {
                        return Ok(proposal);
                    }
                }
            }
        }
        Err(IcnError::Governance("Proposal not found".into()))
    }

    pub fn get_votes(&self, proposal_id: &str) -> IcnResult<Vec<Vote>> {
        let mut votes = Vec::new();
        for block in self.blockchain.chain().iter().rev() {
            for transaction in &block.transactions {
                if transaction.transaction_type == "Vote" {
                    let vote: Vote = serde_json::from_slice(&transaction.data)
                        .map_err(|e| IcnError::Serialization(e.to_string()))?;
                    if vote.proposal_id == proposal_id {
                        votes.push(vote);
                    }
                }
            }
        }
        Ok(votes)
    }

    pub fn list_active_proposals(&self) -> IcnResult<Vec<Proposal>> {
        let mut active_proposals = Vec::new();
        for block in self.blockchain.chain().iter().rev() {
            for transaction in &block.transactions {
                if transaction.transaction_type == "CreateProposal" {
                    let proposal: Proposal = serde_json::from_slice(&transaction.data)
                        .map_err(|e| IcnError::Serialization(e.to_string()))?;
                    if proposal.status == ProposalStatus::Active && proposal.voting_ends_at > Utc::now() {
                        active_proposals.push(proposal);
                    }
                }
            }
        }
        Ok(active_proposals)
    }

    pub fn mark_as_implemented(&mut self, proposal_id: &str) -> IcnResult<()> {
        let mut proposal = self.get_proposal(proposal_id)?;
        
        if proposal.status != ProposalStatus::Passed {
            return Err(IcnError::Governance("Proposal has not passed".into()));
        }

        proposal.status = ProposalStatus::Implemented;
        proposal.execution_timestamp = Some(Utc::now());

        let transaction = Transaction::new_governance(
            "SYSTEM".to_string(),
            "ImplementProposal".to_string(),
            serde_json::to_vec(&proposal).map_err(|e| IcnError::Serialization(e.to_string()))?
        );

        self.blockchain.add_transaction(transaction)
    }

    pub fn get_proposal_result(&self, proposal_id: &str) -> IcnResult<ProposalResult> {
        let proposal = self.get_proposal(proposal_id)?;
        let votes = self.get_votes(proposal_id)?;

        let total_votes = votes.len();
        let total_power: f64 = votes.iter().map(|v| v.vote_power).sum();
        let in_favor_power: f64 = votes.iter().filter(|v| v.in_favor).map(|v| v.vote_power).sum();
        let against_power = total_power - in_favor_power;

        Ok(ProposalResult {
            proposal_id: proposal_id.to_string(),
            status: proposal.status,
            total_votes,
            total_power,
            in_favor_power,
            against_power,
            quorum_reached: total_power >= proposal.required_quorum,
            passed: proposal.status == ProposalStatus::Passed,
        })
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ProposalResult {
    pub proposal_id: String,
    pub status: ProposalStatus,
    pub total_votes: usize,
    pub total_power: f64,
    pub in_favor_power: f64,
    pub against_power: f64,
    pub quorum_reached: bool,
    pub passed: bool,
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_blockchain::Blockchain;
    use icn_reputation::ReputationSystem;
    use icn_currency::CurrencySystem;

    fn create_test_environment() -> (Blockchain, ReputationSystem, CurrencySystem) {
        let blockchain = Blockchain::new();
        let mut reputation_system = ReputationSystem::new(0.01, 0.0, 100.0);
        let mut currency_system = CurrencySystem::new();
        
        // Initialize some reputation and governance tokens for testing
        reputation_system.add_score("Alice", 50.0);
        reputation_system.add_score("Bob", 30.0);
        currency_system.mint("Alice", &CurrencyType::Governance, 1000.0).unwrap();
        currency_system.mint("Bob", &CurrencyType::Governance, 1000.0).unwrap();

        (blockchain, reputation_system, currency_system)
    }

    #[test]
    fn test_one_person_one_vote() {
        let (blockchain, reputation_system, mut currency_system) = create_test_environment();
        let mut gs = GovernanceSystem::new(blockchain, reputation_system);

        let proposal_id = gs.create_proposal(
            "Test Proposal".to_string(),
            "This is a test proposal".to_string(),
            "Alice".to_string(),
            Duration::days(7),
            ProposalType::Constitutional,
            ProposalCategory::Economic,
            0.5,
            VotingSystem::OnePersonOneVote,
        ).unwrap();

        gs.vote(&proposal_id, "Alice".to_string(), true, None, &mut currency_system).unwrap();
        gs.vote(&proposal_id, "Bob".to_string(), false, None, &mut currency_system).unwrap();

        // Fast-forward time
        let mut proposal = gs.get_proposal(&proposal_id).unwrap();
        proposal.voting_ends_at = Utc::now() - Duration::hours(1);
        let update_transaction = Transaction::new_governance(
            "SYSTEM".to_string(),
            "UpdateProposal".to_string(),
            serde_json::to_vec(&proposal).unwrap()
        );
        gs.blockchain.add_transaction(update_transaction).unwrap();

        let result = gs.tally_votes(&proposal_id).unwrap();
        assert_eq!(result, ProposalStatus::Passed);

        let proposal_result = gs.get_proposal_result(&proposal_id).unwrap();
        assert_eq!(proposal_result.total_votes, 2);
        assert_eq!(proposal_result.total_power, 2.0);
        assert_eq!(proposal_result.in_favor_power, 1.0);
        assert_eq!(proposal_result.against_power, 1.0);
        assert!(proposal_result.quorum_reached);
        assert!(proposal_result.passed);
    }

    #[test]
    fn test_token_weighted_voting() {
        let (blockchain, reputation_system, mut currency_system) = create_test_environment();
        let mut gs = GovernanceSystem::new(blockchain, reputation_system);

        let proposal_id = gs.create_proposal(
            "Token Weighted Proposal".to_string(),
            "This is a token weighted proposal".to_string(),
            "Alice".to_string(),
            Duration::days(7),
            ProposalType::EconomicAdjustment,
            ProposalCategory::Economic,
            500.0,
            VotingSystem::TokenWeighted { max_power: 800.0 },
        ).unwrap();

        gs.vote(&proposal_id, "Alice".to_string(), true, None, &mut currency_system).unwrap();
        gs.vote(&proposal_id, "Bob".to_string(), false, None, &mut currency_system).unwrap();

        // Fast-forward time
        let mut proposal = gs.get_proposal(&proposal_id).unwrap();
        proposal.voting_ends_at = Utc::now() - Duration::hours(1);
        let update_transaction = Transaction::new_governance(
            "SYSTEM".to_string(),
            "UpdateProposal".to_string(),
            serde_json::to_vec(&proposal).unwrap()
        );
        gs.blockchain.add_transaction(update_transaction).unwrap();

        let result = gs.tally_votes(&proposal_id).unwrap();
        assert_eq!(result, ProposalStatus::Passed);

        let proposal_result = gs.get_proposal_result(&proposal_id).unwrap();
        assert_eq!(proposal_result.total_votes, 2);
        assert_eq!(proposal_result.total_power, 1600.0);
        assert_eq!(proposal_result.in_favor_power, 800.0);
        assert_eq!(proposal_result.against_power, 800.0);
        assert!(proposal_result.quorum_reached);
        assert!(proposal_result.passed);
    }

    #[test]
    fn test_quadratic_voting() {
        let (blockchain, reputation_system, mut currency_system) = create_test_environment();
        let mut gs = GovernanceSystem::new(blockchain, reputation_system);

        let proposal_id = gs.create_proposal(
            "Quadratic Voting Proposal".to_string(),
            "This is a quadratic voting proposal".to_string(),
            "Alice".to_string(),
            Duration::days(7),
            ProposalType::NetworkUpgrade,
            ProposalCategory::Technical,
            5.0,
            VotingSystem::Quadratic { max_votes: 10 },
        ).unwrap();

        gs.vote(&proposal_id, "Alice".to_string(), true, Some(9.0), &mut currency_system).unwrap();
        gs.vote(&proposal_id, "Bob".to_string(), false, Some(4.0), &mut currency_system).unwrap();

        // Fast-forward time
        let mut proposal = gs.get_proposal(&proposal_id).unwrap();
        proposal.voting_ends_at = Utc::now() - Duration::hours(1);
        let update_transaction = Transaction::new_governance(
            "SYSTEM".to_string(),
            "UpdateProposal".to_string(),
            serde_json::to_vec(&proposal).unwrap()
        );
        gs.blockchain.add_transaction(update_transaction).unwrap();

        let result = gs.tally_votes(&proposal_id).unwrap();
        assert_eq!(result, ProposalStatus::Passed);

        let proposal_result = gs.get_proposal_result(&proposal_id).unwrap();
        assert_eq!(proposal_result.total_votes, 2);
        assert_eq!(proposal_result.total_power, 5.0); // 3 (sqrt of 9) + 2 (sqrt of 4)
        assert_eq!(proposal_result.in_favor_power, 3.0);
        assert_eq!(proposal_result.against_power, 2.0);
        assert!(proposal_result.quorum_reached);
        assert!(proposal_result.passed);
    }

    #[test]
    fn test_reputation_weighted_voting() {
        let (blockchain, reputation_system, mut currency_system) = create_test_environment();
        let mut gs = GovernanceSystem::new(blockchain, reputation_system);

        let proposal_id = gs.create_proposal(
            "Reputation Weighted Proposal".to_string(),
            "This is a reputation weighted proposal".to_string(),
            "Alice".to_string(),
            Duration::days(7),
            ProposalType::Constitutional,
            ProposalCategory::Economic,
            40.0,
            VotingSystem::ReputationWeighted,
        ).unwrap();

        gs.vote(&proposal_id, "Alice".to_string(), true, None, &mut currency_system).unwrap();
        gs.vote(&proposal_id, "Bob".to_string(), false, None, &mut currency_system).unwrap();

        // Fast-forward time
        let mut proposal = gs.get_proposal(&proposal_id).unwrap();
        proposal.voting_ends_at = Utc::now() - Duration::hours(1);
        let update_transaction = Transaction::new_governance(
            "SYSTEM".to_string(),
            "UpdateProposal".to_string(),
            serde_json::to_vec(&proposal).unwrap()
        );
        gs.blockchain.add_transaction(update_transaction).unwrap();

        let result = gs.tally_votes(&proposal_id).unwrap();
        assert_eq!(result, ProposalStatus::Passed);

        let proposal_result = gs.get_proposal_result(&proposal_id).unwrap();
        assert_eq!(proposal_result.total_votes, 2);
        assert_eq!(proposal_result.total_power, 80.0); // 50 (Alice) + 30 (Bob)
        assert_eq!(proposal_result.in_favor_power, 50.0);
        assert_eq!(proposal_result.against_power, 30.0);
        assert!(proposal_result.quorum_reached);
        assert!(proposal_result.passed);
    }

    #[test]
    fn test_hybrid_voting() {
        let (blockchain, reputation_system, mut currency_system) = create_test_environment();
        let mut gs = GovernanceSystem::new(blockchain, reputation_system);

        let proposal_id = gs.create_proposal(
            "Hybrid Voting Proposal".to_string(),
            "This is a hybrid voting proposal".to_string(),
            "Alice".to_string(),
            Duration::days(7),
            ProposalType::EconomicAdjustment,
            ProposalCategory::Economic,
            100.0,
            VotingSystem::Hybrid { 
                reputation_weight: 0.5, 
                token_weight: 0.001, 
                max_power: 100.0 
            },
        ).unwrap();

        gs.vote(&proposal_id, "Alice".to_string(), true, None, &mut currency_system).unwrap();
        gs.vote(&proposal_id, "Bob".to_string(), false, None, &mut currency_system).unwrap();

        // Fast-forward time
        let mut proposal = gs.get_proposal(&proposal_id).unwrap();
        proposal.voting_ends_at = Utc::now() - Duration::hours(1);
        let update_transaction = Transaction::new_governance(
            "SYSTEM".to_string(),
            "UpdateProposal".to_string(),
            serde_json::to_vec(&proposal).unwrap()
        );
        gs.blockchain.add_transaction(update_transaction).unwrap();

        let result = gs.tally_votes(&proposal_id).unwrap();
        assert_eq!(result, ProposalStatus::Passed);

        let proposal_result = gs.get_proposal_result(&proposal_id).unwrap();
        assert_eq!(proposal_result.total_votes, 2);
        // Alice: min(50 * 0.5 + 1000 * 0.001, 100) = 26
        // Bob: min(30 * 0.5 + 1000 * 0.001, 100) = 16
        assert_eq!(proposal_result.total_power, 42.0);
        assert_eq!(proposal_result.in_favor_power, 26.0);
        assert_eq!(proposal_result.against_power, 16.0);
        assert!(proposal_result.quorum_reached);
        assert!(proposal_result.passed);
    }

    #[test]
    fn test_quorum_not_reached() {
        let (blockchain, reputation_system, mut currency_system) = create_test_environment();
        let mut gs = GovernanceSystem::new(blockchain, reputation_system);

        let proposal_id = gs.create_proposal(
            "High Quorum Proposal".to_string(),
            "This proposal requires high quorum".to_string(),
            "Alice".to_string(),
            Duration::days(7),
            ProposalType::Constitutional,
            ProposalCategory::Technical,
            200.0, // High quorum requirement
            VotingSystem::TokenWeighted { max_power: 100.0 },
        ).unwrap();

        gs.vote(&proposal_id, "Alice".to_string(), true, None, &mut currency_system).unwrap();
        
        // Fast-forward time
        let mut proposal = gs.get_proposal(&proposal_id).unwrap();
        proposal.voting_ends_at = Utc::now() - Duration::hours(1);
        let update_transaction = Transaction::new_governance(
            "SYSTEM".to_string(),
            "UpdateProposal".to_string(),
            serde_json::to_vec(&proposal).unwrap()
        );
        gs.blockchain.add_transaction(update_transaction).unwrap();

        let result = gs.tally_votes(&proposal_id).unwrap();
        assert_eq!(result, ProposalStatus::Rejected);

        let proposal_result = gs.get_proposal_result(&proposal_id).unwrap();
        assert!(!proposal_result.quorum_reached);
        assert!(!proposal_result.passed);
    }

    #[test]
    fn test_vote_after_end_period() {
        let (blockchain, reputation_system, mut currency_system) = create_test_environment();
        let mut gs = GovernanceSystem::new(blockchain, reputation_system);

        let proposal_id = gs.create_proposal(
            "Test Proposal".to_string(),
            "This is a test proposal".to_string(),
            "Alice".to_string(),
            Duration::days(7),
            ProposalType::Constitutional,
            ProposalCategory::Economic,
            0.5,
            VotingSystem::OnePersonOneVote,
        ).unwrap();

        // Fast-forward time
        let mut proposal = gs.get_proposal(&proposal_id).unwrap();
        proposal.voting_ends_at = Utc::now() - Duration::hours(1);
        let update_transaction = Transaction::new_governance(
            "SYSTEM".to_string(),
            "UpdateProposal".to_string(),
            serde_json::to_vec(&proposal).unwrap()
        );
        gs.blockchain.add_transaction(update_transaction).unwrap();

        // Try to vote after the voting period has ended
        let vote_result = gs.vote(&proposal_id, "Alice".to_string(), true, None, &mut currency_system);
        assert!(vote_result.is_err());
    }

    #[test]
    fn test_multiple_proposals() {
        let (blockchain, reputation_system, mut currency_system) = create_test_environment();
        let mut gs = GovernanceSystem::new(blockchain, reputation_system);

        let proposal_id1 = gs.create_proposal(
            "Proposal 1".to_string(),
            "This is proposal 1".to_string(),
            "Alice".to_string(),
            Duration::days(7),
            ProposalType::Constitutional,
            ProposalCategory::Economic,
            0.5,
            VotingSystem::OnePersonOneVote,
        ).unwrap();

        let proposal_id2 = gs.create_proposal(
            "Proposal 2".to_string(),
            "This is proposal 2".to_string(),
            "Bob".to_string(),
            Duration::days(7),
            ProposalType::EconomicAdjustment,
            ProposalCategory::Economic,
            0.5,
            VotingSystem::TokenWeighted { max_power: 100.0 },
        ).unwrap();

        gs.vote(&proposal_id1, "Alice".to_string(), true, None, &mut currency_system).unwrap();
        gs.vote(&proposal_id1, "Bob".to_string(), false, None, &mut currency_system).unwrap();
        gs.vote(&proposal_id2, "Alice".to_string(), false, None, &mut currency_system).unwrap();
        gs.vote(&proposal_id2, "Bob".to_string(), true, None, &mut currency_system).unwrap();

        // Fast-forward time
        for proposal_id in &[&proposal_id1, &proposal_id2] {
            let mut proposal = gs.get_proposal(proposal_id).unwrap();
            proposal.voting_ends_at = Utc::now() - Duration::hours(1);
            let update_transaction = Transaction::new_governance(
                "SYSTEM".to_string(),
                "UpdateProposal".to_string(),
                serde_json::to_vec(&proposal).unwrap()
            );
            gs.blockchain.add_transaction(update_transaction).unwrap();
        }

        let result1 = gs.tally_votes(&proposal_id1).unwrap();
        let result2 = gs.tally_votes(&proposal_id2).unwrap();

        assert_eq!(result1, ProposalStatus::Passed);
        assert_eq!(result2, ProposalStatus::Passed);

        let active_proposals = gs.list_active_proposals().unwrap();
        assert_eq!(active_proposals.len(), 0);

        let proposal_result1 = gs.get_proposal_result(&proposal_id1).unwrap();
        let proposal_result2 = gs.get_proposal_result(&proposal_id2).unwrap();

        assert_eq!(proposal_result1.total_votes, 2);
        assert_eq!(proposal_result1.total_power, 2.0);
        assert_eq!(proposal_result1.in_favor_power, 1.0);
        assert_eq!(proposal_result1.against_power, 1.0);

        assert_eq!(proposal_result2.total_votes, 2);
        assert_eq!(proposal_result2.total_power, 200.0);
        assert_eq!(proposal_result2.in_favor_power, 100.0);
        assert_eq!(proposal_result2.against_power, 100.0);
    }

    #[test]
    fn test_proposal_implementation() {
        let (blockchain, reputation_system, mut currency_system) = create_test_environment();
        let mut gs = GovernanceSystem::new(blockchain, reputation_system);

        let proposal_id = gs.create_proposal(
            "Implementation Test".to_string(),
            "This proposal will be implemented".to_string(),
            "Alice".to_string(),
            Duration::days(1),
            ProposalType::NetworkUpgrade,
            ProposalCategory::Technical,
            0.5,
            VotingSystem::OnePersonOneVote,
        ).unwrap();

        gs.vote(&proposal_id, "Alice".to_string(), true, None, &mut currency_system).unwrap();
        gs.vote(&proposal_id, "Bob".to_string(), true, None, &mut currency_system).unwrap();

        // Fast-forward time
        let mut proposal = gs.get_proposal(&proposal_id).unwrap();
        proposal.voting_ends_at = Utc::now() - Duration::hours(1);
        let update_transaction = Transaction::new_governance(
            "SYSTEM".to_string(),
            "UpdateProposal".to_string(),
            serde_json::to_vec(&proposal).unwrap()
        );
        gs.blockchain.add_transaction(update_transaction).unwrap();

        gs.tally_votes(&proposal_id).unwrap();
        
        assert!(gs.mark_as_implemented(&proposal_id).is_ok());
        
        let implemented_proposal = gs.get_proposal(&proposal_id).unwrap();
        assert_eq!(implemented_proposal.status, ProposalStatus::Implemented);
        assert!(implemented_proposal.execution_timestamp.is_some());
    }

    #[test]
    fn test_vote_power_limits() {
        let (blockchain, reputation_system, mut currency_system) = create_test_environment();
        let mut gs = GovernanceSystem::new(blockchain, reputation_system);

        // Mint more tokens for Alice
        currency_system.mint("Alice", &CurrencyType::Governance, 9000.0).unwrap();

        let proposal_id = gs.create_proposal(
            "Vote Power Limit Test".to_string(),
            "This proposal tests vote power limits".to_string(),
            "Bob".to_string(),
            Duration::days(7),
            ProposalType::EconomicAdjustment,
            ProposalCategory::Economic,
            5000.0,
            VotingSystem::TokenWeighted { max_power: 5000.0 },
        ).unwrap();

        gs.vote(&proposal_id, "Alice".to_string(), true, None, &mut currency_system).unwrap();
        gs.vote(&proposal_id, "Bob".to_string(), false, None, &mut currency_system).unwrap();

        // Fast-forward time
        let mut proposal = gs.get_proposal(&proposal_id).unwrap();
        proposal.voting_ends_at = Utc::now() - Duration::hours(1);
        let update_transaction = Transaction::new_governance(
            "SYSTEM".to_string(),
            "UpdateProposal".to_string(),
            serde_json::to_vec(&proposal).unwrap()
        );
        gs.blockchain.add_transaction(update_transaction).unwrap();

        let result = gs.tally_votes(&proposal_id).unwrap();
        assert_eq!(result, ProposalStatus::Passed);

        let proposal_result = gs.get_proposal_result(&proposal_id).unwrap();
        assert_eq!(proposal_result.total_votes, 2);
        assert_eq!(proposal_result.total_power, 6000.0); // 5000 (Alice's limit) + 1000 (Bob)
        assert_eq!(proposal_result.in_favor_power, 5000.0);
        assert_eq!(proposal_result.against_power, 1000.0);
        assert!(proposal_result.quorum_reached);
        assert!(proposal_result.passed);
    }

    #[test]
    fn test_quadratic_voting_limits() {
        let (blockchain, reputation_system, mut currency_system) = create_test_environment();
        let mut gs = GovernanceSystem::new(blockchain, reputation_system);

        let proposal_id = gs.create_proposal(
            "Quadratic Voting Limit Test".to_string(),
            "This proposal tests quadratic voting limits".to_string(),
            "Alice".to_string(),
            Duration::days(7),
            ProposalType::NetworkUpgrade,
            ProposalCategory::Technical,
            10.0,
            VotingSystem::Quadratic { max_votes: 10 },
        ).unwrap();

        // This should succeed (9 votes, cost of 81 tokens)
        assert!(gs.vote(&proposal_id, "Alice".to_string(), true, Some(9.0), &mut currency_system).is_ok());

        // This should fail (11 votes, exceeds max_votes)
        assert!(gs.vote(&proposal_id, "Bob".to_string(), false, Some(11.0), &mut currency_system).is_err());

        // This should succeed (4 votes, cost of 16 tokens)
        assert!(gs.vote(&proposal_id, "Bob".to_string(), false, Some(4.0), &mut currency_system).is_ok());

        // Fast-forward time
        let mut proposal = gs.get_proposal(&proposal_id).unwrap();
        proposal.voting_ends_at = Utc::now() - Duration::hours(1);
        let update_transaction = Transaction::new_governance(
            "SYSTEM".to_string(),
            "UpdateProposal".to_string(),
            serde_json::to_vec(&proposal).unwrap()
        );
        gs.blockchain.add_transaction(update_transaction).unwrap();

        let result = gs.tally_votes(&proposal_id).unwrap();
        assert_eq!(result, ProposalStatus::Passed);

        let proposal_result = gs.get_proposal_result(&proposal_id).unwrap();
        assert_eq!(proposal_result.total_votes, 2);
        assert_eq!(proposal_result.total_power, 5.0); // 3 (sqrt of 9) + 2 (sqrt of 4)
        assert_eq!(proposal_result.in_favor_power, 3.0);
        assert_eq!(proposal_result.against_power, 2.0);
        assert!(proposal_result.quorum_reached);
        assert!(proposal_result.passed);

        // Check if Alice's balance was deducted correctly
        let alice_balance = currency_system.get_balance("Alice", &CurrencyType::Governance).unwrap();
        assert_eq!(alice_balance, 919.0); // 1000 - 81 (cost of 9 votes)

        // Check if Bob's balance was deducted correctly
        let bob_balance = currency_system.get_balance("Bob", &CurrencyType::Governance).unwrap();
        assert_eq!(bob_balance, 984.0); // 1000 - 16 (cost of 4 votes)
    }

    #[test]
    fn test_edge_cases() {
        let (blockchain, reputation_system, mut currency_system) = create_test_environment();
        let mut gs = GovernanceSystem::new(blockchain, reputation_system);

        // Test case 1: Create a proposal with 0 quorum requirement
        let proposal_id1 = gs.create_proposal(
            "Zero Quorum Proposal".to_string(),
            "This proposal has zero quorum requirement".to_string(),
            "Alice".to_string(),
            Duration::days(7),
            ProposalType::Constitutional,
            ProposalCategory::Economic,
            0.0,
            VotingSystem::OnePersonOneVote,
        ).unwrap();

        // Test case 2: Create a proposal with 100% quorum requirement
        let proposal_id2 = gs.create_proposal(
            "Full Quorum Proposal".to_string(),
            "This proposal requires full quorum".to_string(),
            "Bob".to_string(),
            Duration::days(7),
            ProposalType::EconomicAdjustment,
            ProposalCategory::Economic,
            f64::MAX,
            VotingSystem::TokenWeighted { max_power: f64::MAX },
        ).unwrap();

        // Vote on zero quorum proposal
        gs.vote(&proposal_id1, "Alice".to_string(), true, None, &mut currency_system).unwrap();

        // Vote on full quorum proposal
        gs.vote(&proposal_id2, "Alice".to_string(), true, None, &mut currency_system).unwrap();
        gs.vote(&proposal_id2, "Bob".to_string(), true, None, &mut currency_system).unwrap();

        // Fast-forward time
        for proposal_id in &[&proposal_id1, &proposal_id2] {
            let mut proposal = gs.get_proposal(proposal_id).unwrap();
            proposal.voting_ends_at = Utc::now() - Duration::hours(1);
            let update_transaction = Transaction::new_governance(
                "SYSTEM".to_string(),
                "UpdateProposal".to_string(),
                serde_json::to_vec(&proposal).unwrap()
            );
            gs.blockchain.add_transaction(update_transaction).unwrap();
        }

        // Tally votes for zero quorum proposal
        let result1 = gs.tally_votes(&proposal_id1).unwrap();
        assert_eq!(result1, ProposalStatus::Passed);

        let proposal_result1 = gs.get_proposal_result(&proposal_id1).unwrap();
        assert_eq!(proposal_result1.total_votes, 1);
        assert_eq!(proposal_result1.total_power, 1.0);
        assert_eq!(proposal_result1.in_favor_power, 1.0);
        assert_eq!(proposal_result1.against_power, 0.0);
        assert!(proposal_result1.quorum_reached);
        assert!(proposal_result1.passed);

        // Tally votes for full quorum proposal
        let result2 = gs.tally_votes(&proposal_id2).unwrap();
        assert_eq!(result2, ProposalStatus::Rejected);

        let proposal_result2 = gs.get_proposal_result(&proposal_id2).unwrap();
        assert_eq!(proposal_result2.total_votes, 2);
        assert_eq!(proposal_result2.total_power, 2000.0);
        assert_eq!(proposal_result2.in_favor_power, 2000.0);
        assert_eq!(proposal_result2.against_power, 0.0);
        assert!(!proposal_result2.quorum_reached);
        assert!(!proposal_result2.passed);

        // Test case 3: Try to vote with negative power (should fail)
        let proposal_id3 = gs.create_proposal(
            "Negative Vote Test".to_string(),
            "This proposal tests negative voting power".to_string(),
            "Alice".to_string(),
            Duration::days(7),
            ProposalType::NetworkUpgrade,
            ProposalCategory::Technical,
            1.0,
            VotingSystem::Quadratic { max_votes: 10 },
        ).unwrap();

        assert!(gs.vote(&proposal_id3, "Alice".to_string(), true, Some(-1.0), &mut currency_system).is_err());

        // Test case 4: Try to create a proposal with negative quorum (should fail)
        let proposal_id4 = gs.create_proposal(
            "Negative Quorum Test".to_string(),
            "This proposal has a negative quorum requirement".to_string(),
            "Bob".to_string(),
            Duration::days(7),
            ProposalType::Constitutional,
            ProposalCategory::Economic,
            -1.0,
            VotingSystem::OnePersonOneVote,
        );

        assert!(proposal_id4.is_err());
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_governance/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_governance/src/proposal.rs =====
use crate::democracy::{ProposalCategory, ProposalType, ProposalStatus};
use chrono::{DateTime, Utc, Duration};
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Proposal {
    pub id: String,
    pub title: String,
    pub description: String,
    pub proposer: String,
    pub created_at: DateTime<Utc>,
    pub voting_ends_at: DateTime<Utc>,
    pub status: ProposalStatus,
    pub proposal_type: ProposalType,
    pub category: ProposalCategory,
    pub required_quorum: f64,
    pub execution_timestamp: Option<DateTime<Utc>>,
}

impl Proposal {
    pub fn new(
        id: String,
        title: String,
        description: String,
        proposer: String,
        voting_period: Duration,
        proposal_type: ProposalType,
        category: ProposalCategory,
        required_quorum: f64,
        execution_timestamp: Option<DateTime<Utc>>,
    ) -> Self {
        let now = Utc::now();
        Proposal {
            id,
            title,
            description,
            proposer,
            created_at: now,
            voting_ends_at: now + voting_period,
            status: ProposalStatus::Active,
            proposal_type,
            category,
            required_quorum,
            execution_timestamp,
        }
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_governance/src/proposal.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_governance/src/voting.rs =====
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Vote {
    pub voter: String,
    pub proposal_id: String,
    pub in_favor: bool,
    pub weight: f64,
    pub timestamp: DateTime<Utc>,
}

impl Vote {
    pub fn new(voter: String, proposal_id: String, in_favor: bool, weight: f64) -> Self {
        Vote {
            voter,
            proposal_id,
            in_favor,
            weight,
            timestamp: Utc::now(),
        }
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_governance/src/voting.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_identity/Cargo.toml =====
[package]
name = "icn_identity"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
ed25519-dalek = "1.0"
rand = "0.7"
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
hex = "0.4"

[dev-dependencies]
tokio = { version = "1.0", features = ["full"] }===== END OF /home/matt/InterCooperative-Network/crates/icn_identity/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_identity/src/did.rs =====
use chrono::{DateTime, Utc};
use ed25519_dalek::{Keypair, PublicKey, Signature, Verifier};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct DecentralizedIdentity {
    pub id: String,
    #[serde(with = "public_key_serde")]
    pub public_key: PublicKey,
    pub created_at: DateTime<Utc>,
    pub reputation: f64,
    pub attributes: HashMap<String, String>,
}

mod public_key_serde {
    use ed25519_dalek::PublicKey;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};

    pub fn serialize<S>(public_key: &PublicKey, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let bytes = public_key.to_bytes();
        bytes.serialize(serializer)
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<PublicKey, D::Error>
    where
        D: Deserializer<'de>,
    {
        let bytes = Vec::<u8>::deserialize(deserializer)?;
        PublicKey::from_bytes(&bytes).map_err(serde::de::Error::custom)
    }
}

impl DecentralizedIdentity {
    pub fn new(attributes: HashMap<String, String>) -> (Self, Keypair) {
        let mut csprng = rand::rngs::OsRng {};
        let keypair: Keypair = Keypair::generate(&mut csprng);
        let public_key = keypair.public;
        let id = format!("did:icn:{}", hex::encode(public_key.to_bytes()));

        (
            Self {
                id,
                public_key,
                created_at: Utc::now(),
                reputation: 1.0,
                attributes,
            },
            keypair,
        )
    }

    pub fn verify_signature(&self, message: &[u8], signature: &Signature) -> bool {
        self.public_key.verify(message, signature).is_ok()
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_identity/src/did.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_identity/src/identity_manager.rs =====
use crate::DecentralizedIdentity;
use ed25519_dalek::Signature;
use icn_core::error::{Error, Result};
use std::collections::HashMap;

pub struct IdentityManager {
    identities: HashMap<String, DecentralizedIdentity>,
}

impl IdentityManager {
    pub fn new() -> Self {
        IdentityManager {
            identities: HashMap::new(),
        }
    }

    pub fn create_identity(&mut self, attributes: HashMap<String, String>) -> Result<DecentralizedIdentity> {
        let (identity, _) = DecentralizedIdentity::new(attributes);
        self.identities.insert(identity.id.clone(), identity.clone());
        Ok(identity)
    }

    pub fn get_identity(&self, id: &str) -> Option<&DecentralizedIdentity> {
        self.identities.get(id)
    }

    pub fn update_reputation(&mut self, id: &str, change: f64) -> Result<()> {
        let identity = self.identities.get_mut(id).ok_or(Error::IdentityError("Identity not found".to_string()))?;
        identity.reputation += change;
        Ok(())
    }

    pub fn verify_signature(&self, id: &str, message: &[u8], signature: &Signature) -> Result<bool> {
        let identity = self.identities.get(id).ok_or(Error::IdentityError("Identity not found".to_string()))?;
        Ok(identity.verify_signature(message, signature))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use ed25519_dalek::{Keypair, Signer};

    #[test]
    fn test_identity_management() {
        let mut manager = IdentityManager::new();
        
        // Create a new identity
        let mut attributes = HashMap::new();
        attributes.insert("name".to_string(), "Alice".to_string());
        let identity = manager.create_identity(attributes).unwrap();
        
        // Verify the identity exists
        assert!(manager.get_identity(&identity.id).is_some());
        
        // Update reputation
        assert!(manager.update_reputation(&identity.id, 0.5).is_ok());
        let updated_identity = manager.get_identity(&identity.id).unwrap();
        assert_eq!(updated_identity.reputation, 1.5);
        
        // Test signature verification
        let message = b"Hello, World!";
        let mut csprng = rand::rngs::OsRng {};
        let keypair = Keypair::generate(&mut csprng);
        let signature = keypair.sign(message);
        
        // This should fail because we're using a different keypair
        assert!(!manager.verify_signature(&identity.id, message, &signature).unwrap());
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_identity/src/identity_manager.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_identity/src/lib.rs =====
use icn_common::{IcnResult, IcnError};
use ed25519_dalek::{Keypair, PublicKey, Signature, Signer, Verifier};
use rand::rngs::OsRng;
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};
use std::collections::HashMap;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct DecentralizedIdentity {
    pub id: String,
    #[serde(with = "public_key_serde")]
    pub public_key: PublicKey,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub reputation: f64,
    pub attributes: HashMap<String, String>,
    pub status: IdentityStatus,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub enum IdentityStatus {
    Active,
    Suspended,
    Revoked,
}

mod public_key_serde {
    use super::*;
    use serde::{Deserializer, Serializer};

    pub fn serialize<S>(public_key: &PublicKey, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let bytes = public_key.to_bytes();
        bytes.serialize(serializer)
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<PublicKey, D::Error>
    where
        D: Deserializer<'de>,
    {
        let bytes = Vec::<u8>::deserialize(deserializer)?;
        PublicKey::from_bytes(&bytes).map_err(serde::de::Error::custom)
    }
}

impl DecentralizedIdentity {
    pub fn new(attributes: HashMap<String, String>) -> IcnResult<(Self, Keypair)> {
        let mut csprng = OsRng {};
        let keypair: Keypair = Keypair::generate(&mut csprng);
        let public_key = keypair.public;
        let id = format!("did:icn:{}", hex::encode(public_key.to_bytes()));
        let now = Utc::now();

        Ok((
            Self {
                id,
                public_key,
                created_at: now,
                updated_at: now,
                reputation: 1.0,
                attributes,
                status: IdentityStatus::Active,
            },
            keypair,
        ))
    }

    pub fn verify_signature(&self, message: &[u8], signature: &Signature) -> bool {
        self.public_key.verify(message, signature).is_ok()
    }
}

pub struct IdentityManager {
    identities: HashMap<String, DecentralizedIdentity>,
}

impl IdentityManager {
    pub fn new() -> Self {
        IdentityManager {
            identities: HashMap::new(),
        }
    }

    pub fn create_identity(&mut self, attributes: HashMap<String, String>) -> IcnResult<DecentralizedIdentity> {
        let (identity, _) = DecentralizedIdentity::new(attributes)?;
        self.identities.insert(identity.id.clone(), identity.clone());
        Ok(identity)
    }

    pub fn get_identity(&self, id: &str) -> IcnResult<&DecentralizedIdentity> {
        self.identities.get(id).ok_or(IcnError::Identity("Identity not found".to_string()))
    }

    pub fn update_identity(&mut self, id: &str, attributes: HashMap<String, String>) -> IcnResult<()> {
        let identity = self.identities.get_mut(id).ok_or(IcnError::Identity("Identity not found".to_string()))?;
        identity.attributes.extend(attributes);
        identity.updated_at = Utc::now();
        Ok(())
    }

    pub fn update_reputation(&mut self, id: &str, change: f64) -> IcnResult<()> {
        let identity = self.identities.get_mut(id).ok_or(IcnError::Identity("Identity not found".to_string()))?;
        identity.reputation += change;
        identity.updated_at = Utc::now();
        Ok(())
    }

    pub fn suspend_identity(&mut self, id: &str) -> IcnResult<()> {
        let identity = self.identities.get_mut(id).ok_or(IcnError::Identity("Identity not found".to_string()))?;
        identity.status = IdentityStatus::Suspended;
        identity.updated_at = Utc::now();
        Ok(())
    }

    pub fn revoke_identity(&mut self, id: &str) -> IcnResult<()> {
        let identity = self.identities.get_mut(id).ok_or(IcnError::Identity("Identity not found".to_string()))?;
        identity.status = IdentityStatus::Revoked;
        identity.updated_at = Utc::now();
        Ok(())
    }

    pub fn verify_signature(&self, id: &str, message: &[u8], signature: &Signature) -> IcnResult<bool> {
        let identity = self.identities.get(id).ok_or(IcnError::Identity("Identity not found".to_string()))?;
        Ok(identity.verify_signature(message, signature))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use ed25519_dalek::Signer;

    #[test]
    fn test_identity_creation_and_verification() {
        let mut manager = IdentityManager::new();
        
        let mut attributes = HashMap::new();
        attributes.insert("name".to_string(), "Alice".to_string());
        
        let identity = manager.create_identity(attributes).unwrap();
        
        assert!(manager.get_identity(&identity.id).is_ok());
        
        let message = b"Hello, World!";
        let mut csprng = OsRng {};
        let keypair = Keypair::generate(&mut csprng);
        let signature = keypair.sign(message);
        
        // This should fail because we're using a different keypair
        assert!(!manager.verify_signature(&identity.id, message, &signature).unwrap());
        
        // Create a valid signature
        let (_, keypair) = DecentralizedIdentity::new(HashMap::new()).unwrap();
        let valid_signature = keypair.sign(message);
        
        // This should succeed
        assert!(manager.verify_signature(&identity.id, message, &valid_signature).unwrap());
    }

    #[test]
    fn test_identity_management() {
        let mut manager = IdentityManager::new();
        
        // Create an identity
        let mut attributes = HashMap::new();
        attributes.insert("name".to_string(), "Alice".to_string());
        let identity = manager.create_identity(attributes).unwrap();
        
        // Update identity
        let mut new_attributes = HashMap::new();
        new_attributes.insert("email".to_string(), "alice@example.com".to_string());
        assert!(manager.update_identity(&identity.id, new_attributes).is_ok());
        
        // Check updated identity
        let updated_identity = manager.get_identity(&identity.id).unwrap();
        assert_eq!(updated_identity.attributes.get("email"), Some(&"alice@example.com".to_string()));
        
        // Update reputation
        assert!(manager.update_reputation(&identity.id, 0.5).is_ok());
        let updated_identity = manager.get_identity(&identity.id).unwrap();
        assert_eq!(updated_identity.reputation, 1.5);
        
        // Suspend identity
        assert!(manager.suspend_identity(&identity.id).is_ok());
        let suspended_identity = manager.get_identity(&identity.id).unwrap();
        assert_eq!(suspended_identity.status, IdentityStatus::Suspended);
        
        // Revoke identity
        assert!(manager.revoke_identity(&identity.id).is_ok());
        let revoked_identity = manager.get_identity(&identity.id).unwrap();
        assert_eq!(revoked_identity.status, IdentityStatus::Revoked);
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_identity/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_incentives/Cargo.toml =====
[package]
name = "icn_incentives"
version = "0.1.0"
edition = "2021"

[dependencies]
===== END OF /home/matt/InterCooperative-Network/crates/icn_incentives/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_incentives/src/lib.rs =====
pub fn add(left: usize, right: usize) -> usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_incentives/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_market/Cargo.toml =====
[package]
name = "icn_market"
version = "0.1.0"
edition = "2021"

[dependencies]
===== END OF /home/matt/InterCooperative-Network/crates/icn_market/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_market/src/lib.rs =====
pub fn add(left: usize, right: usize) -> usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_market/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/Cargo.toml =====
[package]
name = "icn_network"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
log = "0.4"
thiserror = "1.0"

[dev-dependencies]
tokio = { version = "1.0", features = ["full"] }===== END OF /home/matt/InterCooperative-Network/crates/icn_network/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/src/discovery.rs =====
use icn_common::{IcnError, IcnResult};
use std::sync::{Arc, RwLock};
use log::{info, error};

/// Represents a node discovery mechanism in the network.
pub struct NodeDiscovery {
    discovered_nodes: Arc<RwLock<Vec<String>>>,
}

impl NodeDiscovery {
    /// Creates a new instance of NodeDiscovery.
    pub fn new() -> Self {
        NodeDiscovery {
            discovered_nodes: Arc::new(RwLock::new(Vec::new())),
        }
    }

    /// Starts the node discovery process.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn start(&self) -> IcnResult<()> {
        info!("Node discovery started");
        // Simulated discovery process
        let nodes = vec!["Node1".to_string(), "Node2".to_string()];
        let mut discovered_nodes = self.discovered_nodes.write().unwrap();
        *discovered_nodes = nodes;
        Ok(())
    }

    /// Stops the node discovery process.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn stop(&self) -> IcnResult<()> {
        info!("Node discovery stopped");
        let mut discovered_nodes = self.discovered_nodes.write().unwrap();
        discovered_nodes.clear();
        Ok(())
    }

    /// Retrieves the list of discovered nodes.
    ///
    /// # Returns
    ///
    /// * `Vec<String>` - A vector containing the discovered nodes.
    pub fn get_discovered_nodes(&self) -> Vec<String> {
        let discovered_nodes = self.discovered_nodes.read().unwrap();
        discovered_nodes.clone()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_node_discovery() {
        let discovery = NodeDiscovery::new();
        assert!(discovery.start().is_ok());
        assert_eq!(discovery.get_discovered_nodes().len(), 2);
        assert!(discovery.stop().is_ok());
        assert!(discovery.get_discovered_nodes().is_empty());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_network/src/discovery.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/src/lib.rs =====
use icn_common::{IcnResult, IcnError};
use serde::{Serialize, Deserialize};
use std::collections::{HashMap, HashSet};
use std::net::SocketAddr;
use tokio::sync::mpsc;
use log::{info, warn, error};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PacketType {
    Ping,
    Pong,
    PeerDiscovery,
    Transaction,
    Block,
    Consensus,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Packet {
    pub packet_type: PacketType,
    pub source: SocketAddr,
    pub destination: SocketAddr,
    pub content: Vec<u8>,
}

#[derive(Debug)]
pub struct Peer {
    pub address: SocketAddr,
    pub last_seen: std::time::Instant,
}

pub struct Network {
    local_addr: SocketAddr,
    peers: HashMap<SocketAddr, Peer>,
    pending_connections: HashSet<SocketAddr>,
    packet_sender: mpsc::Sender<Packet>,
    packet_receiver: mpsc::Receiver<Packet>,
}

impl Network {
    pub fn new(local_addr: SocketAddr) -> Self {
        let (packet_sender, packet_receiver) = mpsc::channel(100);
        Network {
            local_addr,
            peers: HashMap::new(),
            pending_connections: HashSet::new(),
            packet_sender,
            packet_receiver,
        }
    }

    pub async fn start(&mut self) -> IcnResult<()> {
        info!("Starting network on {}", self.local_addr);
        // TODO: Implement actual network initialization
        Ok(())
    }

    pub async fn stop(&mut self) -> IcnResult<()> {
        info!("Stopping network");
        // TODO: Implement network shutdown
        Ok(())
    }

    pub async fn connect_to_peer(&mut self, peer_addr: SocketAddr) -> IcnResult<()> {
        if self.peers.contains_key(&peer_addr) || self.pending_connections.contains(&peer_addr) {
            return Ok(());
        }

        self.pending_connections.insert(peer_addr);
        // TODO: Implement actual peer connection logic
        info!("Connecting to peer: {}", peer_addr);
        
        // Simulating successful connection
        self.add_peer(peer_addr)?;
        self.pending_connections.remove(&peer_addr);
        Ok(())
    }

    pub fn add_peer(&mut self, peer_addr: SocketAddr) -> IcnResult<()> {
        if self.peers.contains_key(&peer_addr) {
            return Err(IcnError::Network("Peer already connected".into()));
        }

        let peer = Peer {
            address: peer_addr,
            last_seen: std::time::Instant::now(),
        };
        self.peers.insert(peer_addr, peer);
        info!("Added new peer: {}", peer_addr);
        Ok(())
    }

    pub fn remove_peer(&mut self, peer_addr: &SocketAddr) -> IcnResult<()> {
        if self.peers.remove(peer_addr).is_none() {
            return Err(IcnError::Network("Peer not found".into()));
        }
        info!("Removed peer: {}", peer_addr);
        Ok(())
    }

    pub async fn send_packet(&self, packet: Packet) -> IcnResult<()> {
        self.packet_sender.send(packet).await.map_err(|e| IcnError::Network(format!("Failed to send packet: {}", e)))
    }

    pub async fn receive_packet(&mut self) -> IcnResult<Packet> {
        self.packet_receiver.recv().await.ok_or(IcnError::Network("Failed to receive packet".into()))
    }

    pub async fn broadcast(&self, packet_type: PacketType, content: Vec<u8>) -> IcnResult<()> {
        for peer_addr in self.peers.keys() {
            let packet = Packet {
                packet_type: packet_type.clone(),
                source: self.local_addr,
                destination: *peer_addr,
                content: content.clone(),
            };
            self.send_packet(packet).await?;
        }
        Ok(())
    }

    pub fn get_peers(&self) -> Vec<SocketAddr> {
        self.peers.keys().cloned().collect()
    }

    pub async fn handle_incoming_packets(&mut self) -> IcnResult<()> {
        while let Ok(packet) = self.receive_packet().await {
            match packet.packet_type {
                PacketType::Ping => self.handle_ping(packet).await?,
                PacketType::Pong => self.handle_pong(packet).await?,
                PacketType::PeerDiscovery => self.handle_peer_discovery(packet).await?,
                PacketType::Transaction => self.handle_transaction(packet).await?,
                PacketType::Block => self.handle_block(packet).await?,
                PacketType::Consensus => self.handle_consensus(packet).await?,
            }
        }
        Ok(())
    }

    async fn handle_ping(&self, packet: Packet) -> IcnResult<()> {
        let pong = Packet {
            packet_type: PacketType::Pong,
            source: self.local_addr,
            destination: packet.source,
            content: vec![],
        };
        self.send_packet(pong).await
    }

    async fn handle_pong(&mut self, packet: Packet) -> IcnResult<()> {
        if let Some(peer) = self.peers.get_mut(&packet.source) {
            peer.last_seen = std::time::Instant::now();
        }
        Ok(())
    }

    async fn handle_peer_discovery(&mut self, packet: Packet) -> IcnResult<()> {
        let peer_addresses: Vec<SocketAddr> = bincode::deserialize(&packet.content)
            .map_err(|e| IcnError::Network(format!("Failed to deserialize peer addresses: {}", e)))?;

        for addr in peer_addresses {
            if addr != self.local_addr && !self.peers.contains_key(&addr) {
                self.connect_to_peer(addr).await?;
            }
        }

        // Share our known peers with the sender
        let our_peers: Vec<SocketAddr> = self.peers.keys().cloned().collect();
        let response = Packet {
            packet_type: PacketType::PeerDiscovery,
            source: self.local_addr,
            destination: packet.source,
            content: bincode::serialize(&our_peers)
                .map_err(|e| IcnError::Network(format!("Failed to serialize peer addresses: {}", e)))?,
        };
        self.send_packet(response).await
    }

    async fn handle_transaction(&self, packet: Packet) -> IcnResult<()> {
        // TODO: Implement transaction handling logic
        // For now, we'll just log the received transaction
        info!("Received transaction from {}", packet.source);
        Ok(())
    }

    async fn handle_block(&self, packet: Packet) -> IcnResult<()> {
        // TODO: Implement block handling logic
        // For now, we'll just log the received block
        info!("Received block from {}", packet.source);
        Ok(())
    }

    async fn handle_consensus(&self, packet: Packet) -> IcnResult<()> {
        // TODO: Implement consensus message handling logic
        // For now, we'll just log the received consensus message
        info!("Received consensus message from {}", packet.source);
        Ok(())
    }

    pub async fn maintain_network(&mut self) -> IcnResult<()> {
        let mut interval = tokio::time::interval(std::time::Duration::from_secs(60));
        loop {
            interval.tick().await;
            self.remove_inactive_peers().await?;
            self.discover_new_peers().await?;
        }
    }

    async fn remove_inactive_peers(&mut self) -> IcnResult<()> {
        let now = std::time::Instant::now();
        let inactive_peers: Vec<SocketAddr> = self.peers
            .iter()
            .filter(|(_, peer)| now.duration_since(peer.last_seen) > std::time::Duration::from_secs(300))
            .map(|(addr, _)| *addr)
            .collect();

        for addr in inactive_peers {
            self.remove_peer(&addr)?;
        }
        Ok(())
    }

    async fn discover_new_peers(&mut self) -> IcnResult<()> {
        let peer_discovery_packet = Packet {
            packet_type: PacketType::PeerDiscovery,
            source: self.local_addr,
            destination: self.local_addr, // This will be replaced for each peer
            content: bincode::serialize(&self.get_peers())
                .map_err(|e| IcnError::Network(format!("Failed to serialize peer addresses: {}", e)))?,
        };

        for peer_addr in self.get_peers() {
            let mut packet = peer_discovery_packet.clone();
            packet.destination = peer_addr;
            self.send_packet(packet).await?;
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tokio::runtime::Runtime;

    #[test]
    fn test_network_operations() {
        let rt = Runtime::new().unwrap();
        rt.block_on(async {
            let mut network = Network::new("127.0.0.1:8000".parse().unwrap());
            
            // Test starting the network
            assert!(network.start().await.is_ok());

            // Test adding a peer
            let peer_addr: SocketAddr = "127.0.0.1:8001".parse().unwrap();
            assert!(network.connect_to_peer(peer_addr).await.is_ok());
            assert_eq!(network.get_peers().len(), 1);

            // Test removing a peer
            assert!(network.remove_peer(&peer_addr).is_ok());
            assert_eq!(network.get_peers().len(), 0);

            // Test sending a packet
            let packet = Packet {
                packet_type: PacketType::Ping,
                source: network.local_addr,
                destination: peer_addr,
                content: vec![],
            };
            assert!(network.send_packet(packet).await.is_ok());

            // Test stopping the network
            assert!(network.stop().await.is_ok());
        });
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_network/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/src/naming.rs =====
use icn_common::{IcnError, IcnResult};
use log::{info, error};

/// Represents a naming service in the ICN project.
pub struct NamingService;

impl NamingService {
    /// Creates a new instance of NamingService.
    pub fn new() -> Self {
        NamingService
    }

    /// Starts the naming service.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn start(&self) -> IcnResult<()> {
        info!("Naming service started");
        // Simulated naming service start process
        Ok(())
    }

    /// Stops the naming service.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn stop(&self) -> IcnResult<()> {
        info!("Naming service stopped");
        // Simulated naming service stop process
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_naming_service_start_and_stop() {
        let naming_service = NamingService::new();
        assert!(naming_service.start().is_ok());
        assert!(naming_service.stop().is_ok());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_network/src/naming.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/src/network.rs =====
use crate::{discovery::NodeDiscovery, protocol::NetworkProtocol, routing::Router, security::NetworkSecurity};
use icn_common::{IcnError, IcnResult};
use std::sync::{Arc, RwLock};

/// Represents a network in the ICN project.
pub struct Network {
    discovery: Arc<RwLock<NodeDiscovery>>,
    protocol: Arc<RwLock<NetworkProtocol>>,
    router: Arc<RwLock<Router>>,
    security: Arc<RwLock<NetworkSecurity>>,
}

impl Network {
    /// Creates a new network instance.
    ///
    /// # Arguments
    ///
    /// * `discovery` - Arc to the node discovery module.
    /// * `protocol` - Arc to the network protocol module.
    /// * `router` - Arc to the routing module.
    /// * `security` - Arc to the network security module.
    ///
    /// # Returns
    ///
    /// * `Network` - A new instance of Network.
    pub fn new(
        discovery: Arc<RwLock<NodeDiscovery>>,
        protocol: Arc<RwLock<NetworkProtocol>>,
        router: Arc<RwLock<Router>>,
        security: Arc<RwLock<NetworkSecurity>>,
    ) -> Self {
        Network {
            discovery,
            protocol,
            router,
            security,
        }
    }

    /// Starts the network.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn start(&self) -> IcnResult<()> {
        let discovery = self.discovery.read().unwrap();
        discovery.start()?;

        let protocol = self.protocol.read().unwrap();
        protocol.start()?;

        let router = self.router.read().unwrap();
        router.start()?;

        let security = self.security.read().unwrap();
        security.start()?;

        Ok(())
    }

    /// Stops the network.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn stop(&self) -> IcnResult<()> {
        let discovery = self.discovery.read().unwrap();
        discovery.stop()?;

        let protocol = self.protocol.read().unwrap();
        protocol.stop()?;

        let router = self.router.read().unwrap();
        router.stop()?;

        let security = self.security.read().unwrap();
        security.stop()?;

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::discovery::MockNodeDiscovery;
    use crate::protocol::MockNetworkProtocol;
    use crate::routing::MockRouter;
    use crate::security::MockNetworkSecurity;
    use std::sync::Arc;

    #[test]
    fn test_network_start_and_stop() {
        let discovery = Arc::new(RwLock::new(MockNodeDiscovery::new()));
        let protocol = Arc::new(RwLock::new(MockNetworkProtocol::new()));
        let router = Arc::new(RwLock::new(MockRouter::new()));
        let security = Arc::new(RwLock::new(MockNetworkSecurity::new()));

        let network = Network::new(discovery, protocol, router, security);

        assert!(network.start().is_ok());
        assert!(network.stop().is_ok());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_network/src/network.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/src/node.rs =====
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub enum NodeType {
    PersonalDevice,
    CooperativeServer,
    GovernmentServer,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Node {
    pub id: String,
    pub node_type: NodeType,
    pub address: String,
}

impl Node {
    pub fn new(id: &str, node_type: NodeType, address: &str) -> Self {
        Node {
            id: id.to_string(),
            node_type,
            address: address.to_string(),
        }
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_network/src/node.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/src/packet.rs =====
use icn_common::{IcnError, IcnResult};
use serde::{Serialize, Deserialize};

/// Represents a network packet in the ICN project.
#[derive(Serialize, Deserialize, Debug)]
pub struct Packet {
    pub source: String,
    pub destination: String,
    pub payload: Vec<u8>,
}

impl Packet {
    /// Creates a new packet.
    ///
    /// # Arguments
    ///
    /// * `source` - The source address.
    /// * `destination` - The destination address.
    /// * `payload` - The packet payload.
    ///
    /// # Returns
    ///
    /// * `Packet` - A new instance of Packet.
    pub fn new(source: String, destination: String, payload: Vec<u8>) -> Self {
        Packet {
            source,
            destination,
            payload,
        }
    }

    /// Validates the packet.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the packet is invalid.
    pub fn validate(&self) -> IcnResult<()> {
        if self.source.is_empty() || self.destination.is_empty() {
            return Err(IcnError::Network("Invalid packet: source or destination is empty".into()));
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_packet_creation_and_validation() {
        let packet = Packet::new("Source".to_string(), "Destination".to_string(), vec![1, 2, 3]);
        assert!(packet.validate().is_ok());

        let invalid_packet = Packet::new("".to_string(), "Destination".to_string(), vec![1, 2, 3]);
        assert!(invalid_packet.validate().is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_network/src/packet.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/src/protocol.rs =====
use icn_common::{IcnError, IcnResult};
use log::{info, error};

/// Represents a network protocol in the ICN project.
pub struct NetworkProtocol;

impl NetworkProtocol {
    /// Creates a new instance of NetworkProtocol.
    pub fn new() -> Self {
        NetworkProtocol
    }

    /// Starts the network protocol.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn start(&self) -> IcnResult<()> {
        info!("Network protocol started");
        // Simulated protocol start process
        Ok(())
    }

    /// Stops the network protocol.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn stop(&self) -> IcnResult<()> {
        info!("Network protocol stopped");
        // Simulated protocol stop process
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_protocol_start_and_stop() {
        let protocol = NetworkProtocol::new();
        assert!(protocol.start().is_ok());
        assert!(protocol.stop().is_ok());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_network/src/protocol.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/src/routing.rs =====
use icn_common::{IcnError, IcnResult};
use log::{info, error};

/// Represents a router in the ICN project.
pub struct Router;

impl Router {
    /// Creates a new instance of Router.
    pub fn new() -> Self {
        Router
    }

    /// Starts the router.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn start(&self) -> IcnResult<()> {
        info!("Router started");
        // Simulated router start process
        Ok(())
    }

    /// Stops the router.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn stop(&self) -> IcnResult<()> {
        info!("Router stopped");
        // Simulated router stop process
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_router_start_and_stop() {
        let router = Router::new();
        assert!(router.start().is_ok());
        assert!(router.stop().is_ok());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_network/src/routing.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/src/security.rs =====
use icn_common::{IcnError, IcnResult};
use log::{info, error};

/// Represents network security in the ICN project.
pub struct NetworkSecurity;

impl NetworkSecurity {
    /// Creates a new instance of NetworkSecurity.
    pub fn new() -> Self {
        NetworkSecurity
    }

    /// Starts the network security module.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn start(&self) -> IcnResult<()> {
        info!("Network security started");
        // Simulated security start process
        Ok(())
    }

    /// Stops the network security module.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn stop(&self) -> IcnResult<()> {
        info!("Network security stopped");
        // Simulated security stop process
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_security_start_and_stop() {
        let security = NetworkSecurity::new();
        assert!(security.start().is_ok());
        assert!(security.stop().is_ok());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_network/src/security.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_node_management/Cargo.toml =====
[package]
name = "icn_node_management"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_core = { path = "../icn_core" }
icn_network = { path = "../icn_network" }
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
log = "0.4"
thiserror = "1.0"

[dev-dependencies]
tokio = { version = "1.0", features = ["full"] }
===== END OF /home/matt/InterCooperative-Network/crates/icn_node_management/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/content_store.rs =====
use std::collections::HashMap;
use std::time::{Duration, Instant};

const MAX_CACHE_SIZE: usize = 1000;
const DEFAULT_TTL: Duration = Duration::from_secs(3600);

struct CacheEntry {
    content: Vec<u8>,
    timestamp: Instant,
    ttl: Duration,
}

pub struct ContentStore {
    cache: HashMap<String, CacheEntry>,
}

impl ContentStore {
    pub fn new() -> Self {
        ContentStore {
            cache: HashMap::new(),
        }
    }

    pub fn add(&mut self, name: String, content: Vec<u8>) {
        self.cache.insert(name, CacheEntry {
            content,
            timestamp: Instant::now(),
            ttl: DEFAULT_TTL,
        });

        if self.cache.len() > MAX_CACHE_SIZE {
            self.evict_oldest();
        }
    }

    pub fn get(&self, name: &str) -> Option<Vec<u8>> {
        self.cache.get(name).and_then(|entry| {
            if entry.timestamp.elapsed() < entry.ttl {
                Some(entry.content.clone())
            } else {
                None
            }
        })
    }

    pub fn get_and_pop(&mut self, name: &str) -> Option<Vec<u8>> {
        if let Some(entry) = self.cache.remove(name) {
            if entry.timestamp.elapsed() < entry.ttl {
                Some(entry.content)
            } else {
                None
            }
        } else {
            None
        }
    }

    fn evict_oldest(&mut self) {
        if let Some(oldest_key) = self.cache.keys().next().cloned() {
            self.cache.remove(&oldest_key);
        }
    }

    pub fn remove_expired(&mut self) {
        let now = Instant::now();
        self.cache.retain(|_, entry| now.duration_since(entry.timestamp) < entry.ttl);
    }

    pub fn set_ttl(&mut self, name: &str, ttl: Duration) {
        if let Some(entry) = self.cache.get_mut(name) {
            entry.ttl = ttl;
        }
    }

    pub fn is_empty(&self) -> bool {
        self.cache.is_empty()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_content_store() {
        let mut cs = ContentStore::new();
        let content = vec![1, 2, 3, 4];
        cs.add("test".to_string(), content.clone());

        assert_eq!(cs.get("test"), Some(content.clone()));
        assert_eq!(cs.get("nonexistent"), None);

        cs.set_ttl("test", Duration::from_secs(1));
        std::thread::sleep(Duration::from_secs(2));
        assert_eq!(cs.get("test"), None);

        cs.add("test2".to_string(), vec![5, 6, 7, 8]);
        assert!(!cs.is_empty());

        cs.remove_expired();
        assert_eq!(cs.get("test2"), Some(vec![5, 6, 7, 8]));
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/content_store.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/fib.rs =====
use std::collections::HashMap;
use std::net::SocketAddr;

/// Represents an entry in the Forwarding Information Base (FIB).
#[derive(Debug, Clone)]
pub struct FibEntry {
    pub name: String,           // The name of the content or prefix.
    pub next_hops: Vec<SocketAddr>, // The list of next hop addresses.
}

impl FibEntry {
    pub fn new(name: String, next_hop: SocketAddr) -> Self {
        FibEntry {
            name,
            next_hops: vec![next_hop],
        }
    }

    pub fn add_next_hop(&mut self, next_hop: SocketAddr) {
        if !self.next_hops.contains(&next_hop) {
            self.next_hops.push(next_hop);
        }
    }

    pub fn remove_next_hop(&mut self, next_hop: &SocketAddr) {
        self.next_hops.retain(|&x| x != *next_hop);
    }
}

/// Represents the Forwarding Information Base (FIB) which stores FIB entries.
pub struct ForwardingInformationBase {
    entries: HashMap<String, FibEntry>, // The collection of FIB entries, indexed by name.
}

impl ForwardingInformationBase {
    pub fn new() -> Self {
        ForwardingInformationBase {
            entries: HashMap::new(),
        }
    }

    pub fn add_entry(&mut self, name: String, next_hop: SocketAddr) {
        self.entries
            .entry(name.clone())
            .and_modify(|e| e.add_next_hop(next_hop))
            .or_insert_with(|| FibEntry::new(name, next_hop));
    }

    pub fn remove_entry(&mut self, name: &str) {
        self.entries.remove(name);
    }

    pub fn get_next_hops(&self, name: &str) -> Option<&Vec<SocketAddr>> {
        self.entries.get(name).map(|entry| &entry.next_hops)
    }

    pub fn longest_prefix_match(&self, name: &str) -> Option<&FibEntry> {
        self.entries
            .iter()
            .filter(|(prefix, _)| name.starts_with(*prefix))
            .max_by_key(|(prefix, _)| prefix.len())
            .map(|(_, entry)| entry)
    }

    pub fn is_empty(&self) -> bool {
        self.entries.is_empty()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fib() {
        let mut fib = ForwardingInformationBase::new();

        let addr1: SocketAddr = "127.0.0.1:8000".parse().unwrap();
        let addr2: SocketAddr = "127.0.0.1:8001".parse().unwrap();

        fib.add_entry("/test".to_string(), addr1);
        fib.add_entry("/test/nested".to_string(), addr2);

        assert_eq!(fib.get_next_hops("/test").unwrap().len(), 1);
        assert_eq!(fib.get_next_hops("/test/nested").unwrap().len(), 1);

        let longest_match = fib.longest_prefix_match("/test/nested/deep");
        assert!(longest_match.is_some());
        assert_eq!(longest_match.unwrap().name, "/test/nested");

        fib.remove_entry("/test");
        assert!(fib.get_next_hops("/test").is_none());

        let mut entry = FibEntry::new("/example".to_string(), addr1);
        entry.add_next_hop(addr2);
        assert_eq!(entry.next_hops.len(), 2);
        entry.remove_next_hop(&addr1);
        assert_eq!(entry.next_hops.len(), 1);
        assert_eq!(entry.next_hops[0], addr2);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/fib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/icn_node.rs =====
// ===============================================
// ICN Node Implementation
// ===============================================
// This file contains the main implementation for the ICN (InterCooperative Network) node.
// It includes module declarations and the primary structure and functions for node operations.
//
// Key concepts:
// - Modular Structure: Using Rust's module system to organize code.
// - Node Operations: Handling packets, managing blockchain state, and executing smart contracts.

pub mod blockchain;
pub mod consensus;
pub mod currency;
pub mod democracy;
pub mod did;
pub mod network;
pub mod node;
pub mod smart_contract;
pub mod vm;

pub use crate::blockchain::{Block, Transaction, Blockchain};
pub use crate::consensus::PoCConsensus;
pub use crate::currency::{CurrencyType, CurrencySystem, Wallet};
pub use crate::democracy::{DemocraticSystem, ProposalCategory, ProposalType};
pub use crate::did::{DecentralizedIdentity, DidManager};
pub use crate::network::{Node as NetworkNode, Network};
pub use crate::node::{ContentStore, ForwardingInformationBase, Packet, PacketType, PendingInterestTable};
pub use crate::blockchain::TransactionValidator;
pub use crate::vm::{CoopVM, Opcode, Value, CSCLCompiler};

use std::sync::{Arc, Mutex};
use std::error::Error;

/// ICN Node Structure
///
/// This struct represents a node in the InterCooperative Network (ICN).
/// It holds the state for content storage, pending interest table (PIT), forwarding information base (FIB),
/// the blockchain, and the cooperative virtual machine (CoopVM).
///
/// # Fields
/// * `content_store` - Stores data packets
/// * `pit` - Manages pending interest table for interest packets
/// * `fib` - Manages forwarding information base for routing
/// * `blockchain` - The blockchain state
/// * `coop_vm` - The cooperative virtual machine for executing smart contracts
pub struct ICNNode {
    pub content_store: Arc<Mutex<ContentStore>>,
    pub pit: Arc<Mutex<PendingInterestTable>>,
    pub fib: Arc<Mutex<ForwardingInformationBase>>,
    pub blockchain: Arc<Mutex<Blockchain>>,
    pub coop_vm: Arc<Mutex<CoopVM>>,
}

impl ICNNode {
    /// Creates a new ICN Node
    ///
    /// This function initializes a new ICN node with the provided blockchain and cooperative VM instances.
    ///
    /// # Arguments
    /// * `blockchain` - The initial blockchain state
    /// * `coop_vm` - The initial cooperative VM instance
    ///
    /// # Returns
    /// A new instance of `ICNNode`
    pub fn new(blockchain: Blockchain, coop_vm: CoopVM) -> Self {
        Self {
            content_store: Arc::new(Mutex::new(ContentStore::new())),
            pit: Arc::new(Mutex::new(PendingInterestTable::new())),
            fib: Arc::new(Mutex::new(ForwardingInformationBase::new())),
            blockchain: Arc::new(Mutex::new(blockchain)),
            coop_vm: Arc::new(Mutex::new(coop_vm)),
        }
    }

    /// Processes an incoming packet
    ///
    /// This function processes different types of packets by delegating to the appropriate handler.
    ///
    /// # Arguments
    /// * `packet` - The packet to be processed
    ///
    /// # Returns
    /// A result indicating success or failure
    ///
    /// # Errors
    /// This function will return an error if the packet processing fails.
    pub fn process_packet(&self, packet: Packet) -> Result<(), Box<dyn Error>> {
        match packet.packet_type {
            PacketType::Interest => self.process_interest(packet),
            PacketType::Data => self.process_data(packet),
        }
    }

    /// Processes an interest packet
    ///
    /// Interest packets request specific data from the network. This function handles those requests.
    ///
    /// # Arguments
    /// * `packet` - The interest packet to be processed
    ///
    /// # Returns
    /// A result indicating success or failure
    ///
    /// # Errors
    /// This function will return an error if processing the interest packet fails.
    fn process_interest(&self, packet: Packet) -> Result<(), Box<dyn Error>> {
        // Logic to process interest packets
        Ok(())
    }

    /// Processes a data packet
    ///
    /// Data packets contain the requested information. This function handles those packets.
    ///
    /// # Arguments
    /// * `packet` - The data packet to be processed
    ///
    /// # Returns
    /// A result indicating success or failure
    ///
    /// # Errors
    /// This function will return an error if processing the data packet fails.
    fn process_data(&self, packet: Packet) -> Result<(), Box<dyn Error>> {
        // Logic to process data packets
        Ok(())
    }

    /// Executes a smart contract
    ///
    /// This function executes a given smart contract using the cooperative VM.
    ///
    /// # Arguments
    /// * `contract` - The smart contract to be executed
    ///
    /// # Returns
    /// A result indicating success or failure
    ///
    /// # Errors
    /// This function will return an error if executing the smart contract fails.
    pub fn execute_smart_contract(&self, contract: String) -> Result<(), Box<dyn Error>> {
        // Logic to execute smart contract
        Ok(())
    }

    /// Compiles a smart contract
    ///
    /// This function compiles a smart contract string into a sequence of opcodes.
    ///
    /// # Arguments
    /// * `contract` - The smart contract code as a string
    ///
    /// # Returns
    /// A vector of opcodes representing the compiled contract
    ///
    /// # Errors
    /// This function will return an error if compiling the contract fails.
    fn compile_contract(&self, contract: &str) -> Result<Vec<Opcode>, Box<dyn Error>> {
        // Logic to compile contract
        Ok(vec![])
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/icn_node.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/lib.rs =====
mod content_store;
mod fib;
mod pit;

pub use content_store::ContentStore;
pub use fib::ForwardingInformationBase;
pub use pit::PendingInterestTable;

use icn_core::error::{Error, Result};
use icn_network::Node as NetworkNode;

pub struct IcnNodeManager {
    network_node: NetworkNode,
    content_store: ContentStore,
    fib: ForwardingInformationBase,
    pit: PendingInterestTable,
}

impl IcnNodeManager {
    pub fn new(network_node: NetworkNode) -> Self {
        IcnNodeManager {
            network_node,
            content_store: ContentStore::new(),
            fib: ForwardingInformationBase::new(),
            pit: PendingInterestTable::new(),
        }
    }

    pub fn add_content(&mut self, name: String, content: Vec<u8>) -> Result<()> {
        self.content_store.add(name, content);
        Ok(())
    }

    pub fn get_content(&self, name: &str) -> Option<Vec<u8>> {
        self.content_store.get(name)
    }

    pub fn add_fib_entry(&mut self, prefix: String, next_hop: String) -> Result<()> {
        self.fib.add_entry(prefix, next_hop);
        Ok(())
    }

    pub fn add_pit_entry(&mut self, name: String, incoming_face: String) -> Result<()> {
        self.pit.add_interest(name, &incoming_face);
        Ok(())
    }

    pub fn remove_expired_content(&mut self) {
        self.content_store.remove_expired();
    }

    pub fn clear_expired_pit_entries(&mut self) {
        self.pit.clear_expired();
    }

    pub fn process_interest_packet(&self, packet: Packet) -> Result<()> {
        // Logic to process interest packets
        Ok(())
    }

    pub fn process_data_packet(&self, packet: Packet) -> Result<()> {
        // Logic to process data packets
        Ok(())
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/node.rs =====
// ===============================================
// Content Store, FIB, and PIT Implementation
// ===============================================
// This file defines the structures and methods for the Content Store, Forwarding Information Base (FIB),
// and Pending Interest Table (PIT) used in the ICN Node.
//
// Key concepts:
// - Content Store: A cache for storing data packets temporarily.
// - Forwarding Information Base (FIB): A table that stores routing information for named data.
// - Pending Interest Table (PIT): A table that keeps track of interests that have been forwarded but not yet satisfied.

use std::collections::HashMap;

/// A struct representing a packet in the ICN Node.
#[derive(Clone)]
pub struct Packet {
    pub packet_type: PacketType,
    pub name: String,
    pub content: Vec<u8>,
}

/// Enum representing the type of a packet, either Interest or Data.
#[derive(Clone)]
pub enum PacketType {
    Interest,
    Data,
}

/// A struct representing the Content Store.
pub struct ContentStore {
    store: HashMap<String, Vec<u8>>,
}

impl ContentStore {
    /// Creates a new Content Store.
    pub fn new() -> Self {
        ContentStore {
            store: HashMap::new(),
        }
    }

    /// Inserts data into the Content Store.
    /// # Arguments
    /// * `name` - The name of the data.
    /// * `content` - The content of the data.
    pub fn insert(&mut self, name: String, content: Vec<u8>) {
        self.store.insert(name, content);
    }

    /// Retrieves data from the Content Store.
    /// # Arguments
    /// * `name` - The name of the data.
    /// # Returns
    /// An optional reference to the content if it exists.
    pub fn get(&self, name: &str) -> Option<&Vec<u8>> {
        self.store.get(name)
    }

    /// Checks if the Content Store is empty.
    /// # Returns
    /// True if the Content Store is empty, otherwise false.
    pub fn is_empty(&self) -> bool {
        self.store.is_empty()
    }
}

/// A struct representing the Forwarding Information Base (FIB).
pub struct ForwardingInformationBase {
    table: HashMap<String, Vec<String>>,
}

impl ForwardingInformationBase {
    /// Creates a new FIB.
    pub fn new() -> Self {
        ForwardingInformationBase {
            table: HashMap::new(),
        }
    }

    /// Adds an entry to the FIB.
    /// # Arguments
    /// * `name` - The name of the data.
    /// * `interface` - The interface to forward the data.
    pub fn add_entry(&mut self, name: String, interface: String) {
        self.table.entry(name).or_insert(Vec::new()).push(interface);
    }

    /// Retrieves the interfaces for a given name from the FIB.
    /// # Arguments
    /// * `name` - The name of the data.
    /// # Returns
    /// An optional reference to a vector of interfaces if they exist.
    pub fn get_interfaces(&self, name: &str) -> Option<&Vec<String>> {
        self.table.get(name)
    }

    /// Checks if the FIB is empty.
    /// # Returns
    /// True if the FIB is empty, otherwise false.
    pub fn is_empty(&self) -> bool {
        self.table.is_empty()
    }
}

/// A struct representing the Pending Interest Table (PIT).
pub struct PendingInterestTable {
    table: HashMap<String, Vec<String>>,
}

impl PendingInterestTable {
    /// Creates a new PIT.
    pub fn new() -> Self {
        PendingInterestTable {
            table: HashMap::new(),
        }
    }

    /// Adds an interest to the PIT.
    /// # Arguments
    /// * `name` - The name of the interest.
    /// * `interface` - The interface from which the interest came.
    pub fn add_interest(&mut self, name: String, interface: String) {
        self.table.entry(name).or_insert(Vec::new()).push(interface);
    }

    /// Retrieves the incoming interfaces for a given name from the PIT.
    /// # Arguments
    /// * `name` - The name of the interest.
    /// # Returns
    /// An optional reference to a vector of interfaces if they exist.
    pub fn get_incoming_interfaces(&self, name: &str) -> Option<&Vec<String>> {
        self.table.get(name)
    }

    /// Checks if the PIT is empty.
    /// # Returns
    /// True if the PIT is empty, otherwise false.
    pub fn is_empty(&self) -> bool {
        self.table.is_empty()
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/node.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/pit.rs =====
use std::collections::HashMap;
use std::time::{Duration, Instant};

const DEFAULT_INTEREST_LIFETIME: Duration = Duration::from_secs(4);

struct PitEntry {
    interfaces: Vec<String>,
    timestamp: Instant,
}

pub struct PendingInterestTable {
    entries: HashMap<String, PitEntry>,
}

impl PendingInterestTable {
    pub fn new() -> Self {
        PendingInterestTable {
            entries: HashMap::new(),
        }
    }

    pub fn add_interest(&mut self, name: String, interface: &str) {
        self.entries
            .entry(name)
            .and_modify(|e| {
                if !e.interfaces.contains(&interface.to_string()) {
                    e.interfaces.push(interface.to_string());
                }
                e.timestamp = Instant::now();
            })
            .or_insert(PitEntry {
                interfaces: vec![interface.to_string()],
                timestamp: Instant::now(),
            });
    }

    pub fn remove_interest(&mut self, name: &str) {
        self.entries.remove(name);
    }

    pub fn has_pending_interest(&self, name: &str) -> bool {
        self.entries.contains_key(name)
    }

    pub fn get_incoming_interfaces(&self, name: &str) -> Option<Vec<String>> {
        self.entries.get(name).map(|entry| entry.interfaces.clone())
    }

    pub fn add_incoming_interface(&mut self, name: &str, interface: &str) {
        if let Some(entry) = self.entries.get_mut(name) {
            if !entry.interfaces.contains(&interface.to_string()) {
                entry.interfaces.push(interface.to_string());
            }
        }
    }

    pub fn clear_expired(&mut self) {
        self.entries.retain(|_, entry| entry.timestamp.elapsed() < DEFAULT_INTEREST_LIFETIME);
    }

    pub fn is_empty(&self) -> bool {
        self.entries.is_empty()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pending_interest_table() {
        let mut pit = PendingInterestTable::new();
        
        pit.add_interest("test".to_string(), "interface1");
        assert!(pit.has_pending_interest("test"));
        
        pit.add_incoming_interface("test", "interface2");
        let interfaces = pit.get_incoming_interfaces("test").unwrap();
        assert_eq!(interfaces.len(), 2);
        assert!(interfaces.contains(&"interface1".to_string()));
        assert!(interfaces.contains(&"interface2".to_string()));
        
        pit.remove_interest("test");
        assert!(!pit.has_pending_interest("test"));

        pit.add_interest("test_expired".to_string(), "interface1");
        std::thread::sleep(Duration::from_secs(5));
        pit.clear_expired();
        assert!(!pit.has_pending_interest("test_expired"));
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/pit.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_reputation/Cargo.toml =====
[package]
name = "icn_reputation"
version = "0.1.0"
edition = "2021"

[dependencies]
===== END OF /home/matt/InterCooperative-Network/crates/icn_reputation/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_reputation/src/lib.rs =====
// File: crates/icn_reputation/src/lib.rs

use std::collections::HashMap;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReputationScore {
    score: f64,
    last_updated: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReputationEvent {
    entity_id: String,
    event_type: ReputationEventType,
    value: f64,
    timestamp: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ReputationEventType {
    Contribution,
    Participation,
    Feedback,
    Violation,
}

pub struct ReputationSystem {
    scores: HashMap<String, ReputationScore>,
    events: Vec<ReputationEvent>,
    decay_rate: f64,
    min_score: f64,
    max_score: f64,
}

impl ReputationSystem {
    pub fn new(decay_rate: f64, min_score: f64, max_score: f64) -> Self {
        ReputationSystem {
            scores: HashMap::new(),
            events: Vec::new(),
            decay_rate,
            min_score,
            max_score,
        }
    }

    pub fn add_event(&mut self, event: ReputationEvent) {
        self.events.push(event.clone());
        self.update_score(&event.entity_id, event);
    }

    pub fn get_score(&self, entity_id: &str) -> Option<f64> {
        self.scores.get(entity_id).map(|score| score.score)
    }

    fn update_score(&mut self, entity_id: &str, event: ReputationEvent) {
        let score = self.scores.entry(entity_id.to_string()).or_insert(ReputationScore {
            score: 0.0,
            last_updated: Utc::now(),
        });

        // Apply time decay
        let time_diff = (Utc::now() - score.last_updated).num_days() as f64;
        score.score *= (1.0 - self.decay_rate).powf(time_diff);

        // Update score based on event
        match event.event_type {
            ReputationEventType::Contribution | ReputationEventType::Participation => {
                score.score += event.value;
            }
            ReputationEventType::Feedback => {
                score.score += event.value * 0.5; // Feedback has less impact
            }
            ReputationEventType::Violation => {
                score.score -= event.value;
            }
        }

        // Ensure score is within bounds
        score.score = score.score.clamp(self.min_score, self.max_score);
        score.last_updated = Utc::now();
    }

    pub fn get_top_entities(&self, limit: usize) -> Vec<(String, f64)> {
        let mut entities: Vec<(String, f64)> = self.scores
            .iter()
            .map(|(id, score)| (id.clone(), score.score))
            .collect();
        entities.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());
        entities.truncate(limit);
        entities
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_reputation_system() {
        let mut system = ReputationSystem::new(0.01, 0.0, 100.0);

        // Add some events
        system.add_event(ReputationEvent {
            entity_id: "Alice".to_string(),
            event_type: ReputationEventType::Contribution,
            value: 10.0,
            timestamp: Utc::now(),
        });

        system.add_event(ReputationEvent {
            entity_id: "Bob".to_string(),
            event_type: ReputationEventType::Participation,
            value: 5.0,
            timestamp: Utc::now(),
        });

        // Check scores
        assert!(system.get_score("Alice").unwrap() > system.get_score("Bob").unwrap());

        // Add a violation for Alice
        system.add_event(ReputationEvent {
            entity_id: "Alice".to_string(),
            event_type: ReputationEventType::Violation,
            value: 3.0,
            timestamp: Utc::now(),
        });

        // Check top entities
        let top = system.get_top_entities(2);
        assert_eq!(top.len(), 2);
        assert_eq!(top[0].0, "Alice");
        assert_eq!(top[1].0, "Bob");
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_reputation/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_sharding/Cargo.toml =====
[package]
name = "icn_sharding"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
icn_blockchain = { path = "../icn_blockchain" }
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
log = "0.4"
thiserror = "1.0"
chrono = { version = "0.4", features = ["serde"] }
rand = "0.8"
sha2 = "0.9"

[dev-dependencies]
tokio-test = "0.4"===== END OF /home/matt/InterCooperative-Network/crates/icn_sharding/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_sharding/src/cross_shard_communication.rs =====
use crate::blockchain::Transaction;
use crate::sharding::ShardingManager;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{Mutex, mpsc};
use uuid::Uuid;
use icn_common::{Error, Result};

#[derive(Clone, Debug)]
pub struct CrossShardTransaction {
    pub transaction: Transaction,
    pub from_shard: u64,
    pub to_shard: u64,
    pub status: CrossShardTransactionStatus,
}

#[derive(Clone, Debug, PartialEq)]
pub enum CrossShardTransactionStatus {
    Initiated,
    LockAcquired,
    Committed,
    Failed(String),
}

pub struct CrossShardCommunicator {
    sharding_manager: Arc<Mutex<ShardingManager>>,
    pending_transactions: Arc<Mutex<HashMap<String, CrossShardTransaction>>>,
    tx_channels: HashMap<u64, mpsc::Sender<CrossShardTransaction>>,
}

impl CrossShardCommunicator {
    pub fn new(sharding_manager: Arc<Mutex<ShardingManager>>) -> Self {
        let pending_transactions = Arc::new(Mutex::new(HashMap::new()));
        let mut tx_channels = HashMap::new();
        let shard_count = sharding_manager.lock().unwrap().get_shard_count();
        
        for i in 0..shard_count {
            let (tx, mut rx) = mpsc::channel(100);
            tx_channels.insert(i, tx);
            let sm = Arc::clone(&sharding_manager);
            let pt = Arc::clone(&pending_transactions);
            
            tokio::spawn(async move {
                while let Some(transaction) = rx.recv().await {
                    if let Err(e) = Self::process_transaction(sm.clone(), pt.clone(), transaction).await {
                        log::error!("Error processing cross-shard transaction: {}", e);
                    }
                }
            });
        }

        CrossShardCommunicator {
            sharding_manager,
            pending_transactions,
            tx_channels,
        }
    }

    pub async fn initiate_cross_shard_transaction(&self, transaction: Transaction) -> Result<String> {
        let sharding_manager = self.sharding_manager.lock().await;
        let from_shard = sharding_manager.get_shard_for_address(&transaction.from);
        let to_shard = sharding_manager.get_shard_for_address(&transaction.to);

        if from_shard == to_shard {
            return Err(Error::ShardingError("Not a cross-shard transaction".to_string()));
        }

        let cross_shard_tx = CrossShardTransaction {
            transaction: transaction.clone(),
            from_shard,
            to_shard,
            status: CrossShardTransactionStatus::Initiated,
        };

        let tx_id = Uuid::new_v4().to_string();
        self.pending_transactions.lock().await.insert(tx_id.clone(), cross_shard_tx.clone());

        if let Some(tx) = self.tx_channels.get(&from_shard) {
            tx.send(cross_shard_tx).await.map_err(|e| Error::CommunicationError(e.to_string()))?;
        } else {
            return Err(Error::ShardingError(format!("Channel for shard {} not found", from_shard)));
        }

        Ok(tx_id)
    }

    async fn process_transaction(
        sharding_manager: Arc<Mutex<ShardingManager>>,
        pending_transactions: Arc<Mutex<HashMap<String, CrossShardTransaction>>>,
        mut transaction: CrossShardTransaction
    ) -> Result<()> {
        // Phase 1: Lock funds in the source shard
        {
            let mut sm = sharding_manager.lock().await;
            sm.lock_funds_in_shard(
                transaction.from_shard,
                &transaction.transaction.from,
                &transaction.transaction.currency_type,
                transaction.transaction.amount
            )?;
        }
        transaction.status = CrossShardTransactionStatus::LockAcquired;

        // Phase 2: Transfer funds to the destination shard
        {
            let mut sm = sharding_manager.lock().await;
            sm.transfer_between_shards(transaction.from_shard, transaction.to_shard, &transaction.transaction)?;
        }

        // Phase 3: Commit the transaction
        {
            let mut sm = sharding_manager.lock().await;
            sm.commit_cross_shard_transaction(&transaction.transaction, transaction.from_shard, transaction.to_shard)?;
        }

        transaction.status = CrossShardTransactionStatus::Committed;
        pending_transactions.lock().await.insert(Uuid::new_v4().to_string(), transaction);
        Ok(())
    }

    pub async fn get_transaction_status(&self, tx_id: &str) -> Option<CrossShardTransactionStatus> {
        self.pending_transactions.lock().await.get(tx_id).map(|tx| tx.status.clone())
    }

    pub async fn wait_for_transaction(&self, tx_id: &str, timeout: std::time::Duration) -> Result<CrossShardTransactionStatus> {
        let start_time = std::time::Instant::now();
        while start_time.elapsed() < timeout {
            if let Some(status) = self.get_transaction_status(tx_id).await {
                match status {
                    CrossShardTransactionStatus::Committed => return Ok(status),
                    CrossShardTransactionStatus::Failed(reason) => return Err(Error::TransactionFailed(reason)),
                    _ => tokio::time::sleep(std::time::Duration::from_millis(100)).await,
                }
            }
            tokio::time::sleep(std::time::Duration::from_millis(100)).await;
        }
        Err(Error::Timeout("Transaction timeout".to_string()))
    }

    pub async fn cleanup_completed_transactions(&self) {
        let mut pending_transactions = self.pending_transactions.lock().await;
        pending_transactions.retain(|_, tx| {
            match tx.status {
                CrossShardTransactionStatus::Committed => false,
                CrossShardTransactionStatus::Failed(_) => false,
                _ => true,
            }
        });
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_common::CurrencyType;
    use ed25519_dalek::Keypair;
    use rand::rngs::OsRng;

    #[tokio::test]
    async fn test_cross_shard_transaction() {
        let sharding_manager = Arc::new(Mutex::new(ShardingManager::new(2, 10)));
        let communicator = CrossShardCommunicator::new(sharding_manager.clone());

        {
            let mut sm = sharding_manager.lock().await;
            sm.add_address_to_shard("Alice".to_string(), 0);
            sm.add_address_to_shard("Bob".to_string(), 1);
            sm.initialize_balance("Alice".to_string(), CurrencyType::BasicNeeds, 1000.0).unwrap();
        }

        let mut csprng = OsRng{};
        let keypair: Keypair = Keypair::generate(&mut csprng);

        let mut transaction = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            200.0,
            CurrencyType::BasicNeeds,
            1000,
        );
        transaction.sign(&keypair).unwrap();

        let tx_id = communicator.initiate_cross_shard_transaction(transaction).await.unwrap();

        // Wait for the transaction to be processed
        let status = communicator.wait_for_transaction(&tx_id, std::time::Duration::from_secs(5)).await.unwrap();
        assert_eq!(status, CrossShardTransactionStatus::Committed);

        let sm = sharding_manager.lock().await;
        let alice_balance = sm.get_balance("Alice".to_string(), CurrencyType::BasicNeeds).unwrap();
        let bob_balance = sm.get_balance("Bob".to_string(), CurrencyType::BasicNeeds).unwrap();
        
        assert_eq!(alice_balance, 800.0);
        assert_eq!(bob_balance, 200.0);
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_sharding/src/cross_shard_communication.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_sharding/src/cross_shard_sync.rs =====
use icn_common::{Result, Error};
use icn_blockchain::Block;
use std::collections::HashMap;
use tokio::sync::RwLock;
use std::sync::Arc;

pub struct CrossShardSyncManager {
    shard_data: Arc<RwLock<HashMap<u64, Vec<Block>>>>,
}

impl CrossShardSyncManager {
    pub fn new() -> Self {
        CrossShardSyncManager {
            shard_data: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    pub async fn synchronize(&self, shard_id: u64, blocks: Vec<Block>) -> Result<()> {
        let mut shard_data = self.shard_data.write().await;
        shard_data.insert(shard_id, blocks);
        Ok(())
    }

    pub async fn get_shard_data(&self, shard_id: u64) -> Result<Vec<Block>> {
        let shard_data = self.shard_data.read().await;
        shard_data.get(&shard_id)
            .cloned()
            .ok_or_else(|| Error::ShardingError(format!("No data for shard {}", shard_id)))
    }

    pub async fn validate_cross_shard_state(&self) -> Result<bool> {
        // Implement cross-shard state validation logic here
        // This is a placeholder implementation
        Ok(true)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_blockchain::Transaction;

    #[tokio::test]
    async fn test_cross_shard_sync() {
        let sync_manager = CrossShardSyncManager::new();
        
        let block = Block {
            index: 1,
            timestamp: chrono::Utc::now().timestamp(),
            transactions: vec![Transaction::new(
                "Alice".to_string(),
                "Bob".to_string(),
                100.0,
                icn_common::CurrencyType::BasicNeeds,
                0,
            )],
            previous_hash: "previous_hash".to_string(),
            hash: "current_hash".to_string(),
        };

        sync_manager.synchronize(1, vec![block.clone()]).await.unwrap();
        
        let retrieved_blocks = sync_manager.get_shard_data(1).await.unwrap();
        assert_eq!(retrieved_blocks.len(), 1);
        assert_eq!(retrieved_blocks[0].hash, block.hash);

        assert!(sync_manager.validate_cross_shard_state().await.unwrap());
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_sharding/src/cross_shard_sync.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_sharding/src/cross_shard_transaction_manager.rs =====
use icn_common::{IcnResult, IcnError, Block, Transaction, CurrencyType};
use std::collections::HashMap;
use sha2::{Sha256, Digest};

pub struct Shard {
    pub id: u64,
    pub blockchain: Vec<Block>,
    pub balances: HashMap<String, HashMap<CurrencyType, f64>>,
    pub pending_transactions: Vec<Transaction>,
}

pub struct ShardingManager {
    shards: HashMap<u64, Shard>,
    shard_count: u64,
    address_to_shard: HashMap<String, u64>,
}

impl ShardingManager {
    pub fn new(shard_count: u64) -> Self {
        let mut shards = HashMap::new();
        for i in 0..shard_count {
            shards.insert(i, Shard {
                id: i,
                blockchain: vec![Block::genesis()],
                balances: HashMap::new(),
                pending_transactions: Vec::new(),
            });
        }
        
        ShardingManager {
            shards,
            shard_count,
            address_to_shard: HashMap::new(),
        }
    }

    pub fn get_shard_count(&self) -> u64 {
        self.shard_count
    }

    pub fn process_transaction(&mut self, transaction: &Transaction) -> IcnResult<()> {
        let shard_id = self.get_shard_for_address(&transaction.from);
        {
            let shard = self.shards.get_mut(&shard_id).ok_or_else(|| IcnError::Sharding("Shard not found".to_string()))?;
            if !self.verify_transaction(shard, transaction) {
                return Err(IcnError::Sharding("Invalid transaction".to_string()));
            }
            shard.pending_transactions.push(transaction.clone());
        }
        let shard = self.shards.get_mut(&shard_id).ok_or_else(|| IcnError::Sharding("Shard not found".to_string()))?;
        self.update_balances(shard, transaction)
    }

    fn update_balances(&mut self, shard: &mut Shard, transaction: &Transaction) -> IcnResult<()> {
        let sender_balances = shard.balances.entry(transaction.from.clone()).or_insert_with(HashMap::new);
        let sender_balance = sender_balances.entry(transaction.currency_type.clone()).or_insert(0.0);
        
        if *sender_balance < transaction.amount {
            return Err(IcnError::Sharding("Insufficient balance".to_string()));
        }
        
        *sender_balance -= transaction.amount;

        let recipient_balances = shard.balances.entry(transaction.to.clone()).or_insert_with(HashMap::new);
        let recipient_balance = recipient_balances.entry(transaction.currency_type.clone()).or_insert(0.0);
        *recipient_balance += transaction.amount;

        Ok(())
    }

    pub fn create_block(&mut self, shard_id: u64) -> IcnResult<Block> {
        let new_block;
        {
            let shard = self.shards.get_mut(&shard_id).ok_or_else(|| IcnError::Sharding("Shard not found".to_string()))?;
            let previous_block = shard.blockchain.last().ok_or_else(|| IcnError::Sharding("No previous block found".to_string()))?;
            
            new_block = Block {
                index: shard.blockchain.len() as u64,
                timestamp: chrono::Utc::now().timestamp(),
                transactions: shard.pending_transactions.clone(),
                previous_hash: previous_block.hash.clone(),
                hash: String::new(), // Will be set later
            };

            shard.pending_transactions.clear();
        }
        let new_block = self.calculate_block_hash(new_block);
        let shard = self.shards.get_mut(&shard_id).ok_or_else(|| IcnError::Sharding("Shard not found".to_string()))?;
        shard.blockchain.push(new_block.clone());
        Ok(new_block)
    }

    pub fn get_shard_for_address(&self, address: &str) -> u64 {
        *self.address_to_shard.get(address).unwrap_or(&(self.hash_address(address) % self.shard_count))
    }

    pub fn add_address_to_shard(&mut self, address: String, shard_id: u64) -> IcnResult<()> {
        if shard_id >= self.shard_count {
            return Err(IcnError::Sharding("Invalid shard ID".to_string()));
        }
        self.address_to_shard.insert(address, shard_id);
        Ok(())
    }

    pub fn get_balance(&self, address: &str, currency_type: &CurrencyType) -> IcnResult<f64> {
        let shard_id = self.get_shard_for_address(address);
        let shard = self.shards.get(&shard_id).ok_or_else(|| IcnError::Sharding("Shard not found".to_string()))?;
        
        Ok(shard.balances
            .get(address)
            .and_then(|balances| balances.get(currency_type))
            .cloned()
            .unwrap_or(0.0))
    }

    fn verify_transaction(&self, shard: &Shard, transaction: &Transaction) -> bool {
        if let Some(sender_balances) = shard.balances.get(&transaction.from) {
            if let Some(balance) = sender_balances.get(&transaction.currency_type) {
                return *balance >= transaction.amount;
            }
        }
        false
    }

    fn hash_address(&self, address: &str) -> u64 {
        let mut hasher = Sha256::new();
        hasher.update(address.as_bytes());
        let result = hasher.finalize();
        let hash_bytes: [u8; 8] = result[..8].try_into().unwrap_or([0; 8]);
        u64::from_le_bytes(hash_bytes)
    }

    fn calculate_block_hash(&self, mut block: Block) -> Block {
        let mut hasher = Sha256::new();
        hasher.update(block.index.to_string().as_bytes());
        hasher.update(block.timestamp.to_string().as_bytes());
        for transaction in &block.transactions {
            hasher.update(transaction.from.as_bytes());
            hasher.update(transaction.to.as_bytes());
            hasher.update(transaction.amount.to_string().as_bytes());
            hasher.update(format!("{:?}", transaction.currency_type).as_bytes());
        }
        hasher.update(block.previous_hash.as_bytes());
        
        let hash = format!("{:x}", hasher.finalize());
        block.hash = hash;
        block
    }

    pub fn transfer_between_shards(&mut self, from_shard_id: u64, to_shard_id: u64, transaction: &Transaction) -> IcnResult<()> {
        {
            // Deduct from the source shard
            let from_shard = self.shards.get_mut(&from_shard_id).ok_or_else(|| IcnError::Sharding("Source shard not found".to_string()))?;
            self.update_balances(from_shard, transaction)?;
        }

        // Add to the destination shard
        let mut reverse_transaction = transaction.clone();
        reverse_transaction.from = transaction.to.clone();
        reverse_transaction.to = transaction.from.clone();
        {
            let to_shard = self.shards.get_mut(&to_shard_id).ok_or_else(|| IcnError::Sharding("Destination shard not found".to_string()))?;
            self.update_balances(to_shard, &reverse_transaction)?;
        }

        Ok(())
    }

    pub fn get_shard_state(&self, shard_id: u64) -> IcnResult<&Shard> {
        self.shards.get(&shard_id).ok_or_else(|| IcnError::Sharding("Shard not found".to_string()))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sharding_manager() {
        let mut manager = ShardingManager::new(4);
        assert_eq!(manager.get_shard_count(), 4);

        let transaction = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 100.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: 0,
            signature: None,
        };

        manager.add_address_to_shard("Alice".to_string(), 0).unwrap();
        manager.add_address_to_shard("Bob".to_string(), 1).unwrap();

        // Initialize Alice's balance
        let alice_shard = manager.shards.get_mut(&0).unwrap();
        alice_shard.balances.entry("Alice".to_string()).or_insert_with(HashMap::new).insert(CurrencyType::BasicNeeds, 200.0);

        assert!(manager.process_transaction(&transaction).is_ok());

        assert_eq!(manager.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap(), 100.0);
        assert_eq!(manager.get_balance("Bob", &CurrencyType::BasicNeeds).unwrap(), 100.0);

        // Test block creation
        let block = manager.create_block(0).unwrap();
        assert_eq!(block.index, 1);
        assert_eq!(block.transactions.len(), 1);

        // Test cross-shard transaction
        let cross_shard_tx = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 50.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: 1,
            signature: None,
        };

        assert!(manager.transfer_between_shards(0, 1, &cross_shard_tx).is_ok());
        assert_eq!(manager.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap(), 50.0);
        assert_eq!(manager.get_balance("Bob", &CurrencyType::BasicNeeds).unwrap(), 150.0);

        // Test getting shard state
        let shard_state = manager.get_shard_state(0).unwrap();
        assert_eq!(shard_state.id, 0);
        assert_eq!(shard_state.blockchain.len(), 2); // Genesis block + 1 new block

        // Test invalid shard access
        assert!(manager.get_shard_state(10).is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_sharding/src/cross_shard_transaction_manager.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_sharding/src/lib.rs =====
use icn_common::{IcnResult, IcnError, Block, Transaction, CurrencyType};
use std::collections::{HashMap, HashSet};
use sha2::{Sha256, Digest};
use chrono::Utc;

pub struct Shard {
    pub id: u64,
    pub blockchain: Vec<Block>,
    pub balances: HashMap<String, HashMap<CurrencyType, f64>>,
    pub pending_transactions: Vec<Transaction>,
}

pub struct ShardingManager {
    shards: HashMap<u64, Shard>,
    shard_count: u64,
    address_to_shard: HashMap<String, u64>,
}

impl ShardingManager {
    pub fn new(shard_count: u64) -> Self {
        let mut shards = HashMap::new();
        for i in 0..shard_count {
            shards.insert(i, Shard {
                id: i,
                blockchain: vec![Block::genesis()],
                balances: HashMap::new(),
                pending_transactions: Vec::new(),
            });
        }

        ShardingManager {
            shards,
            shard_count,
            address_to_shard: HashMap::new(),
        }
    }

    pub fn get_shard_count(&self) -> u64 {
        self.shard_count
    }

    pub fn process_transaction(&mut self, transaction: &Transaction) -> IcnResult<()> {
        let from_shard = self.get_shard_for_address(&transaction.from);
        let to_shard = self.get_shard_for_address(&transaction.to);

        if from_shard == to_shard {
            self.process_intra_shard_transaction(from_shard, transaction)
        } else {
            self.process_cross_shard_transaction(from_shard, to_shard, transaction)
        }
    }

    fn process_intra_shard_transaction(&mut self, shard_id: u64, transaction: &Transaction) -> IcnResult<()> {
        let shard = self.shards.get_mut(&shard_id).ok_or_else(|| IcnError::Sharding("Shard not found".to_string()))?;

        if !self.verify_transaction(shard, transaction) {
            return Err(IcnError::Sharding("Invalid transaction".to_string()));
        }

        shard.pending_transactions.push(transaction.clone());
        self.update_balances(shard, transaction)
    }

    fn process_cross_shard_transaction(&mut self, from_shard: u64, to_shard: u64, transaction: &Transaction) -> IcnResult<()> {
        // Lock funds in the source shard
        {
            let from_shard = self.shards.get_mut(&from_shard).ok_or_else(|| IcnError::Sharding("Source shard not found".to_string()))?;
            if !self.verify_transaction(from_shard, transaction) {
                return Err(IcnError::Sharding("Invalid transaction".to_string()));
            }
            self.update_balances(from_shard, transaction)?;
        }

        // Update recipient's balance in the destination shard
        {
            let to_shard = self.shards.get_mut(&to_shard).ok_or_else(|| IcnError::Sharding("Destination shard not found".to_string()))?;
            let mut reverse_transaction = transaction.clone();
            reverse_transaction.from = transaction.to.clone();
            reverse_transaction.to = transaction.from.clone();
            self.update_balances(to_shard, &reverse_transaction)?;
        }

        Ok(())
    }

    fn update_balances(&mut self, shard: &mut Shard, transaction: &Transaction) -> IcnResult<()> {
        let sender_balances = shard.balances.entry(transaction.from.clone()).or_insert_with(HashMap::new);
        let sender_balance = sender_balances.entry(transaction.currency_type.clone()).or_insert(0.0);

        if *sender_balance < transaction.amount {
            return Err(IcnError::Sharding("Insufficient balance".to_string()));
        }

        *sender_balance -= transaction.amount;

        let recipient_balances = shard.balances.entry(transaction.to.clone()).or_insert_with(HashMap::new);
        let recipient_balance = recipient_balances.entry(transaction.currency_type.clone()).or_insert(0.0);
        *recipient_balance += transaction.amount;

        Ok(())
    }

    pub fn create_block(&mut self, shard_id: u64) -> IcnResult<Block> {
        let shard = self.shards.get_mut(&shard_id).ok_or_else(|| IcnError::Sharding("Shard not found".to_string()))?;
        let previous_block = shard.blockchain.last().ok_or_else(|| IcnError::Sharding("No previous block found".to_string()))?;

        let new_block = Block {
            index: shard.blockchain.len() as u64,
            timestamp: Utc::now().timestamp(),
            transactions: shard.pending_transactions.clone(),
            previous_hash: previous_block.hash.clone(),
            hash: String::new(), // Will be set later
        };

        let new_block = self.calculate_block_hash(new_block);
        shard.blockchain.push(new_block.clone());
        shard.pending_transactions.clear();

        Ok(new_block)
    }

    pub fn get_shard_for_address(&self, address: &str) -> u64 {
        *self.address_to_shard.get(address).unwrap_or(&(self.hash_address(address) % self.shard_count))
    }

    pub fn add_address_to_shard(&mut self, address: String, shard_id: u64) -> IcnResult<()> {
        if shard_id >= self.shard_count {
            return Err(IcnError::Sharding("Invalid shard ID".to_string()));
        }
        self.address_to_shard.insert(address, shard_id);
        Ok(())
    }

    pub fn get_balance(&self, address: &str, currency_type: &CurrencyType) -> IcnResult<f64> {
        let shard_id = self.get_shard_for_address(address);
        let shard = self.shards.get(&shard_id).ok_or_else(|| IcnError::Sharding("Shard not found".to_string()))?;

        Ok(shard.balances
            .get(address)
            .and_then(|balances| balances.get(currency_type))
            .cloned()
            .unwrap_or(0.0))
    }

    fn verify_transaction(&self, shard: &Shard, transaction: &Transaction) -> bool {
        if let Some(sender_balances) = shard.balances.get(&transaction.from) {
            if let Some(balance) = sender_balances.get(&transaction.currency_type) {
                return *balance >= transaction.amount;
            }
        }
        false
    }

    fn hash_address(&self, address: &str) -> u64 {
        let mut hasher = Sha256::new();
        hasher.update(address.as_bytes());
        let result = hasher.finalize();
        let hash_bytes: [u8; 8] = result[..8].try_into().unwrap_or([0; 8]);
        u64::from_le_bytes(hash_bytes)
    }

    fn calculate_block_hash(&self, mut block: Block) -> Block {
        let mut hasher = Sha256::new();
        hasher.update(block.index.to_string().as_bytes());
        hasher.update(block.timestamp.to_string().as_bytes());
        for transaction in &block.transactions {
            hasher.update(transaction.from.as_bytes());
            hasher.update(transaction.to.as_bytes());
            hasher.update(transaction.amount.to_string().as_bytes());
            hasher.update(format!("{:?}", transaction.currency_type).as_bytes());
        }
        hasher.update(block.previous_hash.as_bytes());

        let hash = format!("{:x}", hasher.finalize());
        block.hash = hash;
        block
    }

    pub fn rebalance_shards(&mut self) -> IcnResult<()> {
        let total_addresses: usize = self.address_to_shard.len();
        let target_addresses_per_shard = total_addresses / self.shard_count as usize;
        let mut overloaded_shards: Vec<u64> = Vec::new();
        let mut underloaded_shards: Vec<u64> = Vec::new();

        // Identify overloaded and underloaded shards
        for shard_id in 0..self.shard_count {
            let shard_addresses: usize = self.address_to_shard.values().filter(|&&s| s == shard_id).count();
            if shard_addresses > target_addresses_per_shard + 1 {
                overloaded_shards.push(shard_id);
            } else if shard_addresses < target_addresses_per_shard {
                underloaded_shards.push(shard_id);
            }
        }

        // Rebalance addresses between shards
        for overloaded_shard in overloaded_shards {
            let addresses_to_move: Vec<String> = self.address_to_shard
                .iter()
                .filter(|&(_, &shard)| shard == overloaded_shard)
                .map(|(addr, _)| addr.clone())
                .take((self.address_to_shard.values().filter(|&&s| s == overloaded_shard).count() - target_addresses_per_shard) as usize)
                .collect();

            for address in addresses_to_move {
                if let Some(target_shard) = underloaded_shards.first() {
                    self.move_address_to_shard(&address, *target_shard)?;
                    if self.address_to_shard.values().filter(|&&s| s == *target_shard).count() >= target_addresses_per_shard {
                        underloaded_shards.remove(0);
                    }
                }
            }
        }

        Ok(())
    }

    pub fn handle_shard_failure(&mut self, failed_shard_id: u64) -> IcnResult<()> {
        if failed_shard_id >= self.shard_count {
            return Err(IcnError::Sharding("Invalid shard ID".to_string()));
        }

        // Collect addresses from the failed shard
        let failed_shard_addresses: Vec<String> = self.address_to_shard
            .iter()
            .filter(|&(_, &shard)| shard == failed_shard_id)
            .map(|(addr, _)| addr.clone())
            .collect();

        // Redistribute addresses to other shards
        let mut target_shard_id = (failed_shard_id + 1) % self.shard_count;
        for address in failed_shard_addresses {
            while target_shard_id == failed_shard_id {
                target_shard_id = (target_shard_id + 1) % self.shard_count;
            }
            self.move_address_to_shard(&address, target_shard_id)?;
            target_shard_id = (target_shard_id + 1) % self.shard_count;
        }

        // Clear the failed shard's data
        if let Some(failed_shard) = self.shards.get_mut(&failed_shard_id) {
            failed_shard.blockchain = vec![Block::genesis()];
            failed_shard.balances.clear();
            failed_shard.pending_transactions.clear();
        }

        // Trigger a network-wide state update
        self.update_network_state()?;

        Ok(())
    }

    fn move_address_to_shard(&mut self, address: &str, new_shard_id: u64) -> IcnResult<()> {
        let old_shard_id = self.get_shard_for_address(address);
        if old_shard_id == new_shard_id {
            return Ok(());
        }

        // Move balances
        if let Some(old_shard) = self.shards.get_mut(&old_shard_id) {
            if let Some(balances) = old_shard.balances.remove(address) {
                if let Some(new_shard) = self.shards.get_mut(&new_shard_id) {
                    new_shard.balances.insert(address.to_string(), balances);
                }
            }
        }

        // Update address_to_shard mapping
        self.address_to_shard.insert(address.to_string(), new_shard_id);

        Ok(())
    }

    fn update_network_state(&self) -> IcnResult<()> {
        // In a real implementation, this method would broadcast the updated state
        // to all nodes in the network, ensuring consistency across the system.
        // For now, we'll just log the action.
        println!("Network state update triggered");
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sharding_manager() {
        let mut manager = ShardingManager::new(4);
        assert_eq!(manager.get_shard_count(), 4);

        let transaction = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 100.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: 0,
            signature: None,
        };

        manager.add_address_to_shard("Alice".to_string(), 0).unwrap();
        manager.add_address_to_shard("Bob".to_string(), 1).unwrap();

        // Initialize Alice's balance
        let alice_shard = manager.shards.get_mut(&0).unwrap();
        alice_shard.balances.entry("Alice".to_string()).or_insert_with(HashMap::new).insert(CurrencyType::BasicNeeds, 200.0);

        assert!(manager.process_transaction(&transaction).is_ok());

        assert_eq!(manager.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap(), 100.0);
        assert_eq!(manager.get_balance("Bob", &CurrencyType::BasicNeeds).unwrap(), 100.0);

        // Test block creation
        let block = manager.create_block(0).unwrap();
        assert_eq!(block.index, 1);
        assert_eq!(block.transactions.len(), 1);

        // Test cross-shard transaction
        let cross_shard_tx = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 50.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: 1,
            signature: None,
        };

        assert!(manager.process_transaction(&cross_shard_tx).is_ok());
        assert_eq!(manager.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap(), 50.0);
        assert_eq!(manager.get_balance("Bob", &CurrencyType::BasicNeeds).unwrap(), 150.0);

        // Test getting shard state
        let shard_state = manager.shards.get(&0).unwrap();
        assert_eq!(shard_state.id, 0);
        assert_eq!(shard_state.blockchain.len(), 2); // Genesis block + 1 new block

        // Test invalid shard access
        assert!(manager.get_balance("NonexistentUser", &CurrencyType::BasicNeeds).is_err());
    }

    #[test]
    fn test_rebalance_shards() {
        let mut manager = ShardingManager::new(3);
        
        // Add addresses to shards unevenly
        for i in 0..10 {
            manager.add_address_to_shard(format!("Address{}", i), 0).unwrap();
        }
        for i in 10..15 {
            manager.add_address_to_shard(format!("Address{}", i), 1).unwrap();
        }
        for i in 15..17 {
            manager.add_address_to_shard(format!("Address{}", i), 2).unwrap();
        }

        // Rebalance shards
        manager.rebalance_shards().unwrap();

        // Check if shards are more evenly balanced
        let shard_0_count = manager.address_to_shard.values().filter(|&&s| s == 0).count();
        let shard_1_count = manager.address_to_shard.values().filter(|&&s| s == 1).count();
        let shard_2_count = manager.address_to_shard.values().filter(|&&s| s == 2).count();

        assert!(shard_0_count >= 5 && shard_0_count <= 6);
        assert!(shard_1_count >= 5 && shard_1_count <= 6);
        assert!(shard_2_count >= 5 && shard_2_count <= 6);
    }

    #[test]
    fn test_handle_shard_failure() {
        let mut manager = ShardingManager::new(3);
        
        // Add addresses and balances to shards
        for i in 0..9 {
            let address = format!("Address{}", i);
            manager.add_address_to_shard(address.clone(), i / 3).unwrap();
            let shard = manager.shards.get_mut(&(i / 3)).unwrap();
            shard.balances.entry(address).or_insert_with(HashMap::new).insert(CurrencyType::BasicNeeds, 100.0);
        }

        // Simulate failure of shard 1
        manager.handle_shard_failure(1).unwrap();

        // Check if addresses from shard 1 have been redistributed
        assert_eq!(manager.address_to_shard.values().filter(|&&s| s == 1).count(), 0);

        // Check if balances have been moved
        for i in 3..6 {
            let address = format!("Address{}", i);
            let new_shard_id = manager.get_shard_for_address(&address);
            assert_ne!(new_shard_id, 1);
            let balance = manager.get_balance(&address, &CurrencyType::BasicNeeds).unwrap();
            assert_eq!(balance, 100.0);
        }

        // Check if shard 1 has been reset
        let shard_1 = manager.shards.get(&1).unwrap();
        assert_eq!(shard_1.blockchain.len(), 1); // Only genesis block
        assert!(shard_1.balances.is_empty());
        assert!(shard_1.pending_transactions.is_empty());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_sharding/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_smart_contracts/Cargo.toml =====
[package]
name = "icn_smart_contracts"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
icn_vm = { path = "../icn_vm" }
serde = { version = "1.0", features = ["derive"] }
thiserror = "1.0"
log = "0.4"
pest = "2.1"
pest_derive = "2.1"===== END OF /home/matt/InterCooperative-Network/crates/icn_smart_contracts/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_smart_contracts/src/lib.rs =====
// crates/icn_smart_contracts/src/lib.rs

use pest::Parser;
use pest_derive::Parser;
use icn_common::{IcnResult, IcnError, CurrencyType};
use icn_vm::{CoopVM, Opcode, Value};
use std::collections::HashMap;
use std::fmt;

// Define the parser for our smart contract language
#[derive(Parser)]
#[grammar = "contract.pest"]
struct ContractParser;

// Enum to represent different types of smart contracts
#[derive(Debug, Clone)]
pub enum SmartContractType {
    AssetTransfer,
    VotingSystem,
    ReputationManagement,
    ResourceAllocation,
    CustomLogic,
}

// Struct to represent a compiled smart contract
#[derive(Debug)]
pub struct CompiledContract {
    contract_type: SmartContractType,
    bytecode: Vec<Opcode>,
    abi: ContractABI,
}

// Struct to represent the ABI (Application Binary Interface) of a smart contract
#[derive(Debug)]
pub struct ContractABI {
    functions: Vec<ContractFunction>,
    events: Vec<ContractEvent>,
}

// Struct to represent a function in the smart contract's ABI
#[derive(Debug)]
pub struct ContractFunction {
    name: String,
    inputs: Vec<ContractParameter>,
    outputs: Vec<ContractParameter>,
}

// Struct to represent an event in the smart contract's ABI
#[derive(Debug)]
pub struct ContractEvent {
    name: String,
    parameters: Vec<ContractParameter>,
}

// Struct to represent a parameter in a function or event
#[derive(Debug)]
pub struct ContractParameter {
    name: String,
    param_type: ContractValueType,
}

// Enum to represent the possible value types in a smart contract
#[derive(Debug, Clone)]
pub enum ContractValueType {
    Integer,
    Float,
    Boolean,
    String,
    Address,
    List(Box<ContractValueType>),
    Map(Box<ContractValueType>, Box<ContractValueType>),
}

impl fmt::Display for ContractValueType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ContractValueType::Integer => write!(f, "Integer"),
            ContractValueType::Float => write!(f, "Float"),
            ContractValueType::Boolean => write!(f, "Boolean"),
            ContractValueType::String => write!(f, "String"),
            ContractValueType::Address => write!(f, "Address"),
            ContractValueType::List(inner) => write!(f, "List<{}>", inner),
            ContractValueType::Map(key, value) => write!(f, "Map<{}, {}>", key, value),
        }
    }
}

// The main compiler for our natural language smart contracts
pub struct NaturalLanguageCompiler;

impl NaturalLanguageCompiler {
    // Compile a natural language contract into bytecode
    pub fn compile(input: &str) -> IcnResult<CompiledContract> {
        let pairs = ContractParser::parse(Rule::contract, input)
            .map_err(|e| IcnError::SmartContract(format!("Parsing error: {}", e)))?;

        let mut bytecode = Vec::new();
        let mut abi = ContractABI {
            functions: Vec::new(),
            events: Vec::new(),
        };
        let mut contract_type = SmartContractType::CustomLogic;

        for pair in pairs {
            match pair.as_rule() {
                Rule::contract_type => {
                    contract_type = Self::parse_contract_type(pair.into_inner().next().unwrap().as_str())?;
                }
                Rule::function_definition => {
                    let (func_bytecode, func_abi) = Self::compile_function(pair)?;
                    bytecode.extend(func_bytecode);
                    abi.functions.push(func_abi);
                }
                Rule::statement => {
                    bytecode.extend(Self::compile_statement(pair)?);
                }
                Rule::event_definition => {
                    abi.events.push(Self::compile_event(pair)?);
                }
                _ => {}
            }
        }

        Ok(CompiledContract {
            contract_type,
            bytecode,
            abi,
        })
    }

    // Parse the contract type from the input
    fn parse_contract_type(type_str: &str) -> IcnResult<SmartContractType> {
        match type_str {
            "AssetTransfer" => Ok(SmartContractType::AssetTransfer),
            "VotingSystem" => Ok(SmartContractType::VotingSystem),
            "ReputationManagement" => Ok(SmartContractType::ReputationManagement),
            "ResourceAllocation" => Ok(SmartContractType::ResourceAllocation),
            "CustomLogic" => Ok(SmartContractType::CustomLogic),
            _ => Err(IcnError::SmartContract(format!("Unknown contract type: {}", type_str))),
        }
    }

    // Compile a function definition
    fn compile_function(pair: pest::iterators::Pair<Rule>) -> IcnResult<(Vec<Opcode>, ContractFunction)> {
        let mut inner = pair.into_inner();
        let name = inner.next().unwrap().as_str().to_string();
        let params = inner.next().unwrap();
        let body = inner.next().unwrap();

        let mut inputs = Vec::new();
        let mut param_bytecode = Vec::new();
        for param in params.into_inner() {
            let mut param_inner = param.into_inner();
            let param_name = param_inner.next().unwrap().as_str().to_string();
            let param_type = Self::parse_type(param_inner.next().unwrap().as_str())?;
            inputs.push(ContractParameter {
                name: param_name.clone(),
                param_type: param_type.clone(),
            });
            param_bytecode.push(Opcode::Store(param_name));
        }

        let mut body_bytecode = Self::compile_statement(body)?;
        let mut bytecode = param_bytecode;
        bytecode.extend(body_bytecode);
        bytecode.push(Opcode::Return);

        let func_abi = ContractFunction {
            name,
            inputs,
            outputs: vec![],  // For simplicity, we're not handling return types yet
        };

        Ok((bytecode, func_abi))
    }

    // Compile a single statement
    fn compile_statement(pair: pest::iterators::Pair<Rule>) -> IcnResult<Vec<Opcode>> {
        let inner = pair.into_inner().next().unwrap();
        match inner.as_rule() {
            Rule::assignment => Self::compile_assignment(inner),
            Rule::if_statement => Self::compile_if_statement(inner),
            Rule::while_loop => Self::compile_while_loop(inner),
            Rule::function_call => Self::compile_function_call(inner),
            Rule::return_statement => Self::compile_return_statement(inner),
            _ => Err(IcnError::SmartContract("Unknown statement type".into())),
        }
    }

    // Compile an assignment statement
    fn compile_assignment(pair: pest::iterators::Pair<Rule>) -> IcnResult<Vec<Opcode>> {
        let mut inner = pair.into_inner();
        let variable = inner.next().unwrap().as_str();
        let value = inner.next().unwrap();

        let mut opcodes = Self::compile_expression(value)?;
        opcodes.push(Opcode::Store(variable.to_string()));
        Ok(opcodes)
    }

    // Compile an if statement
    fn compile_if_statement(pair: pest::iterators::Pair<Rule>) -> IcnResult<Vec<Opcode>> {
        let mut inner = pair.into_inner();
        let condition = inner.next().unwrap();
        let true_branch = inner.next().unwrap();
        let false_branch = inner.next();

        let mut opcodes = Self::compile_expression(condition)?;
        let true_opcodes = Self::compile_statement(true_branch)?;
        let false_opcodes = false_branch.map(Self::compile_statement).transpose()?;

        opcodes.push(Opcode::JumpIf(true_opcodes.len() as usize + 1));
        opcodes.extend(true_opcodes);
        if let Some(false_opcodes) = false_opcodes {
            opcodes.push(Opcode::Jump(false_opcodes.len() as usize));
            opcodes.extend(false_opcodes);
        }

        Ok(opcodes)
    }

    // Compile a while loop
    fn compile_while_loop(pair: pest::iterators::Pair<Rule>) -> IcnResult<Vec<Opcode>> {
        let mut inner = pair.into_inner();
        let condition = inner.next().unwrap();
        let body = inner.next().unwrap();

        let condition_opcodes = Self::compile_expression(condition)?;
        let body_opcodes = Self::compile_statement(body)?;

        let mut opcodes = Vec::new();
        opcodes.extend(condition_opcodes.clone());
        opcodes.push(Opcode::JumpIf(body_opcodes.len() as usize + 2));
        opcodes.extend(body_opcodes);
        opcodes.extend(condition_opcodes);
        opcodes.push(Opcode::JumpIf(usize::MAX - (opcodes.len() - 1)));

        Ok(opcodes)
    }

    // Compile a function call
    fn compile_function_call(pair: pest::iterators::Pair<Rule>) -> IcnResult<Vec<Opcode>> {
        let mut inner = pair.into_inner();
        let function_name = inner.next().unwrap().as_str();
        let arguments = inner.next().unwrap().into_inner();

        let mut opcodes = Vec::new();
        for arg in arguments {
            opcodes.extend(Self::compile_expression(arg)?);
        }
        opcodes.push(Opcode::Call(function_name.to_string()));
        Ok(opcodes)
    }

    // Compile a return statement
    fn compile_return_statement(pair: pest::iterators::Pair<Rule>) -> IcnResult<Vec<Opcode>> {
        let mut inner = pair.into_inner();
        let expression = inner.next().unwrap();

        let mut opcodes = Self::compile_expression(expression)?;
        opcodes.push(Opcode::Return);
        Ok(opcodes)
    }

    // Compile an expression
    fn compile_expression(pair: pest::iterators::Pair<Rule>) -> IcnResult<Vec<Opcode>> {
        match pair.as_rule() {
            Rule::number => Ok(vec![Opcode::Push(Value::Int(pair.as_str().parse().unwrap()))]),
            Rule::string => Ok(vec![Opcode::Push(Value::String(pair.into_inner().next().unwrap().as_str().to_string()))]),
            Rule::boolean => Ok(vec![Opcode::Push(Value::Bool(pair.as_str().parse().unwrap()))]),
            Rule::variable => Ok(vec![Opcode::Load(pair.as_str().to_string())]),
            Rule::expression => {
                let mut inner = pair.into_inner();
                let left = inner.next().unwrap();
                let operator = inner.next();
                let right = inner.next();

                let mut opcodes = Self::compile_expression(left)?;
                if let (Some(op), Some(right)) = (operator, right) {
                    opcodes.extend(Self::compile_expression(right)?);
                    opcodes.push(match op.as_str() {
                        "+" => Opcode::Add,
                        "-" => Opcode::Sub,
                        "*" => Opcode::Mul,
                        "/" => Opcode::Div,
                        "==" => Opcode::Eq,
                        "!=" => Opcode::Neq,
                        "<" => Opcode::Lt,
                        "<=" => Opcode::Lte,
                        ">" => Opcode::Gt,
                        ">=" => Opcode::Gte,
                        "and" => Opcode::And,
                        "or" => Opcode::Or,
                        _ => return Err(IcnError::SmartContract(format!("Unknown operator: {}", op.as_str()))),
                    });
                }
                Ok(opcodes)
            }
            _ => Err(IcnError::SmartContract("Unknown expression type".into())),
        }
    }

    // Compile an event definition
    fn compile_event(pair: pest::iterators::Pair<Rule>) -> IcnResult<ContractEvent> {
        let mut inner = pair.into_inner();
        let name = inner.next().unwrap().as_str().to_string();
        let params = inner.next().unwrap();

        let mut parameters = Vec::new();
        for param in params.into_inner() {
            let mut param_inner = param.into_inner();
            let param_name = param_inner.next().unwrap().as_str().to_string();
            let param_type = Self::parse_type(param_inner.next().unwrap().as_str())?;
            parameters.push(ContractParameter {
                name: param_name,
                param_type,
            });
        }

        Ok(ContractEvent { name, parameters })
    }

    // Parse a type string into a ContractValueType
    fn parse_type(type_str: &str) -> IcnResult<ContractValueType> {
        match type_str {
            "int" => Ok(ContractValueType::Integer),
            "float" => Ok(ContractValueType::Float),
            "bool" => Ok(ContractValueType::Boolean),
            "string" => Ok(ContractValueType::String),
            "address" => Ok(ContractValueType::Address),
            _ if type_str.starts_with("list<") => {
                let inner_type = &type_str[5..type_str.len()-1];
                Ok(ContractValueType::List(Box::new(Self::parse_type(inner_type)?)))
            }
            _ if type_str.starts_with("map<") => {
                let inner_types: Vec<&str> = type_str[4..type_str.len()-1].split(',').collect();
                if inner_types.len() != 2 {
                    return Err(IcnError::SmartContract("Invalid map type format".into()));
                }
                Ok(ContractValueType::Map(
                    Box::new(Self::parse_type(inner_types[0].trim())?),
                    Box::new(Self::parse_type(inner_types[1].trim())?)))
                }
                _ => Err(IcnError::SmartContract(format!("Unknown type: {}", type_str))),
            }
        }
    }
    
    /// Struct to represent the execution context of a smart contract
    pub struct ContractContext {
        pub balances: HashMap<String, HashMap<CurrencyType, f64>>,
        pub storage: HashMap<String, Value>,
        pub block_height: u64,
        pub timestamp: u64,
        pub caller: String,
    }
    
    /// Smart contract executor
    pub struct SmartContractExecutor {
        vm: CoopVM,
    }
    
    impl SmartContractExecutor {
        pub fn new() -> Self {
            SmartContractExecutor {
                vm: CoopVM::new(Vec::new()),
            }
        }
    
        /// Execute a compiled smart contract
        pub fn execute(&mut self, contract: &CompiledContract, context: &mut ContractContext, function: &str, args: Vec<Value>) -> IcnResult<Option<Value>> {
            self.vm.load_program(contract.bytecode.clone());
            self.vm.set_context(context);
    
            // Find the function in the ABI
            let function_abi = contract.abi.functions.iter()
                .find(|f| f.name == function)
                .ok_or_else(|| IcnError::SmartContract(format!("Function {} not found", function)))?;
    
            // Check argument count
            if args.len() != function_abi.inputs.len() {
                return Err(IcnError::SmartContract("Incorrect number of arguments".into()));
            }
    
            // Push arguments onto the stack
            for arg in args {
                self.vm.push(arg);
            }
    
            // Call the function
            self.vm.call(function)?;
    
            // Run the VM
            self.vm.run()?;
    
            // Return the top value from the stack, if any
            Ok(self.vm.pop())
        }
    }
    
    #[cfg(test)]
    mod tests {
        use super::*;
    
        #[test]
        fn test_compile_simple_contract() {
            let contract_source = r#"
            contract_type: AssetTransfer
    
            function transfer(from: address, to: address, amount: int) {
                if balanceOf(from) >= amount {
                    balanceOf[from] = balanceOf[from] - amount;
                    balanceOf[to] = balanceOf[to] + amount;
                    emit Transfer(from, to, amount);
                }
            }
    
            event Transfer(from: address, to: address, amount: int)
            "#;
    
            let compiled_contract = NaturalLanguageCompiler::compile(contract_source).unwrap();
    
            assert_eq!(compiled_contract.contract_type, SmartContractType::AssetTransfer);
            assert!(!compiled_contract.bytecode.is_empty());
            assert_eq!(compiled_contract.abi.functions.len(), 1);
            assert_eq!(compiled_contract.abi.events.len(), 1);
    
            let transfer_function = &compiled_contract.abi.functions[0];
            assert_eq!(transfer_function.name, "transfer");
            assert_eq!(transfer_function.inputs.len(), 3);
    
            let transfer_event = &compiled_contract.abi.events[0];
            assert_eq!(transfer_event.name, "Transfer");
            assert_eq!(transfer_event.parameters.len(), 3);
        }
    
        #[test]
        fn test_execute_simple_contract() {
            let contract_source = r#"
            contract_type: AssetTransfer
    
            function transfer(from: address, to: address, amount: int) {
                if balanceOf(from) >= amount {
                    balanceOf[from] = balanceOf[from] - amount;
                    balanceOf[to] = balanceOf[to] + amount;
                    emit Transfer(from, to, amount);
                }
            }
    
            event Transfer(from: address, to: address, amount: int)
            "#;
    
            let compiled_contract = NaturalLanguageCompiler::compile(contract_source).unwrap();
            let mut executor = SmartContractExecutor::new();
    
            let mut context = ContractContext {
                balances: HashMap::new(),
                storage: HashMap::new(),
                block_height: 1,
                timestamp: 1623456789,
                caller: "system".to_string(),
            };
    
            // Initialize balances
            let mut from_balance = HashMap::new();
            from_balance.insert(CurrencyType::BasicNeeds, 100.0);
            context.balances.insert("Alice".to_string(), from_balance);
    
            let mut to_balance = HashMap::new();
            to_balance.insert(CurrencyType::BasicNeeds, 50.0);
            context.balances.insert("Bob".to_string(), to_balance);
    
            // Execute transfer
            let result = executor.execute(
                &compiled_contract,
                &mut context,
                "transfer",
                vec![
                    Value::String("Alice".to_string()),
                    Value::String("Bob".to_string()),
                    Value::Int(30),
                ],
            );
    
            assert!(result.is_ok());
    
            // Check balances after transfer
            assert_eq!(context.balances["Alice"][&CurrencyType::BasicNeeds], 70.0);
            assert_eq!(context.balances["Bob"][&CurrencyType::BasicNeeds], 80.0);
        }
    }
    
    // Helper trait for CoopVM to interact with ContractContext
    trait VMContext {
        fn get_balance(&self, address: &str, currency: &CurrencyType) -> f64;
        fn set_balance(&mut self, address: &str, currency: &CurrencyType, amount: f64);
        fn get_storage(&self, key: &str) -> Option<&Value>;
        fn set_storage(&mut self, key: String, value: Value);
        fn emit_event(&mut self, name: &str, params: Vec<Value>);
    }
    
    impl VMContext for ContractContext {
        fn get_balance(&self, address: &str, currency: &CurrencyType) -> f64 {
            self.balances.get(address).and_then(|balances| balances.get(currency)).cloned().unwrap_or(0.0)
        }
    
        fn set_balance(&mut self, address: &str, currency: &CurrencyType, amount: f64) {
            self.balances.entry(address.to_string()).or_insert_with(HashMap::new).insert(currency.clone(), amount);
        }
    
        fn get_storage(&self, key: &str) -> Option<&Value> {
            self.storage.get(key)
        }
    
        fn set_storage(&mut self, key: String, value: Value) {
            self.storage.insert(key, value);
        }
    
        fn emit_event(&mut self, name: &str, params: Vec<Value>) {
            println!("Event emitted: {} {:?}", name, params);
            // In a real implementation, this would interact with the blockchain to record the event
        }
    }
    
    // Extend CoopVM to work with ContractContext
    impl CoopVM {
        pub fn set_context(&mut self, context: &ContractContext) {
            // Implementation depends on how CoopVM is designed to interact with external state
        }
    
        pub fn push(&mut self, value: Value) {
            // Implementation to push a value onto the VM's stack
        }
    
        pub fn pop(&mut self) -> Option<Value> {
            // Implementation to pop a value from the VM's stack
        }
    
        pub fn call(&mut self, function: &str) -> IcnResult<()> {
            // Implementation to call a function in the VM
            Ok(())
        }
    }===== END OF /home/matt/InterCooperative-Network/crates/icn_smart_contracts/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_storage/Cargo.toml =====
[package]
name = "icn_storage"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
log = "0.4"
thiserror = "1.0"
sha2 = "0.9"

[dev-dependencies]
tokio-test = "0.4"===== END OF /home/matt/InterCooperative-Network/crates/icn_storage/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_storage/src/lib.rs =====
/// The ICN storage module.
pub mod storage_manager;
pub mod storage_node;
===== END OF /home/matt/InterCooperative-Network/crates/icn_storage/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_storage/src/storage_manager.rs =====
use crate::storage_node::StorageNode;
use icn_common::{IcnError, IcnResult};
use std::sync::{Arc, RwLock};
use log::{info, error};

/// Manages storage nodes and handles data storage operations.
pub struct StorageManager {
    nodes: Arc<RwLock<Vec<StorageNode>>>,
}

impl StorageManager {
    /// Creates a new instance of StorageManager.
    pub fn new() -> Self {
        StorageManager {
            nodes: Arc::new(RwLock::new(Vec::new())),
        }
    }

    /// Adds a storage node to the manager.
    ///
    /// # Arguments
    ///
    /// * `node` - The storage node to be added.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn add_node(&self, node: StorageNode) -> IcnResult<()> {
        let mut nodes = self.nodes.write().unwrap();
        nodes.push(node);
        info!("Storage node added");
        Ok(())
    }

    /// Removes a storage node from the manager.
    ///
    /// # Arguments
    ///
    /// * `node_id` - The ID of the storage node to be removed.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn remove_node(&self, node_id: &str) -> IcnResult<()> {
        let mut nodes = self.nodes.write().unwrap();
        nodes.retain(|node| node.id != node_id);
        info!("Storage node removed");
        Ok(())
    }

    /// Stores data across available storage nodes.
    ///
    /// # Arguments
    ///
    /// * `data` - The data to be stored.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn store_data(&self, data: Vec<u8>) -> IcnResult<()> {
        let nodes = self.nodes.read().unwrap();
        if nodes.is_empty() {
            return Err(IcnError::Storage("No available storage nodes".into()));
        }
        // Simple round-robin distribution of data
        let node = &nodes[0];
        node.store(data)?;
        info!("Data stored");
        Ok(())
    }

    /// Retrieves data from storage nodes.
    ///
    /// # Arguments
    ///
    /// * `data_id` - The ID of the data to be retrieved.
    ///
    /// # Returns
    ///
    /// * `IcnResult<Vec<u8>>` - The retrieved data.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn retrieve_data(&self, data_id: &str) -> IcnResult<Vec<u8>> {
        let nodes = self.nodes.read().unwrap();
        for node in nodes.iter() {
            if let Ok(data) = node.retrieve(data_id) {
                return Ok(data);
            }
        }
        Err(IcnError::Storage("Data not found".into()))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::storage_node::MockStorageNode;

    #[test]
    fn test_add_and_remove_node() {
        let manager = StorageManager::new();
        let node = MockStorageNode::new("Node1".to_string());
        assert!(manager.add_node(node).is_ok());
        assert!(manager.remove_node("Node1").is_ok());
    }

    #[test]
    fn test_store_and_retrieve_data() {
        let manager = StorageManager::new();
        let node = MockStorageNode::new("Node1".to_string());
        manager.add_node(node).unwrap();

        let data = vec![1, 2, 3];
        assert!(manager.store_data(data.clone()).is_ok());
        let retrieved_data = manager.retrieve_data("data_id").unwrap();
        assert_eq!(retrieved_data, data);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_storage/src/storage_manager.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_storage/src/storage_node.rs =====
use icn_common::{IcnError, IcnResult};
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use log::{info, error};

/// Represents a storage node in the ICN project.
pub struct StorageNode {
    pub id: String,
    data_store: Arc<RwLock<HashMap<String, Vec<u8>>>>,
}

impl StorageNode {
    /// Creates a new instance of StorageNode.
    ///
    /// # Arguments
    ///
    /// * `id` - The ID of the storage node.
    ///
    /// # Returns
    ///
    /// * `StorageNode` - A new instance of StorageNode.
    pub fn new(id: String) -> Self {
        StorageNode {
            id,
            data_store: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// Stores data in the storage node.
    ///
    /// # Arguments
    ///
    /// * `data` - The data to be stored.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn store(&self, data: Vec<u8>) -> IcnResult<()> {
        let mut data_store = self.data_store.write().unwrap();
        let data_id = format!("data_{}", data_store.len() + 1);
        data_store.insert(data_id.clone(), data);
        info!("Data stored with ID: {}", data_id);
        Ok(())
    }

    /// Retrieves data from the storage node.
    ///
    /// # Arguments
    ///
    /// * `data_id` - The ID of the data to be retrieved.
    ///
    /// # Returns
    ///
    /// * `IcnResult<Vec<u8>>` - The retrieved data.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn retrieve(&self, data_id: &str) -> IcnResult<Vec<u8>> {
        let data_store = self.data_store.read().unwrap();
        data_store.get(data_id).cloned().ok_or_else(|| IcnError::Storage("Data not found".into()))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_store_and_retrieve_data() {
        let node = StorageNode::new("Node1".to_string());
        let data = vec![1, 2, 3];
        assert!(node.store(data.clone()).is_ok());
        let retrieved_data = node.retrieve("data_1").unwrap();
        assert_eq!(retrieved_data, data);
    }

    #[test]
    fn test_retrieve_non_existent_data() {
        let node = StorageNode::new("Node1".to_string());
        assert!(node.retrieve("non_existent_data").is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_storage/src/storage_node.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_testnet/Cargo.toml =====
[package]
name = "icn_testnet"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
icn_blockchain = { path = "../icn_blockchain" }
icn_consensus = { path = "../icn_consensus" }
icn_currency = { path = "../icn_currency" }
icn_governance = { path = "../icn_governance" }
icn_identity = { path = "../icn_identity" }
icn_network = { path = "../icn_network" }
icn_sharding = { path = "../icn_sharding" }
icn_storage = { path = "../icn_storage" }
icn_vm = { path = "../icn_vm" }
icn_core = { path = "../icn_core" }
icn_api = { path = "../icn_api" }
tokio = { version = "1.0", features = ["full"] }
log = "0.4"
env_logger = "0.9"
rand = "0.8"===== END OF /home/matt/InterCooperative-Network/crates/icn_testnet/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_testnet/src/main.rs =====
use icn_core::{IcnNode, Config};
use icn_types::{Transaction, Proposal, ProposalType, ProposalCategory, CurrencyType, ProposalStatus};
use std::io::{self, Write};
use chrono::{Duration, Utc};
use log::{info, warn, error};
use uuid::Uuid;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    env_logger::init();

    let config = Config {
        shard_count: 4,
        consensus_threshold: 0.66,
        consensus_quorum: 0.51,
        network_port: 8080,
    };

    info!("Starting InterCooperative Network testnet...");
    let node = IcnNode::new(config)?;
    node.start()?;

    info!("Node started successfully. Type 'help' for available commands.");

    loop {
        print!("> ");
        io::stdout().flush().unwrap();

        let mut input = String::new();
        io::stdin().read_line(&mut input).unwrap();
        let input = input.trim();

        match input {
            "help" => print_help(),
            "exit" => break,
            "transaction" => process_transaction(&node)?,
            "proposal" => create_proposal(&node)?,
            "balance" => check_balance(&node)?,
            "identity" => create_identity(&node)?,
            "allocate" => allocate_resource(&node)?,
            "network" => get_network_stats(&node)?,
            _ => println!("Unknown command. Type 'help' for available commands."),
        }
    }

    info!("Stopping node...");
    node.stop()?;
    info!("Node stopped. Goodbye!");

    Ok(())
}

fn print_help() {
    println!("Available commands:");
    println!("  help        - Show this help message");
    println!("  transaction - Create a new transaction");
    println!("  proposal    - Create a new proposal");
    println!("  balance     - Check account balance");
    println!("  identity    - Create a new identity");
    println!("  allocate    - Allocate a resource");
    println!("  network     - Get network statistics");
    println!("  exit        - Exit the application");
}

fn process_transaction(node: &IcnNode) -> Result<(), Box<dyn std::error::Error>> {
    info!("Processing a new transaction");
    
    print!("From: ");
    io::stdout().flush()?;
    let mut from = String::new();
    io::stdin().read_line(&mut from)?;
    
    print!("To: ");
    io::stdout().flush()?;
    let mut to = String::new();
    io::stdin().read_line(&mut to)?;
    
    print!("Amount: ");
    io::stdout().flush()?;
    let mut amount_str = String::new();
    io::stdin().read_line(&mut amount_str)?;
    let amount: f64 = amount_str.trim().parse()?;

    let transaction = Transaction {
        from: from.trim().to_string(),
        to: to.trim().to_string(),
        amount,
        currency_type: CurrencyType::BasicNeeds,
        timestamp: Utc::now().timestamp(),
        signature: None,
    };

    node.process_transaction(transaction)?;
    info!("Transaction processed successfully");
    Ok(())
}

fn create_proposal(node: &IcnNode) -> Result<(), Box<dyn std::error::Error>> {
    info!("Creating a new proposal");
    
    print!("Title: ");
    io::stdout().flush()?;
    let mut title = String::new();
    io::stdin().read_line(&mut title)?;
    
    print!("Description: ");
    io::stdout().flush()?;
    let mut description = String::new();
    io::stdin().read_line(&mut description)?;
    
    print!("Proposer: ");
    io::stdout().flush()?;
    let mut proposer = String::new();
    io::stdin().read_line(&mut proposer)?;

    let proposal = Proposal {
        id: Uuid::new_v4().to_string(),
        title: title.trim().to_string(),
        description: description.trim().to_string(),
        proposer: proposer.trim().to_string(),
        created_at: Utc::now(),
        voting_ends_at: Utc::now() + Duration::days(7),
        status: ProposalStatus::Active,
        proposal_type: ProposalType::Constitutional,
        category: ProposalCategory::Economic,
        required_quorum: 0.66,
        execution_timestamp: None,
    };

    let proposal_id = node.create_proposal(proposal)?;
    info!("Proposal created successfully with ID: {}", proposal_id);
    Ok(())
}

fn check_balance(node: &IcnNode) -> Result<(), Box<dyn std::error::Error>> {
    info!("Checking balance");
    
    print!("Address: ");
    io::stdout().flush()?;
    let mut address = String::new();
    io::stdin().read_line(&mut address)?;
    
    let balance = node.get_balance(address.trim(), &CurrencyType::BasicNeeds)?;
    println!("Balance: {}", balance);
    Ok(())
}

fn create_identity(node: &IcnNode) -> Result<(), Box<dyn std::error::Error>> {
    info!("Creating a new identity");
    
    print!("Name: ");
    io::stdout().flush()?;
    let mut name = String::new();
    io::stdin().read_line(&mut name)?;

    print!("Email: ");
    io::stdout().flush()?;
    let mut email = String::new();
    io::stdin().read_line(&mut email)?;

    let mut attributes = std::collections::HashMap::new();
    attributes.insert("name".to_string(), name.trim().to_string());
    attributes.insert("email".to_string(), email.trim().to_string());

    let identity = node.create_identity(attributes)?;
    info!("Identity created successfully with ID: {}", identity.id);
    Ok(())
}

fn allocate_resource(node: &IcnNode) -> Result<(), Box<dyn std::error::Error>> {
    info!("Allocating a resource");
    
    print!("Resource ID: ");
    io::stdout().flush()?;
    let mut resource_id = String::new();
    io::stdin().read_line(&mut resource_id)?;

    print!("Amount: ");
    io::stdout().flush()?;
    let mut amount_str = String::new();
    io::stdin().read_line(&mut amount_str)?;
    let amount: u64 = amount_str.trim().parse()?;

    node.allocate_resource(resource_id.trim(), amount)?;
    info!("Resource allocated successfully");
    Ok(())
}

fn get_network_stats(node: &IcnNode) -> Result<(), Box<dyn std::error::Error>> {
    info!("Getting network statistics");
    
    let stats = node.get_network_stats()?;
    println!("Connected peers: {}", stats.connected_peers);
    println!("Total transactions: {}", stats.total_transactions);
    println!("Network uptime: {} seconds", stats.uptime.as_secs());
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_node_creation_and_basic_operations() {
        let config = Config {
            shard_count: 4,
            consensus_threshold: 0.66,
            consensus_quorum: 0.51,
            network_port: 8080,
        };

        let node = IcnNode::new(config).unwrap();
        assert!(node.start().is_ok());

        // Test create identity
        let mut attributes = std::collections::HashMap::new();
        attributes.insert("name".to_string(), "Alice".to_string());
        attributes.insert("email".to_string(), "alice@example.com".to_string());
        let identity = node.create_identity(attributes).unwrap();
        assert_eq!(identity.attributes.get("name"), Some(&"Alice".to_string()));

        // Test process transaction
        let transaction = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 50.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: Utc::now().timestamp(),
            signature: None,
        };
        assert!(node.process_transaction(transaction).is_ok());

        // Test create proposal
        let proposal = Proposal {
            id: Uuid::new_v4().to_string(),
            title: "Test Proposal".to_string(),
            description: "This is a test proposal".to_string(),
            proposer: "Alice".to_string(),
            created_at: Utc::now(),
            voting_ends_at: Utc::now() + Duration::days(7),
            status: ProposalStatus::Active,
            proposal_type: ProposalType::Constitutional,
            category: ProposalCategory::Economic,
            required_quorum: 0.66,
            execution_timestamp: None,
        };
        assert!(node.create_proposal(proposal).is_ok());

        // Test get network stats
        let stats = node.get_network_stats().unwrap();
        assert!(stats.connected_peers >= 0);

        assert!(node.stop().is_ok());
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_testnet/src/main.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_utils/Cargo.toml =====
# File: icn_utils/Cargo.toml

[package]
name = "icn_utils"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
sha2 = "0.9"
ed25519-dalek = "1.0"
rand = "0.7"
thiserror = "1.0"
serde_json = "1.0"
bincode = "1.3"
hex = "0.4"
icn_common = { path = "../icn_common" }

[dev-dependencies]
serde_json = "1.0"
===== END OF /home/matt/InterCooperative-Network/crates/icn_utils/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_utils/src/error.rs =====
use thiserror::Error;

#[derive(Error, Debug)]
pub enum IcnError {
    #[error("Blockchain error: {0}")]
    Blockchain(String),

    #[error("Consensus error: {0}")]
    Consensus(String),

    #[error("Currency error: {0}")]
    Currency(String),

    #[error("Governance error: {0}")]
    Governance(String),

    #[error("Identity error: {0}")]
    Identity(String),

    #[error("Network error: {0}")]
    Network(String),

    #[error("Node management error: {0}")]
    NodeManagement(String),

    #[error("Sharding error: {0}")]
    Sharding(String),

    #[error("Storage error: {0}")]
    Storage(String),

    #[error("VM error: {0}")]
    Vm(String),

    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),

    #[error("Serialization error: {0}")]
    Serialization(#[from] serde_json::Error),

    #[error("Database error: {0}")]
    Database(String),

    #[error("Configuration error: {0}")]
    Config(String),

    #[error("Unknown error: {0}")]
    Unknown(String),
}

pub type IcnResult<T> = std::result::Result<T, IcnError>;
===== END OF /home/matt/InterCooperative-Network/crates/icn_utils/src/error.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_utils/src/lib.rs =====
// File: icn_utils/src/lib.rs

// Import necessary modules and crates
use sha2::{Digest, Sha256};
use chrono::{DateTime, Duration, Utc};
use hex::FromHexError;

// Function to encode data to a hexadecimal string
pub fn hex_encode(data: &[u8]) -> String {
    hex::encode(data)
}

// Function to decode a hexadecimal string to data
pub fn hex_decode(s: &str) -> Result<Vec<u8>, FromHexError> {
    hex::decode(s)
}

// Function to hash data using SHA-256
pub fn hash_data(data: &[u8]) -> Vec<u8> {
    let mut hasher = Sha256::new();
    hasher.update(data);
    hasher.finalize().to_vec()
}

// Function to calculate the Merkle root from a list of hashes
pub fn calculate_merkle_root(hashes: &[Vec<u8>]) -> Vec<u8> {
    if hashes.is_empty() {
        return vec![];
    }
    if hashes.len() == 1 {
        return hashes[0].clone();
    }
    let mut next_level = Vec::new();
    for chunk in hashes.chunks(2) {
        let mut hasher = Sha256::new();
        hasher.update(&chunk[0]);
        if chunk.len() > 1 {
            hasher.update(&chunk[1]);
        } else {
            hasher.update(&chunk[0]);
        }
        next_level.push(hasher.finalize().to_vec());
    }
    calculate_merkle_root(&next_level)
}

// Time-related utilities
pub mod time {
    use super::*;

    // Function to get the current UTC time
    pub fn now() -> DateTime<Utc> {
        Utc::now()
    }

    // Function to check if a given timestamp is expired based on a duration
    pub fn is_expired(timestamp: DateTime<Utc>, duration: Duration) -> bool {
        now() > timestamp + duration
    }
}

// Cryptographic utilities
pub mod crypto {
    use ed25519_dalek::{Keypair, PublicKey, SecretKey, Signature, Signer, Verifier};
    use rand::rngs::OsRng;

    // Function to generate a new key pair (public and private keys)
    pub fn generate_keypair() -> Keypair {
        let mut csprng = OsRng {};
        Keypair::generate(&mut csprng)
    }

    // Function to sign a message with a given secret key
    pub fn sign(secret_key: &SecretKey, message: &[u8]) -> Signature {
        let keypair = Keypair {
            public: PublicKey::from(secret_key),
            secret: *secret_key,
        };
        keypair.sign(message)
    }

    // Function to verify a signature with a given public key and message
    pub fn verify(public_key: &PublicKey, message: &[u8], signature: &Signature) -> bool {
        public_key.verify(message, signature).is_ok()
    }
}

// Unit tests for the utility functions
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_hex_encode_decode() {
        let data = vec![0x12, 0x34, 0x56, 0x78];
        let encoded = hex_encode(&data);
        assert_eq!(encoded, "12345678");
        let decoded = hex_decode(&encoded).unwrap();
        assert_eq!(decoded, data);
    }

    #[test]
    fn test_hash_data() {
        let data = b"test data";
        let hash = hash_data(data);
        assert_eq!(hash.len(), 32);
    }

    #[test]
    fn test_calculate_merkle_root() {
        let hashes = vec![
            vec![1; 32],
            vec![2; 32],
            vec![3; 32],
            vec![4; 32],
        ];
        let root = calculate_merkle_root(&hashes);
        assert_eq!(root.len(), 32);

        // Test with odd number of hashes
        let odd_hashes = vec![
            vec![1; 32],
            vec![2; 32],
            vec![3; 32],
        ];
        let odd_root = calculate_merkle_root(&odd_hashes);
        assert_eq!(odd_root.len(), 32);
    }

    #[test]
    fn test_time_utils() {
        let now = time::now();
        let duration = Duration::seconds(10);
        assert!(!time::is_expired(now, duration));
        assert!(time::is_expired(now - Duration::seconds(20), duration));
    }

    #[test]
    fn test_crypto_utils() {
        let keypair = crypto::generate_keypair();
        let message = b"test message";
        let signature = crypto::sign(&keypair.secret, message);
        assert!(crypto::verify(&keypair.public, message, &signature));
        
        // Test with incorrect message
        let wrong_message = b"wrong message";
        assert!(!crypto::verify(&keypair.public, wrong_message, &signature));
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_utils/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_utils/src/types/block.rs =====
// icn_utils/src/types/block.rs

use serde::{Serialize, Deserialize};
use sha2::{Sha256, Digest};
use crate::types::transaction::Transaction;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Block {
    pub index: u64,
    pub previous_hash: String,
    pub timestamp: u64,
    pub transactions: Vec<Transaction>,
    pub hash: String,
}

impl Block {
    pub fn new(index: u64, transactions: Vec<Transaction>, previous_hash: String) -> Self {
        let timestamp = chrono::Utc::now().timestamp() as u64;
        let mut block = Block {
            index,
            previous_hash,
            timestamp,
            transactions,
            hash: String::new(),
        };
        block.hash = block.calculate_hash();
        block
    }

    pub fn calculate_hash(&self) -> String {
        let input = format!(
            "{}{}{}{:?}",
            self.index, self.previous_hash, self.timestamp, self.transactions
        );
        let mut hasher = Sha256::new();
        hasher.update(input.as_bytes());
        format!("{:x}", hasher.finalize())
    }

    pub fn genesis() -> Self {
        Block::new(0, vec![], String::from("0"))
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_utils/src/types/block.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_utils/src/types/mod.rs =====
pub mod block;
pub mod transaction;

pub use self::block::Block;
pub use self::transaction::Transaction;

use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Error {
    pub message: String,
}

pub type Result<T> = std::result::Result<T, Error>;

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, Hash)]
pub enum CurrencyType {
    BasicNeeds,
    Education,
    Environmental,
    Community,
    Volunteer,
    Storage,
    Processing,
    Energy,
    Luxury,
    Service,
    Custom(String),
    AssetToken(String),
    Bond(String),
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Currency {
    pub currency_type: CurrencyType,
    pub total_supply: f64,
    pub creation_date: DateTime<Utc>,
    pub last_issuance: DateTime<Utc>,
    pub issuance_rate: f64,
}

impl Currency {
    pub fn new(currency_type: CurrencyType, initial_supply: f64, issuance_rate: f64) -> Self {
        let now = Utc::now();
        Currency {
            currency_type,
            total_supply: initial_supply,
            creation_date: now,
            last_issuance: now,
            issuance_rate,
        }
    }

    pub fn mint(&mut self, amount: f64) -> Result<()> {
        self.total_supply += amount;
        self.last_issuance = Utc::now();
        Ok(())
    }

    pub fn burn(&mut self, amount: f64) -> Result<()> {
        if amount > self.total_supply {
            return Err(Error {
                message: "Insufficient supply to burn".to_string(),
            });
        }
        self.total_supply -= amount;
        Ok(())
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CurrencySystem {
    pub currencies: HashMap<CurrencyType, Currency>,
}

impl CurrencySystem {
    pub fn new() -> Self {
        CurrencySystem {
            currencies: HashMap::new(),
        }
    }

    pub fn add_currency(&mut self, currency_type: CurrencyType, initial_supply: f64, issuance_rate: f64) {
        let currency = Currency::new(currency_type.clone(), initial_supply, issuance_rate);
        self.currencies.insert(currency_type, currency);
    }

    pub fn get_currency(&self, currency_type: &CurrencyType) -> Option<&Currency> {
        self.currencies.get(currency_type)
    }

    pub fn get_currency_mut(&mut self, currency_type: &CurrencyType) -> Option<&mut Currency> {
        self.currencies.get_mut(currency_type)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_currency_mint_burn() {
        let mut currency = Currency::new(CurrencyType::BasicNeeds, 1000.0, 0.01);
        assert!(currency.mint(100.0).is_ok());
        assert_eq!(currency.total_supply, 1100.0);
        assert!(currency.burn(200.0).is_ok());
        assert_eq!(currency.total_supply, 900.0);
        assert!(currency.burn(1000.0).is_err());
    }

    #[test]
    fn test_currency_system() {
        let mut system = CurrencySystem::new();
        system.add_currency(CurrencyType::BasicNeeds, 1000.0, 0.01);
        system.add_currency(CurrencyType::Education, 500.0, 0.005);

        assert!(system.get_currency(&CurrencyType::BasicNeeds).is_some());
        assert!(system.get_currency(&CurrencyType::Education).is_some());
        assert!(system.get_currency(&CurrencyType::Environmental).is_none());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_utils/src/types/mod.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_utils/src/types/transaction.rs =====
use serde::{Deserialize, Serialize};
use ed25519_dalek::{Keypair, PublicKey, Signature, Signer, Verifier};
use crate::types::CurrencyType; // Import CurrencyType from crate
use bincode;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Transaction {
    pub from: String,
    pub to: String,
    pub amount: f64,
    pub gas_limit: u64,
    pub currency_type: CurrencyType, // Add this field
    pub signature: Option<Vec<u8>>,
    pub public_key: Option<Vec<u8>>,
}

impl Transaction {
    pub fn new(from: String, to: String, amount: f64, gas_limit: u64, currency_type: CurrencyType) -> Self {
        Transaction {
            from,
            to,
            amount,
            gas_limit,
            currency_type, // Initialize the field
            signature: None,
            public_key: None,
        }
    }

    pub fn sign(&mut self, keypair: &Keypair) -> Result<(), String> {
        let message = self.to_bytes();
        let signature = keypair.sign(&message);
        self.signature = Some(signature.to_bytes().to_vec());
        self.public_key = Some(keypair.public.to_bytes().to_vec());
        Ok(())
    }

    pub fn verify(&self) -> Result<bool, String> {
        let public_key_bytes = self.public_key.as_ref().ok_or("No public key present")?;
        let signature_bytes = self.signature.as_ref().ok_or("No signature present")?;

        let public_key = PublicKey::from_bytes(public_key_bytes).map_err(|e| e.to_string())?;
        let signature = Signature::from_bytes(signature_bytes).map_err(|e| e.to_string())?;

        let message = self.to_bytes();
        Ok(public_key.verify(&message, &signature).is_ok())
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut bytes = Vec::new();
        bytes.extend_from_slice(self.from.as_bytes());
        bytes.extend_from_slice(self.to.as_bytes());
        bytes.extend_from_slice(&self.amount.to_le_bytes());
        bytes.extend_from_slice(&self.gas_limit.to_le_bytes());
        // Serialize currency_type and append to bytes
        let currency_type_bytes = bincode::serialize(&self.currency_type).unwrap();
        bytes.extend_from_slice(&currency_type_bytes);
        bytes
    }

    pub fn to_string(&self) -> String {
        format!("{}{}{}{}", self.from, self.to, self.amount, self.gas_limit)
    }

    pub fn is_signed(&self) -> bool {
        self.signature.is_some() && self.public_key.is_some()
    }

    pub fn get_fee(&self) -> f64 {
        self.gas_limit as f64 * 0.0001
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_utils/src/types/transaction.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_utils/src/utils.rs =====
// icn_utils/src/utils.rs

// Placeholder for utility functions
pub fn some_utility_function() {
    // Utility function implementation
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_utils/src/utils.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_vm/Cargo.toml =====
[package]
name = "icn_vm"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
log = "0.4"
thiserror = "1.0"
chrono = { version = "0.4", features = ["serde"] }

[dev-dependencies]
tokio-test = "0.4"===== END OF /home/matt/InterCooperative-Network/crates/icn_vm/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_vm/src/compiler.rs =====
use crate::vm::opcode::{Opcode, Value};
use std::error::Error;

// Define the tokens that the lexer will generate from source code
#[derive(Debug, PartialEq, Clone)]
enum Token {
    Identifier(String),
    Integer(i64),
    Float(f64),
    String(String),
    True,
    False,
    If,
    Else,
    While,
    Function,
    Return,
    Vote,
    AllocateResource,
    UpdateReputation,
    CreateProposal,
    GetProposalStatus,
    Emit,
    LParen,
    RParen,
    LBrace,
    RBrace,
    Semicolon,
    Comma,
    Equals,
    Plus,
    Minus,
    Multiply,
    Divide,
    Modulo,
    DoubleEquals,
    NotEquals,
    GreaterThan,
    LessThan,
    GreaterThanEquals,
    LessThanEquals,
    And,
    Or,
    Not,
}

// Lexer for converting source code into tokens
struct Lexer {
    input: Vec<char>,
    position: usize,
}

impl Lexer {
    // Create a new lexer with the given input string
    fn new(input: &str) -> Self {
        Lexer {
            input: input.chars().collect(),
            position: 0,
        }
    }

    // Get the next token from the input
    fn next_token(&mut self) -> Option<Token> {
        self.skip_whitespace();

        if self.position >= self.input.len() {
            return None;
        }

        match self.input[self.position] {
            '(' => {
                self.position += 1;
                Some(Token::LParen)
            }
            ')' => {
                self.position += 1;
                Some(Token::RParen)
            }
            '{' => {
                self.position += 1;
                Some(Token::LBrace)
            }
            '}' => {
                self.position += 1;
                Some(Token::RBrace)
            }
            ';' => {
                self.position += 1;
                Some(Token::Semicolon)
            }
            ',' => {
                self.position += 1;
                Some(Token::Comma)
            }
            '+' => {
                self.position += 1;
                Some(Token::Plus)
            }
            '-' => {
                self.position += 1;
                Some(Token::Minus)
            }
            '*' => {
                self.position += 1;
                Some(Token::Multiply)
            }
            '/' => {
                self.position += 1;
                Some(Token::Divide)
            }
            '%' => {
                self.position += 1;
                Some(Token::Modulo)
            }
            '=' => {
                if self.peek_next() == Some('=') {
                    self.position += 2;
                    Some(Token::DoubleEquals)
                } else {
                    self.position += 1;
                    Some(Token::Equals)
                }
            }
            '!' => {
                if self.peek_next() == Some('=') {
                    self.position += 2;
                    Some(Token::NotEquals)
                } else {
                    self.position += 1;
                    Some(Token::Not)
                }
            }
            '>' => {
                if self.peek_next() == Some('=') {
                    self.position += 2;
                    Some(Token::GreaterThanEquals)
                } else {
                    self.position += 1;
                    Some(Token::GreaterThan)
                }
            }
            '<' => {
                if self.peek_next() == Some('=') {
                    self.position += 2;
                    Some(Token::LessThanEquals)
                } else {
                    self.position += 1;
                    Some(Token::LessThan)
                }
            }
            '&' => {
                if self.peek_next() == Some('&') {
                    self.position += 2;
                    Some(Token::And)
                } else {
                    None // Invalid token
                }
            }
            '|' => {
                if self.peek_next() == Some('|') {
                    self.position += 2;
                    Some(Token::Or)
                } else {
                    None // Invalid token
                }
            }
            '"' => Some(self.read_string()),
            c if c.is_alphabetic() => Some(self.read_identifier()),
            c if c.is_digit(10) => Some(self.read_number()),
            _ => None, // Invalid token
        }
    }

    // Skip whitespace characters in the input
    fn skip_whitespace(&mut self) {
        while self.position < self.input.len() && self.input[self.position].is_whitespace() {
            self.position += 1;
        }
    }

    // Peek at the next character without advancing the position
    fn peek_next(&self) -> Option<char> {
        if self.position + 1 < self.input.len() {
            Some(self.input[self.position + 1])
        } else {
            None
        }
    }

    // Read a string token from the input
    fn read_string(&mut self) -> Token {
        self.position += 1; // Skip opening quote
        let start = self.position;
        while self.position < self.input.len() && self.input[self.position] != '"' {
            self.position += 1;
        }
        let value: String = self.input[start..self.position].iter().collect();
        self.position += 1; // Skip closing quote
        Token::String(value)
    }

    // Read an identifier token from the input
    fn read_identifier(&mut self) -> Token {
        let start = self.position;
        while self.position < self.input.len() && (self.input[self.position].is_alphanumeric() || self.input[self.position] == '_') {
            self.position += 1;
        }
        let value: String = self.input[start..self.position].iter().collect();
        match value.as_str() {
            "true" => Token::True,
            "false" => Token::False,
            "if" => Token::If,
            "else" => Token::Else,
            "while" => Token::While,
            "function" => Token::Function,
            "return" => Token::Return,
            "vote" => Token::Vote,
            "allocate_resource" => Token::AllocateResource,
            "update_reputation" => Token::UpdateReputation,
            "create_proposal" => Token::CreateProposal,
            "get_proposal_status" => Token::GetProposalStatus,
            "emit" => Token::Emit,
            _ => Token::Identifier(value),
        }
    }

    // Read a number token from the input
    fn read_number(&mut self) -> Token {
        let start = self.position;
        let mut is_float = false;
        while self.position < self.input.len() && (self.input[self.position].is_digit(10) || self.input[self.position] == '.') {
            if self.input[self.position] == '.' {
                is_float = true;
            }
            self.position += 1;
        }
        let value: String = self.input[start..self.position].iter().collect();
        if is_float {
            Token::Float(value.parse().unwrap())
        } else {
            Token::Integer(value.parse().unwrap())
        }
    }
}

// Parser for converting tokens into opcodes
struct Parser {
    tokens: Vec<Token>,
    position: usize,
}

impl Parser {
    // Create a new parser with the given tokens
    fn new(tokens: Vec<Token>) -> Self {
        Parser {
            tokens,
            position: 0,
        }
    }

    // Parse the tokens into a vector of opcodes
    fn parse(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        let mut opcodes = Vec::new();
        while self.position < self.tokens.len() {
            opcodes.append(&mut self.parse_statement()?);
        }
        Ok(opcodes)
    }

    // Parse a single statement into opcodes
    fn parse_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        match self.current_token() {
            Some(Token::If) => self.parse_if_statement(),
            Some(Token::While) => self.parse_while_statement(),
            Some(Token::Function) => self.parse_function_definition(),
            Some(Token::Return) => self.parse_return_statement(),
            Some(Token::Identifier(_)) => self.parse_assignment_or_function_call(),
            Some(Token::Vote) => self.parse_vote_statement(),
            Some(Token::AllocateResource) => self.parse_allocate_resource_statement(),
            Some(Token::UpdateReputation) => self.parse_update_reputation_statement(),
            Some(Token::CreateProposal) => self.parse_create_proposal_statement(),
            Some(Token::GetProposalStatus) => self.parse_get_proposal_status_statement(),
            Some(Token::Emit) => self.parse_emit_statement(),
            _ => Err("Unexpected token in statement".into()),
        }
    }

    // Parse an if statement into opcodes
    fn parse_if_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        // Implementation for parsing if statements
        Err("If statement parsing not implemented yet".into())
    }

    // Parse a while loop into opcodes
    fn parse_while_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        // Implementation for parsing while loops
        Err("While statement parsing not implemented yet".into())
    }

    // Parse a function definition into opcodes
    fn parse_function_definition(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        // Implementation for parsing function definitions
        Err("Function definition parsing not implemented yet".into())
    }

    // Parse a return statement into opcodes
    fn parse_return_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        self.consume_token(Token::Return)?;
        let mut opcodes = self.parse_expression()?;
        opcodes.push(Opcode::Return);
        self.consume_token(Token::Semicolon)?;
        Ok(opcodes)
    }

    // Parse an assignment or function call into opcodes
    fn parse_assignment_or_function_call(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        let identifier = self.consume_identifier()?;
        match self.current_token() {
            Some(Token::Equals) => self.parse_assignment(identifier),
            Some(Token::LParen) => self.parse_function_call(identifier),
            _ => Err("Expected '=' or '(' after identifier".into()),
        }
    }

    // Parse an assignment statement into opcodes
    fn parse_assignment(&mut self, identifier: String) -> Result<Vec<Opcode>, Box<dyn Error>> {
        self.consume_token(Token::Equals)?;
        let mut opcodes = self.parse_expression()?;
        opcodes.push(Opcode::Store(identifier));
        self.consume_token(Token::Semicolon)?;
        Ok(opcodes)
    }

    // Parse a function call into opcodes
    fn parse_function_call(&mut self, identifier: String) -> Result<Vec<Opcode>, Box<dyn Error>> {
        self.consume_token(Token::LParen)?;
        let mut opcodes = Vec::new();
        while !matches!(self.current_token(), Some(Token::RParen)) {
            opcodes.append(&mut self.parse_expression()?);
            if matches!(self.current_token(), Some(Token::Comma)) {
                self.consume_token(Token::Comma)?;
            }
        }
        self.consume_token(Token::RParen)?;
        opcodes.push(Opcode::Call(identifier));
        self.consume_token(Token::Semicolon)?;
        Ok(opcodes)
    }

    // Parse a vote statement into opcodes
    fn parse_vote_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        self.consume_token(Token::Vote)?;
        self.consume_token(Token::LParen)?;
        let proposal_id = self.consume_string()?;
        self.consume_token(Token::Comma)?;
        let mut opcodes = self.parse_expression()?; // This should push a boolean onto the stack
        self.consume_token(Token::RParen)?;
        opcodes.push(Opcode::Vote(proposal_id));
        self.consume_token(Token::Semicolon)?;
        Ok(opcodes)
    }

    // Parse an allocate resource statement into opcodes
    fn parse_allocate_resource_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        self.consume_token(Token::AllocateResource)?;
        self.consume_token(Token::LParen)?;
        let resource_id = self.consume_string()?;
        self.consume_token(Token::Comma)?;
        let mut opcodes = self.parse_expression()?; // This should push an integer onto the stack
        self.consume_token(Token::RParen)?;
        opcodes.push(Opcode::AllocateResource(resource_id));
        self.consume_token(Token::Semicolon)?;
        Ok(opcodes)
    }

    // Parse an update reputation statement into opcodes
    fn parse_update_reputation_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        self.consume_token(Token::UpdateReputation)?;
        self.consume_token(Token::LParen)?;
        let address = self.consume_string()?;
        self.consume_token(Token::Comma)?;
        let mut opcodes = self.parse_expression()?; // This should push an integer onto the stack
        self.consume_token(Token::RParen)?;
        opcodes.push(Opcode::UpdateReputation(address));
        self.consume_token(Token::Semicolon)?;
        Ok(opcodes)
    }

    // Parse a create proposal statement into opcodes
    fn parse_create_proposal_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        self.consume_token(Token::CreateProposal)?;
        self.consume_token(Token::LParen)?;
        let mut opcodes = self.parse_expression()?; // This should push a string onto the stack
        self.consume_token(Token::RParen)?;
        opcodes.push(Opcode::CreateProposal);
        self.consume_token(Token::Semicolon)?;
        Ok(opcodes)
    }

    // Parse a get proposal status statement into opcodes
    fn parse_get_proposal_status_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        self.consume_token(Token::GetProposalStatus)?;
        self.consume_token(Token::LParen)?;
        let mut opcodes = self.parse_expression()?; // This should push a string onto the stack
        self.consume_token(Token::RParen)?;
        opcodes.push(Opcode::GetProposalStatus);
        self.consume_token(Token::Semicolon)?;
        Ok(opcodes)
    }

    // Parse an emit statement into opcodes
    fn parse_emit_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        self.consume_token(Token::Emit)?;
        self.consume_token(Token::LParen)?;
        let event_name = self.consume_string()?;
        self.consume_token(Token::Comma)?;
        let mut opcodes = self.parse_expression()?; // This should push the event data onto the stack
        self.consume_token(Token::RParen)?;
        opcodes.push(Opcode::Emit(event_name));
        self.consume_token(Token::Semicolon)?;
        Ok(opcodes)
    }

    // Parse an expression into opcodes
    fn parse_expression(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        let mut opcodes = self.parse_term()?;

        while let Some(token) = self.current_token() {
            match token {
                Token::Plus => {
                    self.position += 1;
                    opcodes.append(&mut self.parse_term()?);
                    opcodes.push(Opcode::Add);
                }
                Token::Minus => {
                    self.position += 1;
                    opcodes.append(&mut self.parse_term()?);
                    opcodes.push(Opcode::Sub);
                }
                _ => break,
            }
        }

        Ok(opcodes)
    }

    fn parse_term(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        let mut opcodes = self.parse_factor()?;

        while let Some(token) = self.current_token() {
            match token {
                Token::Multiply => {
                    self.position += 1;
                    opcodes.append(&mut self.parse_factor()?);
                    opcodes.push(Opcode::Mul);
                }
                Token::Divide => {
                    self.position += 1;
                    opcodes.append(&mut self.parse_factor()?);
                    opcodes.push(Opcode::Div);
                }
                _ => break,
            }
        }

        Ok(opcodes)
    }

    fn parse_factor(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        let token = self.current_token().cloned();
        match token {
            Some(Token::Integer(value)) => {
                self.position += 1;
                Ok(vec![Opcode::Push(Value::Int(value))])
            }
            Some(Token::Float(value)) => {
                self.position += 1;
                Ok(vec![Opcode::Push(Value::Float(value))])
            }
            Some(Token::String(value)) => {
                self.position += 1;
                Ok(vec![Opcode::Push(Value::String(value))])
            }
            Some(Token::True) => {
                self.position += 1;
                Ok(vec![Opcode::Push(Value::Bool(true))])
            }
            Some(Token::False) => {
                self.position += 1;
                Ok(vec![Opcode::Push(Value::Bool(false))])
            }
            Some(Token::Identifier(name)) => {
                self.position += 1;
                Ok(vec![Opcode::Load(name)])
            }
            Some(Token::LParen) => {
                self.position += 1;
                let expr = self.parse_expression()?;
                self.consume_token(Token::RParen)?;
                Ok(expr)
            }
            _ => Err("Unexpected token in expression".into()),
        }
    }

    // Consume the next token if it matches the expected token
    fn consume_token(&mut self, expected: Token) -> Result<(), Box<dyn Error>> {
        if self.current_token() == Some(&expected) {
            self.position += 1;
            Ok(())
        } else {
            Err(format!("Unexpected token: expected {:?}, found {:?}", expected, self.current_token()).into())
        }
    }

    // Consume an identifier token
    fn consume_identifier(&mut self) -> Result<String, Box<dyn Error>> {
        if let Some(Token::Identifier(name)) = self.current_token().cloned() {
            self.position += 1;
            Ok(name)
        } else {
            Err(format!("Expected identifier, found {:?}", self.current_token()).into())
        }
    }

    // Consume a string token
    fn consume_string(&mut self) -> Result<String, Box<dyn Error>> {
        if let Some(Token::String(value)) = self.current_token().cloned() {
            self.position += 1;
            Ok(value)
        } else {
            Err(format!("Expected string, found {:?}", self.current_token()).into())
        }
    }

    // Get the current token
    fn current_token(&self) -> Option<&Token> {
        self.tokens.get(self.position)
    }
}

// Compiler for converting source code into opcodes
pub struct CSCLCompiler {
    lexer: Lexer,
}

impl CSCLCompiler {
    // Create a new compiler with the given input source code
    pub fn new(input: &str) -> Self {
        CSCLCompiler {
            lexer: Lexer::new(input),
        }
    }

    // Compile the source code into a vector of opcodes
    pub fn compile(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        let tokens = self.lexer.tokens();
        let mut parser = Parser::new(tokens);
        parser.parse()
    }
}

impl Lexer {
    // Get all tokens from the input
    fn tokens(&mut self) -> Vec<Token> {
        let mut tokens = Vec::new();
        while let Some(token) = self.next_token() {
            tokens.push(token);
        }
        tokens
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_lexer() {
        let input = "function test(x, y) { return x + y; }";
        let mut lexer = Lexer::new(input);
        let tokens = lexer.tokens();

        assert_eq!(tokens, vec![
            Token::Function,
            Token::Identifier("test".to_string()),
            Token::LParen,
            Token::Identifier("x".to_string()),
            Token::Comma,
            Token::Identifier("y".to_string()),
            Token::RParen,
            Token::LBrace,
            Token::Return,
            Token::Identifier("x".to_string()),
            Token::Plus,
            Token::Identifier("y".to_string()),
            Token::Semicolon,
            Token::RBrace,
        ]);
    }

    #[test]
    fn test_compiler() {
        let input = "x = 5 + 3 * 2; y = (10 - 4) / 2;";
        let mut compiler = CSCLCompiler::new(input);
        let opcodes = compiler.compile().unwrap();

        assert_eq!(opcodes, vec![
            Opcode::Push(Value::Int(5)),
            Opcode::Push(Value::Int(3)),
            Opcode::Push(Value::Int(2)),
            Opcode::Mul,
            Opcode::Add,
            Opcode::Store("x".to_string()),
            Opcode::Push(Value::Int(10)),
            Opcode::Push(Value::Int(4)),
            Opcode::Sub,
            Opcode::Push(Value::Int(2)),
            Opcode::Div,
            Opcode::Store("y".to_string()),
        ]);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_vm/src/compiler.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_vm/src/coop_vm.rs =====
use super::opcode::{Opcode, Value};
use std::collections::HashMap;

pub struct CoopVM {
    stack: Vec<Value>,
    memory: HashMap<String, Value>,
    program: Vec<Opcode>,
    pc: usize,
}

impl CoopVM {
    pub fn new(program: Vec<Opcode>) -> Self {
        CoopVM {
            stack: Vec::new(),
            memory: HashMap::new(),
            program,
            pc: 0,
        }
    }

    pub fn load_program(&mut self, program: Vec<Opcode>) {
        self.program = program;
        self.pc = 0;
    }

    pub fn run(&mut self) -> Result<(), String> {
        while self.pc < self.program.len() {
            self.execute_instruction()?;
            self.pc += 1;
        }
        Ok(())
    }

    fn execute_instruction(&mut self) -> Result<(), String> {
        let opcode = self.program[self.pc].clone();
        match opcode {
            Opcode::Push(value) => self.stack.push(value),
            Opcode::Pop => {
                self.stack.pop().ok_or("Stack underflow")?;
            }
            Opcode::Add => self.binary_op(|a, b| a + b)?,
            Opcode::Sub => self.binary_op(|a, b| a - b)?,
            Opcode::Mul => self.binary_op(|a, b| a * b)?,
            Opcode::Div => self.binary_op(|a, b| a / b)?,
            Opcode::Eq => self.compare_op(|a, b| a == b)?,
            Opcode::Lt => self.compare_op(|a, b| a < b)?,
            Opcode::Gt => self.compare_op(|a, b| a > b)?,
            Opcode::And => self.logic_op(|a, b| a && b)?,
            Opcode::Or => self.logic_op(|a, b| a || b)?,
            Opcode::Not => {
                let a = self.pop_bool()?;
                self.stack.push(Value::Bool(!a));
            }
            Opcode::Return => return Ok(()), // For now, just return
            Opcode::Store(name) => {
                let value = self.stack.pop().ok_or("Stack underflow")?;
                self.memory.insert(name, value);
            }
            Opcode::Load(name) => {
                let value = self.memory.get(&name).ok_or("Variable not found")?.clone();
                self.stack.push(value);
            }
            Opcode::Call(_) => return Err("Function calls not implemented yet".to_string()),
            Opcode::Vote(proposal_id) => {
                let vote = self.pop_bool()?;
                println!("Voting {} on proposal {}", if vote { "Yes" } else { "No" }, proposal_id);
            }
            Opcode::AllocateResource(resource_id) => {
                let amount = self.pop_int()?;
                println!("Allocating {} units of resource {}", amount, resource_id);
            }
            Opcode::UpdateReputation(address) => {
                let change = self.pop_int()?;
                println!("Updating reputation of {} by {}", address, change);
            }
            Opcode::CreateProposal => {
                let description = self.pop_string()?;
                println!("Creating proposal: {}", description);
                self.stack.push(Value::String("new_proposal_id".to_string()));
            }
            Opcode::GetProposalStatus => {
                let proposal_id = self.pop_string()?;
                println!("Getting status of proposal: {}", proposal_id);
                self.stack.push(Value::String("Active".to_string()));
            }
            Opcode::Emit(event_name) => {
                let event_data = self.stack.pop().ok_or("Stack underflow")?;
                println!("Emitting event {}: {:?}", event_name, event_data);
            }
        }
        Ok(())
    }

    fn binary_op<F>(&mut self, op: F) -> Result<(), String>
    where
        F: Fn(i64, i64) -> i64,
    {
        let b = self.pop_int()?;
        let a = self.pop_int()?;
        self.stack.push(Value::Int(op(a, b)));
        Ok(())
    }

    fn compare_op<F>(&mut self, op: F) -> Result<(), String>
    where
        F: Fn(&Value, &Value) -> bool,
    {
        let b = self.stack.pop().ok_or("Stack underflow")?;
        let a = self.stack.pop().ok_or("Stack underflow")?;
        self.stack.push(Value::Bool(op(&a, &b)));
        Ok(())
    }

    fn logic_op<F>(&mut self, op: F) -> Result<(), String>
    where
        F: Fn(bool, bool) -> bool,
    {
        let b = self.pop_bool()?;
        let a = self.pop_bool()?;
        self.stack.push(Value::Bool(op(a, b)));
        Ok(())
    }

    fn pop_int(&mut self) -> Result<i64, String> {
        match self.stack.pop().ok_or("Stack underflow")? {
            Value::Int(i) => Ok(i),
            _ => Err("Expected integer value".to_string()),
        }
    }

    fn pop_bool(&mut self) -> Result<bool, String> {
        match self.stack.pop().ok_or("Stack underflow")? {
            Value::Bool(b) => Ok(b),
            _ => Err("Expected boolean value".to_string()),
        }
    }

    fn pop_string(&mut self) -> Result<String, String> {
        match self.stack.pop().ok_or("Stack underflow")? {
            Value::String(s) => Ok(s),
            _ => Err("Expected string value".to_string()),
        }
    }

    pub fn get_stack(&self) -> &Vec<Value> {
        &self.stack
    }

    pub fn get_memory(&self) -> &HashMap<String, Value> {
        &self.memory
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_vm/src/coop_vm.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_vm/src/lib.rs =====
use icn_common::{IcnResult, IcnError};
use std::collections::HashMap;

#[derive(Clone, Debug, PartialEq)]
pub enum Value {
    Int(i64),
    Float(f64),
    Bool(bool),
    String(String),
}

#[derive(Clone, Debug)]
pub enum Opcode {
    Push(Value),
    Pop,
    Add,
    Sub,
    Mul,
    Div,
    Eq,
    Neq,
    Lt,
    Lte,
    Gt,
    Gte,
    And,
    Or,
    Not,
    Store(String),
    Load(String),
    Call(String),
    JumpIf(usize),
    Jump(usize),
}

pub struct CoopVM {
    stack: Vec<Value>,
    memory: HashMap<String, Value>,
    program: Vec<Opcode>,
    pc: usize,
    context: Option<ContractContext>,
}

pub struct ContractContext {
    pub balances: HashMap<String, f64>,
    pub votes: HashMap<String, bool>,
    pub reputation: HashMap<String, i32>,
}

impl CoopVM {
    pub fn new(program: Vec<Opcode>) -> Self {
        CoopVM {
            stack: Vec::new(),
            memory: HashMap::new(),
            program,
            pc: 0,
            context: None,
        }
    }

    pub fn load_program(&mut self, program: Vec<Opcode>) {
        self.program = program;
        self.pc = 0;
    }

    pub fn set_context(&mut self, context: &ContractContext) {
        self.context = Some(ContractContext {
            balances: context.balances.clone(),
            votes: context.votes.clone(),
            reputation: context.reputation.clone(),
        });
    }

    pub fn run(&mut self) -> IcnResult<()> {
        while self.pc < self.program.len() {
            self.execute_instruction()?;
            self.pc += 1;
        }
        Ok(())
    }

    fn execute_instruction(&mut self) -> IcnResult<()> {
        let instruction = &self.program[self.pc];
        match instruction {
            Opcode::Push(value) => self.stack.push(value.clone()),
            Opcode::Pop => { self.stack.pop().ok_or(IcnError::VM("Stack underflow".into()))? ; }
            Opcode::Add => self.binary_op(|a, b| a + b)?,
            Opcode::Sub => self.binary_op(|a, b| a - b)?,
            Opcode::Mul => self.binary_op(|a, b| a * b)?,
            Opcode::Div => self.binary_op(|a, b| a / b)?,
            Opcode::Eq => self.compare_op(|a, b| a == b)?,
            Opcode::Neq => self.compare_op(|a, b| a != b)?,
            Opcode::Lt => self.compare_op(|a, b| a < b)?,
            Opcode::Lte => self.compare_op(|a, b| a <= b)?,
            Opcode::Gt => self.compare_op(|a, b| a > b)?,
            Opcode::Gte => self.compare_op(|a, b| a >= b)?,
            Opcode::And => self.logic_op(|a, b| a && b)?,
            Opcode::Or => self.logic_op(|a, b| a || b)?,
            Opcode::Not => {
                let a = self.pop_bool()?;
                self.stack.push(Value::Bool(!a));
            }
            Opcode::Store(name) => {
                let value = self.stack.pop().ok_or(IcnError::VM("Stack underflow".into()))?;
                self.memory.insert(name.clone(), value);
            }
            Opcode::Load(name) => {
                let value = self.memory.get(name).ok_or(IcnError::VM("Variable not found".into()))?.clone();
                self.stack.push(value);
            }
            Opcode::Call(function) => {
                let result = self.execute_built_in(function)?;
                if let Some(value) = result {
                    self.stack.push(value);
                }
            }
            Opcode::JumpIf(target) => {
                if self.pop_bool()? {
                    self.pc = *target - 1; // -1 because pc will be incremented after this instruction
                }
            }
            Opcode::Jump(target) => {
                self.pc = *target - 1; // -1 because pc will be incremented after this instruction
            }
        }
        Ok(())
    }

    fn binary_op<F>(&mut self, op: F) -> IcnResult<()>
    where
        F: Fn(f64, f64) -> f64,
    {
        let b = self.pop_number()?;
        let a = self.pop_number()?;
        self.stack.push(Value::Float(op(a, b)));
        Ok(())
    }

    fn compare_op<F>(&mut self, op: F) -> IcnResult<()>
    where
        F: Fn(f64, f64) -> bool,
    {
        let b = self.pop_number()?;
        let a = self.pop_number()?;
        self.stack.push(Value::Bool(op(a, b)));
        Ok(())
    }

    fn logic_op<F>(&mut self, op: F) -> IcnResult<()>
    where
        F: Fn(bool, bool) -> bool,
    {
        let b = self.pop_bool()?;
        let a = self.pop_bool()?;
        self.stack.push(Value::Bool(op(a, b)));
        Ok(())
    }

    fn pop_number(&mut self) -> IcnResult<f64> {
        match self.stack.pop().ok_or(IcnError::VM("Stack underflow".into()))? {
            Value::Int(i) => Ok(i as f64),
            Value::Float(f) => Ok(f),
            _ => Err(IcnError::VM("Expected number".into())),
        }
    }

    fn pop_bool(&mut self) -> IcnResult<bool> {
        match self.stack.pop().ok_or(IcnError::VM("Stack underflow".into()))? {
            Value::Bool(b) => Ok(b),
            _ => Err(IcnError::VM("Expected boolean".into())),
        }
    }

    fn pop_string(&mut self) -> IcnResult<String> {
        match self.stack.pop().ok_or(IcnError::VM("Stack underflow".into()))? {
            Value::String(s) => Ok(s),
            _ => Err(IcnError::VM("Expected string".into())),
        }
    }

    fn execute_built_in(&mut self, function: &str) -> IcnResult<Option<Value>> {
        match function {
            "transfer" => self.transfer(),
            "vote" => self.vote(),
            "get_balance" => self.get_balance(),
            "update_reputation" => self.update_reputation(),
            _ => Err(IcnError::VM(format!("Unknown built-in function: {}", function))),
        }
    }

    fn transfer(&mut self) -> IcnResult<Option<Value>> {
        let amount = self.pop_number()?;
        let to = self.pop_string()?;
        let from = self.pop_string()?;

        let context = self.context.as_mut().ok_or(IcnError::VM("No context set".into()))?;
        
        let from_balance = context.balances.entry(from.clone()).or_insert(0.0);
        if *from_balance < amount {
            return Err(IcnError::VM("Insufficient balance".into()));
        }
        *from_balance -= amount;

        let to_balance = context.balances.entry(to.clone()).or_insert(0.0);
        *to_balance += amount;

        Ok(None)
    }

    fn vote(&mut self) -> IcnResult<Option<Value>> {
        let vote = self.pop_bool()?;
        let proposal = self.pop_string()?;

        let context = self.context.as_mut().ok_or(IcnError::VM("No context set".into()))?;
        context.votes.insert(proposal, vote);

        Ok(None)
    }

    fn get_balance(&mut self) -> IcnResult<Option<Value>> {
        let address = self.pop_string()?;

        let context = self.context.as_ref().ok_or(IcnError::VM("No context set".into()))?;
        let balance = *context.balances.get(&address).unwrap_or(&0.0);

        Ok(Some(Value::Float(balance)))
    }

    fn update_reputation(&mut self) -> IcnResult<Option<Value>> {
        let change = self.pop_number()? as i32;
        let address = self.pop_string()?;

        let context = self.context.as_mut().ok_or(IcnError::VM("No context set".into()))?;
        let reputation = context.reputation.entry(address).or_insert(0);
        *reputation += change;

        Ok(None)
    }

    pub fn get_stack(&self) -> &Vec<Value> {
        &self.stack
    }

    pub fn get_memory(&self) -> &HashMap<String, Value> {
        &self.memory
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_operations() {
        let program = vec![
            Opcode::Push(Value::Int(5)),
            Opcode::Push(Value::Int(3)),
            Opcode::Add,
            Opcode::Push(Value::Int(2)),
            Opcode::Mul,
        ];

        let mut vm = CoopVM::new(program);
        vm.run().unwrap();

        assert_eq!(vm.stack, vec![Value::Float(16.0)]);
    }

    #[test]
    fn test_transfer() {
        let program = vec![
            Opcode::Push(Value::String("Alice".to_string())),
            Opcode::Push(Value::String("Bob".to_string())),
            Opcode::Push(Value::Float(50.0)),
            Opcode::Call("transfer".to_string()),
            Opcode::Push(Value::String("Alice".to_string())),
            Opcode::Call("get_balance".to_string()),
            Opcode::Push(Value::String("Bob".to_string())),
            Opcode::Call("get_balance".to_string()),
        ];

        let mut vm = CoopVM::new(program);
        let mut context = ContractContext {
            balances: HashMap::new(),
            votes: HashMap::new(),
            reputation: HashMap::new(),
        };
        context.balances.insert("Alice".to_string(), 100.0);
        context.balances.insert("Bob".to_string(), 0.0);
        vm.set_context(&context);

        vm.run().unwrap();

        assert_eq!(vm.stack, vec![Value::Float(50.0), Value::Float(50.0)]);
    }

    #[test]
    fn test_voting() {
        let program = vec![
            Opcode::Push(Value::String("proposal1".to_string())),
            Opcode::Push(Value::Bool(true)),
            Opcode::Call("vote".to_string()),
            Opcode::Push(Value::String("proposal2".to_string())),
            Opcode::Push(Value::Bool(false)),
            Opcode::Call("vote".to_string()),
        ];

        let mut vm = CoopVM::new(program);
        let context = ContractContext {
            balances: HashMap::new(),
            votes: HashMap::new(),
            reputation: HashMap::new(),
        };
        vm.set_context(&context);

        vm.run().unwrap();

        assert_eq!(vm.context.unwrap().votes.len(), 2);
        assert_eq!(vm.context.unwrap().votes.get("proposal1"), Some(&true));
        assert_eq!(vm.context.unwrap().votes.get("proposal2"), Some(&false));
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_vm/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_vm/src/opcode.rs =====
#[derive(Debug, Clone, PartialEq, PartialOrd)] // Add PartialOrd here
pub enum Value {
    Int(i64),
    Float(f64),
    Bool(bool),
    String(String),
}

#[derive(Debug, Clone, PartialEq)]
pub enum Opcode {
    Push(Value),
    Pop,
    Add,
    Sub,
    Mul,
    Div,
    Eq,
    Lt,
    Gt,
    And,
    Or,
    Not,
    Return,
    Store(String),
    Load(String),
    Call(String),
    Vote(String),
    AllocateResource(String),
    UpdateReputation(String),
    CreateProposal,
    GetProposalStatus,
    Emit(String),
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_vm/src/opcode.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_vm/src/smart_contract.rs =====
use icn_common::{Error, Result};
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct AssetTokenContract {
    pub tokens: Vec<AssetToken>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct AssetToken {
    pub id: String,
    pub owner: String,
    pub metadata: serde_json::Value,
}

impl AssetTokenContract {
    pub fn new() -> Self {
        AssetTokenContract {
            tokens: Vec::new(),
        }
    }

    pub fn create_token(&mut self, id: String, owner: String, metadata: serde_json::Value) -> Result<AssetToken> {
        if self.tokens.iter().any(|t| t.id == id) {
            return Err(Error {
                message: "Token already exists".to_string(),
            });
        }

        let token = AssetToken {
            id: id.clone(),
            owner: owner.clone(),
            metadata,
        };

        self.tokens.push(token.clone());
        Ok(token)
    }

    pub fn transfer_token(&mut self, id: &str, new_owner: String) -> Result<()> {
        let token = self.tokens.iter_mut().find(|t| t.id == id).ok_or_else(|| Error {
            message: "Token not found".to_string(),
        })?;

        token.owner = new_owner;
        Ok(())
    }

    pub fn get_token(&self, id: &str) -> Option<&AssetToken> {
        self.tokens.iter().find(|t| t.id == id)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct BondContract {
    pub bonds: Vec<Bond>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Bond {
    pub id: String,
    pub owner: String,
    pub terms: String,
}

impl BondContract {
    pub fn new() -> Self {
        BondContract {
            bonds: Vec::new(),
        }
    }

    pub fn create_bond(&mut self, id: String, owner: String, terms: String) -> Result<Bond> {
        if self.bonds.iter().any(|b| b.id == id) {
            return Err(Error {
                message: "Bond already exists".to_string(),
            });
        }

        let bond = Bond {
            id: id.clone(),
            owner: owner.clone(),
            terms,
        };

        self.bonds.push(bond.clone());
        Ok(bond)
    }

    pub fn transfer_bond(&mut self, id: &str, new_owner: String) -> Result<()> {
        let bond = self.bonds.iter_mut().find(|b| b.id == id).ok_or_else(|| Error {
            message: "Bond not found".to_string(),
        })?;

        bond.owner = new_owner;
        Ok(())
    }

    pub fn get_bond(&self, id: &str) -> Option<&Bond> {
        self.bonds.iter().find(|b| b.id == id)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn test_create_and_transfer_token() {
        let mut contract = AssetTokenContract::new();
        let metadata = json!({ "type": "Real Estate", "location": "123 Main St" });

        let token = contract.create_token("token1".to_string(), "Alice".to_string(), metadata).unwrap();
        assert_eq!(token.owner, "Alice");

        contract.transfer_token("token1", "Bob".to_string()).unwrap();
        let updated_token = contract.get_token("token1").unwrap();
        assert_eq!(updated_token.owner, "Bob");
    }

    #[test]
    fn test_create_and_transfer_bond() {
        let mut contract = BondContract::new();
        let bond = contract.create_bond("bond1".to_string(), "Alice".to_string(), "Terms of the bond".to_string()).unwrap();
        assert_eq!(bond.owner, "Alice");

        contract.transfer_bond("bond1", "Bob".to_string()).unwrap();
        let updated_bond = contract.get_bond("bond1").unwrap();
        assert_eq!(updated_bond.owner, "Bob");
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_vm/src/smart_contract.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_vm/src/templates.rs =====
===== END OF /home/matt/InterCooperative-Network/crates/icn_vm/src/templates.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_vm/src/vm.rs =====
// File: src/vm.rs

use std::collections::HashMap;
use std::fmt;

#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub enum Value {
    Int(i64),
    Float(f64),
    Bool(bool),
    String(String),
    Address(String),
    List(Vec<Value>),
}

impl fmt::Display for Value {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Value::Int(i) => write!(f, "{}", i),
            Value::Float(fl) => write!(f, "{}", fl),
            Value::Bool(b) => write!(f, "{}", b),
            Value::String(s) => write!(f, "\"{}\"", s),
            Value::Address(a) => write!(f, "Address({})", a),
            Value::List(l) => write!(f, "{:?}", l),
        }
    }
}

#[derive(Debug, Clone)]
pub enum Opcode {
    Push(Value),
    Pop,
    Add,
    Sub,
    Mul,
    Div,
    Mod,
    Eq,
    Neq,
    Gt,
    Lt,
    Gte,
    Lte,
    And,
    Or,
    Not,
    Store(String),
    Load(String),
    JumpIf(usize),
    Jump(usize),
    Call(String),
    Return,
    CreateList,
    AppendList,
    GetListItem,
    SetListItem,
    Vote(String),
    AllocateResource(String),
    UpdateReputation(String),
    CreateProposal,
    GetProposalStatus,
    Emit(String),
}

pub struct CoopVM {
    stack: Vec<Value>,
    memory: HashMap<String, Value>,
    program: Vec<Opcode>,
    pc: usize,
    call_stack: Vec<usize>,
    functions: HashMap<String, usize>,
}

impl CoopVM {
    pub fn new(program: Vec<Opcode>) -> Self {
        CoopVM {
            stack: Vec::new(),
            memory: HashMap::new(),
            program,
            pc: 0,
            call_stack: Vec::new(),
            functions: HashMap::new(),
        }
    }

    pub fn run(&mut self) -> Result<(), String> {
        while self.pc < self.program.len() {
            self.execute_instruction()?;
            self.pc += 1;
        }
        Ok(())
    }

    fn execute_instruction(&mut self) -> Result<(), String> {
        let current_instruction = &self.program[self.pc].clone();
        match current_instruction {
            Opcode::Push(value) => self.stack.push(value.clone()),
            Opcode::Pop => {
                self.stack.pop().ok_or("Stack underflow")?;
            }
            Opcode::Add => self.binary_op(|a, b| a + b)?,
            Opcode::Sub => self.binary_op(|a, b| a - b)?,
            Opcode::Mul => self.binary_op(|a, b| a * b)?,
            Opcode::Div => self.binary_op(|a, b| a / b)?,
            Opcode::Mod => self.binary_op(|a, b| a % b)?,
            Opcode::Eq => self.compare_op(|a, b| a == b)?,
            Opcode::Neq => self.compare_op(|a, b| a != b)?,
            Opcode::Gt => self.compare_op(|a, b| a > b)?,
            Opcode::Lt => self.compare_op(|a, b| a < b)?,
            Opcode::Gte => self.compare_op(|a, b| a >= b)?,
            Opcode::Lte => self.compare_op(|a, b| a <= b)?,
            Opcode::And => self.logic_op(|a, b| a && b)?,
            Opcode::Or => self.logic_op(|a, b| a || b)?,
            Opcode::Not => {
                let a = self.pop_bool()?;
                self.stack.push(Value::Bool(!a));
            }
            Opcode::Store(name) => {
                let value = self.stack.pop().ok_or("Stack underflow")?;
                self.memory.insert(name.clone(), value);
            }
            Opcode::Load(name) => {
                let value = self.memory.get(name).ok_or("Variable not found")?.clone();
                self.stack.push(value);
            }
            Opcode::JumpIf(target) => {
                if self.pop_bool()? {
                    self.pc = *target - 1;
                }
            }
            Opcode::Jump(target) => {
                self.pc = *target - 1;
            }
            Opcode::Call(func_name) => {
                let func_pc = self.functions.get(func_name).ok_or("Function not found")?;
                self.call_stack.push(self.pc);
                self.pc = *func_pc - 1;
            }
            Opcode::Return => {
                self.pc = self.call_stack.pop().ok_or("Return without call")?;
            }
            Opcode::CreateList => {
                self.stack.push(Value::List(Vec::new()));
            }
            Opcode::AppendList => {
                let value = self.stack.pop().ok_or("Stack underflow")?;
                if let Some(Value::List(list)) = self.stack.last_mut() {
                    list.push(value);
                } else {
                    return Err("Expected list on top of stack".to_string());
                }
            }
            Opcode::GetListItem => {
                let index = self.pop_int()?;
                if let Some(Value::List(list)) = self.stack.pop() {
                    let item = list.get(index as usize).ok_or("List index out of bounds")?.clone();
                    self.stack.push(item);
                } else {
                    return Err("Expected list on top of stack".to_string());
                }
            }
            Opcode::SetListItem => {
                let value = self.stack.pop().ok_or("Stack underflow")?;
                let index = self.pop_int()?;
                if let Some(Value::List(list)) = self.stack.last_mut() {
                    if (index as usize) < list.len() {
                        list[index as usize] = value;
                    } else {
                        return Err("List index out of bounds".to_string());
                    }
                } else {
                    return Err("Expected list on top of stack".to_string());
                }
            }
            Opcode::Vote(proposal_id) => {
                let vote = self.pop_bool()?;
                println!("Voting {} on proposal {}", if vote { "Yes" } else { "No" }, proposal_id);
            }
            Opcode::AllocateResource(resource_id) => {
                let amount = self.pop_int()?;
                println!("Allocating {} units of resource {}", amount, resource_id);
            }
            Opcode::UpdateReputation(address) => {
                let change = self.pop_int()?;
                println!("Updating reputation of {} by {}", address, change);
            }
            Opcode::CreateProposal => {
                let description = self.pop_string()?;
                println!("Creating proposal: {}", description);
                self.stack.push(Value::String("new_proposal_id".to_string()));
            }
            Opcode::GetProposalStatus => {
                let proposal_id = self.pop_string()?;
                println!("Getting status of proposal: {}", proposal_id);
                self.stack.push(Value::String("Active".to_string()));
            }
            Opcode::Emit(event_name) => {
                let event_data = self.stack.pop().ok_or("Stack underflow")?;
                println!("Emitting event {}: {}", event_name, event_data);
            }
        }
        Ok(())
    }

    fn binary_op<F>(&mut self, op: F) -> Result<(), String>
    where
        F: Fn(i64, i64) -> i64,
    {
        let b = self.pop_int()?;
        let a = self.pop_int()?;
        self.stack.push(Value::Int(op(a, b)));
        Ok(())
    }

    fn compare_op<F>(&mut self, op: F) -> Result<(), String>
    where
        F: Fn(&Value, &Value) -> bool,
    {
        let b = self.stack.pop().ok_or("Stack underflow")?;
        let a = self.stack.pop().ok_or("Stack underflow")?;
        self.stack.push(Value::Bool(op(&a, &b)));
        Ok(())
    }

    fn logic_op<F>(&mut self, op: F) -> Result<(), String>
    where
        F: Fn(bool, bool) -> bool,
    {
        let b = self.pop_bool()?;
        let a = self.pop_bool()?;
        self.stack.push(Value::Bool(op(a, b)));
        Ok(())
    }

    fn pop_int(&mut self) -> Result<i64, String> {
        match self.stack.pop().ok_or("Stack underflow")? {
            Value::Int(i) => Ok(i),
            _ => Err("Expected integer value".to_string()),
        }
    }

    fn pop_bool(&mut self) -> Result<bool, String> {
        match self.stack.pop().ok_or("Stack underflow")? {
            Value::Bool(b) => Ok(b),
            _ => Err("Expected boolean value".to_string()),
        }
    }

    fn pop_string(&mut self) -> Result<String, String> {
        match self.stack.pop().ok_or("Stack underflow")? {
            Value::String(s) => Ok(s),
            _ => Err("Expected string value".to_string()),
        }
    }

    pub fn register_function(&mut self, name: String, pc: usize) {
        self.functions.insert(name, pc);
    }

    pub fn get_stack(&self) -> &Vec<Value> {
        &self.stack
    }

    pub fn get_memory(&self) -> &HashMap<String, Value> {
        &self.memory
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_operations() {
        let program = vec![
            Opcode::Push(Value::Int(5)),
            Opcode::Push(Value::Int(3)),
            Opcode::Add,
            Opcode::Push(Value::Int(2)),
            Opcode::Mul,
        ];

        let mut vm = CoopVM::new(program);
        vm.run().unwrap();

        assert_eq!(vm.stack, vec![Value::Int(16)]);
    }

    #[test]
    fn test_store_and_load() {
        let program = vec![
            Opcode::Push(Value::Int(42)),
            Opcode::Store("x".to_string()),
            Opcode::Push(Value::Int(10)),
            Opcode::Load("x".to_string()),
            Opcode::Add,
        ];

        let mut vm = CoopVM::new(program);
        vm.run().unwrap();

        assert_eq!(vm.stack, vec![Value::Int(52)]);
    }

    #[test]
    fn test_conditional_jump() {
        let program = vec![
            Opcode::Push(Value::Bool(true)),
            Opcode::JumpIf(3),
            Opcode::Push(Value::Int(1)),
            Opcode::Push(Value::Int(2)),
            Opcode::Add,
        ];

        let mut vm = CoopVM::new(program);
        vm.run().unwrap();

        assert_eq!(vm.stack, vec![Value::Int(2)]);
    }

    #[test]
    fn test_list_operations() {
        let program = vec![
            Opcode::CreateList,
            Opcode::Push(Value::Int(1)),
            Opcode::AppendList,
            Opcode::Push(Value::Int(2)),
            Opcode::AppendList,
            Opcode::Push(Value::Int(0)),
            Opcode::GetListItem,
        ];

        let mut vm = CoopVM::new(program);
        vm.run().unwrap();

        assert_eq!(vm.stack, vec![Value::List(vec![Value::Int(1), Value::Int(2)]), Value::Int(1)]);
    }

    #[test]
    fn test_cooperative_operations() {
        let program = vec![
            Opcode::Push(Value::String("Proposal 1".to_string())),
            Opcode::CreateProposal,
            Opcode::Push(Value::Bool(true)),
            Opcode::Vote("proposal_1".to_string()),
            Opcode::Push(Value::Int(100)),
            Opcode::AllocateResource("computing_power".to_string()),
            Opcode::Push(Value::Int(5)),
            Opcode::UpdateReputation("user1".to_string()),
            Opcode::Push(Value::String("proposal_1".to_string())),
            Opcode::GetProposalStatus,
        ];

        let mut vm = CoopVM::new(program);
        vm.run().unwrap();

        assert_eq!(vm.stack, vec![Value::String("new_proposal_id".to_string()), Value::String("Active".to_string())]);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_vm/src/vm.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_zkp/Cargo.toml =====
[package]
name = "icn_zkp"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
bellman = "0.11.0"
bls12_381 = "0.6.0"
rand = "0.8"
serde = { version = "1.0", features = ["derive"] }
thiserror = "1.0"

[dev-dependencies]
criterion = "0.3"===== END OF /home/matt/InterCooperative-Network/crates/icn_zkp/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_zkp/src/circuits.rs =====
use bellman::{Circuit, ConstraintSystem, SynthesisError};
use bls12_381::Scalar;
use icn_common::Transaction;

pub struct TransactionCircuit {
    // Private inputs
    sender: Option<Scalar>,
    receiver: Option<Scalar>,
    amount: Option<Scalar>,
    currency_type: Option<Scalar>,

    // Public inputs
    sender_hash: Option<Scalar>,
    receiver_hash: Option<Scalar>,
    amount_hash: Option<Scalar>,
    currency_type_hash: Option<Scalar>,
}

impl TransactionCircuit {
    pub fn new(transaction: &Transaction) -> Self {
        // In a real implementation, you would convert transaction fields to Scalar
        // and compute hashes. This is a simplified version.
        TransactionCircuit {
            sender: Some(Scalar::from(1u64)),
            receiver: Some(Scalar::from(2u64)),
            amount: Some(Scalar::from(transaction.amount as u64)),
            currency_type: Some(Scalar::from(0u64)), // Simplified representation

            sender_hash: Some(Scalar::from(3u64)),
            receiver_hash: Some(Scalar::from(4u64)),
            amount_hash: Some(Scalar::from(5u64)),
            currency_type_hash: Some(Scalar::from(6u64)),
        }
    }

    pub fn empty() -> Self {
        TransactionCircuit {
            sender: None,
            receiver: None,
            amount: None,
            currency_type: None,
            sender_hash: None,
            receiver_hash: None,
            amount_hash: None,
            currency_type_hash: None,
        }
    }

    pub fn public_inputs(transaction: &Transaction) -> Vec<Scalar> {
        // In a real implementation, you would compute actual hashes
        vec![
            Scalar::from(3u64),
            Scalar::from(4u64),
            Scalar::from(5u64),
            Scalar::from(6u64),
        ]
    }
}

impl Circuit<Scalar> for TransactionCircuit {
    fn synthesize<CS: ConstraintSystem<Scalar>>(self, cs: &mut CS) -> Result<(), SynthesisError> {
        // Allocate private inputs
        let sender = cs.alloc(|| "sender", || self.sender.ok_or(SynthesisError::AssignmentMissing))?;
        let receiver = cs.alloc(|| "receiver", || self.receiver.ok_or(SynthesisError::AssignmentMissing))?;
        let amount = cs.alloc(|| "amount", || self.amount.ok_or(SynthesisError::AssignmentMissing))?;
        let currency_type = cs.alloc(|| "currency_type", || self.currency_type.ok_or(SynthesisError::AssignmentMissing))?;

        // Allocate public inputs
        let sender_hash = cs.alloc_input(|| "sender_hash", || self.sender_hash.ok_or(SynthesisError::AssignmentMissing))?;
        let receiver_hash = cs.alloc_input(|| "receiver_hash", || self.receiver_hash.ok_or(SynthesisError::AssignmentMissing))?;
        let amount_hash = cs.alloc_input(|| "amount_hash", || self.amount_hash.ok_or(SynthesisError::AssignmentMissing))?;
        let currency_type_hash = cs.alloc_input(|| "currency_type_hash", || self.currency_type_hash.ok_or(SynthesisError::AssignmentMissing))?;

        // Add constraints
        // In a real implementation, you would add proper constraints to prove the relationship
        // between private inputs and public inputs (hashes)
        cs.enforce(
            || "sender hash constraint",
            |lc| lc + sender,
            |lc| lc + CS::one(),
            |lc| lc + sender_hash
        );

        cs.enforce(
            || "receiver hash constraint",
            |lc| lc + receiver,
            |lc| lc + CS::one(),
            |lc| lc + receiver_hash
        );

        cs.enforce(
            || "amount hash constraint",
            |lc| lc + amount,
            |lc| lc + CS::one(),
            |lc| lc + amount_hash
        );

        cs.enforce(
            || "currency type hash constraint",
            |lc| lc + currency_type,
            |lc| lc + CS::one(),
            |lc| lc + currency_type_hash
        );

        Ok(())
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_zkp/src/circuits.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_zkp/src/lib.rs =====
use bellman::{Circuit, ConstraintSystem, SynthesisError};
use bls12_381::Bls12;
use icn_common::{IcnResult, IcnError, Transaction};
use rand::rngs::OsRng;

mod circuits;
pub use circuits::*;

pub struct ZKPManager {
    params: bellman::groth16::Parameters<Bls12>,
}

impl ZKPManager {
    pub fn new() -> IcnResult<Self> {
        let mut rng = OsRng;
        let params = bellman::groth16::generate_random_parameters::<Bls12, _, _>(
            circuits::TransactionCircuit::empty(),
            &mut rng
        ).map_err(|e| IcnError::ZKP(format!("Failed to generate ZKP parameters: {}", e)))?;

        Ok(ZKPManager { params })
    }

    pub fn create_proof<C>(&self, circuit: C) -> IcnResult<bellman::groth16::Proof<Bls12>>
    where
        C: Circuit<bls12_381::Scalar>,
    {
        let mut rng = OsRng;
        bellman::groth16::create_random_proof===== END OF /home/matt/InterCooperative-Network/crates/icn_zkp/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/Cargo.toml =====
[workspace]
members = [
    "crates/icn_common",
    "crates/icn_blockchain",
    "crates/icn_consensus",
    "crates/icn_currency",
    "crates/icn_governance",
    "crates/icn_identity",
    "crates/icn_network",
    "crates/icn_sharding",
    "crates/icn_storage",
    "crates/icn_vm",
    "crates/icn_api",
    "crates/icn_testnet",
    "crates/icn_core", 
    "crates/icn_zkp", 
    "crates/icn_smart_contracts",
    "crates/icn_reputation",
    "crates/icn_market",
    "crates/icn_incentives",
]

resolver = "2"

[workspace.dependencies]
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
chrono = { version = "0.4", features = ["serde"] }
thiserror = "1.0"
log = "0.4"
env_logger = "0.9"
===== END OF /home/matt/InterCooperative-Network/Cargo.toml =====

