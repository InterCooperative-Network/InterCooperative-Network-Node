===== START OF FILE STRUCTURE =====
/home/matt/InterCooperative-Network
├── build_and_run_demo.sh
├── Cargo.lock
├── Cargo.toml
├── CHANGELOG.md
├── cliff.toml
├── crates
│   ├── icn_api
│   │   ├── Cargo.toml
│   │   ├── README.md
│   │   └── src
│   │       ├── lib.rs
│   │       └── web.rs
│   ├── icn_blockchain
│   │   ├── Cargo.toml
│   │   ├── README.md
│   │   └── src
│   │       ├── asset_tokenization.rs
│   │       ├── blockchain.rs
│   │       ├── lib.rs
│   │       └── transaction_validator.rs
│   ├── icn_common
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── bit_utils.rs
│   │       ├── error.rs
│   │       └── lib.rs
│   ├── icn_consensus
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── bft_poc.rs
│   │       ├── consensus.rs
│   │       ├── lib.rs
│   │       └── proof_of_cooperation.rs
│   ├── icn_core
│   │   ├── Cargo.toml
│   │   ├── src
│   │   │   ├── cli
│   │   │   │   └── mod.rs
│   │   │   ├── config.rs
│   │   │   ├── error.rs
│   │   │   ├── lib.rs
│   │   │   ├── logging
│   │   │   │   └── mod.rs
│   │   │   ├── main.rs
│   │   │   └── security
│   │   │       └── mod.rs
│   │   └── tests
│   │       ├── blockchain_and_consensus_tests.rs
│   │       ├── blockchain_tests.rs
│   │       ├── icn_node_tests.rs
│   │       ├── integration_tests.rs
│   │       ├── mod.rs
│   │       └── smart_contract_tests.rs
│   ├── icn_currency
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── asset_token.rs
│   │       ├── bond.rs
│   │       ├── currency.rs
│   │       ├── lib.rs
│   │       └── wallet.rs
│   ├── icn_dao
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── lib.rs
│   ├── icn_demo
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── main.rs
│   ├── icn_governance
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── democracy.rs
│   │       ├── governance.rs
│   │       ├── lib.rs
│   │       ├── proposal.rs
│   │       └── voting.rs
│   ├── icn_identity
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── did.rs
│   │       ├── identity_manager.rs
│   │       └── lib.rs
│   ├── icn_incentives
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── lib.rs
│   ├── icn_language
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── bytecode.rs
│   │       └── lib.rs
│   ├── icn_market
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── entities.rs
│   │       ├── lib.rs
│   │       ├── market.rs
│   │       ├── market_tests.rs
│   │       └── transaction.rs
│   ├── icn_network
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── discovery.rs
│   │       ├── lib.rs
│   │       ├── naming.rs
│   │       ├── network.rs
│   │       ├── node.rs
│   │       ├── packet.rs
│   │       ├── protocol.rs
│   │       ├── routing.rs
│   │       └── security.rs
│   ├── icn_node_management
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── content_store.rs
│   │       ├── fib.rs
│   │       ├── icn_node.rs
│   │       ├── lib.rs
│   │       ├── node.rs
│   │       └── pit.rs
│   ├── icn_reputation
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── lib.rs
│   ├── icn_sharding
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── cross_shard_communication.rs
│   │       ├── cross_shard_sync.rs
│   │       ├── cross_shard_transaction_manager.rs
│   │       └── lib.rs
│   ├── icn_smart_contracts
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── contract.pest
│   │       └── lib.rs
│   ├── icn_storage
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── lib.rs
│   │       ├── storage_manager.rs
│   │       └── storage_node.rs
│   ├── icn_testnet
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── main.rs
│   ├── icn_utils
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── error.rs
│   │       ├── lib.rs
│   │       ├── types
│   │       │   ├── block.rs
│   │       │   ├── mod.rs
│   │       │   └── transaction.rs
│   │       └── utils.rs
│   ├── icn_vm
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── compiler.rs
│   │       ├── coop_vm.rs
│   │       ├── lib.rs
│   │       ├── opcode.rs
│   │       ├── smart_contract.rs
│   │       ├── templates.rs
│   │       └── vm.rs
│   └── icn_zkp
│       ├── Cargo.toml
│       └── src
│           ├── circuits.rs
│           └── lib.rs
├── docs
│   ├── API.md
│   ├── ARCHITECTURE.md
│   ├── CONTRIBUTING.md
│   ├── index.html
│   ├── README.md
│   ├── script.js
│   ├── style.css
│   └── temp_logo.png
├── examples
│   └── voting_contract.coop
├── frontend
│   ├── app.js
│   └── index.html
├── LICENSE.md
├── PROJECT_STRUCTURE_AND_CODE_CONTENTS.txt
├── README.md
└── update_project.sh

56 directories, 135 files
===== END OF FILE STRUCTURE =====

===== START OF /home/matt/InterCooperative-Network/Cargo.toml =====
[workspace]
members = [
    "crates/icn_common",
    "crates/icn_blockchain",
    "crates/icn_consensus",
    "crates/icn_currency",
    "crates/icn_governance",
    "crates/icn_identity",
    "crates/icn_network",
    "crates/icn_sharding",
    "crates/icn_storage",
    "crates/icn_vm",
    "crates/icn_api",
    "crates/icn_testnet",
    "crates/icn_core",
    "crates/icn_zkp",
    "crates/icn_smart_contracts",
    "crates/icn_reputation",
    "crates/icn_market",
    "crates/icn_incentives",
    "crates/icn_language",
    "crates/icn_demo"
]

resolver = "2"

[workspace.dependencies]
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
chrono = { version = "0.4", features = ["serde"] }
thiserror = "1.0"
log = "0.4"
env_logger = "0.9"
===== END OF /home/matt/InterCooperative-Network/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_api/Cargo.toml =====
[package]
name = "icn_api"
version = "0.1.0"
edition = "2018"

[dependencies]
warp = "0.3"
tokio = { version = "1", features = ["full"] }
icn_core = { path = "../icn_core" }
icn_common = { path = "../icn_common" }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

[dev-dependencies]
tokio = { version = "1.0", features = ["full", "test-util"] }
===== END OF /home/matt/InterCooperative-Network/crates/icn_api/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_api/src/lib.rs =====
// File: icn_api/src/lib.rs

use std::sync::Arc;
use tokio::sync::RwLock;
use warp::{Filter, Rejection, Reply};
use serde::{Deserialize, Serialize};
use icn_common::{IcnResult, IcnError, Transaction, Proposal, CurrencyType, ProposalType, ProposalCategory, ProposalStatus};
use serde_json::json;
use chrono::{Duration, Utc};

// ApiLayer struct remains unchanged
pub struct ApiLayer {
    node: Arc<RwLock<icn_core::IcnNode>>,
}

impl ApiLayer {
    pub fn new(node: Arc<RwLock<icn_core::IcnNode>>) -> Self {
        ApiLayer { node }
    }

    // Existing methods remain unchanged
    pub async fn submit_transaction(&self, transaction: Transaction) -> IcnResult<()> {
        let node = self.node.read().await;
        node.process_transaction(transaction).await
    }

    pub async fn create_proposal(&self, proposal: Proposal) -> IcnResult<String> {
        let node = self.node.read().await;
        node.create_proposal(proposal).await
    }

    pub async fn vote_on_proposal(&self, proposal_id: &str, voter: String, in_favor: bool, weight: f64) -> IcnResult<()> {
        let node = self.node.read().await;
        node.vote_on_proposal(proposal_id, voter, in_favor, weight).await
    }

    pub async fn finalize_proposal(&self, proposal_id: &str) -> IcnResult<ProposalStatus> {
        let node = self.node.read().await;
        node.finalize_proposal(proposal_id).await
    }

    pub async fn get_balance(&self, address: &str, currency_type: &CurrencyType) -> IcnResult<f64> {
        let node = self.node.read().await;
        node.get_balance(address, currency_type).await
    }

    pub async fn mint_currency(&self, address: &str, currency_type: &CurrencyType, amount: f64) -> IcnResult<()> {
        let node = self.node.write().await;
        node.mint_currency(address, currency_type, amount).await
    }

    pub async fn create_identity(&self, attributes: std::collections::HashMap<String, String>) -> IcnResult<String> {
        let node = self.node.write().await;
        node.create_identity(attributes).await
    }

    pub async fn allocate_resource(&self, resource_type: &str, amount: u64) -> IcnResult<()> {
        let node = self.node.write().await;
        node.allocate_resource(resource_type, amount).await
    }

    pub async fn get_network_stats(&self) -> IcnResult<icn_common::NetworkStats> {
        let node = self.node.read().await;
        node.get_network_stats().await
    }

    // New method to get proposal status
    pub async fn get_proposal_status(&self, proposal_id: &str) -> IcnResult<ProposalStatus> {
        let node = self.node.read().await;
        node.get_proposal_status(proposal_id).await
    }
}

// Request and response structs
#[derive(Deserialize)]
struct CreateProposalRequest {
    title: String,
    description: String,
    proposer: String,
    proposal_type: ProposalType,
    category: ProposalCategory,
}

#[derive(Serialize)]
struct CreateProposalResponse {
    proposal_id: String,
}

#[derive(Deserialize)]
struct GetProposalStatusRequest {
    proposal_id: String,
}

#[derive(Serialize)]
struct GetProposalStatusResponse {
    status: ProposalStatus,
}

// Helper function to convert IcnError to warp::Rejection
fn icn_error_to_rejection(error: IcnError) -> warp::Rejection {
    warp::reject::custom(error)
}

// API routes
pub fn api_routes(
    api_layer: Arc<RwLock<ApiLayer>>,
) -> impl Filter<Extract = impl Reply, Error = Rejection> + Clone {
    let api_layer = warp::any().map(move || api_layer.clone());

    let submit_transaction = warp::post()
        .and(warp::path("transaction"))
        .and(warp::body::json())
        .and(api_layer.clone())
        .and_then(handle_submit_transaction);

    let create_proposal = warp::post()
        .and(warp::path("proposal"))
        .and(warp::body::json())
        .and(api_layer.clone())
        .and_then(handle_create_proposal);

    let vote_on_proposal = warp::post()
        .and(warp::path("vote"))
        .and(warp::body::json())
        .and(api_layer.clone())
        .and_then(handle_vote_on_proposal);

    let get_balance = warp::get()
        .and(warp::path("balance"))
        .and(warp::query())
        .and(api_layer.clone())
        .and_then(handle_get_balance);

    let mint_currency = warp::post()
        .and(warp::path("mint"))
        .and(warp::body::json())
        .and(api_layer.clone())
        .and_then(handle_mint_currency);

    let create_identity = warp::post()
        .and(warp::path("identity"))
        .and(warp::body::json())
        .and(api_layer.clone())
        .and_then(handle_create_identity);

    let allocate_resource = warp::post()
        .and(warp::path("allocate"))
        .and(warp::body::json())
        .and(api_layer.clone())
        .and_then(handle_allocate_resource);

    let get_network_stats = warp::get()
        .and(warp::path("stats"))
        .and(api_layer.clone())
        .and_then(handle_get_network_stats);

    let get_proposal_status = warp::get()
        .and(warp::path("proposal"))
        .and(warp::path("status"))
        .and(warp::query())
        .and(api_layer.clone())
        .and_then(handle_get_proposal_status);

    submit_transaction
        .or(create_proposal)
        .or(vote_on_proposal)
        .or(get_balance)
        .or(mint_currency)
        .or(create_identity)
        .or(allocate_resource)
        .or(get_network_stats)
        .or(get_proposal_status)
}

// Handler functions
async fn handle_submit_transaction(
    transaction: Transaction,
    api_layer: Arc<RwLock<ApiLayer>>,
) -> Result<impl Reply, Rejection> {
    let api_layer = api_layer.read().await;
    api_layer
        .submit_transaction(transaction)
        .await
        .map(|_| warp::reply::json(&json!({"status": "success"})))
        .map_err(icn_error_to_rejection)
}

async fn handle_create_proposal(
    proposal_request: CreateProposalRequest,
    api_layer: Arc<RwLock<ApiLayer>>,
) -> Result<impl Reply, Rejection> {
    let api_layer = api_layer.read().await;
    let proposal = Proposal {
        id: Uuid::new_v4().to_string(),
        title: proposal_request.title,
        description: proposal_request.description,
        proposer: proposal_request.proposer,
        created_at: Utc::now(),
        voting_ends_at: Utc::now() + Duration::days(7), // Set voting period to 7 days
        status: ProposalStatus::Active,
        proposal_type: proposal_request.proposal_type,
        category: proposal_request.category,
        required_quorum: 0.51, // Set a default quorum, can be made configurable
        execution_timestamp: None,
    };
    api_layer
        .create_proposal(proposal)
        .await
        .map(|proposal_id| warp::reply::json(&CreateProposalResponse { proposal_id }))
        .map_err(icn_error_to_rejection)
}

async fn handle_vote_on_proposal(
    vote: Vote,
    api_layer: Arc<RwLock<ApiLayer>>,
) -> Result<impl Reply, Rejection> {
    let api_layer = api_layer.read().await;
    api_layer
        .vote_on_proposal(&vote.proposal_id, vote.voter, vote.in_favor, vote.weight)
        .await
        .map(|_| warp::reply::json(&json!({"status": "success"})))
        .map_err(icn_error_to_rejection)
}

async fn handle_get_balance(
    query: GetBalanceQuery,
    api_layer: Arc<RwLock<ApiLayer>>,
) -> Result<impl Reply, Rejection> {
    let api_layer = api_layer.read().await;
    api_layer
        .get_balance(&query.address, &query.currency_type)
        .await
        .map(|balance| warp::reply::json(&json!({"balance": balance})))
        .map_err(icn_error_to_rejection)
}

async fn handle_mint_currency(
    request: MintCurrencyRequest,
    api_layer: Arc<RwLock<ApiLayer>>,
) -> Result<impl Reply, Rejection> {
    let api_layer = api_layer.read().await;
    api_layer
        .mint_currency(&request.address, &request.currency_type, request.amount)
        .await
        .map(|_| warp::reply::json(&json!({"status": "success"})))
        .map_err(icn_error_to_rejection)
}

async fn handle_create_identity(
    attributes: HashMap<String, String>,
    api_layer: Arc<RwLock<ApiLayer>>,
) -> Result<impl Reply, Rejection> {
    let api_layer = api_layer.read().await;
    api_layer
        .create_identity(attributes)
        .await
        .map(|id| warp::reply::json(&json!({"identity_id": id})))
        .map_err(icn_error_to_rejection)
}

async fn handle_allocate_resource(
    request: AllocateResourceRequest,
    api_layer: Arc<RwLock<ApiLayer>>,
) -> Result<impl Reply, Rejection> {
    let api_layer = api_layer.read().await;
    api_layer
        .allocate_resource(&request.resource_type, request.amount)
        .await
        .map(|_| warp::reply::json(&json!({"status": "success"})))
        .map_err(icn_error_to_rejection)
}

async fn handle_get_network_stats(
    api_layer: Arc<RwLock<ApiLayer>>,
) -> Result<impl Reply, Rejection> {
    let api_layer = api_layer.read().await;
    api_layer
        .get_network_stats()
        .await
        .map(|stats| warp::reply::json(&stats))
        .map_err(icn_error_to_rejection)
}

async fn handle_get_proposal_status(
    query: GetProposalStatusRequest,
    api_layer: Arc<RwLock<ApiLayer>>,
) -> Result<impl Reply, Rejection> {
    let api_layer = api_layer.read().await;
    api_layer
        .get_proposal_status(&query.proposal_id)
        .await
        .map(|status| warp::reply::json(&GetProposalStatusResponse { status }))
        .map_err(icn_error_to_rejection)
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_core::Config;
    use std::net::SocketAddr;

    async fn setup_test_env() -> (Arc<RwLock<ApiLayer>>, Arc<RwLock<icn_core::IcnNode>>) {
        let config = Config {
            shard_count: 1,
            consensus_threshold: 0.66,
            consensus_quorum: 0.51,
            network_port: 8080,
        };
        let node = Arc::new(RwLock::new(icn_core::IcnNode::new(config).await.unwrap()));
        let api_layer = Arc::new(RwLock::new(ApiLayer::new(Arc::clone(&node))));
        (api_layer, node)
    }

    #[tokio::test]
    async fn test_submit_transaction() {
        let (api_layer, _) = setup_test_env().await;
        let transaction = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 100.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: chrono::Utc::now().timestamp(),
            signature: None,
        };

        let result = handle_submit_transaction(transaction, api_layer).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_create_proposal() {
        let (api_layer, _) = setup_test_env().await;
        let proposal_request = CreateProposalRequest {
            title: "Test Proposal".to_string(),
            description: "This is a test proposal".to_string(),
            proposer: "Alice".to_string(),
            proposal_type: ProposalType::Constitutional,
            category: ProposalCategory::Economic,
        };

        let result = handle_create_proposal(proposal_request, api_layer).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_vote_on_proposal() {
        let (api_layer, node) = setup_test_env().await;

        let proposal = Proposal {
            id: "test_proposal_id".to_string(),
            title: "Test Proposal".to_string(),
            description: "This is a test proposal".to_string(),
            proposer: "Alice".to_string(),
            created_at: chrono::Utc::now(),
            voting_ends_at: chrono::Utc::now() + chrono::Duration::days(7),
            status: ProposalStatus::Active,
            proposal_type: ProposalType::Constitutional,
            category: ProposalCategory::Economic,
            required_quorum: 0.51,
            execution_timestamp: None,
        };

        {
            let mut node = node.write().await;
            node.create_proposal(proposal.clone()).await.unwrap();
        }

        let vote = Vote {
            proposal_id: "test_proposal_id".to_string(),
            voter: "Bob".to_string(),
            in_favor: true,
            weight: 1.0,
        };

        let result = handle_vote_on_proposal(vote, api_layer).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_get_balance() {
        let (api_layer, node) = setup_test_env().await;

        {
            let mut node = node.write().await;
            node.mint_currency("Alice", &CurrencyType::BasicNeeds, 100.0).await.unwrap();
        }

        let query = GetBalanceQuery {
            address: "Alice".to_string(),
            currency_type: CurrencyType::BasicNeeds,
        };

        let result = handle_get_balance(query, api_layer).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_get_proposal_status() {
        let (api_layer, node) = setup_test_env().await;

        let proposal = Proposal {
            id: "test_proposal_id".to_string(),
            title: "Test Proposal".to_string(),
            description: "This is a test proposal".to_string(),
            proposer: "Alice".to_string(),
            created_at: chrono::Utc::now(),
            voting_ends_at: chrono::Utc::now() + chrono::Duration::days(7),
            status: ProposalStatus::Active,
            proposal_type: ProposalType::Constitutional,
            category: ProposalCategory::Economic,
            required_quorum: 0.51,
            execution_timestamp: None,
        };

        {
            let mut node = node.write().await;
            node.create_proposal(proposal.clone()).await.unwrap();
        }

        let query = GetProposalStatusRequest {
            proposal_id: "test_proposal_id".to_string(),
        };

        let result = handle_get_proposal_status(query, api_layer).await;
        assert!(result.is_ok());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_api/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_api/src/web.rs =====
// File: icn_api/src/web.rs

use warp::Filter;
use crate::ApiLayer;
use std::sync::Arc;
use icn_common::{Transaction, Proposal, DecentralizedIdentity};
use warp::http::StatusCode;

pub async fn start_web_server(api: Arc<ApiLayer>) {
    let api = warp::any().map(move || api.clone());

    let hello = warp::path!("hello" / String)
        .map(|name| format!("Hello, {}!", name));

    let transaction = warp::post()
        .and(warp::path("transaction"))
        .and(warp::body::json())
        .and(api.clone())
        .and_then(handle_transaction);

    let proposal = warp::post()
        .and(warp::path("proposal"))
        .and(warp::body::json())
        .and(api.clone())
        .and_then(handle_proposal);

    let identity = warp::post()
        .and(warp::path("identity"))
        .and(warp::body::json())
        .and(api.clone())
        .and_then(handle_identity);

    let routes = hello
        .or(transaction)
        .or(proposal)
        .or(identity);

    warp::serve(routes)
        .run(([127.0.0.1], 3030))
        .await;
}

async fn handle_transaction(tx: Transaction, api: Arc<ApiLayer>) -> Result<impl warp::Reply, warp::Rejection> {
    match api.submit_transaction(tx).await {
        Ok(_) => Ok(warp::reply::with_status("Transaction submitted", StatusCode::OK)),
        Err(e) => {
            eprintln!("Error submitting transaction: {}", e);
            Ok(warp::reply::with_status(format!("Transaction submission failed: {}", e), StatusCode::BAD_REQUEST))
        }
    }
}

async fn handle_proposal(proposal: Proposal, api: Arc<ApiLayer>) -> Result<impl warp::Reply, warp::Rejection> {
    match api.create_proposal(proposal).await {
        Ok(response) => Ok(warp::reply::json(&response)),
        Err(e) => {
            eprintln!("Error creating proposal: {}", e);
            Ok(warp::reply::with_status(format!("Proposal creation failed: {}", e), StatusCode::BAD_REQUEST))
        }
    }
}

async fn handle_identity(identity: std::collections::HashMap<String, String>, api: Arc<ApiLayer>) -> Result<impl warp::Reply, warp::Rejection> {
    match api.create_identity(identity).await {
        Ok(response) => Ok(warp::reply::json(&response)),
        Err(e) => {
            eprintln!("Error creating identity: {}", e);
            Ok(warp::reply::with_status(format!("Identity creation failed: {}", e), StatusCode::BAD_REQUEST))
        }
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_api/src/web.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_blockchain/Cargo.toml =====
[package]
name = "icn_blockchain"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
sha2 = "0.10"
log = "0.4"
thiserror = "1.0"
serde_json = "1.0"

[dev-dependencies]
tokio-test = "0.4"
===== END OF /home/matt/InterCooperative-Network/crates/icn_blockchain/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_blockchain/src/asset_tokenization.rs =====
// File: icn_blockchain/src/asset_tokenization.rs

use icn_common::bit_utils::{BitVec, set_bit, clear_bit, toggle_bit, rotate_left, rotate_right};
use crate::{Transaction, Blockchain};
use icn_common::error::{IcnError, IcnResult};

/// A struct for validating transactions.
pub struct TransactionValidator;

impl TransactionValidator {
    /// Validates a transaction within the context of a blockchain.
    ///
    /// # Arguments
    ///
    /// * `transaction` - The transaction to validate.
    /// * `blockchain` - The blockchain context.
    ///
    /// # Returns
    ///
    /// `IcnResult<()>` indicating whether the transaction is valid.
    pub fn validate_transaction(transaction: &Transaction, blockchain: &Blockchain) -> IcnResult<()> {
        Self::is_double_spend(transaction, blockchain)?;
        Self::validate_currency_and_amount(transaction)?;
        Self::check_sufficient_balance(transaction, blockchain)?;
        Self::validate_signature(transaction)?;
        Ok(())
    }

    fn is_double_spend(transaction: &Transaction, blockchain: &Blockchain) -> IcnResult<bool> {
        for block in &blockchain.chain {
            for tx in &block.transactions {
                if tx == transaction {
                    return Ok(true);
                }
            }
        }
        Ok(false)
    }

    fn validate_currency_and_amount(transaction: &Transaction) -> IcnResult<()> {
        if transaction.amount <= 0.0 {
            return Err(IcnError::Currency("Invalid currency or amount".to_string()));
        }
        Ok(())
    }

    fn check_sufficient_balance(transaction: &Transaction, blockchain: &Blockchain) -> IcnResult<()> {
        let balance = blockchain.get_balance(&transaction.from, &transaction.currency_type)?;
        if balance < transaction.amount + transaction.get_fee() {
            return Err(IcnError::Currency("Insufficient balance".to_string()));
        }
        Ok(())
    }

    fn validate_signature(transaction: &Transaction) -> IcnResult<()> {
        if !transaction.verify().map_err(|e| IcnError::Identity(format!("Signature verification failed: {}", e)))? {
            return Err(IcnError::Identity("Invalid signature".to_string()));
        }
        Ok(())
    }

    /// Checks if a transaction can be processed by the blockchain.
    ///
    /// # Arguments
    ///
    /// * `transaction` - The transaction to check.
    /// * `blockchain` - The blockchain context.
    ///
    /// # Returns
    ///
    /// `IcnResult<()>` indicating whether the transaction can be processed.
    pub fn can_process_transaction(transaction: &Transaction, blockchain: &Blockchain) -> IcnResult<()> {
        Self::validate_transaction(transaction, blockchain)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::currency::CurrencyType;
    use icn_common::{Transaction, Blockchain};
    use ed25519_dalek::Keypair;
    use rand::rngs::OsRng;

    fn create_signed_transaction(from: &str, to: &str, amount: f64) -> Transaction {
        let mut tx = Transaction::new(
            from.to_string(),
            to.to_string(),
            amount,
            CurrencyType::BasicNeeds,
            1000,
        );
        let mut csprng = OsRng{};
        let keypair: Keypair = Keypair::generate(&mut csprng);
        tx.sign(&keypair).unwrap();
        tx
    }

    #[test]
    fn test_validate_transaction() {
        let mut blockchain = Blockchain::new(Box::new(MockTransactionValidator));
        let tx = create_signed_transaction("Alice", "Bob", 50.0);

        blockchain.add_transaction(create_signed_transaction("Genesis", "Alice", 100.0)).unwrap();
        blockchain.create_block().unwrap();

        assert!(TransactionValidator::validate_transaction(&tx, &blockchain).is_ok());
    }

    #[test]
    fn test_insufficient_balance() {
        let mut blockchain = Blockchain::new(Box::new(MockTransactionValidator));
        let tx = create_signed_transaction("Alice", "Bob", 150.0);

        blockchain.add_transaction(create_signed_transaction("Genesis", "Alice", 100.0)).unwrap();
        blockchain.create_block().unwrap();

        assert!(TransactionValidator::validate_transaction(&tx, &blockchain).is_err());
    }

    #[test]
    fn test_double_spend() {
        let mut blockchain = Blockchain::new(Box::new(MockTransactionValidator));
        let tx = create_signed_transaction("Alice", "Bob", 50.0);

        blockchain.add_transaction(create_signed_transaction("Genesis", "Alice", 100.0)).unwrap();
        blockchain.create_block().unwrap();

        blockchain.add_transaction(tx.clone()).unwrap();
        blockchain.create_block().unwrap();

        assert!(TransactionValidator::validate_transaction(&tx, &blockchain).is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_blockchain/src/asset_tokenization.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_blockchain/src/blockchain.rs =====
// File: crates/icn_blockchain/src/lib.rs

use chrono::{DateTime, Utc};
use icn_common::{IcnResult, IcnError, CurrencyType};
use icn_currency::CurrencySystem;
use serde::{Serialize, Deserialize};
use sha2::{Sha256, Digest};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Block {
    pub index: u64,
    pub timestamp: i64,
    pub transactions: Vec<Transaction>,
    pub previous_hash: String,
    pub hash: String,
    pub nonce: u64,
    pub merkle_root: String,
}

impl Block {
    pub fn new(index: u64, transactions: Vec<Transaction>, previous_hash: &str) -> Self {
        let mut block = Block {
            index,
            timestamp: Utc::now().timestamp(),
            transactions,
            previous_hash: previous_hash.to_string(),
            hash: String::new(),
            nonce: 0,
            merkle_root: String::new(),
        };
        block.merkle_root = block.calculate_merkle_root();
        block.hash = block.calculate_hash();
        block
    }

    pub fn calculate_hash(&self) -> String {
        let mut hasher = Sha256::new();
        hasher.update(self.index.to_string());
        hasher.update(&self.timestamp.to_string());
        hasher.update(&self.merkle_root);
        hasher.update(&self.previous_hash);
        hasher.update(&self.nonce.to_string());
        format!("{:x}", hasher.finalize())
    }

    pub fn calculate_merkle_root(&self) -> String {
        let transaction_hashes: Vec<String> = self.transactions
            .iter()
            .map(|tx| {
                let mut hasher = Sha256::new();
                hasher.update(serde_json::to_string(tx).unwrap().as_bytes());
                format!("{:x}", hasher.finalize())
            })
            .collect();

        if transaction_hashes.is_empty() {
            return String::from("0000000000000000000000000000000000000000000000000000000000000000");
        }

        let mut merkle_tree = transaction_hashes;
        while merkle_tree.len() > 1 {
            let mut new_level = Vec::new();
            for chunk in merkle_tree.chunks(2) {
                let mut hasher = Sha256::new();
                hasher.update(chunk[0].as_bytes());
                if chunk.len() > 1 {
                    hasher.update(chunk[1].as_bytes());
                } else {
                    hasher.update(chunk[0].as_bytes());
                }
                new_level.push(format!("{:x}", hasher.finalize()));
            }
            merkle_tree = new_level;
        }

        merkle_tree[0].clone()
    }

    pub fn mine(&mut self, difficulty: usize) {
        let target = "0".repeat(difficulty);
        while &self.hash[..difficulty] != target {
            self.nonce += 1;
            self.hash = self.calculate_hash();
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Transaction {
    pub from: String,
    pub to: String,
    pub amount: f64,
    pub currency_type: CurrencyType,
    pub timestamp: i64,
    pub signature: Option<Vec<u8>>,
}

pub struct Blockchain {
    pub chain: Vec<Block>,
    pub pending_transactions: Vec<Transaction>,
    pub difficulty: usize,
    currency_system: CurrencySystem,
}

impl Blockchain {
    pub fn new(difficulty: usize) -> Self {
        let mut blockchain = Blockchain {
            chain: Vec::new(),
            pending_transactions: Vec::new(),
            difficulty,
            currency_system: CurrencySystem::new(),
        };
        blockchain.create_genesis_block();
        blockchain
    }

    fn create_genesis_block(&mut self) {
        let genesis_block = Block::new(0, Vec::new(), "0");
        self.chain.push(genesis_block);
    }

    pub fn add_transaction(&mut self, transaction: Transaction) -> IcnResult<()> {
        if self.validate_transaction(&transaction)? {
            self.pending_transactions.push(transaction);
            Ok(())
        } else {
            Err(IcnError::Blockchain("Invalid transaction".into()))
        }
    }

    pub fn mine_pending_transactions(&mut self, miner_address: &str) -> IcnResult<()> {
        let reward_transaction = Transaction {
            from: "Network".to_string(),
            to: miner_address.to_string(),
            amount: 1.0, // Mining reward
            currency_type: CurrencyType::BasicNeeds,
            timestamp: Utc::now().timestamp(),
            signature: None,
        };
        self.pending_transactions.push(reward_transaction);

        let mut new_block = Block::new(
            self.chain.len() as u64,
            self.pending_transactions.clone(),
            &self.get_latest_block().hash,
        );
        new_block.mine(self.difficulty);
        self.add_block(new_block)?;

        self.pending_transactions.clear();
        Ok(())
    }

    fn add_block(&mut self, block: Block) -> IcnResult<()> {
        self.chain.push(block);
        self.update_balances()?;
        Ok(())
    }

    pub fn get_latest_block(&self) -> &Block {
        self.chain.last().unwrap()
    }

    pub fn is_chain_valid(&self) -> bool {
        for i in 1..self.chain.len() {
            let current_block = &self.chain[i];
            let previous_block = &self.chain[i - 1];

            if current_block.hash != current_block.calculate_hash() {
                return false;
            }

            if current_block.previous_hash != previous_block.hash {
                return false;
            }

            if current_block.merkle_root != current_block.calculate_merkle_root() {
                return false;
            }

            if !self.validate_block_transactions(current_block) {
                return false;
            }
        }
        true
    }

    fn validate_block_transactions(&self, block: &Block) -> bool {
        for transaction in &block.transactions {
            if !self.validate_transaction(transaction).unwrap_or(false) {
                return false;
            }
        }
        true
    }

    fn validate_transaction(&self, transaction: &Transaction) -> IcnResult<bool> {
        if transaction.from == "Network" {
            return Ok(true); // Allow mining rewards
        }

        let sender_balance = self.currency_system.get_balance(&transaction.from, &transaction.currency_type)?;
        if sender_balance < transaction.amount {
            return Ok(false);
        }

        // Additional validation logic can be added here (e.g., signature verification)
        if let Some(signature) = &transaction.signature {
            // Implement signature verification logic here
            // For now, we'll assume all signatures are valid
            // In a real implementation, you would verify the signature against the transaction data
            // using the sender's public key
        }

        Ok(true)
    }

    fn update_balances(&mut self) -> IcnResult<()> {
        for transaction in &self.get_latest_block().transactions {
            self.currency_system.process_transaction(transaction)?;
        }
        Ok(())
    }

    pub fn get_balance(&self, address: &str, currency_type: &CurrencyType) -> IcnResult<f64> {
        self.currency_system.get_balance(address, currency_type)
    }

    pub fn get_transactions(&self, address: &str) -> Vec<&Transaction> {
        self.chain
            .iter()
            .flat_map(|block| block.transactions.iter())
            .filter(|tx| tx.from == address || tx.to == address)
            .collect()
    }

    pub fn get_block_by_hash(&self, hash: &str) -> Option<&Block> {
        self.chain.iter().find(|block| block.hash == hash)
    }

    pub fn get_block_by_index(&self, index: u64) -> Option<&Block> {
        self.chain.get(index as usize)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_blockchain_creation() {
        let blockchain = Blockchain::new(2);
        assert_eq!(blockchain.chain.len(), 1);
        assert_eq!(blockchain.chain[0].index, 0);
    }

    #[test]
    fn test_add_transaction_and_mine() {
        let mut blockchain = Blockchain::new(2);
        let transaction = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 50.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: Utc::now().timestamp(),
            signature: None,
        };

        // Add initial balance for Alice
        blockchain.currency_system.mint("Alice", &CurrencyType::BasicNeeds, 100.0).unwrap();

        assert!(blockchain.add_transaction(transaction).is_ok());
        assert_eq!(blockchain.pending_transactions.len(), 1);

        assert!(blockchain.mine_pending_transactions("Miner").is_ok());
        assert_eq!(blockchain.chain.len(), 2);
        assert_eq!(blockchain.pending_transactions.len(), 0);

        // Check balances after mining
        assert_eq!(blockchain.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap(), 50.0);
        assert_eq!(blockchain.get_balance("Bob", &CurrencyType::BasicNeeds).unwrap(), 50.0);
        assert_eq!(blockchain.get_balance("Miner", &CurrencyType::BasicNeeds).unwrap(), 1.0);
    }

    #[test]
    fn test_blockchain_validity() {
        let mut blockchain = Blockchain::new(2);
        let transaction = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 50.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: Utc::now().timestamp(),
            signature: None,
        };

        blockchain.currency_system.mint("Alice", &CurrencyType::BasicNeeds, 100.0).unwrap();

        assert!(blockchain.add_transaction(transaction).is_ok());
        assert!(blockchain.mine_pending_transactions("Miner").is_ok());

        assert!(blockchain.is_chain_valid());

        // Tamper with a block to test invalid chain
        blockchain.chain[1].transactions[0].amount = 100.0;
        assert!(!blockchain.is_chain_valid());
    }

    #[test]
    fn test_get_transactions() {
        let mut blockchain = Blockchain::new(2);
        let transaction1 = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 50.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: Utc::now().timestamp(),
            signature: None,
        };
        let transaction2 = Transaction {
            from: "Bob".to_string(),
            to: "Charlie".to_string(),
            amount: 25.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: Utc::now().timestamp(),
            signature: None,
        };

        blockchain.currency_system.mint("Alice", &CurrencyType::BasicNeeds, 100.0).unwrap();
        blockchain.currency_system.mint("Bob", &CurrencyType::BasicNeeds, 50.0).unwrap();

        assert!(blockchain.add_transaction(transaction1).is_ok());
        assert!(blockchain.add_transaction(transaction2).is_ok());
        assert!(blockchain.mine_pending_transactions("Miner").is_ok());

        let alice_transactions = blockchain.get_transactions("Alice");
        assert_eq!(alice_transactions.len(), 1);
        assert_eq!(alice_transactions[0].from, "Alice");

        let bob_transactions = blockchain.get_transactions("Bob");
        assert_eq!(bob_transactions.len(), 2);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_blockchain/src/blockchain.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_blockchain/src/lib.rs =====
// File: icn_blockchain/src/lib.rs

use chrono::{DateTime, Utc};
use icn_common::{IcnResult, IcnError, CurrencyType};
use icn_currency::CurrencySystem;
use serde::{Serialize, Deserialize};
use sha2::{Sha256, Digest};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Block {
    pub index: u64,
    pub timestamp: i64,
    pub transactions: Vec<Transaction>,
    pub previous_hash: String,
    pub hash: String,
    pub nonce: u64,
    pub merkle_root: String,
}

impl Block {
    pub fn new(index: u64, transactions: Vec<Transaction>, previous_hash: &str) -> Self {
        let mut block = Block {
            index,
            timestamp: Utc::now().timestamp(),
            transactions,
            previous_hash: previous_hash.to_string(),
            hash: String::new(),
            nonce: 0,
            merkle_root: String::new(),
        };
        block.merkle_root = block.calculate_merkle_root();
        block.hash = block.calculate_hash();
        block
    }

    pub fn calculate_hash(&self) -> String {
        let mut hasher = Sha256::new();
        hasher.update(self.index.to_string());
        hasher.update(&self.timestamp.to_string());
        hasher.update(&self.merkle_root);
        hasher.update(&self.previous_hash);
        hasher.update(&self.nonce.to_string());
        format!("{:x}", hasher.finalize())
    }

    pub fn calculate_merkle_root(&self) -> String {
        let transaction_hashes: Vec<String> = self.transactions
            .iter()
            .map(|tx| {
                let mut hasher = Sha256::new();
                hasher.update(serde_json::to_string(tx).unwrap().as_bytes());
                format!("{:x}", hasher.finalize())
            })
            .collect();

        if transaction_hashes.is_empty() {
            return String::from("0000000000000000000000000000000000000000000000000000000000000000");
        }

        let mut merkle_tree = transaction_hashes;
        while merkle_tree.len() > 1 {
            let mut new_level = Vec::new();
            for chunk in merkle_tree.chunks(2) {
                let mut hasher = Sha256::new();
                hasher.update(chunk[0].as_bytes());
                if chunk.len() > 1 {
                    hasher.update(chunk[1].as_bytes());
                } else {
                    hasher.update(chunk[0].as_bytes());
                }
                new_level.push(format!("{:x}", hasher.finalize()));
            }
            merkle_tree = new_level;
        }

        merkle_tree[0].clone()
    }

    pub fn mine(&mut self, difficulty: usize) {
        let target = "0".repeat(difficulty);
        while &self.hash[..difficulty] != target {
            self.nonce += 1;
            self.hash = self.calculate_hash();
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Transaction {
    pub from: String,
    pub to: String,
    pub amount: f64,
    pub currency_type: CurrencyType,
    pub timestamp: i64,
    pub signature: Option<Vec<u8>>,
}

pub struct Blockchain {
    pub chain: Vec<Block>,
    pub pending_transactions: Vec<Transaction>,
    pub difficulty: usize,
    currency_system: CurrencySystem,
}

impl Blockchain {
    pub fn new(difficulty: usize) -> Self {
        let mut blockchain = Blockchain {
            chain: Vec::new(),
            pending_transactions: Vec::new(),
            difficulty,
            currency_system: CurrencySystem::new(),
        };
        blockchain.create_genesis_block();
        blockchain
    }

    fn create_genesis_block(&mut self) {
        let genesis_block = Block::new(0, Vec::new(), "0");
        self.chain.push(genesis_block);
    }

    pub fn add_transaction(&mut self, transaction: Transaction) -> IcnResult<()> {
        if self.validate_transaction(&transaction)? {
            self.pending_transactions.push(transaction);
            Ok(())
        } else {
            Err(IcnError::Blockchain("Invalid transaction".into()))
        }
    }

    pub fn mine_pending_transactions(&mut self, miner_address: &str) -> IcnResult<()> {
        let reward_transaction = Transaction {
            from: "Network".to_string(),
            to: miner_address.to_string(),
            amount: 1.0, // Mining reward
            currency_type: CurrencyType::BasicNeeds,
            timestamp: Utc::now().timestamp(),
            signature: None,
        };
        self.pending_transactions.push(reward_transaction);

        let new_block = Block::new(
            self.chain.len() as u64,
            self.pending_transactions.clone(),
            &self.get_latest_block().hash,
        );
        self.add_block(new_block)?;

        self.pending_transactions.clear();
        Ok(())
    }

    pub fn add_block(&mut self, mut block: Block) -> IcnResult<()> {
        block.mine(self.difficulty);
        self.chain.push(block);
        self.update_balances()?;
        Ok(())
    }

    pub fn get_latest_block(&self) -> &Block {
        self.chain.last().unwrap()
    }

    pub fn is_chain_valid(&self) -> bool {
        for i in 1..self.chain.len() {
            let current_block = &self.chain[i];
            let previous_block = &self.chain[i - 1];

            if current_block.hash != current_block.calculate_hash() {
                return false;
            }

            if current_block.previous_hash != previous_block.hash {
                return false;
            }

            if current_block.merkle_root != current_block.calculate_merkle_root() {
                return false;
            }

            if !self.validate_block_transactions(current_block) {
                return false;
            }
        }
        true
    }

    fn validate_block_transactions(&self, block: &Block) -> bool {
        for transaction in &block.transactions {
            if !self.validate_transaction(transaction).unwrap_or(false) {
                return false;
            }
        }
        true
    }

    fn validate_transaction(&self, transaction: &Transaction) -> IcnResult<bool> {
        if transaction.from == "Network" {
            return Ok(true); // Allow mining rewards
        }

        let sender_balance = self.currency_system.get_balance(&transaction.from, &transaction.currency_type)?;
        if sender_balance < transaction.amount {
            return Ok(false);
        }

        // Additional validation logic can be added here (e.g., signature verification)
        if let Some(signature) = &transaction.signature {
            // Implement signature verification logic here
            // For now, we'll assume all signatures are valid
            // In a real implementation, you would verify the signature against the transaction data
            // using the sender's public key
        }

        Ok(true)
    }

    fn update_balances(&mut self) -> IcnResult<()> {
        for transaction in &self.get_latest_block().transactions {
            self.currency_system.process_transaction(transaction)?;
        }
        Ok(())
    }

    pub fn get_balance(&self, address: &str, currency_type: &CurrencyType) -> IcnResult<f64> {
        self.currency_system.get_balance(address, currency_type)
    }

    pub fn get_transactions(&self, address: &str) -> Vec<&Transaction> {
        self.chain
            .iter()
            .flat_map(|block| block.transactions.iter())
            .filter(|tx| tx.from == address || tx.to == address)
            .collect()
    }

    pub fn get_block_by_hash(&self, hash: &str) -> Option<&Block> {
        self.chain.iter().find(|block| block.hash == hash)
    }

    pub fn get_block_by_index(&self, index: u64) -> Option<&Block> {
        self.chain.get(index as usize)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_blockchain_creation() {
        let blockchain = Blockchain::new(2);
        assert_eq!(blockchain.chain.len(), 1);
        assert_eq!(blockchain.chain[0].index, 0);
    }

    #[test]
    fn test_add_transaction_and_mine() {
        let mut blockchain = Blockchain::new(2);
        let transaction = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 50.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: Utc::now().timestamp(),
            signature: None,
        };

        // Add initial balance for Alice
        blockchain.currency_system.mint("Alice", &CurrencyType::BasicNeeds, 100.0).unwrap();

        assert!(blockchain.add_transaction(transaction).is_ok());
        assert_eq!(blockchain.pending_transactions.len(), 1);

        assert!(blockchain.mine_pending_transactions("Miner").is_ok());
        assert_eq!(blockchain.chain.len(), 2);
        assert_eq!(blockchain.pending_transactions.len(), 0);

        // Check balances after mining
        assert_eq!(blockchain.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap(), 50.0);
        assert_eq!(blockchain.get_balance("Bob", &CurrencyType::BasicNeeds).unwrap(), 50.0);
        assert_eq!(blockchain.get_balance("Miner", &CurrencyType::BasicNeeds).unwrap(), 1.0);
    }

    #[test]
    fn test_blockchain_validity() {
        let mut blockchain = Blockchain::new(2);
        let transaction = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 50.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: Utc::now().timestamp(),
            signature: None,
        };

        blockchain.currency_system.mint("Alice", &CurrencyType::BasicNeeds, 100.0).unwrap();

        assert!(blockchain.add_transaction(transaction).is_ok());
        assert!(blockchain.mine_pending_transactions("Miner").is_ok());

        assert!(blockchain.is_chain_valid());

        // Tamper with a block to test invalid chain
        blockchain.chain[1].transactions[0].amount = 100.0;
        assert!(!blockchain.is_chain_valid());
    }

    #[test]
    fn test_get_transactions() {
        let mut blockchain = Blockchain::new(2);
        let transaction1 = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 50.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: Utc::now().timestamp(),
            signature: None,
        };
        let transaction2 = Transaction {
            from: "Bob".to_string(),
            to: "Charlie".to_string(),
            amount: 25.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: Utc::now().timestamp(),
            signature: None,
        };

        blockchain.currency_system.mint("Alice", &CurrencyType::BasicNeeds, 100.0).unwrap();
        blockchain.currency_system.mint("Bob", &CurrencyType::BasicNeeds, 50.0).unwrap();

        assert!(blockchain.add_transaction(transaction1).is_ok());
        assert!(blockchain.add_transaction(transaction2).is_ok());
        assert!(blockchain.mine_pending_transactions("Miner").is_ok());

        let alice_transactions = blockchain.get_transactions("Alice");
        assert_eq!(alice_transactions.len(), 1);
        assert_eq!(alice_transactions[0].from, "Alice");

        let bob_transactions = blockchain.get_transactions("Bob");
        assert_eq!(bob_transactions.len(), 2);
    }

    #[test]
    fn test_get_block_by_hash_and_index() {
        let mut blockchain = Blockchain::new(2);
        let transaction = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 50.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: Utc::now().timestamp(),
            signature: None,
        };

        blockchain.currency_system.mint("Alice", &CurrencyType::BasicNeeds, 100.0).unwrap();
        assert!(blockchain.add_transaction(transaction).is_ok());
        assert!(blockchain.mine_pending_transactions("Miner").is_ok());

        let latest_block = blockchain.get_latest_block();
        let block_by_hash = blockchain.get_block_by_hash(&latest_block.hash);
        assert!(block_by_hash.is_some());
        assert_eq!(block_by_hash.unwrap().hash, latest_block.hash);

        let block_by_index = blockchain.get_block_by_index(1);
        assert!(block_by_index.is_some());
        assert_eq!(block_by_index.unwrap().index, 1);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_blockchain/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_blockchain/src/transaction_validator.rs =====
// File: icn_blockchain/src/transaction_validator.rs

use icn_common::error::{IcnError, IcnResult};
use crate::{Transaction, Blockchain};

/// A struct for validating transactions.
pub struct TransactionValidator;

impl TransactionValidator {
    /// Validates a transaction within the context of a blockchain.
    ///
    /// # Arguments
    ///
    /// * `transaction` - The transaction to validate.
    /// * `blockchain` - The blockchain context.
    ///
    /// # Returns
    ///
    /// `IcnResult<()>` indicating whether the transaction is valid.
    pub fn validate_transaction(transaction: &Transaction, blockchain: &Blockchain) -> IcnResult<()> {
        if Self::is_double_spend(transaction, blockchain)? {
            return Err(IcnError::Currency("Double spend detected".to_string()));
        }
        Self::validate_currency_and_amount(transaction)?;
        Self::check_sufficient_balance(transaction, blockchain)?;
        Self::validate_signature(transaction)?;
        Ok(())
    }

    fn is_double_spend(transaction: &Transaction, blockchain: &Blockchain) -> IcnResult<bool> {
        for block in &blockchain.chain {
            for tx in &block.transactions {
                if tx == transaction {
                    return Ok(true);
                }
            }
        }
        Ok(false)
    }

    fn validate_currency_and_amount(transaction: &Transaction) -> IcnResult<()> {
        if transaction.amount <= 0.0 {
            return Err(IcnError::Currency("Invalid currency or amount".to_string()));
        }
        Ok(())
    }

    fn check_sufficient_balance(transaction: &Transaction, blockchain: &Blockchain) -> IcnResult<()> {
        let balance = blockchain.get_balance(&transaction.from, &transaction.currency_type)?;
        if balance < transaction.amount + transaction.get_fee() {
            return Err(IcnError::Currency("Insufficient balance".to_string()));
        }
        Ok(())
    }

    fn validate_signature(transaction: &Transaction) -> IcnResult<()> {
        if !transaction.verify().map_err(|e| IcnError::Identity(format!("Signature verification failed: {}", e)))? {
            return Err(IcnError::Identity("Invalid signature".to_string()));
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::Blockchain;
    use icn_common::CurrencyType;
    use ed25519_dalek::Keypair;
    use rand::rngs::OsRng;

    fn create_signed_transaction(from: &str, to: &str, amount: f64) -> Transaction {
        let mut tx = Transaction::new(
            from.to_string(),
            to.to_string(),
            amount,
            CurrencyType::BasicNeeds,
            1000,
        );
        let mut csprng = OsRng{};
        let keypair: Keypair = Keypair::generate(&mut csprng);
        tx.sign(&keypair).unwrap();
        tx
    }

    #[test]
    fn test_validate_transaction() {
        let mut blockchain = Blockchain::new(Arc::new(MockTransactionValidator::new()), Arc::new(RwLock::new(MockConsensus::new())));
        let tx = create_signed_transaction("Alice", "Bob", 50.0);

        blockchain.add_transaction(create_signed_transaction("Genesis", "Alice", 100.0)).unwrap();
        blockchain.create_block().unwrap();

        assert!(TransactionValidator::validate_transaction(&tx, &blockchain).is_ok());
    }

    #[test]
    fn test_insufficient_balance() {
        let mut blockchain = Blockchain::new(Arc::new(MockTransactionValidator::new()), Arc::new(RwLock::new(MockConsensus::new())));
        let tx = create_signed_transaction("Alice", "Bob", 150.0);

        blockchain.add_transaction(create_signed_transaction("Genesis", "Alice", 100.0)).unwrap();
        blockchain.create_block().unwrap();

        assert!(TransactionValidator::validate_transaction(&tx, &blockchain).is_err());
    }

    #[test]
    fn test_double_spend() {
        let mut blockchain = Blockchain::new(Arc::new(MockTransactionValidator::new()), Arc::new(RwLock::new(MockConsensus::new())));
        let tx = create_signed_transaction("Alice", "Bob", 50.0);

        blockchain.add_transaction(create_signed_transaction("Genesis", "Alice", 100.0)).unwrap();
        blockchain.create_block().unwrap();

        blockchain.add_transaction(tx.clone()).unwrap();
        blockchain.create_block().unwrap();

        assert!(TransactionValidator::validate_transaction(&tx, &blockchain).is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_blockchain/src/transaction_validator.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_common/Cargo.toml =====
[package]
name = "icn_common"
version = "0.1.0"
authors = ["Your Name <your.email@example.com>"]
edition = "2018"

[dependencies]
chrono = { version = "0.4", features = ["serde"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
sha2 = "0.9"
rand = "0.8"
rand_chacha = "0.3"
ed25519-dalek = "1.0"
thiserror = "1.0"
tokio = { version = "1.0", features = ["full"] }
log = "0.4"
uuid = "0.8"

[dev-dependencies]
rand = "0.8"
rand_chacha = "0.3"===== END OF /home/matt/InterCooperative-Network/crates/icn_common/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_common/src/bit_utils.rs =====
// File: crates/icn_common/src/bit_utils.rs

/// A custom bit vector implementation.
#[derive(Clone, Debug)]
pub struct BitVec {
    storage: Vec<u64>,
    len: usize,
}

impl BitVec {
    /// Creates a new `BitVec` with the specified length, initialized to all zeros.
    pub fn new(len: usize) -> Self {
        let storage_len = (len + 63) / 64;
        BitVec {
            storage: vec![0; storage_len],
            len,
        }
    }

    /// Returns the length of the bit vector.
    pub fn len(&self) -> usize {
        self.len
    }

    /// Returns whether the bit vector is empty.
    pub fn is_empty(&self) -> bool {
        self.len == 0
    }

    /// Sets the bit at the specified index.
    pub fn set(&mut self, index: usize) {
        assert!(index < self.len, "Index out of bounds");
        let (word_index, bit_index) = (index / 64, index % 64);
        self.storage[word_index] |= 1 << bit_index;
    }

    /// Clears the bit at the specified index.
    pub fn clear(&mut self, index: usize) {
        assert!(index < self.len, "Index out of bounds");
        let (word_index, bit_index) = (index / 64, index % 64);
        self.storage[word_index] &= !(1 << bit_index);
    }

    /// Toggles the bit at the specified index.
    pub fn toggle(&mut self, index: usize) {
        assert!(index < self.len, "Index out of bounds");
        let (word_index, bit_index) = (index / 64, index % 64);
        self.storage[word_index] ^= 1 << bit_index;
    }

    /// Returns the value of the bit at the specified index.
    pub fn get(&self, index: usize) -> bool {
        assert!(index < self.len, "Index out of bounds");
        let (word_index, bit_index) = (index / 64, index % 64);
        (self.storage[word_index] & (1 << bit_index)) != 0
    }

    /// Sets a range of bits to 1.
    pub fn set_range(&mut self, start: usize, end: usize) {
        assert!(start <= end && end < self.len, "Index out of bounds");
        for index in start..=end {
            self.set(index);
        }
    }

    /// Clears a range of bits.
    pub fn clear_range(&mut self, start: usize, end: usize) {
        assert!(start <= end && end < self.len, "Index out of bounds");
        for index in start..=end {
            self.clear(index);
        }
    }

    /// Counts the number of set bits in the bit vector.
    pub fn count_ones(&self) -> u32 {
        self.storage.iter().map(|&x| x.count_ones()).sum()
    }
}

/// Sets the nth bit of a u64 value.
pub fn set_bit(value: u64, n: u8) -> u64 {
    debug_assert!(n < 64, "Bit index out of bounds");
    value | (1 << n)
}

/// Clears the nth bit of a u64 value.
pub fn clear_bit(value: u64, n: u8) -> u64 {
    debug_assert!(n < 64, "Bit index out of bounds");
    value & !(1 << n)
}

/// Toggles the nth bit of a u64 value.
pub fn toggle_bit(value: u64, n: u8) -> u64 {
    debug_assert!(n < 64, "Bit index out of bounds");
    value ^ (1 << n)
}

/// Rotates the bits of a u64 value left by a specified amount.
pub fn rotate_left(value: u64, n: u8) -> u64 {
    value.rotate_left(n as u32)
}

/// Rotates the bits of a u64 value right by a specified amount.
pub fn rotate_right(value: u64, n: u8) -> u64 {
    value.rotate_right(n as u32)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_bit_vec_operations() {
        let mut bv = BitVec::new(100);
        assert_eq!(bv.len(), 100);
        assert!(!bv.is_empty());

        bv.set(5);
        bv.set(50);
        assert!(bv.get(5));
        assert!(bv.get(50));
        assert!(!bv.get(0));

        bv.toggle(5);
        assert!(!bv.get(5));

        bv.clear(50);
        assert!(!bv.get(50));

        bv.set_range(10, 20);
        for i in 10..=20 {
            assert!(bv.get(i));
        }

        bv.clear_range(15, 18);
        for i in 15..=18 {
            assert!(!bv.get(i));
        }

        assert_eq!(bv.count_ones(), 10);

        bv.set(10);
        bv.set(20);
        bv.set(30);
        assert_eq!(bv.count_ones(), 12);
    }

    #[test]
    fn test_bit_operations() {
        assert_eq!(set_bit(0, 3), 8);
        assert_eq!(clear_bit(15, 2), 11);
        assert_eq!(toggle_bit(5, 1), 7);
        assert_eq!(rotate_left(0b1101, 2), 0b110100);
        assert_eq!(rotate_right(0b110100, 2), 0b1101);
    }

    #[test]
    #[should_panic(expected = "Index out of bounds")]
    fn test_bit_vec_out_of_bounds() {
        let mut bv = BitVec::new(10);
        bv.set(10);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_common/src/bit_utils.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_common/src/error.rs =====
// File: crates/icn_common/src/error.rs

use thiserror::Error;

/// Custom error type for the ICN project.
#[derive(Error, Debug)]
pub enum IcnError {
    #[error("Blockchain error: {0}")]
    Blockchain(String),

    #[error("Consensus error: {0}")]
    Consensus(String),

    #[error("Currency error: {0}")]
    Currency(String),

    #[error("Governance error: {0}")]
    Governance(String),

    #[error("Identity error: {0}")]
    Identity(String),

    #[error("Network error: {0}")]
    Network(String),

    #[error("Node management error: {0}")]
    NodeManagement(String),

    #[error("Sharding error: {0}")]
    Sharding(String),

    #[error("Storage error: {0}")]
    Storage(String),

    #[error("VM error: {0}")]
    Vm(String),

    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),

    #[error("Serialization error: {0}")]
    Serialization(#[from] serde_json::Error),

    #[error("Database error: {0}")]
    Database(String),

    #[error("Configuration error: {0}")]
    Config(String),

    #[error("Zero-Knowledge Proof error: {0}")]
    Zkp(String),

    #[error("Validation error: {0}")]
    Validation(String),

    #[error("Unknown error: {0}")]
    Unknown(String),
}

/// Result type for the ICN project.
pub type IcnResult<T> = std::result::Result<T, IcnError>;
===== END OF /home/matt/InterCooperative-Network/crates/icn_common/src/error.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_common/src/lib.rs =====
// File: crates/icn_common/src/lib.rs

pub mod error;
pub mod bit_utils;

pub use crate::error::{IcnError, IcnResult};

use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Config {
    pub shard_count: u64,
    pub consensus_threshold: f64,
    pub consensus_quorum: f64,
    pub network_port: u16,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct Transaction {
    pub from: String,
    pub to: String,
    pub amount: f64,
    pub currency_type: CurrencyType,
    pub timestamp: i64,
    pub signature: Option<Vec<u8>>,
}

impl Transaction {
    pub fn new(from: String, to: String, amount: f64, currency_type: CurrencyType, timestamp: i64) -> Self {
        Transaction {
            from,
            to,
            amount,
            currency_type,
            timestamp,
            signature: None,
        }
    }

    pub fn sign(&mut self, keypair: &ed25519_dalek::Keypair) -> IcnResult<()> {
        let message = format!("{}{}{}{}", self.from, self.to, self.amount, self.timestamp);
        let signature = keypair.sign(message.as_bytes()).to_bytes().to_vec();
        self.signature = Some(signature);
        Ok(())
    }

    pub fn verify(&self) -> IcnResult<bool> {
        if let Some(signature) = &self.signature {
            let message = format!("{}{}{}{}", self.from, self.to, self.amount, self.timestamp);
            let public_key = ed25519_dalek::PublicKey::from_bytes(&self.from.as_bytes())
                .map_err(|e| IcnError::Identity(format!("PublicKey conversion failed: {}", e)))?;
            let signature = ed25519_dalek::Signature::from_bytes(signature)
                .map_err(|e| IcnError::Identity(format!("Signature conversion failed: {}", e)))?;
            public_key
                .verify(message.as_bytes(), &signature)
                .map_err(|e| IcnError::Identity(format!("Signature verification failed: {}", e)))?;
            Ok(true)
        } else {
            Ok(false)
        }
    }

    pub fn get_fee(&self) -> f64 {
        // Simplified fee calculation; in a real implementation, fees would be more complex
        0.01
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proposal {
    pub id: String,
    pub title: String,
    pub description: String,
    pub proposer: String,
    pub created_at: DateTime<Utc>,
    pub voting_ends_at: DateTime<Utc>,
    pub status: ProposalStatus,
    pub proposal_type: ProposalType,
    pub category: ProposalCategory,
    pub required_quorum: f64,
    pub execution_timestamp: Option<DateTime<Utc>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vote {
    pub voter: String,
    pub proposal_id: String,
    pub in_favor: bool,
    pub weight: f64,
    pub timestamp: i64,
    pub zkp: Option<Vec<u8>>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProposalStatus {
    Active,
    Passed,
    Rejected,
    Executed,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProposalType {
    Constitutional,
    EconomicAdjustment,
    NetworkUpgrade,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProposalCategory {
    Economic,
    Technical,
    Social,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum CurrencyType {
    BasicNeeds,
    Education,
    Environmental,
    Community,
    Custom(String),
}

#[derive(Debug, Serialize, Deserialize)]
pub struct NetworkStats {
    pub node_count: usize,
    pub total_transactions: usize,
    pub active_proposals: usize,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_transaction_equality() {
        let tx1 = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 50.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: 0,
            signature: None,
        };

        let tx2 = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 50.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: 0,
            signature: None,
        };

        assert_eq!(tx1, tx2);
    }

    #[test]
    fn test_currency_type_equality() {
        assert_eq!(CurrencyType::BasicNeeds, CurrencyType::BasicNeeds);
        assert_ne!(CurrencyType::BasicNeeds, CurrencyType::Education);
    }

    #[test]
    fn test_proposal_status() {
        let status1 = ProposalStatus::Active;
        let status2 = ProposalStatus::Passed;
        assert_ne!(status1, status2);
    }

    #[test]
    fn test_network_stats() {
        let stats = NetworkStats {
            node_count: 5,
            total_transactions: 100,
            active_proposals: 3,
        };
        assert_eq!(stats.node_count, 5);
        assert_eq!(stats.total_transactions, 100);
        assert_eq!(stats.active_proposals, 3);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_common/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_consensus/Cargo.toml =====
[package]
name = "icn_consensus"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
icn_blockchain = { path = "../icn_blockchain" }
serde = { version = "1.0", features = ["derive"] }
log = "0.4"
thiserror = "1.0"
chrono = { version = "0.4", features = ["serde"] }
rand = "0.8"

[dev-dependencies]
tokio = { version = "1.0", features = ["full"] }===== END OF /home/matt/InterCooperative-Network/crates/icn_consensus/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_consensus/src/bft_poc.rs =====
use icn_utils::{error::IcnError, IcnResult};
use serde::{Serialize, Deserialize};

#[derive(Debug)]
pub enum ProposalStatus {
    Pending,
    Approved,
    Rejected,
}

impl Clone for ProposalStatus {
    fn clone(&self) -> Self {
        match self {
            ProposalStatus::Pending => ProposalStatus::Pending,
            ProposalStatus::Approved => ProposalStatus::Approved,
            ProposalStatus::Rejected => ProposalStatus::Rejected,
        }
    }
}

#[derive(Debug)]
pub struct Proposal {
    pub id: String,
    pub status: ProposalStatus,
    pub votes: Vec<Vote>,
}

#[derive(Clone)]
pub struct Vote {
    pub member_id: String,
    pub vote: bool,
}

pub struct BFTPoC {
    pub proposals: Vec<Proposal>,
}

impl BFTPoC {
    pub fn new() -> Self {
        BFTPoC {
            proposals: Vec::new(),
        }
    }

    pub fn create_proposal(&mut self, proposal_id: String) -> IcnResult<()> {
        if self.proposals.iter().any(|p| p.id == proposal_id) {
            return Err(IcnError::Governance("Proposal already exists".to_string()));
        }

        let proposal = Proposal {
            id: proposal_id,
            status: ProposalStatus::Pending,
            votes: Vec::new(),
        };

        self.proposals.push(proposal);
        Ok(())
    }

    pub fn vote_on_proposal(&mut self, proposal_id: &str, member_id: String, vote: bool) -> IcnResult<()> {
        let proposal = self.proposals.iter_mut().find(|p| p.id == proposal_id).ok_or_else(|| IcnError::Governance("Proposal not found".to_string()))?;

        if proposal.votes.iter().any(|v| v.member_id == member_id) {
            return Err(IcnError::Governance("Member has already voted".to_string()));
        }

        // Validate the member ID
        if member_id.is_empty() {
            return Err(IcnError::Governance("Invalid member ID".to_string()));
        }

        proposal.votes.push(Vote { member_id, vote });
        Ok(())
    }

    pub fn finalize_proposal(&mut self, proposal_id: &str) -> IcnResult<ProposalStatus> {
        let proposal = self.proposals.iter_mut().find(|p| p.id == proposal_id).ok_or_else(|| IcnError::Governance("Proposal not found".to_string()))?;

        let positive_votes = proposal.votes.iter().filter(|v| v.vote).count();
        let negative_votes = proposal.votes.len() - positive_votes;

        proposal.status = if positive_votes > negative_votes {
            ProposalStatus::Approved
        } else {
            ProposalStatus::Rejected
        };

        Ok(proposal.status.clone())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_proposal() {
        let mut bft_poc = BFTPoC::new();

        assert!(bft_poc.create_proposal("proposal1".to_string()).is_ok());
        assert_eq!(bft_poc.proposals.len(), 1);

        assert!(bft_poc.create_proposal("proposal1".to_string()).is_err());
    }

    #[test]
    fn test_vote_on_proposal() {
        let mut bft_poc = BFTPoC::new();
        bft_poc.create_proposal("proposal1".to_string()).unwrap();

        assert!(bft_poc.vote_on_proposal("proposal1", "member1".to_string(), true).is_ok());
        assert_eq!(bft_poc.proposals[0].votes.len(), 1);

        assert!(bft_poc.vote_on_proposal("proposal1", "member1".to_string(), false).is_err());
    }

    #[test]
    fn test_finalize_proposal() {
        let mut bft_poc = BFTPoC::new();
        bft_poc.create_proposal("proposal1".to_string()).unwrap();

        bft_poc.vote_on_proposal("proposal1", "member1".to_string(), true).unwrap();
        bft_poc.vote_on_proposal("proposal1", "member2".to_string(), false).unwrap();

        let status = bft_poc.finalize_proposal("proposal1").unwrap();
        assert_eq!(status, ProposalStatus::Rejected);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_consensus/src/bft_poc.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_consensus/src/consensus.rs =====
// File: icn_consensus/src/consensus.rs

use icn_common::{Block, IcnResult, IcnError};
use std::collections::HashMap;

pub struct PoCConsensus {
    threshold: f64,
    quorum: f64,
    validators: HashMap<String, f64>, // validator_id -> reputation
}

impl PoCConsensus {
    pub fn new(threshold: f64, quorum: f64) -> IcnResult<Self> {
        if threshold <= 0.0 || threshold > 1.0 || quorum <= 0.0 || quorum > 1.0 {
            return Err(IcnError::Consensus("Invalid threshold or quorum value".into()));
        }

        Ok(PoCConsensus {
            threshold,
            quorum,
            validators: HashMap::new(),
        })
    }

    pub fn add_validator(&mut self, validator_id: String, initial_reputation: f64) -> IcnResult<()> {
        if initial_reputation < 0.0 || initial_reputation > 1.0 {
            return Err(IcnError::Consensus("Invalid initial reputation".into()));
        }
        self.validators.insert(validator_id, initial_reputation);
        Ok(())
    }

    pub fn validate_block(&self, block: &Block) -> IcnResult<bool> {
        // In a real implementation, this would involve more complex validation logic
        // For now, we'll just check if the block has transactions
        if block.transactions.is_empty() {
            return Err(IcnError::Consensus("Block has no transactions".into()));
        }
        Ok(true)
    }

    pub fn update_reputation(&mut self, validator_id: &str, change: f64) -> IcnResult<()> {
        let reputation = self.validators.get_mut(validator_id)
            .ok_or_else(|| IcnError::Consensus("Validator not found".into()))?;
        *reputation += change;
        *reputation = reputation.clamp(0.0, 1.0); // This was missing a semicolon
        Ok(())
    }
        

    pub fn get_total_reputation(&self) -> f64 {
        self.validators.values().sum()
    }

    pub fn is_quorum_reached(&self, participating_reputation: f64) -> bool {
        let total_reputation = self.get_total_reputation();
        participating_reputation / total_reputation >= self.quorum
    }

    pub fn is_consensus_reached(&self, approving_reputation: f64, participating_reputation: f64) -> bool {
        approving_reputation / participating_reputation >= self.threshold
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_consensus_creation() {
        assert!(PoCConsensus::new(0.66, 0.51).is_ok());
        assert!(PoCConsensus::new(1.5, 0.5).is_err());
        assert!(PoCConsensus::new(0.5, 1.5).is_err());
    }

    #[test]
    fn test_add_validator() {
        let mut consensus = PoCConsensus::new(0.66, 0.51).unwrap();
        assert!(consensus.add_validator("validator1".to_string(), 0.8).is_ok());
        assert!(consensus.add_validator("validator2".to_string(), 1.2).is_err());
    }

    #[test]
    fn test_validate_block() {
        let consensus = PoCConsensus::new(0.66, 0.51).unwrap();
        let valid_block = Block {
            index: 1,
            timestamp: 12345,
            transactions: vec![icn_common::Transaction {
                from: "Alice".to_string(),
                to: "Bob".to_string(),
                amount: 50.0,
                currency_type: icn_common::CurrencyType::BasicNeeds,
                timestamp: 12345,
                signature: None,
            }],
            previous_hash: "previous_hash".to_string(),
            hash: "current_hash".to_string(),
        };
        assert!(consensus.validate_block(&valid_block).unwrap());

        let invalid_block = Block {
            index: 2,
            timestamp: 23456,
            transactions: vec![],
            previous_hash: "previous_hash".to_string(),
            hash: "current_hash".to_string(),
        };
        assert!(consensus.validate_block(&invalid_block).is_err());
    }

    #[test]
    fn test_reputation_update() {
        let mut consensus = PoCConsensus::new(0.66, 0.51).unwrap();
        consensus.add_validator("validator1".to_string(), 0.5).unwrap();
        
        assert!(consensus.update_reputation("validator1", 0.2).is_ok());
        assert_eq!(consensus.validators["validator1"], 0.7);

        // Test upper bound
        assert!(consensus.update_reputation("validator1", 0.5).is_ok());
        assert_eq!(consensus.validators["validator1"], 1.0);

        // Test lower bound
        assert!(consensus.update_reputation("validator1", -1.5).is_ok());
        assert_eq!(consensus.validators["validator1"], 0.0);

        // Test updating non-existent validator
        assert!(consensus.update_reputation("validator2", 0.1).is_err());
    }

    #[test]
    fn test_quorum_and_consensus() {
        let mut consensus = PoCConsensus::new(0.66, 0.51).unwrap();
        consensus.add_validator("validator1".to_string(), 0.3).unwrap();
        consensus.add_validator("validator2".to_string(), 0.3).unwrap();
        consensus.add_validator("validator3".to_string(), 0.3).unwrap();

        // Test quorum
        assert!(!consensus.is_quorum_reached(0.4));
        assert!(consensus.is_quorum_reached(0.5));

        // Test consensus
        assert!(!consensus.is_consensus_reached(0.3, 0.6));
        assert!(consensus.is_consensus_reached(0.4, 0.6));
    }

    #[test]
    fn test_total_reputation() {
        let mut consensus = PoCConsensus::new(0.66, 0.51).unwrap();
        consensus.add_validator("validator1".to_string(), 0.3).unwrap();
        consensus.add_validator("validator2".to_string(), 0.4).unwrap();
        consensus.add_validator("validator3".to_string(), 0.2).unwrap();

        assert_eq!(consensus.get_total_reputation(), 0.9);

        consensus.update_reputation("validator2", 0.1).unwrap();
        assert_eq!(consensus.get_total_reputation(), 1.0);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_consensus/src/consensus.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_consensus/src/lib.rs =====
// File: icn_consensus/src/lib.rs

use icn_blockchain::Block;
use icn_common::{IcnResult, IcnError, Transaction, CurrencyType};
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use log::{info, warn, error};
use chrono::Utc;

pub struct PoCConsensus {
    threshold: f64,
    quorum: f64,
    validators: HashMap<String, f64>,
    pending_blocks: Vec<Block>,
    blockchain: Arc<RwLock<Vec<Block>>>,
}

impl PoCConsensus {
    pub fn new(threshold: f64, quorum: f64) -> IcnResult<Self> {
        if !(0.0..=1.0).contains(&threshold) || !(0.0..=1.0).contains(&quorum) {
            return Err(IcnError::Consensus("Invalid threshold or quorum value".into()));
        }

        Ok(PoCConsensus {
            threshold,
            quorum,
            validators: HashMap::new(),
            pending_blocks: Vec::new(),
            blockchain: Arc::new(RwLock::new(vec![Block::new(0, Vec::new(), String::from("0"), 4)])),
        })
    }

    pub fn start(&self) -> IcnResult<()> {
        info!("PoC Consensus mechanism started");
        Ok(())
    }

    pub fn stop(&self) -> IcnResult<()> {
        info!("PoC Consensus mechanism stopped");
        Ok(())
    }

    pub fn add_validator(&mut self, id: String, reputation: f64) -> IcnResult<()> {
        if !(0.0..=1.0).contains(&reputation) {
            return Err(IcnError::Consensus("Invalid initial reputation".into()));
        }
        self.validators.insert(id, reputation);
        Ok(())
    }

    pub fn process_new_block(&mut self, block: Block) -> IcnResult<()> {
        self.pending_blocks.push(block);
        self.try_reach_consensus()
    }

    fn try_reach_consensus(&mut self) -> IcnResult<()> {
        let total_reputation: f64 = self.validators.values().sum();
        let quorum_reputation = total_reputation * self.quorum;

        let mut blocks_to_add = Vec::new();

        for block in &self.pending_blocks {
            let mut votes_for = 0.0;
            let mut total_votes = 0.0;

            for (_, reputation) in &self.validators {
                if self.validate_block(block)? {
                    votes_for += reputation;
                }
                total_votes += reputation;

                if total_votes >= quorum_reputation {
                    if votes_for / total_votes >= self.threshold {
                        blocks_to_add.push(block.clone());
                    } else {
                        warn!("Block rejected by consensus: {:?}", block);
                        return Err(IcnError::Consensus("Block rejected by consensus".into()));
                    }
                }
            }
        }

        for block in blocks_to_add {
            self.add_block_to_chain(block)?;
        }

        self.pending_blocks.retain(|b| !blocks_to_add.contains(b));

        Ok(())
    }

    fn validate_block(&self, block: &Block) -> IcnResult<bool> {
        // Check if the block's previous hash matches the last block in the chain
        let blockchain = self.blockchain.read().map_err(|_| IcnError::Consensus("Failed to read blockchain".into()))?;
        let last_block = blockchain.last().ok_or_else(|| IcnError::Consensus("Blockchain is empty".into()))?;
        
        if block.previous_hash != last_block.hash {
            return Ok(false);
        }

        // Verify block hash
        if block.hash != block.calculate_hash() {
            return Ok(false);
        }

        // Validate transactions
        for transaction in &block.transactions {
            if !self.validate_transaction(transaction)? {
                return Ok(false);
            }
        }

        Ok(true)
    }

    fn validate_transaction(&self, transaction: &Transaction) -> IcnResult<bool> {
        // Check if the transaction amount is positive
        if transaction.amount <= 0.0 {
            return Ok(false);
        }

        // Check if the sender has sufficient balance
        let blockchain = self.blockchain.read().map_err(|_| IcnError::Consensus("Failed to read blockchain".into()))?;
        let sender_balance = self.get_balance(&blockchain, &transaction.from, &transaction.currency_type);
        
        if sender_balance < transaction.amount {
            return Ok(false);
        }

        // Add more transaction validation rules as needed

        Ok(true)
    }

    fn add_block_to_chain(&mut self, block: Block) -> IcnResult<()> {
        let mut blockchain = self.blockchain.write().map_err(|_| IcnError::Consensus("Failed to write to blockchain".into()))?;
        blockchain.push(block);
        Ok(())
    }

    pub fn get_blockchain(&self) -> IcnResult<Vec<Block>> {
        let blockchain = self.blockchain.read().map_err(|_| IcnError::Consensus("Failed to read blockchain".into()))?;
        Ok(blockchain.clone())
    }

    fn get_balance(&self, blockchain: &[Block], address: &str, currency_type: &CurrencyType) -> f64 {
        let mut balance = 0.0;
        for block in blockchain {
            for transaction in &block.transactions {
                if transaction.currency_type == *currency_type {
                    if transaction.from == address {
                        balance -= transaction.amount;
                    }
                    if transaction.to == address {
                        balance += transaction.amount;
                    }
                }
            }
        }
        balance
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn create_test_block(index: u64, previous_hash: &str) -> Block {
        Block::new(
            index,
            vec![Transaction {
                from: "Alice".to_string(),
                to: "Bob".to_string(),
                amount: 100.0,
                currency_type: CurrencyType::BasicNeeds,
                timestamp: Utc::now().timestamp(),
                signature: None,
            }],
            previous_hash.to_string(),
            1,
        )
    }

    #[test]
    fn test_poc_consensus_creation() {
        let consensus = PoCConsensus::new(0.66, 0.51);
        assert!(consensus.is_ok());
    }

    #[test]
    fn test_add_validator() {
        let mut consensus = PoCConsensus::new(0.66, 0.51).unwrap();
        assert!(consensus.add_validator("validator1".to_string(), 0.8).is_ok());
        assert!(consensus.add_validator("validator2".to_string(), 0.7).is_ok());
        assert_eq!(consensus.validators.len(), 2);
    }

    #[test]
    fn test_process_new_block() {
        let mut consensus = PoCConsensus::new(0.66, 0.51).unwrap();
        consensus.add_validator("validator1".to_string(), 0.8).unwrap();
        consensus.add_validator("validator2".to_string(), 0.7).unwrap();

        let new_block = create_test_block(1, "test_hash_0");
        assert!(consensus.process_new_block(new_block).is_ok());

        let blockchain = consensus.get_blockchain().unwrap();
        assert_eq!(blockchain.len(), 2);  // Genesis block + 1 new block
    }

    #[test]
    fn test_consensus_threshold() {
        let mut consensus = PoCConsensus::new(0.66, 0.51).unwrap();
        consensus.add_validator("validator1".to_string(), 0.8).unwrap();
        consensus.add_validator("validator2".to_string(), 0.7).unwrap();
        consensus.add_validator("validator3".to_string(), 0.6).unwrap();

        let new_block = create_test_block(1, "test_hash_0");
        assert!(consensus.process_new_block(new_block).is_ok());

        // The total reputation is 2.1, and the quorum is 0.51 * 2.1 = 1.071
        // The threshold is 0.66 * 1.071 = 0.70686
        // So if validators with total reputation > 0.70686 approve, the block should be added

        let blockchain = consensus.get_blockchain().unwrap();
        assert_eq!(blockchain.len(), 2);
    }

    #[test]
    fn test_invalid_block() {
        let mut consensus = PoCConsensus::new(0.66, 0.51).unwrap();
        consensus.add_validator("validator1".to_string(), 0.8).unwrap();
        consensus.add_validator("validator2".to_string(), 0.7).unwrap();

        // Create an invalid block with incorrect previous_hash
        let mut invalid_block = create_test_block(1, "invalid_previous_hash");
        invalid_block.hash = invalid_block.calculate_hash();

        assert!(consensus.process_new_block(invalid_block).is_err());

        let blockchain = consensus.get_blockchain().unwrap();
        assert_eq!(blockchain.len(), 1);  // Only genesis block should remain
    }

    #[test]
    fn test_insufficient_balance_transaction() {
        let mut consensus = PoCConsensus::new(0.66, 0.51).unwrap();
        consensus.add_validator("validator1".to_string(), 0.8).unwrap();
        consensus.add_validator("validator2".to_string(), 0.7).unwrap();

        // Create a block with a transaction that has insufficient balance
        let invalid_transaction = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 1000.0,  // Assume Alice doesn't have this much balance
            currency_type: CurrencyType::BasicNeeds,
            timestamp: Utc::now().timestamp(),
            signature: None,
        };

        let mut invalid_block = Block::new(1, vec![invalid_transaction], "test_hash_0".to_string(), 1);
        invalid_block.hash = invalid_block.calculate_hash();

        assert!(consensus.process_new_block(invalid_block).is_err());

        let blockchain = consensus.get_blockchain().unwrap();
        assert_eq!(blockchain.len(), 1);  // Only genesis block should remain
    }

    #[test]
    fn test_multiple_blocks() {
        let mut consensus = PoCConsensus::new(0.66, 0.51).unwrap();
        consensus.add_validator("validator1".to_string(), 0.8).unwrap();
        consensus.add_validator("validator2".to_string(), 0.7).unwrap();

        let block1 = create_test_block(1, "test_hash_0");
        let block2 = create_test_block(2, &block1.hash);
        let block3 = create_test_block(3, &block2.hash);

        assert!(consensus.process_new_block(block1).is_ok());
        assert!(consensus.process_new_block(block2).is_ok());
        assert!(consensus.process_new_block(block3).is_ok());

        let blockchain = consensus.get_blockchain().unwrap();
        assert_eq!(blockchain.len(), 4);  // Genesis block + 3 new blocks
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_consensus/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_consensus/src/proof_of_cooperation.rs =====
use icn_utils::{error::IcnError, IcnResult};
use sha2::{Sha256, Digest};
use serde::{Serialize, Deserialize};
use chrono::Utc;

#[derive(Debug, Serialize, Deserialize)]
pub struct ProofOfCooperation {
    pub blocks: Vec<Block>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Block {
    pub index: u64,
    pub previous_hash: String,
    pub timestamp: u64,
    pub data: String,
    pub hash: String,
}

impl Block {
    pub fn new(index: u64, previous_hash: String, timestamp: u64, data: String) -> Self {
        let mut block = Block {
            index,
            previous_hash,
            timestamp,
            data,
            hash: String::new(),
        };
        block.hash = block.calculate_hash();
        block
    }

    pub fn calculate_hash(&self) -> String {
        let input = format!("{}{}{}{}", self.index, self.previous_hash, self.timestamp, self.data);
        let mut hasher = Sha256::new();
        hasher.update(input.as_bytes());
        format!("{:x}", hasher.finalize())
    }
}

impl ProofOfCooperation {
    pub fn new() -> Self {
        ProofOfCooperation {
            blocks: Vec::new(),
        }
    }

    pub fn add_block(&mut self, data: String) -> IcnResult<()> {
        let previous_hash = if let Some(last_block) = self.blocks.last() {
            last_block.hash.clone()
        } else {
            String::new()
        };

        let new_block = Block::new(
            self.blocks.len() as u64,
            previous_hash,
            Utc::now().timestamp_millis() as u64,
            data,
        );

        self.blocks.push(new_block);
        Ok(())
    }

    pub fn validate_chain(&self) -> IcnResult<()> {
        for i in 1..self.blocks.len() {
            let previous_block = &self.blocks[i - 1];
            let current_block = &self.blocks[i];

            if current_block.previous_hash != previous_block.hash {
                return Err(IcnError::Blockchain("Invalid previous hash".to_string()));
            }

            if current_block.hash != current_block.calculate_hash() {
                return Err(IcnError::Blockchain("Invalid block hash".to_string()));
            }
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add_and_validate_blocks() {
        let mut poc = ProofOfCooperation::new();
        
        poc.add_block("Block 1 Data".to_string()).unwrap();
        poc.add_block("Block 2 Data".to_string()).unwrap();

        assert_eq!(poc.blocks.len(), 2);
        assert!(poc.validate_chain().is_ok());

        // Tamper with a block
        poc.blocks[1].data = "Tampered Data".to_string();
        assert!(poc.validate_chain().is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_consensus/src/proof_of_cooperation.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/Cargo.toml =====
[package]
name = "icn_core"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
icn_blockchain = { path = "../icn_blockchain" }
icn_consensus = { path = "../icn_consensus" }
icn_currency = { path = "../icn_currency" }
icn_governance = { path = "../icn_governance" }
icn_identity = { path = "../icn_identity" }
icn_network = { path = "../icn_network" }
icn_sharding = { path = "../icn_sharding" }
icn_vm = { path = "../icn_vm" }
icn_language = { path = "../icn_language" }
tokio = { workspace = true }
log = { workspace = true }
thiserror = { workspace = true }
chrono = { workspace = true }
ed25519-dalek = "1.0" # Add this line

[dev-dependencies]
tokio-test = "0.4"
===== END OF /home/matt/InterCooperative-Network/crates/icn_core/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/src/config.rs =====
// icn_core/src/config.rs

use serde::{Deserialize, Serialize};
use serde_json;
use std::fs;
use icn_types::{IcnResult, IcnError};

#[derive(Debug, Serialize, Deserialize)]
pub struct Config {
    pub shard_count: u64,
    pub consensus_threshold: f64,
    pub consensus_quorum: f64,
    pub network_port: u16,
}

impl Config {
    pub fn load(path: &str) -> IcnResult<Self> {
        let config_str = fs::read_to_string(path).map_err(|e| IcnError::ConfigError(e.to_string()))?;
        let config: Config = serde_json::from_str(&config_str).map_err(|e| IcnError::ConfigError(e.to_string()))?;
        Ok(config)
    }

    pub fn save(&self, path: &str) -> IcnResult<()> {
        let config_str = serde_json::to_string_pretty(self).map_err(|e| IcnError::ConfigError(e.to_string()))?;
        fs::write(path, config_str).map_err(|e| IcnError::ConfigError(e.to_string()))?;
        Ok(())
    }
}

impl Default for Config {
    fn default() -> Self {
        Config {
            shard_count: 4,
            consensus_threshold: 0.66,
            consensus_quorum: 0.51,
            network_port: 8080,
        }
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_core/src/config.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/src/error.rs =====
use thiserror::Error;

#[derive(Error, Debug)]
pub enum Error {
    #[error("Blockchain error: {0}")]
    BlockchainError(String),
    
    #[error("Consensus error: {0}")]
    ConsensusError(String),
    
    #[error("Sharding error: {0}")]
    ShardingError(String),
    
    #[error("VM error: {0}")]
    VmError(String),
    
    #[error("Network error: {0}")]
    NetworkError(String),
    
    #[error("Smart contract error: {0}")]
    SmartContractError(String),
    
    #[error("I/O error: {0}")]
    IoError(#[from] std::io::Error),

    #[error("Lock error: {0}")]
    LockError(String),

    #[error("Communication error: {0}")]
    CommunicationError(String),

    #[error("Transaction failed: {0}")]
    TransactionFailed(String),

    #[error("Timeout: {0}")]
    Timeout(String),

    #[error("Currency error: {0}")]
    CurrencyError(String),

    #[error("Identity error: {0}")]
    IdentityError(String),

    #[error("Governance error: {0}")]
    GovernanceError(String),
}

pub type Result<T> = std::result::Result<T, Error>;===== END OF /home/matt/InterCooperative-Network/crates/icn_core/src/error.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/src/lib.rs =====
// File: icn_core/src/lib.rs

use icn_common::{Config, Transaction, Proposal, ProposalStatus, Vote, CurrencyType, IcnResult, IcnError, NetworkStats};
use icn_blockchain::Blockchain;
use icn_consensus::PoCConsensus;
use icn_currency::CurrencySystem;
use icn_governance::GovernanceSystem;
use icn_identity::IdentityService;
use icn_network::NetworkManager;
use icn_sharding::ShardingManager;
use icn_vm::SmartContractExecutor;
use icn_zkp::ZKPManager;
use std::sync::Arc;
use tokio::sync::RwLock;
use std::collections::HashMap;
use chrono::{DateTime, Utc};

pub struct IcnNode {
    config: Config,
    blockchain: Arc<RwLock<Blockchain>>,
    consensus: Arc<RwLock<PoCConsensus>>,
    currency_system: Arc<RwLock<CurrencySystem>>,
    governance: Arc<RwLock<GovernanceSystem>>,
    identity_service: Arc<RwLock<IdentityService>>,
    network_manager: Arc<RwLock<NetworkManager>>,
    sharding_manager: Arc<RwLock<ShardingManager>>,
    smart_contract_executor: Arc<RwLock<SmartContractExecutor>>,
    zkp_manager: Arc<RwLock<ZKPManager>>,
    proposals: Arc<RwLock<HashMap<String, Proposal>>>, // Added for proposal management
}

impl IcnNode {
    pub async fn new(config: Config) -> IcnResult<Self> {
        let blockchain = Arc::new(RwLock::new(Blockchain::new(config.difficulty)));
        let consensus = Arc::new(RwLock::new(PoCConsensus::new(config.consensus_threshold, config.consensus_quorum)?));
        let currency_system = Arc::new(RwLock::new(CurrencySystem::new()));
        let governance = Arc::new(RwLock::new(GovernanceSystem::new()));
        let identity_service = Arc::new(RwLock::new(IdentityService::new()));
        let network_manager = Arc::new(RwLock::new(NetworkManager::new(config.network_port)));
        let sharding_manager = Arc::new(RwLock::new(ShardingManager::new(config.shard_count)));
        let smart_contract_executor = Arc::new(RwLock::new(SmartContractExecutor::new()));
        let zkp_manager = Arc::new(RwLock::new(ZKPManager::new(64))); // Assuming 64-bit range proofs
        let proposals = Arc::new(RwLock::new(HashMap::new())); // Initialize proposals

        Ok(Self {
            config,
            blockchain,
            consensus,
            currency_system,
            governance,
            identity_service,
            network_manager,
            sharding_manager,
            smart_contract_executor,
            zkp_manager,
            proposals, // Include proposals map
        })
    }

    pub async fn start(&self) -> IcnResult<()> {
        self.consensus.write().await.start()?;
        self.network_manager.write().await.start()?;
        Ok(())
    }

    pub async fn stop(&self) -> IcnResult<()> {
        self.consensus.write().await.stop()?;
        self.network_manager.write().await.stop()?;
        Ok(())
    }

    pub async fn process_transaction(&self, transaction: Transaction) -> IcnResult<()> {
        // Verify the transaction
        self.verify_transaction(&transaction).await?;

        // Get the shard for the transaction
        let shard_id = self.sharding_manager.read().await.get_shard_for_address(&transaction.from);

        // Process the transaction in the blockchain
        self.blockchain.write().await.add_transaction(transaction.clone())?;
        
        // Update the currency system
        self.currency_system.write().await.process_transaction(&transaction)?;

        // Process the transaction in the shard
        self.sharding_manager.write().await.process_transaction(shard_id, &transaction)?;

        Ok(())
    }

    pub async fn create_proposal(&self, proposal: Proposal) -> IcnResult<String> {
        // Verify the proposal
        self.verify_proposal(&proposal).await?;

        // Create the proposal in the governance system
        let proposal_id = self.governance.write().await.create_proposal(proposal)?;

        // Broadcast the new proposal to the network
        self.network_manager.read().await.broadcast_proposal(&proposal_id)?;

        Ok(proposal_id)
    }

    pub async fn get_balance(&self, address: &str, currency_type: &CurrencyType) -> IcnResult<f64> {
        self.currency_system.read().await.get_balance(address, currency_type)
    }

    pub async fn create_identity(&self, attributes: HashMap<String, String>) -> IcnResult<String> {
        self.identity_service.write().await.create_identity(attributes)
    }

    pub async fn allocate_resource(&self, resource_type: &str, amount: u64) -> IcnResult<()> {
        self.sharding_manager.write().await.allocate_resource(resource_type, amount)
    }

    pub async fn get_network_stats(&self) -> IcnResult<NetworkStats> {
        self.network_manager.read().await.get_stats()
    }

    pub async fn get_proposal(&self, proposal_id: &str) -> IcnResult<Option<Proposal>> {
        self.governance.read().await.get_proposal(proposal_id)
    }

    pub async fn list_active_proposals(&self) -> IcnResult<Vec<Proposal>> {
        self.governance.read().await.list_active_proposals()
    }

    pub async fn vote_on_proposal(&self, proposal_id: &str, voter: String, in_favor: bool, weight: f64) -> IcnResult<()> {
        self.governance.write().await.vote_on_proposal(proposal_id, voter, in_favor, weight)
    }

    pub async fn finalize_proposal(&self, proposal_id: &str) -> IcnResult<ProposalStatus> {
        self.governance.write().await.finalize_proposal(proposal_id)
    }

    pub async fn mint_currency(&self, address: &str, currency_type: &CurrencyType, amount: f64) -> IcnResult<()> {
        self.currency_system.write().await.mint(address, currency_type, amount)
    }

    pub async fn get_identity(&self, id: &str) -> IcnResult<HashMap<String, String>> {
        self.identity_service.read().await.get_identity(id)
    }

    pub async fn update_identity(&self, id: &str, attributes: HashMap<String, String>) -> IcnResult<()> {
        self.identity_service.write().await.update_identity(id, attributes)
    }

    pub async fn execute_smart_contract(&self, contract_id: &str, function: &str, args: Vec<icn_vm::Value>) -> IcnResult<Option<icn_vm::Value>> {
        self.smart_contract_executor.write().await.execute_contract(contract_id, function, args)
    }

    pub async fn get_blockchain(&self) -> IcnResult<Vec<icn_blockchain::Block>> {
        Ok(self.blockchain.read().await.chain.clone())
    }

    pub async fn get_shard_count(&self) -> u64 {
        self.config.shard_count
    }

    pub async fn get_consensus_threshold(&self) -> f64 {
        self.config.consensus_threshold
    }

    pub async fn get_consensus_quorum(&self) -> f64 {
        self.config.consensus_quorum
    }

    pub async fn get_network_port(&self) -> u16 {
        self.config.network_port
    }

    // New function to get proposal status
    pub async fn get_proposal_status(&self, proposal_id: &str) -> IcnResult<ProposalStatus> {
        let proposal = self.governance.read().await.get_proposal(proposal_id)?
            .ok_or_else(|| IcnError::Governance("Proposal not found".into()))?;
        Ok(proposal.status)
    }

    // Helper methods

    async fn verify_transaction(&self, transaction: &Transaction) -> IcnResult<()> {
        // Verify the transaction signature
        if !transaction.verify()? {
            return Err(IcnError::Blockchain("Invalid transaction signature".into()));
        }

        // Check if the sender has sufficient balance
        let sender_balance = self.get_balance(&transaction.from, &transaction.currency_type).await?;
        if sender_balance < transaction.amount {
            return Err(IcnError::Currency("Insufficient balance".into()));
        }

        Ok(())
    }

    async fn verify_proposal(&self, proposal: &Proposal) -> IcnResult<()> {
        // Check if the proposer exists
        if self.get_identity(&proposal.proposer).await.is_err() {
            return Err(IcnError::Governance("Proposer does not exist".into()));
        }

        // Additional checks can be added here, such as:
        // - Checking if the proposal type is valid
        // - Verifying the proposal's required quorum is within acceptable limits
        // - Ensuring the voting period is reasonable

        Ok(())
    }

    pub async fn get_total_balance(&self, address: &str, currency_type: &CurrencyType) -> IcnResult<f64> {
        let mut total_balance = 0.0;
        for shard_id in 0..self.config.shard_count {
            total_balance += self.sharding_manager.read().await.get_shard_balance(shard_id, address, currency_type)?;
        }
        Ok(total_balance)
    }

    pub async fn list_active_proposals_with_status(&self) -> IcnResult<Vec<(Proposal, f64)>> {
        let proposals = self.governance.read().await.list_active_proposals()?;
        let mut proposals_with_status = Vec::new();
        
        for proposal in proposals {
            let votes = self.governance.read().await.get_votes(&proposal.id)?;
            let total_votes: f64 = votes.iter().map(|v| v.weight).sum();
            let votes_in_favor: f64 = votes.iter().filter(|v| v.in_favor).map(|v| v.weight).sum();
            let status = if total_votes > 0.0 { votes_in_favor / total_votes } else { 0.0 };
            proposals_with_status.push((proposal, status));
        }
        
        Ok(proposals_with_status)
    }

    pub async fn check_sufficient_balance(&self, address: &str, amount: f64, currency_type: &CurrencyType) -> IcnResult<bool> {
        let balance = self.get_total_balance(address, currency_type).await?;
        Ok(balance >= amount)
    }

    pub async fn get_node_reputation(&self, node_id: &str) -> IcnResult<f64> {
        self.consensus.read().await.get_node_reputation(node_id)
    }

    pub async fn update_node_reputation(&self, node_id: &str, change: f64) -> IcnResult<()> {
        self.consensus.write().await.update_node_reputation(node_id, change)
    }

    pub async fn get_shard_for_address(&self, address: &str) -> u64 {
        self.sharding_manager.read().await.get_shard_for_address(address)
    }

    pub async fn create_smart_contract(&self, code: String) -> IcnResult<String> {
        self.smart_contract_executor.write().await.create_contract(code)
    }

    pub async fn get_smart_contract(&self, contract_id: &str) -> IcnResult<Option<String>> {
        self.smart_contract_executor.read().await.get_contract(contract_id)
    }

    pub async fn update_smart_contract(&self, contract_id: &str, new_code: String) -> IcnResult<()> {
        self.smart_contract_executor.write().await.update_contract(contract_id, new_code)
    }

    pub async fn delete_smart_contract(&self, contract_id: &str) -> IcnResult<()> {
        self.smart_contract_executor.write().await.delete_contract(contract_id)
    }

    pub async fn create_zkp(&self, transaction: &Transaction) -> IcnResult<(Vec<u8>, Vec<u8>)> {
        let zkp_manager = self.zkp_manager.read().await;
        let (proof, committed_values) = zkp_manager.create_proof(transaction)?;
        Ok((proof.to_bytes(), serde_json::to_vec(&committed_values)?))
    }

    pub async fn verify_zkp(&self, proof: &[u8], committed_values: &[u8]) -> IcnResult<bool> {
        let zkp_manager = self.zkp_manager.read().await;
        let proof = bulletproofs::RangeProof::from_bytes(proof)?;
        let committed_values: Vec<curve25519_dalek::scalar::Scalar> = serde_json::from_slice(committed_values)?;
        zkp_manager.verify_proof(&proof, &committed_values)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Duration;

    async fn create_test_node() -> IcnNode {
        let config = Config {
            shard_count: 1,
            consensus_threshold: 0.66,
            consensus_quorum: 0.51,
            network_port: 8080,
            difficulty: 2,
        };
        IcnNode::new(config).await.unwrap()
    }

    #[tokio::test]
    async fn test_node_creation_and_lifecycle() {
        let node = create_test_node().await;
        assert_eq!(node.get_shard_count().await, 1);
        assert_eq!(node.get_consensus_threshold().await, 0.66);
        assert_eq!(node.get_consensus_quorum().await, 0.51);
        assert_eq!(node.get_network_port().await, 8080);

        assert!(node.start().await.is_ok());
        assert!(node.stop().await.is_ok());
    }

    #[tokio::test]
    async fn test_transaction_processing() {
        let node = create_test_node().await;
        
        // Mint some currency for testing
        assert!(node.mint_currency("Alice", &CurrencyType::BasicNeeds, 1000.0).await.is_ok());

        let transaction = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 100.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: Utc::now().timestamp(),
            signature: None,
        };

        assert!(node.process_transaction(transaction).await.is_ok());

        // Check balances
        let alice_balance = node.get_balance("Alice", &CurrencyType::BasicNeeds).await.unwrap();
        let bob_balance = node.get_balance("Bob", &CurrencyType::BasicNeeds).await.unwrap();
        assert_eq!(alice_balance, 900.0);
        assert_eq!(bob_balance, 100.0);
    }

    #[tokio::test]
    async fn test_proposal_lifecycle() {
        let node = create_test_node().await;

        let proposal = Proposal {
            id: "test_proposal".to_string(),
            title: "Test Proposal".to_string(),
            description: "This is a test proposal".to_string(),
            proposer: "Alice".to_string(),
            created_at: Utc::now(),
            voting_ends_at: Utc::now() + Duration::days(7),
            status: ProposalStatus::Active,
            proposal_type: ProposalType::Constitutional,
            category: ProposalCategory::Economic,
            required_quorum: 0.51,
            execution_timestamp: None,
        };

        // Create proposal
        let proposal_id = node.create_proposal(proposal).await.unwrap();

        // Check if proposal exists
        let retrieved_proposal = node.get_proposal(&proposal_id).await.unwrap();
        assert!(retrieved_proposal.is_some());

        // List active proposals
        let active_proposals = node.list_active_proposals().await.unwrap();
        assert_eq!(active_proposals.len(), 1);

        // Vote on proposal
        assert!(node.vote_on_proposal(&proposal_id, "Alice".to_string(), true, 1.0).await.is_ok());
        assert!(node.vote_on_proposal(&proposal_id, "Bob".to_string(), false, 1.0).await.is_ok());

        // Get proposal status
        let status = node.get_proposal_status(&proposal_id).await.unwrap();
        assert_eq!(status, ProposalStatus::Active);

        // Finalize proposal
        let final_status = node.finalize_proposal(&proposal_id).await.unwrap();
        assert_eq!(final_status, ProposalStatus::Passed);
    }

    #[tokio::test]
    async fn test_identity_management() {
        let node = create_test_node().await;

        let mut attributes = HashMap::new();
        attributes.insert("name".to_string(), "Alice".to_string());
        attributes.insert("age".to_string(), "30".to_string());

        // Create identity
        let identity_id = node.create_identity(attributes.clone()).await.unwrap();

        // Get identity
        let retrieved_attributes = node.get_identity(&identity_id).await.unwrap();
        assert_eq!(retrieved_attributes, attributes);

        // Update identity
        attributes.insert("location".to_string(), "New York".to_string());
        assert!(node.update_identity(&identity_id, attributes.clone()).await.is_ok());

        // Verify updated identity
        let updated_attributes = node.get_identity(&identity_id).await.unwrap();
        assert_eq!(updated_attributes, attributes);
    }

    #[tokio::test]
    async fn test_resource_allocation() {
        let node = create_test_node().await;
        assert!(node.allocate_resource("computing_power", 100).await.is_ok());
        // In a real implementation, we would check if the resource was actually allocated
        // For now, we just check if the method call succeeds
    }

    #[tokio::test]
    async fn test_smart_contract_execution() {
        let node = create_test_node().await;

        // Create a simple smart contract
        let contract_code = r#"
            fn add(a: i64, b: i64) -> i64 {
                a + b
            }
        "#.to_string();
        let contract_id = node.create_smart_contract(contract_code).await.unwrap();

        // Execute the smart contract
        let result = node.execute_smart_contract(&contract_id, "add", vec![icn_vm::Value::Int(5), icn_vm::Value::Int(3)]).await.unwrap();
        assert_eq!(result, Some(icn_vm::Value::Int(8)));
    }

    #[tokio::test]
    async fn test_blockchain_operations() {
        let node = create_test_node().await;

        // Add some transactions to create blocks
        for i in 0..5 {
            let transaction = Transaction {
                from: format!("User{}", i),
                to: format!("User{}", i+1),
                amount: 10.0,
                currency_type: CurrencyType::BasicNeeds,
                timestamp: Utc::now().timestamp(),
                signature: None,
            };
            node.process_transaction(transaction).await.unwrap();
        }

        let blockchain = node.get_blockchain().await.unwrap();
        assert!(blockchain.len() > 1); // At least genesis block and one more
    }

    #[tokio::test]
    async fn test_network_stats() {
        let node = create_test_node().await;
        let stats = node.get_network_stats().await.unwrap();
        assert!(stats.node_count >= 0);
        assert!(stats.total_transactions >= 0);
        assert!(stats.active_proposals >= 0);
    }

    #[tokio::test]
    async fn test_zkp_operations() {
        let node = create_test_node().await;

        // Create a transaction
        let transaction = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 100.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: Utc::now().timestamp(),
            signature: None,
        };

        // Create a ZKP for the transaction
        let (proof, committed_values) = node.create_zkp(&transaction).await.unwrap();

        // Verify the ZKP
        let is_valid = node.verify_zkp(&proof, &committed_values).await.unwrap();
        assert!(is_valid);

        // Test with tampered data
        let mut tampered_values = committed_values.clone();
        tampered_values[0] ^= 1; // Flip a bit
        let is_invalid = node.verify_zkp(&proof, &tampered_values).await.unwrap();
        assert!(!is_invalid);
    }

    #[tokio::test]
    async fn test_reputation_management() {
        let node = create_test_node().await;
        let node_id = "test_node";

        // Initial reputation should be 0 or a default value
        let initial_reputation = node.get_node_reputation(node_id).await.unwrap();
        assert_eq!(initial_reputation, 0.0);

        // Update reputation
        node.update_node_reputation(node_id, 0.5).await.unwrap();
        let updated_reputation = node.get_node_reputation(node_id).await.unwrap();
        assert_eq!(updated_reputation, 0.5);

        // Update reputation again
        node.update_node_reputation(node_id, -0.2).await.unwrap();
        let final_reputation = node.get_node_reputation(node_id).await.unwrap();
        assert_eq!(final_reputation, 0.3);
    }

    #[tokio::test]
    async fn test_sharding() {
        let node = create_test_node().await;
        let address = "test_address";

        let shard_id = node.get_shard_for_address(address).await;
        assert!(shard_id < node.get_shard_count().await);

        // Test balance across shards
        node.mint_currency(address, &CurrencyType::BasicNeeds, 100.0).await.unwrap();
        let total_balance = node.get_total_balance(address, &CurrencyType::BasicNeeds).await.unwrap();
        assert_eq!(total_balance, 100.0);
    }

    #[tokio::test]
    async fn test_smart_contract_lifecycle() {
        let node = create_test_node().await;

        // Create a smart contract
        let contract_code = r#"
            fn multiply(a: i64, b: i64) -> i64 {
                a * b
            }
        "#.to_string();
        let contract_id = node.create_smart_contract(contract_code.clone()).await.unwrap();

        // Get the smart contract
        let retrieved_code = node.get_smart_contract(&contract_id).await.unwrap();
        assert_eq!(retrieved_code, Some(contract_code));

        // Update the smart contract
        let new_contract_code = r#"
            fn multiply(a: i64, b: i64) -> i64 {
                a * b + 1
            }
        "#.to_string();
        node.update_smart_contract(&contract_id, new_contract_code.clone()).await.unwrap();

        // Verify the update
        let updated_code = node.get_smart_contract(&contract_id).await.unwrap();
        assert_eq!(updated_code, Some(new_contract_code));

        // Execute the updated contract
        let result = node.execute_smart_contract(&contract_id, "multiply", vec![icn_vm::Value::Int(5), icn_vm::Value::Int(3)]).await.unwrap();
        assert_eq!(result, Some(icn_vm::Value::Int(16))); // 5 * 3 + 1 = 16

        // Delete the smart contract
        node.delete_smart_contract(&contract_id).await.unwrap();

        // Verify deletion
        let deleted_code = node.get_smart_contract(&contract_id).await.unwrap();
        assert_eq!(deleted_code, None);
    }

    #[tokio::test]
    async fn test_proposal_voting_and_finalization() {
        let node = create_test_node().await;

        // Create a proposal
        let proposal = Proposal {
            id: "test_proposal".to_string(),
            title: "Test Proposal".to_string(),
            description: "This is a test proposal".to_string(),
            proposer: "Alice".to_string(),
            created_at: Utc::now(),
            voting_ends_at: Utc::now() + Duration::days(7),
            status: ProposalStatus::Active,
            proposal_type: ProposalType::Constitutional,
            category: ProposalCategory::Economic,
            required_quorum: 0.51,
            execution_timestamp: None,
        };

        let proposal_id = node.create_proposal(proposal).await.unwrap();

        // Vote on the proposal
        node.vote_on_proposal(&proposal_id, "Alice".to_string(), true, 0.3).await.unwrap();
        node.vote_on_proposal(&proposal_id, "Bob".to_string(), true, 0.3).await.unwrap();
        node.vote_on_proposal(&proposal_id, "Charlie".to_string(), false, 0.2).await.unwrap();

        // Check proposal status
        let proposals_with_status = node.list_active_proposals_with_status().await.unwrap();
        assert_eq!(proposals_with_status.len(), 1);
        let (retrieved_proposal, voting_status) = &proposals_with_status[0];
        assert_eq!(retrieved_proposal.id, proposal_id);
        assert!(*voting_status > 0.5); // 0.6 in favor out of 0.8 total votes

        // Finalize the proposal
        let final_status = node.finalize_proposal(&proposal_id).await.unwrap();
        assert_eq!(final_status, ProposalStatus::Passed);

        // Verify the proposal is no longer active
        let active_proposals = node.list_active_proposals().await.unwrap();
        assert_eq!(active_proposals.len(), 0);
    }

    #[tokio::test]
    async fn test_cross_shard_balance() {
        let mut config = Config {
            shard_count: 2,
            consensus_threshold: 0.66,
            consensus_quorum: 0.51,
            network_port: 8080,
            difficulty: 2,
        };
        let node = IcnNode::new(config).await.unwrap();

        let address = "cross_shard_user";

        // Mint currency in both shards
        node.mint_currency(address, &CurrencyType::BasicNeeds, 50.0).await.unwrap();
        node.mint_currency(address, &CurrencyType::BasicNeeds, 50.0).await.unwrap();

        // Check total balance across shards
        let total_balance = node.get_total_balance(address, &CurrencyType::BasicNeeds).await.unwrap();
        assert_eq!(total_balance, 100.0);

        // Perform a cross-shard transaction
        let transaction = Transaction {
            from: address.to_string(),
            to: "another_user".to_string(),
            amount: 75.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: Utc::now().timestamp(),
            signature: None,
        };

        assert!(node.process_transaction(transaction).await.is_ok());

        // Verify the balance after cross-shard transaction
        let new_balance = node.get_total_balance(address, &CurrencyType::BasicNeeds).await.unwrap();
        assert_eq!(new_balance, 25.0);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_core/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/src/logging/mod.rs =====
use log::{info, warn, error, debug};

pub fn log_info(message: &str) {
    info!("{}", message);
}

pub fn log_warn(message: &str) {
    warn!("{}", message);
}

pub fn log_error(message: &str) {
    error!("{}", message);
}

pub fn log_debug(message: &str) {
    debug!("{}", message);
}===== END OF /home/matt/InterCooperative-Network/crates/icn_core/src/logging/mod.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/src/main.rs =====
// icn_core/src/main.rs

use icn_core::{IcnNode, Config};
use icn_common::{IcnResult, IcnError, Transaction, Proposal, ProposalType, ProposalCategory, CurrencyType, ProposalStatus};
use std::io::{self, Write};
use chrono::{Duration, Utc};
use log::{info, warn, error};
use uuid::Uuid;

fn main() -> IcnResult<()> {
    env_logger::init();

    let config = Config::load("config.json").unwrap_or_else(|_| {
        warn!("Failed to load config.json, using default configuration");
        Config::default()
    });

    info!("Starting InterCooperative Network node...");
    let node = IcnNode::new(config)?;
    node.start()?;

    info!("Node started successfully. Type 'help' for available commands.");

    loop {
        print!("> ");
        io::stdout().flush().unwrap();

        let mut input = String::new();
        io::stdin().read_line(&mut input).unwrap();
        let input = input.trim();

        match input {
            "help" => print_help(),
            "exit" => break,
            "transaction" => process_transaction(&node)?,
            "proposal" => create_proposal(&node)?,
            "balance" => check_balance(&node)?,
            _ => println!("Unknown command. Type 'help' for available commands."),
        }
    }

    info!("Stopping node...");
    node.stop()?;
    info!("Node stopped. Goodbye!");

    Ok(())
}

fn print_help() {
    println!("Available commands:");
    println!("  help        - Show this help message");
    println!("  transaction - Create a new transaction");
    println!("  proposal    - Create a new proposal");
    println!("  balance     - Check account balance");
    println!("  exit        - Exit the application");
}

fn process_transaction(node: &IcnNode) -> IcnResult<()> {
    info!("Processing a new transaction");
    
    print!("From: ");
    io::stdout().flush().unwrap();
    let mut from = String::new();
    io::stdin().read_line(&mut from).unwrap();
    
    print!("To: ");
    io::stdout().flush().unwrap();
    let mut to = String::new();
    io::stdin().read_line(&mut to).unwrap();
    
    print!("Amount: ");
    io::stdout().flush().unwrap();
    let mut amount_str = String::new();
    io::stdin().read_line(&mut amount_str).unwrap();
    let amount: f64 = amount_str.trim().parse().map_err(|_| IcnError::InvalidInput("Invalid amount".to_string()))?;

    let transaction = Transaction {
        from: from.trim().to_string(),
        to: to.trim().to_string(),
        amount,
        currency_type: CurrencyType::BasicNeeds,
        timestamp: Utc::now().timestamp(),
        signature: None,
    };

    node.process_transaction(transaction)?;
    info!("Transaction processed successfully");
    Ok(())
}

fn create_proposal(node: &IcnNode) -> IcnResult<()> {
    info!("Creating a new proposal");
    
    print!("Title: ");
    io::stdout().flush().unwrap();
    let mut title = String::new();
    io::stdin().read_line(&mut title).unwrap();
    
    print!("Description: ");
    io::stdout().flush().unwrap();
    let mut description = String::new();
    io::stdin().read_line(&mut description).unwrap();
    
    print!("Proposer: ");
    io::stdout().flush().unwrap();
    let mut proposer = String::new();
    io::stdin().read_line(&mut proposer).unwrap();

    let proposal = Proposal {
        id: Uuid::new_v4().to_string(),
        title: title.trim().to_string(),
        description: description.trim().to_string(),
        proposer: proposer.trim().to_string(),
        created_at: Utc::now(),
        voting_ends_at: Utc::now() + Duration::days(7),
        status: ProposalStatus::Active,
        proposal_type: ProposalType::Constitutional,
        category: ProposalCategory::Economic,
        required_quorum: 0.66,
        execution_timestamp: None,
    };

    node.create_proposal(proposal)?;
    info!("Proposal created successfully");
    Ok(())
}

fn check_balance(node: &IcnNode) -> IcnResult<()> {
    info!("Checking balance");
    
    print!("Address: ");
    io::stdout().flush().unwrap();
    let mut address = String::new();
    io::stdin().read_line(&mut address).unwrap();
    
    let balance = node.get_balance(address.trim(), &CurrencyType::BasicNeeds)?;
    println!("Balance: {}", balance);
    Ok(())
}===== END OF /home/matt/InterCooperative-Network/crates/icn_core/src/main.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/src/security/mod.rs =====
use crate::error::Result;
use ed25519_dalek::{Keypair, PublicKey, Signature, Verifier};

pub struct SecurityManager {
    // Add fields as needed
}

impl SecurityManager {
    pub fn new() -> Self {
        SecurityManager {
            // Initialize fields
        }
    }

    pub fn verify_signature(&self, public_key: &PublicKey, message: &[u8], signature: &Signature) -> Result<bool> {
        Ok(public_key.verify(message, signature).is_ok())
    }

    pub fn generate_keypair() -> Keypair {
        Keypair::generate(&mut rand::thread_rng())
    }

    // Add more security-related methods as needed
}===== END OF /home/matt/InterCooperative-Network/crates/icn_core/src/security/mod.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/tests/blockchain_and_consensus_tests.rs =====
// Filename: src/tests/blockchain_and_consensus_tests.rs

use crate::blockchain::{Blockchain, Transaction};
use crate::currency::CurrencyType;
use crate::consensus::Consensus;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_blockchain_creation() {
        let blockchain = Blockchain::new();
        assert_eq!(blockchain.chain.len(), 1, "Blockchain should be initialized with one genesis block");
        assert_eq!(blockchain.chain[0].index, 0, "Genesis block should have index 0");
    }

    #[test]
    fn test_block_creation() {
        let mut blockchain = Blockchain::new();
        blockchain.consensus.add_member("Alice".to_string());
        let transactions = vec![
            Transaction::new("Alice".to_string(), "Bob".to_string(), 100.0, CurrencyType::BasicNeeds, 1000),
            Transaction::new("Bob".to_string(), "Charlie".to_string(), 50.0, CurrencyType::Education, 1000),
        ];
        let result = blockchain.create_block("Alice".to_string());
        assert!(result.is_ok(), "Block creation failed: {:?}", result.err());
        assert_eq!(blockchain.chain.len(), 2, "Blockchain should have two blocks after creation");
    }

    #[test]
    fn test_reputation_update() {
        let mut blockchain = Blockchain::new();
        blockchain.consensus.add_member("Alice".to_string());
        blockchain.consensus.update_reputation("Alice", 0.5);
        assert_eq!(blockchain.consensus.get_reputation("Alice"), Some(1.5), 
                   "Alice's reputation should be updated to 1.5");
    }

    #[test]
    fn test_voting() {
        let mut blockchain = Blockchain::new();
        blockchain.consensus.add_member("Alice".to_string());
        blockchain.consensus.add_member("Bob".to_string());
        blockchain.consensus.add_member("Charlie".to_string());
        
        let transactions = vec![
            Transaction::new("Alice".to_string(), "Bob".to_string(), 100.0, CurrencyType::BasicNeeds, 1000),
        ];
        blockchain.create_block("Alice".to_string()).expect("Block creation should succeed");
        
        assert!(blockchain.vote_on_block("Alice", 1, true).is_ok(), "Alice should be able to vote");
        assert!(blockchain.vote_on_block("Bob", 1, true).is_ok(), "Bob should be able to vote");
        assert!(blockchain.vote_on_block("Charlie", 1, true).is_ok(), "Charlie should be able to vote");
        
        assert!(blockchain.consensus.is_block_valid(1), "Block should be valid after voting");
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_core/tests/blockchain_and_consensus_tests.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/tests/blockchain_tests.rs =====
// Filename: src/tests/blockchain_tests.rs

use crate::blockchain::{Blockchain, Transaction};
use crate::currency::CurrencyType;

#[test]
fn test_blockchain_creation() {
    let blockchain = Blockchain::new();
    assert_eq!(blockchain.chain.len(), 1);
    assert_eq!(blockchain.chain[0].index, 0);
}

#[test]
fn test_add_block() {
    let mut blockchain = Blockchain::new();
    let transaction = Transaction::new(
        "Alice".to_string(),
        "Bob".to_string(),
        100.0,
        CurrencyType::BasicNeeds,
        1000,
    );
    blockchain.add_transaction(transaction);
    assert!(blockchain.create_block("Node1".to_string()).is_ok());
    assert_eq!(blockchain.chain.len(), 2);
}

#[test]
fn test_blockchain_validity() {
    let mut blockchain = Blockchain::new();
    let transaction = Transaction::new(
        "Alice".to_string(),
        "Bob".to_string(),
        100.0,
        CurrencyType::BasicNeeds,
        1000,
    );
    blockchain.add_transaction(transaction);
    assert!(blockchain.create_block("Node1".to_string()).is_ok());
    assert!(blockchain.is_chain_valid());
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_core/tests/blockchain_tests.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/tests/icn_node_tests.rs =====
// Filename: src/tests/icn_node_tests.rs

// Import necessary modules and types
use crate::icn_node::{IcnNode, Packet, PacketType};
use std::net::SocketAddr;

#[test]
fn test_fib_functionality() {
    let mut node = IcnNode::new();
    let addr1: SocketAddr = "127.0.0.1:8000".parse().unwrap();
    let addr2: SocketAddr = "127.0.0.1:8001".parse().unwrap();

    node.fib.add_entry("/example/path".to_string(), addr1);
    node.fib.add_entry("/example/path".to_string(), addr2);

    let next_hops = node.fib.get_next_hops("/example/path");
    assert!(next_hops.is_some());
    assert_eq!(next_hops.unwrap().len(), 2);
    assert!(next_hops.unwrap().contains(&addr1));
    assert!(next_hops.unwrap().contains(&addr2));

    let longest_match = node.fib.longest_prefix_match("/example/path/subpath");
    assert!(longest_match.is_some());
    assert_eq!(longest_match.unwrap().name, "/example/path");
}

#[test]
fn test_content_store() {
    let mut node = IcnNode::new();
    let packet = Packet {
        packet_type: PacketType::Data,
        name: "/test/data".to_string(),
        content: vec![1, 2, 3, 4],
    };

    node.content_store.add(packet.name.clone(), packet.clone());
    let retrieved = node.content_store.get(&packet.name);
    assert!(retrieved.is_some());
    assert_eq!(retrieved.unwrap().content, vec![1, 2, 3, 4]);
}

#[test]
fn test_packet_processing() {
    let mut node = IcnNode::new();
    let addr: SocketAddr = "127.0.0.1:8000".parse().unwrap();
    node.add_interface("eth0".to_string(), addr);
    node.fib.add_entry("/test".to_string(), addr);

    let interest_packet = Packet {
        packet_type: PacketType::Interest,
        name: "/test/data".to_string(),
        content: vec![],
    };

    node.process_packet(interest_packet.clone(), "eth0");
    assert!(node.pit.has_pending_interest(&interest_packet.name));

    let data_packet = Packet {
        packet_type: PacketType::Data,
        name: "/test/data".to_string(),
        content: vec![1, 2, 3, 4],
    };

    node.process_packet(data_packet.clone(), "eth0");
    assert!(!node.pit.has_pending_interest(&data_packet.name));
    assert!(node.content_store.get(&data_packet.name).is_some());
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_core/tests/icn_node_tests.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/tests/integration_tests.rs =====
// File: crates/icn_core/tests/integration_tests.rs

use icn_core::{IcnNode, Config};
use icn_common::{Transaction, Proposal, CurrencyType, ProposalStatus, ProposalType, ProposalCategory};
use tokio::test;
use std::collections::HashMap;
use chrono::Utc;
use uuid::Uuid;

#[tokio::test]
async fn test_node_creation_and_basic_operations() {
    let config = Config {
        shard_count: 4,
        consensus_threshold: 0.66,
        consensus_quorum: 0.51,
        network_port: 8080,
    };

    let node = IcnNode::new(config).unwrap();
    node.start().await.unwrap();

    // Test create identity
    let mut attributes = HashMap::new();
    attributes.insert("name".to_string(), "Alice".to_string());
    attributes.insert("email".to_string(), "alice@example.com".to_string());
    let identity = node.create_identity(attributes).unwrap();
    assert_eq!(identity.attributes.get("name"), Some(&"Alice".to_string()));

    // Test process transaction
    let transaction = Transaction {
        from: "Alice".to_string(),
        to: "Bob".to_string(),
        amount: 50.0,
        currency_type: CurrencyType::BasicNeeds,
        timestamp: chrono::Utc::now().timestamp(),
        signature: None,
    };
    assert!(node.process_transaction(transaction).await.is_ok());

    // Test create proposal
    let proposal = Proposal {
        id: Uuid::new_v4().to_string(),
        title: "Test Proposal".to_string(),
        description: "This is a test proposal".to_string(),
        proposer: "Alice".to_string(),
        created_at: Utc::now(),
        voting_ends_at: Utc::now() + chrono::Duration::days(7),
        status: ProposalStatus::Active,
        proposal_type: ProposalType::Constitutional,
        category: ProposalCategory::Economic,
        required_quorum: 0.66,
        execution_timestamp: None,
    };
    assert!(node.create_proposal(proposal).is_ok());

    // Test get network stats
    let stats = node.get_network_stats().await.unwrap();
    assert!(stats.connected_peers >= 0);

    // Test allocate resource
    assert!(node.allocate_resource("computing_power", 100).is_ok());

    // Test get balance
    let balance = node.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap();
    assert!(balance >= 0.0);

    node.stop().await.unwrap();
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_core/tests/integration_tests.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/tests/mod.rs =====
// ===============================================
// Tests Module
// ===============================================
// This module re-exports the contents of the tests submodules.
// The tests submodules contain various test cases to ensure
// the correctness and reliability of the blockchain implementation.

#[cfg(test)]
mod tests {
    use super::*;
    use crate::currency::CurrencyType;
    use ed25519_dalek::Keypair;
    use rand::rngs::OsRng;

    #[test]
    fn test_cross_shard_transaction() {
        let node = IcnNode::new();

        // Initialize balances
        {
            let mut sharding_manager = node.sharding_manager.write().unwrap();
            sharding_manager.add_address_to_shard("Alice".to_string(), 0);
            sharding_manager.add_address_to_shard("Bob".to_string(), 1);
            sharding_manager.initialize_balance("Alice".to_string(), CurrencyType::BasicNeeds, 1000.0);
        }

        let mut csprng = OsRng{};
        let keypair: Keypair = Keypair::generate(&mut csprng);

        let mut transaction = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            500.0,
            CurrencyType::BasicNeeds,
            1000,
        );
        if let Err(e) = transaction.sign(&keypair) {
            panic!("Failed to sign transaction: {}", e);
        }

        println!("Signed transaction: {:?}", transaction);

        assert!(node.process_cross_shard_transaction(&transaction).is_ok(), "Cross-shard transaction failed");

        // Check balances after transaction
        let sharding_manager = node.sharding_manager.read().unwrap();
        assert_eq!(sharding_manager.get_balance("Alice".to_string(), CurrencyType::BasicNeeds), 500.0);
        assert_eq!(sharding_manager.get_balance("Bob".to_string(), CurrencyType::BasicNeeds), 500.0);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_core/tests/mod.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/tests/smart_contract_tests.rs =====
// Filename: src/tests/smart_contract_tests.rs

use crate::blockchain::Blockchain;
use crate::smart_contract::{parse_contract, ContractType};

#[test]
fn test_smart_contract_integration() {
    let mut blockchain = Blockchain::new();

    // Deploy an asset transfer contract
    let contract_input = "Asset Transfer
Creator: Alice
From: Alice
To: Bob
Asset: ICN_TOKEN
Amount: 100.0";

    let contract = parse_contract(contract_input).unwrap();
    blockchain.deploy_smart_contract(contract).unwrap();

    // Deploy a proposal contract
    let proposal_input = "Proposal
Creator: Charlie
Title: New Community Project
Description: Implement a recycling program
Voting Period: 604800
Option 1: Approve
Option 2: Reject
Quorum: 0.5";

    let proposal_contract = parse_contract(proposal_input).unwrap();
    blockchain.deploy_smart_contract(proposal_contract).unwrap();

    // Execute smart contracts
    blockchain.execute_smart_contracts().unwrap();

    // Verify blockchain state
    assert_eq!(blockchain.chain.len(), 2); // Genesis block + 1 block with contracts
    assert_eq!(blockchain.chain.last().unwrap().smart_contracts.len(), 2);

    // Verify contract execution results
    let env = &blockchain.execution_environment;
    assert_eq!(env.balances.get("Bob").unwrap().get("ICN_TOKEN").unwrap(), &100.0);
    assert!(env.votes.contains_key(&blockchain.chain.last().unwrap().smart_contracts[1].id));
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_core/tests/smart_contract_tests.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_currency/Cargo.toml =====
[package]
name = "icn_currency"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
serde = { version = "1.0", features = ["derive"] }
log = "0.4"
thiserror = "1.0"
chrono = { version = "0.4", features = ["serde"] }

[dev-dependencies]
tokio = { version = "1.0", features = ["full"] }===== END OF /home/matt/InterCooperative-Network/crates/icn_currency/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_currency/src/asset_token.rs =====
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct AssetToken {
    pub asset_id: String,
    pub name: String,
    pub description: String,
    pub owner: String,
    pub value: f64,
}

impl AssetToken {
    pub fn new(asset_id: String, name: String, description: String, owner: String, value: f64) -> Self {
        AssetToken {
            asset_id,
            name,
            description,
            owner,
            value,
        }
    }

    pub fn transfer(&mut self, new_owner: String) {
        self.owner = new_owner;
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_currency/src/asset_token.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_currency/src/bond.rs =====
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Bond {
    pub bond_id: String,
    pub name: String,
    pub description: String,
    pub issuer: String,
    pub face_value: f64,
    pub maturity_date: DateTime<Utc>,
    pub interest_rate: f64,
    pub owner: String,
}

impl Bond {
    pub fn new(bond_id: String, name: String, description: String, issuer: String, face_value: f64, maturity_date: DateTime<Utc>, interest_rate: f64, owner: String) -> Self {
        Bond {
            bond_id,
            name,
            description,
            issuer,
            face_value,
            maturity_date,
            interest_rate,
            owner,
        }
    }

    pub fn transfer(&mut self, new_owner: String) {
        self.owner = new_owner;
    }

    pub fn calculate_current_value(&self, current_date: DateTime<Utc>) -> f64 {
        if current_date >= self.maturity_date {
            self.face_value
        } else {
            let years_to_maturity = (self.maturity_date - current_date).num_days() as f64 / 365.0;
            self.face_value * (1.0 + self.interest_rate).powf(years_to_maturity)
        }
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_currency/src/bond.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_currency/src/currency.rs =====
use icn_common::{IcnResult, IcnError, CurrencyType, Transaction};
use std::collections::HashMap;
use chrono::{DateTime, Utc};
use log::{info, warn};

/// Represents the balance of a particular currency for a given account.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Balance {
    pub currency: CurrencyType,
    pub amount: f64,
}

/// Represents a currency system managing multiple currencies.
pub struct CurrencySystem {
    pub accounts: HashMap<String, Vec<Balance>>,
}

impl CurrencySystem {
    /// Creates a new CurrencySystem.
    pub fn new() -> Self {
        CurrencySystem {
            accounts: HashMap::new(),
        }
    }

    /// Mints a specified amount of a currency to a given account.
    ///
    /// # Arguments
    ///
    /// * `account` - The account to mint the currency to.
    /// * `currency` - The type of currency to mint.
    /// * `amount` - The amount of currency to mint.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Currency` if the operation fails.
    pub fn mint(&mut self, account: &str, currency: CurrencyType, amount: f64) -> IcnResult<()> {
        let balances = self.accounts.entry(account.to_string()).or_insert_with(Vec::new);
        if let Some(balance) = balances.iter_mut().find(|b| b.currency == currency) {
            balance.amount += amount;
        } else {
            balances.push(Balance { currency, amount });
        }
        info!("Minted {} of {:?} to {}", amount, currency, account);
        Ok(())
    }

    /// Burns a specified amount of a currency from a given account.
    ///
    /// # Arguments
    ///
    /// * `account` - The account to burn the currency from.
    /// * `currency` - The type of currency to burn.
    /// * `amount` - The amount of currency to burn.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Currency` if the account has insufficient balance.
    pub fn burn(&mut self, account: &str, currency: CurrencyType, amount: f64) -> IcnResult<()> {
        let balances = self.accounts.entry(account.to_string()).or_insert_with(Vec::new);
        if let Some(balance) = balances.iter_mut().find(|b| b.currency == currency) {
            if balance.amount < amount {
                return Err(IcnError::Currency("Insufficient balance".into()));
            }
            balance.amount -= amount;
            info!("Burned {} of {:?} from {}", amount, currency, account);
            Ok(())
        } else {
            Err(IcnError::Currency("Currency not found in account".into()))
        }
    }

    /// Transfers a specified amount of a currency from one account to another.
    ///
    /// # Arguments
    ///
    /// * `from` - The account to transfer the currency from.
    /// * `to` - The account to transfer the currency to.
    /// * `currency` - The type of currency to transfer.
    /// * `amount` - The amount of currency to transfer.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Currency` if the sender has insufficient balance or if the operation fails.
    pub fn transfer(&mut self, from: &str, to: &str, currency: CurrencyType, amount: f64) -> IcnResult<()> {
        self.burn(from, currency.clone(), amount)?;
        self.mint(to, currency, amount)?;
        info!("Transferred {} of {:?} from {} to {}", amount, currency, from, to);
        Ok(())
    }

    /// Gets the balance of a particular currency for a given account.
    ///
    /// # Arguments
    ///
    /// * `account` - The account to get the balance for.
    /// * `currency` - The type of currency to get the balance of.
    ///
    /// # Returns
    ///
    /// The balance of the specified currency for the given account.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Currency` if the currency is not found in the account.
    pub fn get_balance(&self, account: &str, currency: &CurrencyType) -> IcnResult<f64> {
        let balances = self.accounts.get(account)
            .ok_or_else(|| IcnError::Currency("Account not found".into()))?;
        
        let balance = balances.iter()
            .find(|b| &b.currency == currency)
            .ok_or_else(|| IcnError::Currency("Currency not found in account".into()))?;
        
        Ok(balance.amount)
    }

    /// Lists all balances for a given account.
    ///
    /// # Arguments
    ///
    /// * `account` - The account to list the balances for.
    ///
    /// # Returns
    ///
    /// A list of balances for the specified account.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Currency` if the account is not found.
    pub fn list_balances(&self, account: &str) -> IcnResult<Vec<Balance>> {
        let balances = self.accounts.get(account)
            .ok_or_else(|| IcnError::Currency("Account not found".into()))?;
        Ok(balances.clone())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_mint() {
        let mut currency_system = CurrencySystem::new();
        assert!(currency_system.mint("Alice", CurrencyType::BasicNeeds, 100.0).is_ok());
        assert_eq!(currency_system.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap(), 100.0);
    }

    #[test]
    fn test_burn() {
        let mut currency_system = CurrencySystem::new();
        currency_system.mint("Alice", CurrencyType::BasicNeeds, 100.0).unwrap();
        assert!(currency_system.burn("Alice", CurrencyType::BasicNeeds, 50.0).is_ok());
        assert_eq!(currency_system.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap(), 50.0);
        assert!(currency_system.burn("Alice", CurrencyType::BasicNeeds, 60.0).is_err());
    }

    #[test]
    fn test_transfer() {
        let mut currency_system = CurrencySystem::new();
        currency_system.mint("Alice", CurrencyType::BasicNeeds, 100.0).unwrap();
        assert!(currency_system.transfer("Alice", "Bob", CurrencyType::BasicNeeds, 50.0).is_ok());
        assert_eq!(currency_system.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap(), 50.0);
        assert_eq!(currency_system.get_balance("Bob", &CurrencyType::BasicNeeds).unwrap(), 50.0);
        assert!(currency_system.transfer("Alice", "Bob", CurrencyType::BasicNeeds, 60.0).is_err());
    }

    #[test]
    fn test_get_balance() {
        let mut currency_system = CurrencySystem::new();
        currency_system.mint("Alice", CurrencyType::BasicNeeds, 100.0).unwrap();
        assert_eq!(currency_system.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap(), 100.0);
        assert!(currency_system.get_balance("Alice", &CurrencyType::Education).is_err());
        assert!(currency_system.get_balance("Bob", &CurrencyType::BasicNeeds).is_err());
    }

    #[test]
    fn test_list_balances() {
        let mut currency_system = CurrencySystem::new();
        currency_system.mint("Alice", CurrencyType::BasicNeeds, 100.0).unwrap();
        currency_system.mint("Alice", CurrencyType::Education, 50.0).unwrap();
        let balances = currency_system.list_balances("Alice").unwrap();
        assert_eq!(balances.len(), 2);
        assert_eq!(balances[0].amount, 100.0);
        assert_eq!(balances[1].amount, 50.0);
        assert!(currency_system.list_balances("Bob").is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_currency/src/currency.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_currency/src/lib.rs =====
// File: crates/icn_currency/src/lib.rs

use icn_common::{IcnResult, IcnError, Transaction, CurrencyType};
use std::collections::HashMap;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Currency {
    pub currency_type: CurrencyType,
    pub total_supply: f64,
    pub creation_date: DateTime<Utc>,
    pub last_issuance: DateTime<Utc>,
    pub issuance_rate: f64,
}

impl Currency {
    pub fn new(currency_type: CurrencyType, initial_supply: f64, issuance_rate: f64) -> Self {
        let now = Utc::now();
        Currency {
            currency_type,
            total_supply: initial_supply,
            creation_date: now,
            last_issuance: now,
            issuance_rate,
        }
    }

    pub fn mint(&mut self, amount: f64) -> IcnResult<()> {
        if amount < 0.0 {
            return Err(IcnError::Currency("Cannot mint negative amount".into()));
        }
        self.total_supply += amount;
        self.last_issuance = Utc::now();
        Ok(())
    }

    pub fn burn(&mut self, amount: f64) -> IcnResult<()> {
        if amount < 0.0 {
            return Err(IcnError::Currency("Cannot burn negative amount".into()));
        }
        if amount > self.total_supply {
            return Err(IcnError::Currency("Insufficient supply to burn".into()));
        }
        self.total_supply -= amount;
        Ok(())
    }
}

pub struct CurrencySystem {
    pub currencies: HashMap<CurrencyType, Currency>,
    balances: HashMap<String, HashMap<CurrencyType, f64>>,
}

impl CurrencySystem {
    pub fn new() -> Self {
        CurrencySystem {
            currencies: HashMap::new(),
            balances: HashMap::new(),
        }
    }

    pub fn add_currency(&mut self, currency_type: CurrencyType, initial_supply: f64, issuance_rate: f64) -> IcnResult<()> {
        if self.currencies.contains_key(&currency_type) {
            return Err(IcnError::Currency("Currency already exists".into()));
        }
        let currency = Currency::new(currency_type.clone(), initial_supply, issuance_rate);
        self.currencies.insert(currency_type, currency);
        Ok(())
    }

    pub fn mint(&mut self, currency_type: &CurrencyType, amount: f64) -> IcnResult<()> {
        let currency = self.currencies.get_mut(currency_type)
            .ok_or_else(|| IcnError::Currency("Currency not found".into()))?;
        currency.mint(amount)
    }

    pub fn burn(&mut self, currency_type: &CurrencyType, amount: f64) -> IcnResult<()> {
        let currency = self.currencies.get_mut(currency_type)
            .ok_or_else(|| IcnError::Currency("Currency not found".into()))?;
        currency.burn(amount)
    }

    pub fn process_transaction(&mut self, transaction: &Transaction) -> IcnResult<()> {
        self.transfer(
            &transaction.from,
            &transaction.to,
            &transaction.currency_type,
            transaction.amount,
        )
    }

    pub fn transfer(&mut self, from: &str, to: &str, currency_type: &CurrencyType, amount: f64) -> IcnResult<()> {
        if amount < 0.0 {
            return Err(IcnError::Currency("Cannot transfer negative amount".into()));
        }

        let from_balance = self.get_balance(from, currency_type)?;
        if from_balance < amount {
            return Err(IcnError::Currency("Insufficient balance".into()));
        }

        self.update_balance(from, currency_type, -amount)?;
        self.update_balance(to, currency_type, amount)?;

        Ok(())
    }

    pub fn get_balance(&self, address: &str, currency_type: &CurrencyType) -> IcnResult<f64> {
        Ok(*self.balances
            .get(address)
            .and_then(|balances| balances.get(currency_type))
            .unwrap_or(&0.0))
    }

    fn update_balance(&mut self, address: &str, currency_type: &CurrencyType, amount: f64) -> IcnResult<()> {
        let balance = self.balances
            .entry(address.to_string())
            .or_insert_with(HashMap::new)
            .entry(currency_type.clone())
            .or_insert(0.0);
        *balance += amount;
        Ok(())
    }

    pub fn get_total_supply(&self, currency_type: &CurrencyType) -> IcnResult<f64> {
        self.currencies.get(currency_type)
            .map(|currency| currency.total_supply)
            .ok_or_else(|| IcnError::Currency("Currency not found".into()))
    }

    pub fn get_issuance_rate(&self, currency_type: &CurrencyType) -> IcnResult<f64> {
        self.currencies.get(currency_type)
            .map(|currency| currency.issuance_rate)
            .ok_or_else(|| IcnError::Currency("Currency not found".into()))
    }

    pub fn update_issuance_rate(&mut self, currency_type: &CurrencyType, new_rate: f64) -> IcnResult<()> {
        let currency = self.currencies.get_mut(currency_type)
            .ok_or_else(|| IcnError::Currency("Currency not found".into()))?;
        currency.issuance_rate = new_rate;
        Ok(())
    }

    pub fn list_currencies(&self) -> Vec<CurrencyType> {
        self.currencies.keys().cloned().collect()
    }

    pub fn get_currency_info(&self, currency_type: &CurrencyType) -> IcnResult<Currency> {
        self.currencies.get(currency_type)
            .cloned()
            .ok_or_else(|| IcnError::Currency("Currency not found".into()))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_currency_system() {
        let mut system = CurrencySystem::new();

        // Add currencies
        assert!(system.add_currency(CurrencyType::BasicNeeds, 1000.0, 0.01).is_ok());
        assert!(system.add_currency(CurrencyType::Education, 500.0, 0.005).is_ok());

        // Test minting
        assert!(system.mint(&CurrencyType::BasicNeeds, 100.0).is_ok());
        assert_eq!(system.get_total_supply(&CurrencyType::BasicNeeds).unwrap(), 1100.0);

        // Test burning
        assert!(system.burn(&CurrencyType::BasicNeeds, 50.0).is_ok());
        assert_eq!(system.get_total_supply(&CurrencyType::BasicNeeds).unwrap(), 1050.0);

        // Test transfer
        system.update_balance("Alice", &CurrencyType::BasicNeeds, 100.0).unwrap();
        assert!(system.transfer("Alice", "Bob", &CurrencyType::BasicNeeds, 50.0).is_ok());
        assert_eq!(system.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap(), 50.0);
        assert_eq!(system.get_balance("Bob", &CurrencyType::BasicNeeds).unwrap(), 50.0);

        // Test insufficient balance
        assert!(system.transfer("Alice", "Bob", &CurrencyType::BasicNeeds, 100.0).is_err());

        // Test get issuance rate
        assert_eq!(system.get_issuance_rate(&CurrencyType::BasicNeeds).unwrap(), 0.01);

        // Test update issuance rate
        assert!(system.update_issuance_rate(&CurrencyType::BasicNeeds, 0.02).is_ok());
        assert_eq!(system.get_issuance_rate(&CurrencyType::BasicNeeds).unwrap(), 0.02);

        // Test list currencies
        let currencies = system.list_currencies();
        assert_eq!(currencies.len(), 2);
        assert!(currencies.contains(&CurrencyType::BasicNeeds));
        assert!(currencies.contains(&CurrencyType::Education));

        // Test get currency info
        let basic_needs_info = system.get_currency_info(&CurrencyType::BasicNeeds).unwrap();
        assert_eq!(basic_needs_info.total_supply, 1050.0);
        assert_eq!(basic_needs_info.issuance_rate, 0.02);
    }

    #[test]
    fn test_currency_operations() {
        let mut currency = Currency::new(CurrencyType::BasicNeeds, 1000.0, 0.01);

        // Test minting
        assert!(currency.mint(100.0).is_ok());
        assert_eq!(currency.total_supply, 1100.0);

        // Test burning
        assert!(currency.burn(50.0).is_ok());
        assert_eq!(currency.total_supply, 1050.0);

        // Test minting negative amount
        assert!(currency.mint(-100.0).is_err());

        // Test burning negative amount
        assert!(currency.burn(-50.0).is_err());

        // Test burning more than available
        assert!(currency.burn(2000.0).is_err());
    }

    #[test]
    fn test_currency_system_edge_cases() {
        let mut system = CurrencySystem::new();

        // Test adding duplicate currency
        assert!(system.add_currency(CurrencyType::BasicNeeds, 1000.0, 0.01).is_ok());
        assert!(system.add_currency(CurrencyType::BasicNeeds, 2000.0, 0.02).is_err());

        // Test operations on non-existent currency
        assert!(system.mint(&CurrencyType::Education, 100.0).is_err());
        assert!(system.burn(&CurrencyType::Education, 50.0).is_err());
        assert!(system.get_total_supply(&CurrencyType::Education).is_err());
        assert!(system.get_issuance_rate(&CurrencyType::Education).is_err());
        assert!(system.update_issuance_rate(&CurrencyType::Education, 0.03).is_err());
        assert!(system.get_currency_info(&CurrencyType::Education).is_err());

        // Test transfer with non-existent currency
        assert!(system.transfer("Alice", "Bob", &CurrencyType::Education, 50.0).is_err());

        // Test transfer with negative amount
        assert!(system.transfer("Alice", "Bob", &CurrencyType::BasicNeeds, -50.0).is_err());
    }

    #[test]
    fn test_currency_system_process_transaction() {
        let mut system = CurrencySystem::new();
        system.add_currency(CurrencyType::BasicNeeds, 1000.0, 0.01).unwrap();

        // Initialize balance for Alice
        system.update_balance("Alice", &CurrencyType::BasicNeeds, 100.0).unwrap();

        let transaction = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 50.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: Utc::now().timestamp(),
            signature: None,
        };

        assert!(system.process_transaction(&transaction).is_ok());
        assert_eq!(system.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap(), 50.0);
        assert_eq!(system.get_balance("Bob", &CurrencyType::BasicNeeds).unwrap(), 50.0);

        // Test processing invalid transaction
        let invalid_transaction = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 100.0, // More than Alice's balance
            currency_type: CurrencyType::BasicNeeds,
            timestamp: Utc::now().timestamp(),
            signature: None,
        };

        assert!(system.process_transaction(&invalid_transaction).is_err());
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_currency/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_currency/src/wallet.rs =====
use super::CurrencyType;
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use log::{info, error, debug};
use icn_core::error::{Error, Result};

#[derive(Debug, Serialize, Deserialize)]
pub struct Wallet {
    balances: HashMap<CurrencyType, f64>,
}

impl Wallet {
    pub fn new() -> Self {
        debug!("Creating new Wallet");
        Wallet {
            balances: HashMap::new(),
        }
    }

    pub fn deposit(&mut self, currency_type: CurrencyType, amount: f64) -> Result<()> {
        if amount < 0.0 {
            return Err(Error::CurrencyError("Cannot deposit negative amount".to_string()));
        }
        *self.balances.entry(currency_type.clone()).or_insert(0.0) += amount;
        info!("Deposited {} of {:?} into wallet", amount, currency_type);
        Ok(())
    }

    pub fn withdraw(&mut self, currency_type: CurrencyType, amount: f64) -> Result<()> {
        if amount < 0.0 {
            return Err(Error::CurrencyError("Cannot withdraw negative amount".to_string()));
        }
        let balance = self.balances.entry(currency_type.clone()).or_insert(0.0);
        if *balance < amount {
            error!("Insufficient balance for withdrawal. Requested: {}, Available: {}", amount, balance);
            return Err(Error::CurrencyError(format!("Insufficient balance for {:?}", currency_type)));
        }
        *balance -= amount;
        info!("Withdrawn {} of {:?} from wallet", amount, currency_type);
        Ok(())
    }

    pub fn get_balance(&self, currency_type: &CurrencyType) -> f64 {
        *self.balances.get(currency_type).unwrap_or(&0.0)
    }

    pub fn print_balances(&self) {
        info!("Wallet Balances:");
        for (currency_type, balance) in &self.balances {
            info!("{:?}: {}", currency_type, balance);
        }
    }

    pub fn transfer(&mut self, to: &mut Wallet, currency_type: CurrencyType, amount: f64) -> Result<()> {
        self.withdraw(currency_type.clone(), amount)?;
        to.deposit(currency_type, amount)?;
        Ok(())
    }
}


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_wallet_operations() {
        let mut wallet = Wallet::new();
        
        // Test deposit
        assert!(wallet.deposit(CurrencyType::BasicNeeds, 100.0).is_ok());
        assert_eq!(wallet.get_balance(&CurrencyType::BasicNeeds), 100.0);

        // Test withdraw
        assert!(wallet.withdraw(CurrencyType::BasicNeeds, 50.0).is_ok());
        assert_eq!(wallet.get_balance(&CurrencyType::BasicNeeds), 50.0);

        // Test insufficient balance
        assert!(wallet.withdraw(CurrencyType::BasicNeeds, 100.0).is_err());

        // Test transfer
        let mut wallet2 = Wallet::new();
        assert!(wallet.transfer(&mut wallet2, CurrencyType::BasicNeeds, 25.0).is_ok());
        assert_eq!(wallet.get_balance(&CurrencyType::BasicNeeds), 25.0);
        assert_eq!(wallet2.get_balance(&CurrencyType::BasicNeeds), 25.0);
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_currency/src/wallet.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_dao/Cargo.toml =====
===== END OF /home/matt/InterCooperative-Network/crates/icn_dao/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_dao/src/lib.rs =====
// crates/icn_dao/src/lib.rs

use std::collections::HashMap;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use icn_common::{IcnResult, IcnError};
use uuid::Uuid;

/// Represents a member of a DAO
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Member {
    pub id: String,
    pub name: String,
    pub joined_at: DateTime<Utc>,
    pub reputation: f64,
}

/// Represents a proposal in a DAO
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proposal {
    pub id: String,
    pub title: String,
    pub description: String,
    pub proposer: String,
    pub created_at: DateTime<Utc>,
    pub expires_at: DateTime<Utc>,
    pub status: ProposalStatus,
    pub votes: HashMap<String, Vote>,
}

/// Represents the status of a proposal
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProposalStatus {
    Active,
    Passed,
    Rejected,
    Executed,
}

/// Represents a vote on a proposal
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vote {
    pub member: String,
    pub in_favor: bool,
    pub weight: f64,
}

/// Represents the type of a DAO
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DaoType {
    Cooperative,
    Community,
    Custom(String),
}

/// Represents a Decentralized Autonomous Organization (DAO)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Dao {
    pub id: String,
    pub name: String,
    pub dao_type: DaoType,
    pub members: HashMap<String, Member>,
    pub proposals: HashMap<String, Proposal>,
    pub quorum: f64,
    pub majority: f64,
}

impl Dao {
    /// Creates a new DAO
    pub fn new(name: String, dao_type: DaoType, quorum: f64, majority: f64) -> Self {
        Dao {
            id: Uuid::new_v4().to_string(),
            name,
            dao_type,
            members: HashMap::new(),
            proposals: HashMap::new(),
            quorum,
            majority,
        }
    }

    /// Adds a new member to the DAO
    pub fn add_member(&mut self, id: String, name: String) -> IcnResult<()> {
        if self.members.contains_key(&id) {
            return Err(IcnError::Dao("Member already exists".into()));
        }

        let member = Member {
            id: id.clone(),
            name,
            joined_at: Utc::now(),
            reputation: 1.0,
        };

        self.members.insert(id, member);
        Ok(())
    }

    /// Creates a new proposal in the DAO
    pub fn create_proposal(&mut self, title: String, description: String, proposer: String, duration: chrono::Duration) -> IcnResult<String> {
        if !self.members.contains_key(&proposer) {
            return Err(IcnError::Dao("Proposer is not a member of the DAO".into()));
        }

        let id = Uuid::new_v4().to_string();
        let proposal = Proposal {
            id: id.clone(),
            title,
            description,
            proposer,
            created_at: Utc::now(),
            expires_at: Utc::now() + duration,
            status: ProposalStatus::Active,
            votes: HashMap::new(),
        };

        self.proposals.insert(id.clone(), proposal);
        Ok(id)
    }

    /// Casts a vote on a proposal
    pub fn vote(&mut self, proposal_id: &str, member_id: &str, in_favor: bool) -> IcnResult<()> {
        let proposal = self.proposals.get_mut(proposal_id)
            .ok_or_else(|| IcnError::Dao("Proposal not found".into()))?;

        if proposal.status != ProposalStatus::Active {
            return Err(IcnError::Dao("Proposal is not active".into()));
        }

        let member = self.members.get(member_id)
            .ok_or_else(|| IcnError::Dao("Member not found".into()))?;

        let vote = Vote {
            member: member_id.to_string(),
            in_favor,
            weight: member.reputation,
        };

        proposal.votes.insert(member_id.to_string(), vote);
        Ok(())
    }

    /// Finalizes a proposal, determining if it passed or failed
    pub fn finalize_proposal(&mut self, proposal_id: &str) -> IcnResult<ProposalStatus> {
        let proposal = self.proposals.get_mut(proposal_id)
            .ok_or_else(|| IcnError::Dao("Proposal not found".into()))?;

        if proposal.status != ProposalStatus::Active {
            return Err(IcnError::Dao("Proposal is not active".into()));
        }

        let total_votes: f64 = proposal.votes.values().map(|v| v.weight).sum();
        let total_members: f64 = self.members.values().map(|m| m.reputation).sum();

        if total_votes / total_members < self.quorum {
            proposal.status = ProposalStatus::Rejected;
            return Ok(ProposalStatus::Rejected);
        }

        let votes_in_favor: f64 = proposal.votes.values()
            .filter(|v| v.in_favor)
            .map(|v| v.weight)
            .sum();

        if votes_in_favor / total_votes > self.majority {
            proposal.status = ProposalStatus::Passed;
            Ok(ProposalStatus::Passed)
        } else {
            proposal.status = ProposalStatus::Rejected;
            Ok(ProposalStatus::Rejected)
        }
    }

    /// Executes a passed proposal
    pub fn execute_proposal(&mut self, proposal_id: &str) -> IcnResult<()> {
        let proposal = self.proposals.get_mut(proposal_id)
            .ok_or_else(|| IcnError::Dao("Proposal not found".into()))?;

        if proposal.status != ProposalStatus::Passed {
            return Err(IcnError::Dao("Proposal has not passed".into()));
        }

        // Here you would implement the logic to execute the proposal
        // For now, we'll just mark it as executed
        proposal.status = ProposalStatus::Executed;
        Ok(())
    }
}

/// Represents a Cooperative, which is a specific type of DAO
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Cooperative {
    pub dao: Dao,
    pub business_type: String,
    pub member_shares: HashMap<String, f64>,
}

impl Cooperative {
    pub fn new(name: String, business_type: String, quorum: f64, majority: f64) -> Self {
        Cooperative {
            dao: Dao::new(name, DaoType::Cooperative, quorum, majority),
            business_type,
            member_shares: HashMap::new(),
        }
    }

    pub fn issue_shares(&mut self, member_id: &str, shares: f64) -> IcnResult<()> {
        if !self.dao.members.contains_key(member_id) {
            return Err(IcnError::Dao("Member not found".into()));
        }

        *self.member_shares.entry(member_id.to_string()).or_insert(0.0) += shares;
        Ok(())
    }

    pub fn get_member_shares(&self, member_id: &str) -> IcnResult<f64> {
        self.member_shares.get(member_id)
            .cloned()
            .ok_or_else(|| IcnError::Dao("Member has no shares".into()))
    }

    pub fn distribute_profits(&mut self, total_profit: f64) -> IcnResult<()> {
        let total_shares: f64 = self.member_shares.values().sum();
        
        for (member_id, shares) in &self.member_shares {
            let profit_share = total_profit * (shares / total_shares);
            // Here you would typically update the member's balance
            println!("Member {} receives profit share: {}", member_id, profit_share);
        }

        Ok(())
    }
}

/// Represents a Community, which is another specific type of DAO
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Community {
    pub dao: Dao,
    pub location: String,
    pub focus_areas: Vec<String>,
}

impl Community {
    pub fn new(name: String, location: String, focus_areas: Vec<String>, quorum: f64, majority: f64) -> Self {
        Community {
            dao: Dao::new(name, DaoType::Community, quorum, majority),
            location,
            focus_areas,
        }
    }

    pub fn add_focus_area(&mut self, focus_area: String) -> IcnResult<()> {
        if !self.focus_areas.contains(&focus_area) {
            self.focus_areas.push(focus_area);
            Ok(())
        } else {
            Err(IcnError::Dao("Focus area already exists".into()))
        }
    }

    pub fn remove_focus_area(&mut self, focus_area: &str) -> IcnResult<()> {
        if let Some(pos) = self.focus_areas.iter().position(|x| x == focus_area) {
            self.focus_areas.remove(pos);
            Ok(())
        } else {
            Err(IcnError::Dao("Focus area not found".into()))
        }
    }

    pub fn organize_event(&self, event_name: &str, event_description: &str) -> IcnResult<()> {
        // Here you would typically integrate with a calendar or event system
        println!("Community {} is organizing event: {}", self.dao.name, event_name);
        println!("Event description: {}", event_description);
        Ok(())
    }
}

/// A factory for creating different types of DAOs
pub struct DaoFactory;

impl DaoFactory {
    pub fn create_dao(dao_type: DaoType, name: String, quorum: f64, majority: f64) -> Box<dyn DaoTrait> {
        match dao_type {
            DaoType::Cooperative => Box::new(Cooperative::new(name, "General".to_string(), quorum, majority)),
            DaoType::Community => Box::new(Community::new(name, "Global".to_string(), Vec::new(), quorum, majority)),
            DaoType::Custom(custom_type) => {
                // Here you could implement logic to create custom DAO types
                println!("Creating custom DAO of type: {}", custom_type);
                Box::new(Dao::new(name, dao_type, quorum, majority))
            }
        }
    }
}

/// A trait that defines common behavior for all DAO types
pub trait DaoTrait {
    fn get_dao(&self) -> &Dao;
    fn get_dao_mut(&mut self) -> &mut Dao;
    
    fn add_member(&mut self, id: String, name: String) -> IcnResult<()> {
        self.get_dao_mut().add_member(id, name)
    }

    fn create_proposal(&mut self, title: String, description: String, proposer: String, duration: chrono::Duration) -> IcnResult<String> {
        self.get_dao_mut().create_proposal(title, description, proposer, duration)
    }

    fn vote(&mut self, proposal_id: &str, member_id: &str, in_favor: bool) -> IcnResult<()> {
        self.get_dao_mut().vote(proposal_id, member_id, in_favor)
    }

    fn finalize_proposal(&mut self, proposal_id: &str) -> IcnResult<ProposalStatus> {
        self.get_dao_mut().finalize_proposal(proposal_id)
    }

    fn execute_proposal(&mut self, proposal_id: &str) -> IcnResult<()> {
        self.get_dao_mut().execute_proposal(proposal_id)
    }
}

impl DaoTrait for Dao {
    fn get_dao(&self) -> &Dao { self }
    fn get_dao_mut(&mut self) -> &mut Dao { self }
}

impl DaoTrait for Cooperative {
    fn get_dao(&self) -> &Dao { &self.dao }
    fn get_dao_mut(&mut self) -> &mut Dao { &mut self.dao }
}

impl DaoTrait for Community {
    fn get_dao(&self) -> &Dao { &self.dao }
    fn get_dao_mut(&mut self) -> &mut Dao { &mut self.dao }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cooperative_creation_and_operations() {
        let mut coop = Cooperative::new("Test Coop".to_string(), "Agriculture".to_string(), 0.5, 0.6);
        
        assert_eq!(coop.dao.name, "Test Coop");
        assert_eq!(coop.dao.dao_type, DaoType::Cooperative);
        assert_eq!(coop.business_type, "Agriculture");

        coop.add_member("alice".to_string(), "Alice".to_string()).unwrap();
        coop.add_member("bob".to_string(), "Bob".to_string()).unwrap();

        coop.issue_shares("alice", 100.0).unwrap();
        coop.issue_shares("bob", 50.0).unwrap();

        assert_eq!(coop.get_member_shares("alice").unwrap(), 100.0);
        assert_eq!(coop.get_member_shares("bob").unwrap(), 50.0);

        let proposal_id = coop.create_proposal(
            "Test Proposal".to_string(),
            "This is a test proposal".to_string(),
            "alice".to_string(),
            chrono::Duration::days(7)
        ).unwrap();

        coop.vote(&proposal_id, "alice", true).unwrap();
        coop.vote(&proposal_id, "bob", true).unwrap();

        let status = coop.finalize_proposal(&proposal_id).unwrap();
        assert_eq!(status, ProposalStatus::Passed);

        coop.execute_proposal(&proposal_id).unwrap();
    }

    #[test]
    fn test_community_creation_and_operations() {
        let mut community = Community::new(
            "Test Community".to_string(),
            "Test City".to_string(),
            vec!["Education".to_string(), "Environment".to_string()],
            0.5,
            0.6
        );
        
        assert_eq!(community.dao.name, "Test Community");
        assert_eq!(community.dao.dao_type, DaoType::Community);
        assert_eq!(community.location, "Test City");
        assert_eq!(community.focus_areas, vec!["Education", "Environment"]);

        community.add_member("alice".to_string(), "Alice".to_string()).unwrap();
        community.add_member("bob".to_string(), "Bob".to_string()).unwrap();

        community.add_focus_area("Health".to_string()).unwrap();
        assert_eq!(community.focus_areas, vec!["Education", "Environment", "Health"]);

        community.remove_focus_area("Environment").unwrap();
        assert_eq!(community.focus_areas, vec!["Education", "Health"]);

        let proposal_id = community.create_proposal(
            "Community Event".to_string(),
            "Organize a community cleanup day".to_string(),
            "alice".to_string(),
            chrono::Duration::days(7)
        ).unwrap();

        community.vote(&proposal_id, "alice", true).unwrap();
        community.vote(&proposal_id, "bob", true).unwrap();

        let status = community.finalize_proposal(&proposal_id).unwrap();
        assert_eq!(status, ProposalStatus::Passed);

        community.execute_proposal(&proposal_id).unwrap();

        community.organize_event("Community Cleanup Day", "Let's clean up our neighborhood!").unwrap();
    }

    #[test]
    fn test_dao_factory() {
        let cooperative = DaoFactory::create_dao(
            DaoType::Cooperative,
            "Test Cooperative".to_string(),
            0.5,
            0.6
        );
        assert_eq!(cooperative.get_dao().dao_type, DaoType::Cooperative);

        let community = DaoFactory::create_dao(
            DaoType::Community,
            "Test Community".to_string(),
            0.5,
            0.6
        );
        assert_eq!(community.get_dao().dao_type, DaoType::Community);

        let custom_dao = DaoFactory::create_dao(
            DaoType::Custom("CustomType".to_string()),
            "Test Custom DAO".to_string(),
            0.5,
            0.6
        );
        if let DaoType::Custom(custom_type) = custom_dao.get_dao().dao_type {
            assert_eq!(custom_type, "CustomType");
        } else {
            panic!("Expected custom DAO type");
        }

        // Test common operations across different DAO types
        for mut dao in vec![cooperative, community, custom_dao] {
            dao.add_member("alice".to_string(), "Alice".to_string()).unwrap();
            dao.add_member("bob".to_string(), "Bob".to_string()).unwrap();

            let proposal_id = dao.create_proposal(
                "Test Proposal".to_string(),
                "This is a test proposal".to_string(),
                "alice".to_string(),
                chrono::Duration::days(7)
            ).unwrap();

            dao.vote(&proposal_id, "alice", true).unwrap();
            dao.vote(&proposal_id, "bob", true).unwrap();

            let status = dao.finalize_proposal(&proposal_id).unwrap();
            assert_eq!(status, ProposalStatus::Passed);

            dao.execute_proposal(&proposal_id).unwrap();
        }
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_dao/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_demo/Cargo.toml =====
[package]
name = "icn_demo"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_core = { path = "../icn_core" }
icn_common = { path = "../icn_common" }
icn_blockchain = { path = "../icn_blockchain" }
icn_consensus = { path = "../icn_consensus" }
icn_currency = { path = "../icn_currency" }
icn_governance = { path = "../icn_governance" }
icn_identity = { path = "../icn_identity" }
tokio = { version = "1.0", features = ["full"] }
env_logger = "0.9"
log = "0.4"
chrono = { version = "0.4", features = ["serde"] }
uuid = { version = "1.0", features = ["v4"] }===== END OF /home/matt/InterCooperative-Network/crates/icn_demo/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_demo/src/main.rs =====
// File: icn_demo/src/main.rs

use icn_core::{IcnNode, Config};
use icn_common::{Transaction, Proposal, ProposalType, ProposalCategory, CurrencyType, ProposalStatus, IcnResult, IcnError};
use std::io::{self, Write};
use chrono::{Duration, Utc};
use log::{info, warn, error};
use uuid::Uuid;
use std::collections::HashMap;
use tokio;

#[tokio::main]
async fn main() -> IcnResult<()> {
    env_logger::init();

    let config = Config {
        shard_count: 4,
        consensus_threshold: 0.66,
        consensus_quorum: 0.51,
        network_port: 8080,
    };

    info!("Starting InterCooperative Network demo...");
    let node = IcnNode::new(config).await?;
    node.start().await?;

    info!("Node started successfully. Type 'help' for available commands.");

    loop {
        print!("> ");
        io::stdout().flush()?;

        let mut input = String::new();
        io::stdin().read_line(&mut input)?;
        let input = input.trim();

        match input {
            "help" => print_help(),
            "exit" => break,
            "transaction" => process_transaction(&node).await?,
            "proposal" => create_proposal(&node).await?,
            "balance" => check_balance(&node).await?,
            "identity" => create_identity(&node).await?,
            "allocate" => allocate_resource(&node).await?,
            "network" => get_network_stats(&node).await?,
            _ => println!("Unknown command. Type 'help' for available commands."),
        }
    }

    info!("Stopping node...");
    node.stop().await?;
    info!("Node stopped. Goodbye!");

    Ok(())
}

fn print_help() {
    println!("Available commands:");
    println!("  help        - Show this help message");
    println!("  transaction - Create a new transaction");
    println!("  proposal    - Create a new proposal");
    println!("  balance     - Check account balance");
    println!("  identity    - Create a new identity");
    println!("  allocate    - Allocate a resource");
    println!("  network     - Get network statistics");
    println!("  exit        - Exit the application");
}

async fn process_transaction(node: &IcnNode) -> IcnResult<()> {
    println!("Creating a new transaction...");
    
    let from = get_input("From: ")?;
    let to = get_input("To: ")?;
    let amount: f64 = get_input("Amount: ")?.parse()?;
    let currency_type = get_currency_type()?;

    let transaction = Transaction {
        from,
        to,
        amount,
        currency_type,
        timestamp: Utc::now().timestamp(),
        signature: None,
    };

    node.process_transaction(transaction).await?;
    println!("Transaction processed successfully");
    Ok(())
}

async fn create_proposal(node: &IcnNode) -> IcnResult<()> {
    println!("Creating a new proposal...");
    
    let title = get_input("Title: ")?;
    let description = get_input("Description: ")?;
    let proposer = get_input("Proposer: ")?;
    let proposal_type = get_proposal_type()?;
    let category = get_proposal_category()?;

    let proposal = Proposal {
        id: Uuid::new_v4().to_string(),
        title,
        description,
        proposer,
        created_at: Utc::now(),
        voting_ends_at: Utc::now() + Duration::days(7),
        status: ProposalStatus::Active,
        proposal_type,
        category,
        required_quorum: 0.66,
        execution_timestamp: None,
    };

    let proposal_id = node.create_proposal(proposal).await?;
    println!("Proposal created successfully. ID: {}", proposal_id);
    Ok(())
}

async fn check_balance(node: &IcnNode) -> IcnResult<()> {
    let address = get_input("Enter address: ")?;
    let currency_type = get_currency_type()?;
    
    let balance = node.get_balance(&address, &currency_type).await?;
    println!("Balance: {} {:?}", balance, currency_type);
    Ok(())
}

async fn create_identity(node: &IcnNode) -> IcnResult<()> {
    println!("Creating a new identity...");
    
    let name = get_input("Enter name: ")?;
    
    let mut attributes = HashMap::new();
    attributes.insert("name".to_string(), name);
    
    let identity_id = node.create_identity(attributes).await?;
    println!("Identity created successfully. ID: {}", identity_id);
    Ok(())
}

async fn allocate_resource(node: &IcnNode) -> IcnResult<()> {
    println!("Allocating a resource...");

    let resource_type = get_input("Enter resource type: ")?;
    let amount: u64 = get_input("Enter amount: ")?.parse()?;

    node.allocate_resource(&resource_type, amount).await?;
    println!("Resource allocated successfully");
    Ok(())
}

async fn get_network_stats(node: &IcnNode) -> IcnResult<()> {
    let stats = node.get_network_stats().await?;
    println!("Network Statistics:");
    println!("  Connected Peers: {}", stats.node_count);
    println!("  Total Transactions: {}", stats.total_transactions);
    println!("  Active Proposals: {}", stats.active_proposals);
    Ok(())
}

fn get_input(prompt: &str) -> IcnResult<String> {
    print!("{}", prompt);
    io::stdout().flush()?;
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    Ok(input.trim().to_string())
}

fn get_currency_type() -> IcnResult<CurrencyType> {
    println!("Select currency type:");
    println!("1. BasicNeeds");
    println!("2. Education");
    println!("3. Environmental");
    println!("4. Community");
    let choice: u32 = get_input("Enter choice (1-4): ")?.parse()?;
    match choice {
        1 => Ok(CurrencyType::BasicNeeds),
        2 => Ok(CurrencyType::Education),
        3 => Ok(CurrencyType::Environmental),
        4 => Ok(CurrencyType::Community),
        _ => Err(IcnError::InvalidInput("Invalid currency type choice".to_string())),
    }
}

fn get_proposal_type() -> IcnResult<ProposalType> {
    println!("Select proposal type:");
    println!("1. Constitutional");
    println!("2. EconomicAdjustment");
    println!("3. NetworkUpgrade");
    let choice: u32 = get_input("Enter choice (1-3): ")?.parse()?;
    match choice {
        1 => Ok(ProposalType::Constitutional),
        2 => Ok(ProposalType::EconomicAdjustment),
        3 => Ok(ProposalType::NetworkUpgrade),
        _ => Err(IcnError::InvalidInput("Invalid proposal type choice".to_string())),
    }
}

fn get_proposal_category() -> IcnResult<ProposalCategory> {
    println!("Select proposal category:");
    println!("1. Economic");
    println!("2. Technical");
    println!("3. Social");
    let choice: u32 = get_input("Enter choice (1-3): ")?.parse()?;
    match choice {
        1 => Ok(ProposalCategory::Economic),
        2 => Ok(ProposalCategory::Technical),
        3 => Ok(ProposalCategory::Social),
        _ => Err(IcnError::InvalidInput("Invalid proposal category choice".to_string())),
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_demo/src/main.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_governance/Cargo.toml =====
[package]
name = "icn_governance"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
log = "0.4"
thiserror = "1.0"

[dev-dependencies]
tokio = { version = "1.0", features = ["full"] }===== END OF /home/matt/InterCooperative-Network/crates/icn_governance/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_governance/src/democracy.rs =====
use icn_utils::{Error, Result, Proposal, Vote};
use chrono::{DateTime, Utc, Duration};
use serde::{Serialize, Deserialize};
use std::collections::HashMap;
use log::{info, error, debug, warn};

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum ProposalCategory {
    Constitutional,
    Economic,
    Technical,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum ProposalStatus {
    Active,
    Passed,
    Rejected,
    Implemented,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum ProposalType {
    Constitutional,
    EconomicAdjustment,
    NetworkUpgrade,
}

pub struct DemocraticSystem {
    proposals: HashMap<String, Proposal>,
    votes: HashMap<String, Vec<Vote>>,
}

impl DemocraticSystem {
    pub fn new() -> Self {
        debug!("Creating new DemocraticSystem");
        DemocraticSystem {
            proposals: HashMap::new(),
            votes: HashMap::new(),
        }
    }

    pub fn create_proposal(
        &mut self,
        title: String,
        description: String,
        proposer: String,
        voting_period: Duration,
        proposal_type: ProposalType,
        category: ProposalCategory,
        required_quorum: f64,
        execution_timestamp: Option<DateTime<Utc>>,
    ) -> Result<String> {
        let id = format!("prop_{}", Utc::now().timestamp());
        let proposal = Proposal::new(
            id.clone(),
            title,
            description,
            proposer,
            voting_period,
            proposal_type,
            category,
            required_quorum,
            execution_timestamp,
        );
        self.proposals.insert(id.clone(), proposal);
        info!("New proposal created: {}", id);
        Ok(id)
    }

    pub fn vote(&mut self, voter: String, proposal_id: String, in_favor: bool, weight: f64) -> Result<()> {
        let proposal = self.proposals.get(&proposal_id).ok_or(Error::GovernanceError("Proposal not found".to_string()))?;
        
        if proposal.status != ProposalStatus::Active {
            error!("Attempted to vote on inactive proposal: {}", proposal_id);
            return Err(Error::GovernanceError("Voting is not active for this proposal".to_string()));
        }

        if Utc::now() > proposal.voting_ends_at {
            error!("Attempted to vote on expired proposal: {}", proposal_id);
            return Err(Error::GovernanceError("Voting period has ended".to_string()));
        }

        let vote = Vote::new(voter, proposal_id.clone(), in_favor, weight);
        self.votes.entry(proposal_id.clone()).or_insert_with(Vec::new).push(vote);
        info!("Vote recorded for proposal: {}", proposal_id);
        Ok(())
    }

    pub fn tally_votes(&mut self, proposal_id: &str) -> Result<()> {
        let proposal = self.proposals.get_mut(proposal_id).ok_or(Error::GovernanceError("Proposal not found".to_string()))?;
        
        if proposal.status != ProposalStatus::Active {
            error!("Attempted to tally votes for inactive proposal: {}", proposal_id);
            return Err(Error::GovernanceError("Proposal is not active".to_string()));
        }

        if Utc::now() < proposal.voting_ends_at {
            warn!("Attempted to tally votes before voting period ended: {}", proposal_id);
            return Err(Error::GovernanceError("Voting period has not ended yet".to_string()));
        }

        let votes = self.votes.get(proposal_id).ok_or(Error::GovernanceError("No votes found for this proposal".to_string()))?;
        
        let total_weight: f64 = votes.iter().map(|v| v.weight).sum();
        let weight_in_favor: f64 = votes.iter().filter(|v| v.in_favor).map(|v| v.weight).sum();

        if total_weight < proposal.required_quorum {
            proposal.status = ProposalStatus::Rejected;
            info!("Proposal {} rejected due to insufficient quorum", proposal_id);
            return Ok(());
        }

        if weight_in_favor / total_weight > 0.5 {
            proposal.status = ProposalStatus::Passed;
            info!("Proposal {} passed", proposal_id);
        } else {
            proposal.status = ProposalStatus::Rejected;
            info!("Proposal {} rejected", proposal_id);
        }

        Ok(())
    }

    pub fn get_proposal(&self, proposal_id: &str) -> Option<&Proposal> {
        self.proposals.get(proposal_id)
    }

    pub fn get_votes(&self, proposal_id: &str) -> Option<&Vec<Vote>> {
        self.votes.get(proposal_id)
    }

    pub fn list_active_proposals(&self) -> Vec<&Proposal> {
        self.proposals.values()
            .filter(|p| p.status == ProposalStatus::Active)
            .collect()
    }

    pub fn mark_as_implemented(&mut self, proposal_id: &str) -> Result<()> {
        let proposal = self.proposals.get_mut(proposal_id).ok_or(Error::GovernanceError("Proposal not found".to_string()))?;
        
        if proposal.status != ProposalStatus::Passed {
            error!("Attempted to mark non-passed proposal as implemented: {}", proposal_id);
            return Err(Error::GovernanceError("Proposal has not passed".to_string()));
        }

        proposal.status = ProposalStatus::Implemented;
        info!("Proposal {} marked as implemented", proposal_id);
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_utils::ProposalStatus;

    #[test]
    fn test_democratic_system() {
        let mut system = DemocraticSystem::new();
        
        // Create proposal
        let proposal_id = system.create_proposal(
            "Test Proposal".to_string(),
            "This is a test proposal".to_string(),
            "Alice".to_string(),
            Duration::days(7),
            ProposalType::Constitutional,
            ProposalCategory::Technical,
            0.5,
            None,
        ).unwrap();

        // Vote on proposal
        assert!(system.vote("Bob".to_string(), proposal_id.clone(), true, 1.0).is_ok());
        assert!(system.vote("Charlie".to_string(), proposal_id.clone(), false, 1.0).is_ok());
        assert!(system.vote("David".to_string(), proposal_id.clone(), true, 1.0).is_ok());

        // Try to tally votes before voting period ends (should fail)
        assert!(system.tally_votes(&proposal_id).is_err());

        // Simulate voting period end
        let proposal = system.proposals.get_mut(&proposal_id).unwrap();
        proposal.voting_ends_at = Utc::now() - Duration::hours(1);

        // Tally votes
        assert!(system.tally_votes(&proposal_id).is_ok());

        // Check proposal status
        let proposal = system.get_proposal(&proposal_id).unwrap();
        assert_eq!(proposal.status, ProposalStatus::Passed);

        // Mark as implemented
        assert!(system.mark_as_implemented(&proposal_id).is_ok());
        let updated_proposal = system.get_proposal(&proposal_id).unwrap();
        assert_eq!(updated_proposal.status, ProposalStatus::Implemented);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_governance/src/democracy.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_governance/src/governance.rs =====
// File: crates/icn_governance/src/governance.rs

use crate::{Proposal, ProposalStatus, Vote, ProposalType, ProposalCategory};
use icn_common::{IcnResult, IcnError};
use std::collections::HashMap;
use chrono::Utc;
use log::{info, warn};

/// Represents the governance system managing proposals and votes.
pub struct GovernanceSystem {
    pub proposals: HashMap<String, Proposal>,
    pub votes: HashMap<String, Vec<Vote>>,
}

impl GovernanceSystem {
    /// Creates a new Governance system.
    pub fn new() -> Self {
        GovernanceSystem {
            proposals: HashMap::new(),
            votes: HashMap::new(),
        }
    }

    /// Creates a new proposal in the governance system.
    ///
    /// # Arguments
    ///
    /// * `proposal` - The proposal to be created.
    ///
    /// # Returns
    ///
    /// The ID of the created proposal.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Governance` if the proposal already exists.
    pub fn create_proposal(&mut self, proposal: Proposal) -> IcnResult<String> {
        if self.proposals.contains_key(&proposal.id) {
            return Err(IcnError::Governance("Proposal ID already exists".into()));
        }
        let proposal_id = proposal.id.clone();
        self.proposals.insert(proposal_id.clone(), proposal);
        self.votes.insert(proposal_id.clone(), Vec::new());
        Ok(proposal_id)
    }

    pub fn get_proposal(&self, proposal_id: &str) -> IcnResult<&Proposal> {
        self.proposals.get(proposal_id)
            .ok_or_else(|| IcnError::Governance("Proposal not found".into()))
    }

    pub fn vote_on_proposal(&mut self, proposal_id: &str, voter: String, in_favor: bool, weight: f64) -> IcnResult<()> {
        let proposal = self.proposals.get_mut(proposal_id)
            .ok_or_else(|| IcnError::Governance("Proposal not found".into()))?;

        if proposal.status != ProposalStatus::Active {
            return Err(IcnError::Governance("Proposal is not active".into()));
        }

        if Utc::now() > proposal.voting_ends_at {
            return Err(IcnError::Governance("Voting period has ended".into()));
        }

        let votes = self.votes.get_mut(proposal_id)
            .ok_or_else(|| IcnError::Governance("Votes not found for proposal".into()))?;

        if votes.iter().any(|v| v.voter == voter) {
            return Err(IcnError::Governance("Voter has already voted on this proposal".into()));
        }

        votes.push(Vote::new(voter, proposal_id.to_string(), in_favor, weight));
        Ok(())
    }

    pub fn finalize_proposal(&mut self, proposal_id: &str) -> IcnResult<ProposalStatus> {
        let proposal = self.proposals.get_mut(proposal_id)
            .ok_or_else(|| IcnError::Governance("Proposal not found".into()))?;

        if proposal.status != ProposalStatus::Active {
            return Err(IcnError::Governance("Proposal is not active".into()));
        }

        if Utc::now() < proposal.voting_ends_at {
            return Err(IcnError::Governance("Voting period has not ended yet".into()));
        }

        let votes = self.votes.get(proposal_id)
            .ok_or_else(|| IcnError::Governance("Votes not found for proposal".into()))?;

        let total_votes = votes.len() as f64;
        let votes_in_favor = votes.iter().filter(|v| v.in_favor).count() as f64;

        if total_votes == 0.0 || total_votes / proposal.required_quorum < 1.0 {
            proposal.status = ProposalStatus::Rejected;
        } else if votes_in_favor / total_votes > 0.5 {
            proposal.status = ProposalStatus::Passed;
        } else {
            proposal.status = ProposalStatus::Rejected;
        }

        Ok(proposal.status.clone())
    }

    pub fn list_active_proposals(&self) -> Vec<&Proposal> {
        self.proposals.values()
            .filter(|p| p.status == ProposalStatus::Active)
            .collect()
    }
}

impl Default for GovernanceSystem {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Duration;

    fn create_test_proposal(id: &str) -> Proposal {
        Proposal {
            id: id.to_string(),
            title: "Test Proposal".to_string(),
            description: "This is a test proposal".to_string(),
            proposer: "Alice".to_string(),
            created_at: Utc::now(),
            voting_ends_at: Utc::now() + Duration::days(7),
            status: ProposalStatus::Active,
            proposal_type: ProposalType::Constitutional,
            category: ProposalCategory::Technical,
            required_quorum: 0.5,
            execution_timestamp: None,
        }
    }

    #[test]
    fn test_create_proposal() {
        let mut gov_system = GovernanceSystem::new();
        let proposal = create_test_proposal("prop1");
        let proposal_id = gov_system.create_proposal(proposal).unwrap();
        assert_eq!(proposal_id, "prop1");
        assert!(gov_system.get_proposal("prop1").is_ok());
    }

    #[test]
    fn test_vote_on_proposal() {
        let mut gov_system = GovernanceSystem::new();
        let proposal = create_test_proposal("prop1");
        gov_system.create_proposal(proposal).unwrap();

        assert!(gov_system.vote_on_proposal("prop1", "Alice".to_string(), true, 1.0).is_ok());
        assert!(gov_system.vote_on_proposal("prop1", "Bob".to_string(), false, 1.0).is_ok());

        // Test duplicate vote
        assert!(gov_system.vote_on_proposal("prop1", "Alice".to_string(), false, 1.0).is_err());

        // Test vote on non-existent proposal
        assert!(gov_system.vote_on_proposal("prop2", "Charlie".to_string(), true, 1.0).is_err());
    }

    #[test]
    fn test_finalize_proposal() {
        let mut gov_system = GovernanceSystem::new();
        let mut proposal = create_test_proposal("prop1");
        proposal.voting_ends_at = Utc::now() - Duration::hours(1); // Set voting period to have ended
        gov_system.create_proposal(proposal).unwrap();

        gov_system.vote_on_proposal("prop1", "Alice".to_string(), true, 1.0).unwrap();
        gov_system.vote_on_proposal("prop1", "Bob".to_string(), true, 1.0).unwrap();
        gov_system.vote_on_proposal("prop1", "Charlie".to_string(), false, 1.0).unwrap();

        let result = gov_system.finalize_proposal("prop1").unwrap();
        assert_eq!(result, ProposalStatus::Passed);

        // Test finalizing an already finalized proposal
        assert!(gov_system.finalize_proposal("prop1").is_err());
    }

    #[test]
    fn test_list_active_proposals() {
        let mut gov_system = GovernanceSystem::new();
        let proposal1 = create_test_proposal("prop1");
        let proposal2 = create_test_proposal("prop2");
        let mut proposal3 = create_test_proposal("prop3");
        proposal3.status = ProposalStatus::Passed;

        gov_system.create_proposal(proposal1).unwrap();
        gov_system.create_proposal(proposal2).unwrap();
        gov_system.create_proposal(proposal3).unwrap();

        let active_proposals = gov_system.list_active_proposals();
        assert_eq!(active_proposals.len(), 2);
        assert!(active_proposals.iter().any(|p| p.id == "prop1"));
        assert!(active_proposals.iter().any(|p| p.id == "prop2"));
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_governance/src/governance.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_governance/src/lib.rs =====
// File: icn_governance/src/lib.rs

use icn_common::{IcnResult, IcnError};
use chrono::{DateTime, Utc, Duration};
use serde::{Serialize, Deserialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProposalStatus {
    Active,
    Passed,
    Rejected,
    Executed,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProposalType {
    Constitutional,
    EconomicAdjustment,
    NetworkUpgrade,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProposalCategory {
    Economic,
    Technical,
    Social,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proposal {
    pub id: String,
    pub title: String,
    pub description: String,
    pub proposer: String,
    pub created_at: DateTime<Utc>,
    pub voting_ends_at: DateTime<Utc>,
    pub status: ProposalStatus,
    pub proposal_type: ProposalType,
    pub category: ProposalCategory,
    pub required_quorum: f64,
    pub execution_timestamp: Option<DateTime<Utc>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vote {
    pub voter: String,
    pub proposal_id: String,
    pub in_favor: bool,
    pub weight: f64,
    pub timestamp: DateTime<Utc>,
}

pub struct GovernanceSystem {
    proposals: HashMap<String, Proposal>,
    votes: HashMap<String, Vec<Vote>>,
}

impl GovernanceSystem {
    pub fn new() -> Self {
        GovernanceSystem {
            proposals: HashMap::new(),
            votes: HashMap::new(),
        }
    }

    pub fn create_proposal(&mut self, proposal: Proposal) -> IcnResult<String> {
        if self.proposals.contains_key(&proposal.id) {
            return Err(IcnError::Governance("Proposal ID already exists".into()));
        }
        let proposal_id = proposal.id.clone();
        self.proposals.insert(proposal_id.clone(), proposal);
        self.votes.insert(proposal_id.clone(), Vec::new());
        Ok(proposal_id)
    }

    pub fn get_proposal(&self, proposal_id: &str) -> IcnResult<&Proposal> {
        self.proposals.get(proposal_id)
            .ok_or_else(|| IcnError::Governance("Proposal not found".into()))
    }

    pub fn vote_on_proposal(&mut self, proposal_id: &str, voter: String, in_favor: bool, weight: f64) -> IcnResult<()> {
        let proposal = self.proposals.get_mut(proposal_id)
            .ok_or_else(|| IcnError::Governance("Proposal not found".into()))?;

        if proposal.status != ProposalStatus::Active {
            return Err(IcnError::Governance("Proposal is not active".into()));
        }

        if Utc::now() > proposal.voting_ends_at {
            return Err(IcnError::Governance("Voting period has ended".into()));
        }

        let votes = self.votes.get_mut(proposal_id)
            .ok_or_else(|| IcnError::Governance("Votes not found for proposal".into()))?;

        if votes.iter().any(|v| v.voter == voter) {
            return Err(IcnError::Governance("Voter has already voted on this proposal".into()));
        }

        votes.push(Vote {
            voter,
            proposal_id: proposal_id.to_string(),
            in_favor,
            weight,
            timestamp: Utc::now(),
        });

        Ok(())
    }

    pub fn finalize_proposal(&mut self, proposal_id: &str) -> IcnResult<ProposalStatus> {
        let proposal = self.proposals.get_mut(proposal_id)
            .ok_or_else(|| IcnError::Governance("Proposal not found".into()))?;

        if proposal.status != ProposalStatus::Active {
            return Err(IcnError::Governance("Proposal is not active".into()));
        }

        if Utc::now() < proposal.voting_ends_at {
            return Err(IcnError::Governance("Voting period has not ended yet".into()));
        }

        let votes = self.votes.get(proposal_id)
            .ok_or_else(|| IcnError::Governance("Votes not found for proposal".into()))?;

        let total_votes: f64 = votes.iter().map(|v| v.weight).sum();
        let votes_in_favor: f64 = votes.iter().filter(|v| v.in_favor).map(|v| v.weight).sum();

        if total_votes < proposal.required_quorum {
            proposal.status = ProposalStatus::Rejected;
        } else if votes_in_favor / total_votes > 0.5 {
            proposal.status = ProposalStatus::Passed;
        } else {
            proposal.status = ProposalStatus::Rejected;
        }

        Ok(proposal.status.clone())
    }

    pub fn list_active_proposals(&self) -> Vec<&Proposal> {
        self.proposals.values()
            .filter(|p| p.status == ProposalStatus::Active)
            .collect()
    }

    pub fn mark_as_executed(&mut self, proposal_id: &str) -> IcnResult<()> {
        let proposal = self.proposals.get_mut(proposal_id)
            .ok_or_else(|| IcnError::Governance("Proposal not found".into()))?;
        
        if proposal.status != ProposalStatus::Passed {
            return Err(IcnError::Governance("Proposal has not passed".into()));
        }

        proposal.status = ProposalStatus::Executed;
        proposal.execution_timestamp = Some(Utc::now());
        Ok(())
    }

    pub fn get_votes(&self, proposal_id: &str) -> IcnResult<&Vec<Vote>> {
        self.votes.get(proposal_id)
            .ok_or_else(|| IcnError::Governance("Votes not found for proposal".into()))
    }

    pub fn get_proposal_result(&self, proposal_id: &str) -> IcnResult<(f64, f64)> {
        let votes = self.get_votes(proposal_id)?;
        let total_votes: f64 = votes.iter().map(|v| v.weight).sum();
        let votes_in_favor: f64 = votes.iter().filter(|v| v.in_favor).map(|v| v.weight).sum();
        Ok((votes_in_favor, total_votes))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn create_test_proposal() -> Proposal {
        Proposal {
            id: "test_proposal".to_string(),
            title: "Test Proposal".to_string(),
            description: "This is a test proposal".to_string(),
            proposer: "Alice".to_string(),
            created_at: Utc::now(),
            voting_ends_at: Utc::now() + Duration::days(7),
            status: ProposalStatus::Active,
            proposal_type: ProposalType::Constitutional,
            category: ProposalCategory::Economic,
            required_quorum: 0.5,
            execution_timestamp: None,
        }
    }

    #[test]
    fn test_create_proposal() {
        let mut gov_system = GovernanceSystem::new();
        let proposal = create_test_proposal();
        let proposal_id = gov_system.create_proposal(proposal.clone()).unwrap();
        assert_eq!(proposal_id, "test_proposal");
        assert!(gov_system.get_proposal("test_proposal").is_ok());
    }

    #[test]
    fn test_vote_on_proposal() {
        let mut gov_system = GovernanceSystem::new();
        let proposal = create_test_proposal();
        gov_system.create_proposal(proposal).unwrap();

        assert!(gov_system.vote_on_proposal("test_proposal", "Alice".to_string(), true, 1.0).is_ok());
        assert!(gov_system.vote_on_proposal("test_proposal", "Bob".to_string(), false, 1.0).is_ok());

        // Test duplicate vote
        assert!(gov_system.vote_on_proposal("test_proposal", "Alice".to_string(), false, 1.0).is_err());

        // Test vote on non-existent proposal
        assert!(gov_system.vote_on_proposal("non_existent", "Charlie".to_string(), true, 1.0).is_err());
    }

    #[test]
    fn test_finalize_proposal() {
        let mut gov_system = GovernanceSystem::new();
        let mut proposal = create_test_proposal();
        proposal.voting_ends_at = Utc::now() - Duration::hours(1); // Set voting period to have ended
        gov_system.create_proposal(proposal).unwrap();

        gov_system.vote_on_proposal("test_proposal", "Alice".to_string(), true, 1.0).unwrap();
        gov_system.vote_on_proposal("test_proposal", "Bob".to_string(), true, 1.0).unwrap();
        gov_system.vote_on_proposal("test_proposal", "Charlie".to_string(), false, 1.0).unwrap();

        let result = gov_system.finalize_proposal("test_proposal").unwrap();
        assert_eq!(result, ProposalStatus::Passed);

        // Test finalizing an already finalized proposal
        assert!(gov_system.finalize_proposal("test_proposal").is_err());
    }

    #[test]
    fn test_list_active_proposals() {
        let mut gov_system = GovernanceSystem::new();
        let proposal1 = create_test_proposal();
        let mut proposal2 = create_test_proposal();
        proposal2.id = "test_proposal_2".to_string();
        let mut proposal3 = create_test_proposal();
        proposal3.id = "test_proposal_3".to_string();
        proposal3.status = ProposalStatus::Passed;

        gov_system.create_proposal(proposal1).unwrap();
        gov_system.create_proposal(proposal2).unwrap();
        gov_system.create_proposal(proposal3).unwrap();

        let active_proposals = gov_system.list_active_proposals();
        assert_eq!(active_proposals.len(), 2);
        assert!(active_proposals.iter().any(|p| p.id == "test_proposal"));
        assert!(active_proposals.iter().any(|p| p.id == "test_proposal_2"));
    }

    #[test]
    fn test_mark_as_executed() {
        let mut gov_system = GovernanceSystem::new();
        let mut proposal = create_test_proposal();
        proposal.status = ProposalStatus::Passed;
        gov_system.create_proposal(proposal).unwrap();

        assert!(gov_system.mark_as_executed("test_proposal").is_ok());
        let executed_proposal = gov_system.get_proposal("test_proposal").unwrap();
        assert_eq!(executed_proposal.status, ProposalStatus::Executed);
        assert!(executed_proposal.execution_timestamp.is_some());

        // Test marking a non-passed proposal as executed
        let mut proposal2 = create_test_proposal();
        proposal2.id = "test_proposal_2".to_string();
        gov_system.create_proposal(proposal2).unwrap();
        assert!(gov_system.mark_as_executed("test_proposal_2").is_err());
    }

    #[test]
    fn test_get_proposal_result() {
        let mut gov_system = GovernanceSystem::new();
        let proposal = create_test_proposal();
        gov_system.create_proposal(proposal).unwrap();

        gov_system.vote_on_proposal("test_proposal", "Alice".to_string(), true, 1.0).unwrap();
        gov_system.vote_on_proposal("test_proposal", "Bob".to_string(), true, 2.0).unwrap();
        gov_system.vote_on_proposal("test_proposal", "Charlie".to_string(), false, 1.5).unwrap();

        let (votes_in_favor, total_votes) = gov_system.get_proposal_result("test_proposal").unwrap();
        assert_eq!(votes_in_favor, 3.0);
        assert_eq!(total_votes, 4.5);
    }

    #[test]
    fn test_proposal_quorum() {
        let mut gov_system = GovernanceSystem::new();
        let mut proposal = create_test_proposal();
        proposal.required_quorum = 5.0;
        proposal.voting_ends_at = Utc::now() - Duration::hours(1);
        gov_system.create_proposal(proposal).unwrap();

        gov_system.vote_on_proposal("test_proposal", "Alice".to_string(), true, 2.0).unwrap();
        gov_system.vote_on_proposal("test_proposal", "Bob".to_string(), true, 2.0).unwrap();

        let result = gov_system.finalize_proposal("test_proposal").unwrap();
        assert_eq!(result, ProposalStatus::Rejected); // Rejected due to not meeting quorum

        // Test with meeting quorum
        let mut proposal2 = create_test_proposal();
        proposal2.id = "test_proposal_2".to_string();
        proposal2.required_quorum = 5.0;
        proposal2.voting_ends_at = Utc::now() - Duration::hours(1);
        gov_system.create_proposal(proposal2).unwrap();

        gov_system.vote_on_proposal("test_proposal_2", "Alice".to_string(), true, 3.0).unwrap();
        gov_system.vote_on_proposal("test_proposal_2", "Bob".to_string(), true, 3.0).unwrap();

        let result2 = gov_system.finalize_proposal("test_proposal_2").unwrap();
        assert_eq!(result2, ProposalStatus::Passed); // Passed due to meeting quorum and majority
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_governance/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_governance/src/proposal.rs =====
use chrono::{DateTime, Utc, Duration};
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum ProposalCategory {
    Constitutional,
    Economic,
    Technical,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum ProposalStatus {
    Active,
    Passed,
    Rejected,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum ProposalType {
    Constitutional,
    EconomicAdjustment,
    NetworkUpgrade,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Proposal {
    pub id: String,
    pub title: String,
    pub description: String,
    pub proposer: String,
    pub created_at: DateTime<Utc>,
    pub voting_ends_at: DateTime<Utc>,
    pub status: ProposalStatus,
    pub proposal_type: ProposalType,
    pub category: ProposalCategory,
    pub required_quorum: f64,
    pub execution_timestamp: Option<DateTime<Utc>>,
}

impl Proposal {
    #[allow(clippy::too_many_arguments)]
    pub fn new(
        id: String,
        title: String,
        description: String,
        proposer: String,
        voting_period: Duration,
        proposal_type: ProposalType,
        category: ProposalCategory,
        required_quorum: f64,
        execution_timestamp: Option<DateTime<Utc>>,
    ) -> Self {
        let now = Utc::now();
        Proposal {
            id,
            title,
            description,
            proposer,
            created_at: now,
            voting_ends_at: now + voting_period,
            status: ProposalStatus::Active,
            proposal_type,
            category,
            required_quorum,
            execution_timestamp,
        }
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_governance/src/proposal.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_governance/src/voting.rs =====
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Vote {
    pub voter: String,
    pub proposal_id: String,
    pub in_favor: bool,
    pub weight: f64,
    pub timestamp: DateTime<Utc>,
}

impl Vote {
    pub fn new(voter: String, proposal_id: String, in_favor: bool, weight: f64) -> Self {
        Vote {
            voter,
            proposal_id,
            in_favor,
            weight,
            timestamp: Utc::now(),
        }
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_governance/src/voting.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_identity/Cargo.toml =====
[package]
name = "icn_identity"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
ed25519-dalek = "1.0"
rand = "0.7"
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
hex = "0.4"

[dev-dependencies]
tokio = { version = "1.0", features = ["full"] }===== END OF /home/matt/InterCooperative-Network/crates/icn_identity/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_identity/src/did.rs =====
use chrono::{DateTime, Utc};
use ed25519_dalek::{Keypair, PublicKey, Signature, Verifier};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct DecentralizedIdentity {
    pub id: String,
    #[serde(with = "public_key_serde")]
    pub public_key: PublicKey,
    pub created_at: DateTime<Utc>,
    pub reputation: f64,
    pub attributes: HashMap<String, String>,
}

mod public_key_serde {
    use ed25519_dalek::PublicKey;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};

    pub fn serialize<S>(public_key: &PublicKey, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let bytes = public_key.to_bytes();
        bytes.serialize(serializer)
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<PublicKey, D::Error>
    where
        D: Deserializer<'de>,
    {
        let bytes = Vec::<u8>::deserialize(deserializer)?;
        PublicKey::from_bytes(&bytes).map_err(serde::de::Error::custom)
    }
}

impl DecentralizedIdentity {
    pub fn new(attributes: HashMap<String, String>) -> (Self, Keypair) {
        let mut csprng = rand::rngs::OsRng {};
        let keypair: Keypair = Keypair::generate(&mut csprng);
        let public_key = keypair.public;
        let id = format!("did:icn:{}", hex::encode(public_key.to_bytes()));

        (
            Self {
                id,
                public_key,
                created_at: Utc::now(),
                reputation: 1.0,
                attributes,
            },
            keypair,
        )
    }

    pub fn verify_signature(&self, message: &[u8], signature: &Signature) -> bool {
        self.public_key.verify(message, signature).is_ok()
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_identity/src/did.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_identity/src/identity_manager.rs =====
use crate::DecentralizedIdentity;
use ed25519_dalek::Signature;
use icn_common::{IcnError, IcnResult};
use std::collections::HashMap;

pub struct IdentityManager {
    identities: HashMap<String, DecentralizedIdentity>,
}

impl IdentityManager {
    pub fn new() -> Self {
        IdentityManager {
            identities: HashMap::new(),
        }
    }

    pub fn create_identity(&mut self, attributes: HashMap<String, String>) -> IcnResult<DecentralizedIdentity> {
        let (identity, _) = DecentralizedIdentity::new(attributes);
        self.identities.insert(identity.id.clone(), identity.clone());
        Ok(identity)
    }

    pub fn get_identity(&self, id: &str) -> IcnResult<&DecentralizedIdentity> {
        self.identities
            .get(id)
            .ok_or_else(|| IcnError::Identity("Identity not found".into()))
    }

    pub fn update_attributes(&mut self, id: &str, attributes: HashMap<String, String>) -> IcnResult<()> {
        let identity = self.identities
            .get_mut(id)
            .ok_or_else(|| IcnError::Identity("Identity not found".into()))?;

        identity.attributes.extend(attributes);
        Ok(())
    }

    pub fn update_reputation(&mut self, id: &str, change: f64) -> IcnResult<()> {
        let identity = self.identities
            .get_mut(id)
            .ok_or_else(|| IcnError::Identity("Identity not found".into()))?;
        identity.reputation += change;
        Ok(())
    }

    pub fn verify_signature(&self, id: &str, message: &[u8], signature: &Signature) -> IcnResult<bool> {
        let identity = self.get_identity(id)?;
        Ok(identity.verify_signature(message, signature))
    }

    pub fn list_identities(&self) -> Vec<&DecentralizedIdentity> {
        self.identities.values().collect()
    }
}

impl Default for IdentityManager {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use ed25519_dalek::{Keypair, Signer};

    #[test]
    fn test_identity_management() {
        let mut manager = IdentityManager::new();
        
        // Create a new identity
        let mut attributes = HashMap::new();
        attributes.insert("name".to_string(), "Alice".to_string());
        let identity = manager.create_identity(attributes).unwrap();
        
        // Verify the identity exists
        assert!(manager.get_identity(&identity.id).is_ok());
        
        // Update reputation
        assert!(manager.update_reputation(&identity.id, 0.5).is_ok());
        let updated_identity = manager.get_identity(&identity.id).unwrap();
        assert_eq!(updated_identity.reputation, 1.5);
        
        // Test signature verification
        let message = b"Hello, World!";
        let mut csprng = rand::rngs::OsRng {};
        let keypair = Keypair::generate(&mut csprng);
        let signature = keypair.sign(message);
        
        // This should fail because we're using a different keypair
        assert!(!manager.verify_signature(&identity.id, message, &signature).unwrap());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_identity/src/identity_manager.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_identity/src/lib.rs =====
// File: icn_identity/src/lib.rs

use icn_common::{IcnResult, IcnError};
use std::collections::HashMap;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use ed25519_dalek::{Keypair, PublicKey, Signature, Signer, Verifier};
use rand::rngs::OsRng;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct DecentralizedIdentity {
    pub id: String,
    pub public_key: PublicKey,
    pub created_at: DateTime<Utc>,
    pub reputation: f64,
    pub attributes: HashMap<String, String>,
}

impl DecentralizedIdentity {
    pub fn new(attributes: HashMap<String, String>) -> (Self, Keypair) {
        let mut csprng = OsRng {};
        let keypair: Keypair = Keypair::generate(&mut csprng);
        let public_key = keypair.public;
        let id = format!("did:icn:{}", hex::encode(public_key.to_bytes()));

        (
            Self {
                id,
                public_key,
                created_at: Utc::now(),
                reputation: 1.0,
                attributes,
            },
            keypair,
        )
    }

    pub fn verify_signature(&self, message: &[u8], signature: &Signature) -> bool {
        self.public_key.verify(message, signature).is_ok()
    }
}

pub struct IdentityService {
    identities: HashMap<String, DecentralizedIdentity>,
}

impl IdentityService {
    pub fn new() -> Self {
        IdentityService {
            identities: HashMap::new(),
        }
    }

    pub fn create_identity(&mut self, attributes: HashMap<String, String>) -> IcnResult<DecentralizedIdentity> {
        let (identity, _) = DecentralizedIdentity::new(attributes);
        self.identities.insert(identity.id.clone(), identity.clone());
        Ok(identity)
    }

    pub fn get_identity(&self, id: &str) -> IcnResult<&DecentralizedIdentity> {
        self.identities.get(id)
            .ok_or_else(|| IcnError::Identity("Identity not found".into()))
    }

    pub fn update_attributes(&mut self, id: &str, attributes: HashMap<String, String>) -> IcnResult<()> {
        let identity = self.identities.get_mut(id)
            .ok_or_else(|| IcnError::Identity("Identity not found".into()))?;

        identity.attributes.extend(attributes);
        Ok(())
    }

    pub fn update_reputation(&mut self, id: &str, change: f64) -> IcnResult<()> {
        let identity = self.identities.get_mut(id)
            .ok_or_else(|| IcnError::Identity("Identity not found".into()))?;
        identity.reputation += change;
        Ok(())
    }

    pub fn verify_signature(&self, id: &str, message: &[u8], signature: &Signature) -> IcnResult<bool> {
        let identity = self.get_identity(id)?;
        Ok(identity.verify_signature(message, signature))
    }

    pub fn list_identities(&self) -> Vec<&DecentralizedIdentity> {
        self.identities.values().collect()
    }

    pub fn remove_identity(&mut self, id: &str) -> IcnResult<()> {
        self.identities.remove(id)
            .ok_or_else(|| IcnError::Identity("Identity not found".into()))?;
        Ok(())
    }

    pub fn get_reputation(&self, id: &str) -> IcnResult<f64> {
        let identity = self.get_identity(id)?;
        Ok(identity.reputation)
    }

    pub fn get_attribute(&self, id: &str, attribute_key: &str) -> IcnResult<Option<String>> {
        let identity = self.get_identity(id)?;
        Ok(identity.attributes.get(attribute_key).cloned())
    }

    pub fn set_attribute(&mut self, id: &str, key: String, value: String) -> IcnResult<()> {
        let identity = self.identities.get_mut(id)
            .ok_or_else(|| IcnError::Identity("Identity not found".into()))?;
        identity.attributes.insert(key, value);
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_identity_creation_and_retrieval() {
        let mut service = IdentityService::new();
        
        let mut attributes = HashMap::new();
        attributes.insert("name".to_string(), "Alice".to_string());
        attributes.insert("email".to_string(), "alice@example.com".to_string());
        
        let identity = service.create_identity(attributes.clone()).unwrap();
        assert!(identity.id.starts_with("did:icn:"));
        
        let retrieved_identity = service.get_identity(&identity.id).unwrap();
        assert_eq!(retrieved_identity.attributes, attributes);
    }

    #[test]
    fn test_update_attributes() {
        let mut service = IdentityService::new();
        
        let mut attributes = HashMap::new();
        attributes.insert("name".to_string(), "Alice".to_string());
        
        let identity = service.create_identity(attributes).unwrap();
        
        let mut new_attributes = HashMap::new();
        new_attributes.insert("email".to_string(), "alice@example.com".to_string());
        
        service.update_attributes(&identity.id, new_attributes).unwrap();
        
        let updated_identity = service.get_identity(&identity.id).unwrap();
        assert_eq!(updated_identity.attributes.get("name"), Some(&"Alice".to_string()));
        assert_eq!(updated_identity.attributes.get("email"), Some(&"alice@example.com".to_string()));
    }

    #[test]
    fn test_update_reputation() {
        let mut service = IdentityService::new();
        
        let attributes = HashMap::new();
        let identity = service.create_identity(attributes).unwrap();
        
        service.update_reputation(&identity.id, 0.5).unwrap();
        let updated_identity = service.get_identity(&identity.id).unwrap();
        assert_eq!(updated_identity.reputation, 1.5);
    }

    #[test]
    fn test_signature_verification() {
        let mut service = IdentityService::new();
        
        let attributes = HashMap::new();
        let (identity, keypair) = DecentralizedIdentity::new(attributes);
        service.identities.insert(identity.id.clone(), identity);
        
        let message = b"Hello, World!";
        let signature = keypair.sign(message);
        
        assert!(service.verify_signature(&identity.id, message, &signature).unwrap());
    }

    #[test]
    fn test_list_identities() {
        let mut service = IdentityService::new();
        
        let attributes1 = HashMap::new();
        let attributes2 = HashMap::new();
        
        service.create_identity(attributes1).unwrap();
        service.create_identity(attributes2).unwrap();
        
        let identities = service.list_identities();
        assert_eq!(identities.len(), 2);
    }

    #[test]
    fn test_remove_identity() {
        let mut service = IdentityService::new();
        
        let attributes = HashMap::new();
        let identity = service.create_identity(attributes).unwrap();
        
        assert!(service.remove_identity(&identity.id).is_ok());
        assert!(service.get_identity(&identity.id).is_err());
    }

    #[test]
    fn test_get_and_set_attribute() {
        let mut service = IdentityService::new();
        
        let mut attributes = HashMap::new();
        attributes.insert("name".to_string(), "Alice".to_string());
        
        let identity = service.create_identity(attributes).unwrap();
        
        assert_eq!(service.get_attribute(&identity.id, "name").unwrap(), Some("Alice".to_string()));
        assert_eq!(service.get_attribute(&identity.id, "email").unwrap(), None);
        
        service.set_attribute(&identity.id, "email".to_string(), "alice@example.com".to_string()).unwrap();
        assert_eq!(service.get_attribute(&identity.id, "email").unwrap(), Some("alice@example.com".to_string()));
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_identity/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_incentives/Cargo.toml =====
[package]
name = "icn_incentives"
version = "0.1.0"
edition = "2021"

[dependencies]
===== END OF /home/matt/InterCooperative-Network/crates/icn_incentives/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_incentives/src/lib.rs =====
pub fn add(left: usize, right: usize) -> usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_incentives/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_language/Cargo.toml =====
[package]
name = "icn_language"
version = "0.1.0"
edition = "2021"

[dependencies]
nom = "7.1.0"
serde = { version = "1.0", features = ["derive"] }
thiserror = "1.0"
log = "0.4"
icn_common = { path = "../icn_common" }
icn_vm = { path = "../icn_vm" }

[dev-dependencies]
env_logger = "0.10"===== END OF /home/matt/InterCooperative-Network/crates/icn_language/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_language/src/bytecode.rs =====
// crates/icn_language/src/bytecode.rs

use crate::Statement;
use icn_vm::Opcode;

pub fn generate_bytecode(statements: &[Statement]) -> Vec<Opcode> {
    let mut bytecode = Vec::new();

    for statement in statements {
        match statement {
            Statement::Net_Node_Connect { node1, node2 } => {
                bytecode.push(Opcode::Push(icn_vm::Value::String(node1.clone())));
                bytecode.push(Opcode::Push(icn_vm::Value::String(node2.clone())));
                bytecode.push(Opcode::NetNodeConnect);
            },
            Statement::Chain_Block_Create { transactions } => {
                for tx in transactions {
                    bytecode.push(Opcode::Push(icn_vm::Value::String(tx.clone())));
                }
                bytecode.push(Opcode::Push(icn_vm::Value::Int(transactions.len() as i64)));
                bytecode.push(Opcode::ChainBlockCreate);
            },
            Statement::Econ_Currency_Mint { amount, currency_type } => {
                bytecode.push(Opcode::Push(icn_vm::Value::Float(*amount)));
                bytecode.push(Opcode::Push(icn_vm::Value::String(currency_type.clone())));
                bytecode.push(Opcode::EconCurrencyMint);
            },
            Statement::Gov_Proposal_Submit { description } => {
                bytecode.push(Opcode::Push(icn_vm::Value::String(description.clone())));
                bytecode.push(Opcode::GovProposalSubmit);
            },
            Statement::Coop_Member_Add { coop_id, member_id } => {
                bytecode.push(Opcode::Push(icn_vm::Value::String(coop_id.clone())));
                bytecode.push(Opcode::Push(icn_vm::Value::String(member_id.clone())));
                bytecode.push(Opcode::CoopMemberAdd);
            },
            Statement::Comm_Event_Organize { event_details } => {
                bytecode.push(Opcode::Push(icn_vm::Value::String(event_details.clone())));
                bytecode.push(Opcode::CommEventOrganize);
            },
            Statement::Vote_On_Proposal { proposal_id, vote } => {
                bytecode.push(Opcode::Push(icn_vm::Value::String(proposal_id.clone())));
                bytecode.push(Opcode::Push(icn_vm::Value::Bool(*vote)));
                bytecode.push(Opcode::VoteOnProposal);
            },
            Statement::Allocate_Resource { resource, amount } => {
                bytecode.push(Opcode::Push(icn_vm::Value::String(resource.clone())));
                bytecode.push(Opcode::Push(icn_vm::Value::Int(*amount)));
                bytecode.push(Opcode::AllocateResource);
            },
            Statement::Update_Reputation { address, change } => {
                bytecode.push(Opcode::Push(icn_vm::Value::String(address.clone())));
                bytecode.push(Opcode::Push(icn_vm::Value::Int(*change)));
                bytecode.push(Opcode::UpdateReputation);
            },
            Statement::Create_Proposal { title, description } => {
                bytecode.push(Opcode::Push(icn_vm::Value::String(title.clone())));
                bytecode.push(Opcode::Push(icn_vm::Value::String(description.clone())));
                bytecode.push(Opcode::CreateProposal);
            },
            Statement::Get_Proposal_Status { proposal_id } => {
                bytecode.push(Opcode::Push(icn_vm::Value::String(proposal_id.clone())));
                bytecode.push(Opcode::GetProposalStatus);
            },
            Statement::Emit_Event { event_name, event_data } => {
                bytecode.push(Opcode::Push(icn_vm::Value::String(event_name.clone())));
                bytecode.push(Opcode::Push(icn_vm::Value::String(event_data.clone())));
                bytecode.push(Opcode::EmitEvent);
            },
        }
    }

    bytecode
}===== END OF /home/matt/InterCooperative-Network/crates/icn_language/src/bytecode.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_language/src/lib.rs =====
use nom::{
    IResult,
    branch::alt,
    bytes::complete::{tag, take_while1},
    character::complete::{char, multispace0},
    combinator::{map, recognize, opt},
    multi::separated_list0,
    sequence::{delimited, pair, tuple},
};
use icn_vm::{Opcode, Value};

#[derive(Debug, PartialEq)]
pub enum Statement {
    NetNodeConnect { node1: String, node2: String },
    ChainBlockCreate { transactions: Vec<String> },
    EconCurrencyMint { amount: f64, currency_type: String },
    GovProposalSubmit { description: String },
    CoopMemberAdd { coop_id: String, member_id: String },
    CommEventOrganize { event_details: String },
    VoteOnProposal { proposal_id: String, vote: bool },
    AllocateResource { resource: String, amount: i64 },
    UpdateReputation { address: String, change: i64 },
    CreateProposal { title: String, description: String },
    GetProposalStatus { proposal_id: String },
    EmitEvent { event_name: String, event_data: String },
}

fn parse_string(input: &str) -> IResult<&str, String> {
    map(
        delimited(
            char('"'),
            take_while1(|c| c != '"'),
            char('"')
        ),
        |s: &str| s.to_string()
    )(input)
}

fn parse_number(input: &str) -> IResult<&str, f64> {
    map(
        recognize(tuple((
            opt(char('-')),
            take_while1(|c: char| c.is_ascii_digit()),
            opt(pair(
                char('.'),
                take_while1(|c: char| c.is_ascii_digit())
            ))
        ))),
        |s: &str| s.parse().unwrap()
    )(input)
}

fn parse_integer(input: &str) -> IResult<&str, i64> {
    map(
        recognize(pair(
            opt(char('-')),
            take_while1(|c: char| c.is_ascii_digit())
        )),
        |s: &str| s.parse().unwrap()
    )(input)
}

fn parse_boolean(input: &str) -> IResult<&str, bool> {
    alt((
        map(tag("true"), |_| true),
        map(tag("false"), |_| false)
    ))(input)
}

fn parse_net_node_connect(input: &str) -> IResult<&str, Statement> {
    map(
        tuple((
            tag("net-node-connect"),
            multispace0,
            char('('),
            multispace0,
            parse_string,
            multispace0,
            char(','),
            multispace0,
            parse_string,
            multispace0,
            char(')')
        )),
        |(_, _, _, _, node1, _, _, _, node2, _, _)| Statement::NetNodeConnect { node1, node2 }
    )(input)
}

fn parse_chain_block_create(input: &str) -> IResult<&str, Statement> {
    map(
        tuple((
            tag("chain-block-create"),
            multispace0,
            char('('),
            multispace0,
            separated_list0(tuple((multispace0, char(','), multispace0)), parse_string),
            multispace0,
            char(')')
        )),
        |(_, _, _, _, transactions, _, _)| Statement::ChainBlockCreate { transactions }
    )(input)
}

fn parse_econ_currency_mint(input: &str) -> IResult<&str, Statement> {
    map(
        tuple((
            tag("econ-currency-mint"),
            multispace0,
            char('('),
            multispace0,
            parse_number,
            multispace0,
            char(','),
            multispace0,
            parse_string,
            multispace0,
            char(')')
        )),
        |(_, _, _, _, amount, _, _, _, currency_type, _, _)| Statement::EconCurrencyMint { amount, currency_type }
    )(input)
}

fn parse_gov_proposal_submit(input: &str) -> IResult<&str, Statement> {
    map(
        tuple((
            tag("gov-proposal-submit"),
            multispace0,
            char('('),
            multispace0,
            parse_string,
            multispace0,
            char(')')
        )),
        |(_, _, _, _, description, _, _)| Statement::GovProposalSubmit { description }
    )(input)
}

fn parse_coop_member_add(input: &str) -> IResult<&str, Statement> {
    map(
        tuple((
            tag("coop-member-add"),
            multispace0,
            char('('),
            multispace0,
            parse_string,
            multispace0,
            char(','),
            multispace0,
            parse_string,
            multispace0,
            char(')')
        )),
        |(_, _, _, _, coop_id, _, _, _, member_id, _, _)| Statement::CoopMemberAdd { coop_id, member_id }
    )(input)
}

fn parse_comm_event_organize(input: &str) -> IResult<&str, Statement> {
    map(
        tuple((
            tag("comm-event-organize"),
            multispace0,
            char('('),
            multispace0,
            parse_string,
            multispace0,
            char(')')
        )),
        |(_, _, _, _, event_details, _, _)| Statement::CommEventOrganize { event_details }
    )(input)
}

fn parse_vote_on_proposal(input: &str) -> IResult<&str, Statement> {
    map(
        tuple((
            tag("vote-on-proposal"),
            multispace0,
            char('('),
            multispace0,
            parse_string,
            multispace0,
            char(','),
            multispace0,
            parse_boolean,
            multispace0,
            char(')')
        )),
        |(_, _, _, _, proposal_id, _, _, _, vote, _, _)| Statement::VoteOnProposal { proposal_id, vote }
    )(input)
}

fn parse_allocate_resource(input: &str) -> IResult<&str, Statement> {
    map(
        tuple((
            tag("allocate-resource"),
            multispace0,
            char('('),
            multispace0,
            parse_string,
            multispace0,
            char(','),
            multispace0,
            parse_integer,
            multispace0,
            char(')')
        )),
        |(_, _, _, _, resource, _, _, _, amount, _, _)| Statement::AllocateResource { resource, amount }
    )(input)
}

fn parse_update_reputation(input: &str) -> IResult<&str, Statement> {
    map(
        tuple((
            tag("update-reputation"),
            multispace0,
            char('('),
            multispace0,
            parse_string,
            multispace0,
            char(','),
            multispace0,
            parse_integer,
            multispace0,
            char(')')
        )),
        |(_, _, _, _, address, _, _, _, change, _, _)| Statement::UpdateReputation { address, change }
    )(input)
}

fn parse_create_proposal(input: &str) -> IResult<&str, Statement> {
    map(
        tuple((
            tag("create-proposal"),
            multispace0,
            char('('),
            multispace0,
            parse_string,
            multispace0,
            char(','),
            multispace0,
            parse_string,
            multispace0,
            char(')')
        )),
        |(_, _, _, _, title, _, _, _, description, _, _)| Statement::CreateProposal { title, description }
    )(input)
}

fn parse_get_proposal_status(input: &str) -> IResult<&str, Statement> {
    map(
        tuple((
            tag("get-proposal-status"),
            multispace0,
            char('('),
            multispace0,
            parse_string,
            multispace0,
            char(')')
        )),
        |(_, _, _, _, proposal_id, _, _)| Statement::GetProposalStatus { proposal_id }
    )(input)
}

fn parse_emit_event(input: &str) -> IResult<&str, Statement> {
    map(
        tuple((
            tag("emit-event"),
            multispace0,
            char('('),
            multispace0,
            parse_string,
            multispace0,
            char(','),
            multispace0,
            parse_string,
            multispace0,
            char(')')
        )),
        |(_, _, _, _, event_name, _, _, _, event_data, _, _)| Statement::EmitEvent { event_name, event_data }
    )(input)
}

fn parse_statement(input: &str) -> IResult<&str, Statement> {
    alt((
        parse_net_node_connect,
        parse_chain_block_create,
        parse_econ_currency_mint,
        parse_gov_proposal_submit,
        parse_coop_member_add,
        parse_comm_event_organize,
        parse_vote_on_proposal,
        parse_allocate_resource,
        parse_update_reputation,
        parse_create_proposal,
        parse_get_proposal_status,
        parse_emit_event
    ))(input)
}

pub fn compile(source: &str) -> Result<Vec<Statement>, String> {
    let mut statements = Vec::new();
    let mut remaining = source.trim();

    while !remaining.is_empty() {
        match parse_statement(remaining) {
            Ok((rest, statement)) => {
                statements.push(statement);
                remaining = rest.trim();
            }
            Err(nom::Err::Error(e)) | Err(nom::Err::Failure(e)) => {
                return Err(format!("Failed to parse statement: {:?}", e));
            }
            Err(_) => return Err("Unknown parsing error".to_string()),
        }
    }

    Ok(statements)
}

pub fn generate_bytecode(statements: &[Statement]) -> Vec<Opcode> {
    let mut bytecode = Vec::new();

    for statement in statements {
        match statement {
            Statement::NetNodeConnect { node1, node2 } => {
                bytecode.push(Opcode::Push(Value::String(node1.clone())));
                bytecode.push(Opcode::Push(Value::String(node2.clone())));
                bytecode.push(Opcode::NetNodeConnect);
            },
            Statement::ChainBlockCreate { transactions } => {
                for tx in transactions {
                    bytecode.push(Opcode::Push(Value::String(tx.clone())));
                }
                bytecode.push(Opcode::Push(Value::Int(transactions.len() as i64)));
                bytecode.push(Opcode::ChainBlockCreate);
            },
            Statement::EconCurrencyMint { amount, currency_type } => {
                bytecode.push(Opcode::Push(Value::Float(*amount)));
                bytecode.push(Opcode::Push(Value::String(currency_type.clone())));
                bytecode.push(Opcode::EconCurrencyMint);
            },
            Statement::GovProposalSubmit { description } => {
                bytecode.push(Opcode::Push(Value::String(description.clone())));
                bytecode.push(Opcode::GovProposalSubmit);
            },
            Statement::CoopMemberAdd { coop_id, member_id } => {
                bytecode.push(Opcode::Push(Value::String(coop_id.clone())));
                bytecode.push(Opcode::Push(Value::String(member_id.clone())));
                bytecode.push(Opcode::CoopMemberAdd);
            },
            Statement::CommEventOrganize { event_details } => {
                bytecode.push(Opcode::Push(Value::String(event_details.clone())));
                bytecode.push(Opcode::CommEventOrganize);
            },
            Statement::VoteOnProposal { proposal_id, vote } => {
                bytecode.push(Opcode::Push(Value::String(proposal_id.clone())));
                bytecode.push(Opcode::Push(Value::Bool(*vote)));
                bytecode.push(Opcode::VoteOnProposal);
            },
            Statement::AllocateResource { resource, amount } => {
                bytecode.push(Opcode::Push(Value::String(resource.clone())));
                bytecode.push(Opcode::Push(Value::Int(*amount)));
                bytecode.push(Opcode::AllocateResource);
            },
            Statement::UpdateReputation { address, change } => {
                bytecode.push(Opcode::Push(Value::String(address.clone())));
                bytecode.push(Opcode::Push(Value::Int(*change)));
                bytecode.push(Opcode::UpdateReputation);
            },
            Statement::CreateProposal { title, description } => {
                bytecode.push(Opcode::Push(Value::String(title.clone())));
                bytecode.push(Opcode::Push(Value::String(description.clone())));
                bytecode.push(Opcode::CreateProposal);
            },
            Statement::GetProposalStatus { proposal_id } => {
                bytecode.push(Opcode::Push(Value::String(proposal_id.clone())));
                bytecode.push(Opcode::GetProposalStatus);
            },
            Statement::EmitEvent { event_name, event_data } => {
                bytecode.push(Opcode::Push(Value::String(event_name.clone())));
                bytecode.push(Opcode::Push(Value::String(event_data.clone())));
                bytecode.push(Opcode::EmitEvent);
            },
        }
    }

    bytecode
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_net_node_connect() {
        let input = r#"net-node-connect("node1", "node2")"#;
        let result = parse_net_node_connect(input);
        assert!(result.is_ok());
        let (_, statement) = result.unwrap();
        assert_eq!(statement, Statement::NetNodeConnect {
            node1: "node1".to_string(),
            node2: "node2".to_string(),
        });
    }

    #[test]
    fn test_parse_chain_block_create() {
        let input = r#"chain-block-create("tx1", "tx2", "tx3")"#;
        let result = parse_chain_block_create(input);
        assert!(result.is_ok());
        let (_, statement) = result.unwrap();
        assert_eq!(statement, Statement::ChainBlockCreate {
            transactions: vec!["tx1".to_string(), "tx2".to_string(), "tx3".to_string()],
        });
    }

    #[test]
    fn test_parse_econ_currency_mint() {
        let input = r#"econ-currency-mint(100.5, "BasicNeeds")"#;
        let result = parse_econ_currency_mint(input);
        assert!(result.is_ok());
        let (_, statement) = result.unwrap();
        assert_eq!(statement, Statement::EconCurrencyMint {
            amount: 100.5,
            currency_type: "BasicNeeds".to_string(),
        });
    }

    #[test]
    fn test_parse_gov_proposal_submit() {
        let input = r#"gov-proposal-submit("Increase node count")"#;
        let result = parse_gov_proposal_submit(input);
        assert!(result.is_ok());
        let (_, statement) = result.unwrap();
        assert_eq!(statement, Statement::GovProposalSubmit {
            description: "Increase node count".to_string(),
        });
    }

    #[test]
    fn test_parse_coop_member_add() {
        let input = r#"coop-member-add("coop1", "member1")"#;
        let result = parse_coop_member_add(input);
        assert!(result.is_ok());
        let (_, statement) = result.unwrap();
        assert_eq!(statement, Statement::CoopMemberAdd {
            coop_id: "coop1".to_string(),
            member_id: "member1".to_string(),
        });
    }

    #[test]
    fn test_parse_comm_event_organize() {
        let input = r#"comm-event-organize("Community meetup on Saturday")"#;
        let result = parse_comm_event_organize(input);
        assert!(result.is_ok());
        let (_, statement) = result.unwrap();
        assert_eq!(statement, Statement::CommEventOrganize {
            event_details: "Community meetup on Saturday".to_string(),
        });
    }

    #[test]
    fn test_parse_vote_on_proposal() {
        let input = r#"vote-on-proposal("proposal1", true)"#;
        let result = parse_vote_on_proposal(input);
        assert!(result.is_ok());
        let (_, statement) = result.unwrap();
        assert_eq!(statement, Statement::VoteOnProposal {
            proposal_id: "proposal1".to_string(),
            vote: true,
        });
    }

    #[test]
    fn test_parse_allocate_resource() {
        let input = r#"allocate-resource("computing_power", 100)"#;
        let result = parse_allocate_resource(input);
        assert!(result.is_ok());
        let (_, statement) = result.unwrap();
        assert_eq!(statement, Statement::AllocateResource {
            resource: "computing_power".to_string(),
            amount: 100,
        });
    }

    #[test]
    fn test_parse_update_reputation() {
        let input = r#"update-reputation("user1", 5)"#;
        let result = parse_update_reputation(input);
        assert!(result.is_ok());
        let (_, statement) = result.unwrap();
        assert_eq!(statement, Statement::UpdateReputation {
            address: "user1".to_string(),
            change: 5,
        });
    }

    #[test]
    fn test_parse_create_proposal() {
        let input = r#"create-proposal("New Policy", "Implement resource sharing")"#;
        let result = parse_create_proposal(input);
        assert!(result.is_ok());
        let (_, statement) = result.unwrap();
        assert_eq!(statement, Statement::CreateProposal {
            title: "New Policy".to_string(),
            description: "Implement resource sharing".to_string(),
        });
    }

    #[test]
    fn test_parse_get_proposal_status() {
        let input = r#"get-proposal-status("proposal1")"#;
        let result = parse_get_proposal_status(input);
        assert!(result.is_ok());
        let (_, statement) = result.unwrap();
        assert_eq!(statement, Statement::GetProposalStatus {
            proposal_id: "proposal1".to_string(),
        });
    }

    #[test]
    fn test_parse_emit_event() {
        let input = r#"emit-event("NewMember", "Alice joined the network")"#;
        let result = parse_emit_event(input);
        assert!(result.is_ok());
        let (_, statement) = result.unwrap();
        assert_eq!(statement, Statement::EmitEvent {
            event_name: "NewMember".to_string(),
            event_data: "Alice joined the network".to_string(),
        });
    }

    #[test]
    fn test_compile_multiple_statements() {
        let input = r#"
            net-node-connect("node1", "node2")
            econ-currency-mint(100.0, "BasicNeeds")
            gov-proposal-submit("Increase node count")
            coop-member-add("coop1", "Alice")
            comm-event-organize("Community meetup")
            vote-on-proposal("proposal1", true)
            allocate-resource("computing_power", 50)
            update-reputation("Bob", 10)
            create-proposal("New Policy", "Implement resource sharing")
            get-proposal-status("proposal2")
            emit-event("NetworkUpdate", "New node added")
        "#;
        let result = compile(input);
        assert!(result.is_ok());
        let statements = result.unwrap();
        assert_eq!(statements.len(), 11);
        assert!(matches!(statements[0], Statement::NetNodeConnect { .. }));
        assert!(matches!(statements[1], Statement::EconCurrencyMint { .. }));
        assert!(matches!(statements[2], Statement::GovProposalSubmit { .. }));
        assert!(matches!(statements[3], Statement::CoopMemberAdd { .. }));
        assert!(matches!(statements[4], Statement::CommEventOrganize { .. }));
        assert!(matches!(statements[5], Statement::VoteOnProposal { .. }));
        assert!(matches!(statements[6], Statement::AllocateResource { .. }));
        assert!(matches!(statements[7], Statement::UpdateReputation { .. }));
        assert!(matches!(statements[8], Statement::CreateProposal { .. }));
        assert!(matches!(statements[9], Statement::GetProposalStatus { .. }));
        assert!(matches!(statements[10], Statement::EmitEvent { .. }));
    }

    #[test]
    fn test_compile_with_whitespace() {
        let input = r#"
            net-node-connect("node1", "node2")
            
            econ-currency-mint(100.0, "BasicNeeds")
                gov-proposal-submit("Increase node count")
            
        "#;
        let result = compile(input);
        assert!(result.is_ok());
        let statements = result.unwrap();
        assert_eq!(statements.len(), 3);
    }

    #[test]
    fn test_compile_error() {
        let input = r#"
            net-node-connect("node1", "node2")
            invalid-statement()
            econ-currency-mint(100.0, "BasicNeeds")
        "#;
        let result = compile(input);
        assert!(result.is_err());
    }

    #[test]
    fn test_generate_bytecode() {
        let statements = vec![
            Statement::NetNodeConnect {
                node1: "node1".to_string(),
                node2: "node2".to_string(),
            },
            Statement::EconCurrencyMint {
                amount: 100.0,
                currency_type: "BasicNeeds".to_string(),
            },
        ];

        let bytecode = generate_bytecode(&statements);
        
        assert_eq!(bytecode.len(), 5);
        assert!(matches!(bytecode[0], Opcode::Push(Value::String(_))));
        assert!(matches!(bytecode[1], Opcode::Push(Value::String(_))));
        assert!(matches!(bytecode[2], Opcode::NetNodeConnect));
        assert!(matches!(bytecode[3], Opcode::Push(Value::Float(_))));
        assert!(matches!(bytecode[4], Opcode::Push(Value::String(_))));
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_language/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_market/Cargo.toml =====
[package]
name = "icn_market"
version = "0.1.0"
edition = "2018"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
icn_common = { path = "../icn_common" }
===== END OF /home/matt/InterCooperative-Network/crates/icn_market/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_market/src/entities.rs =====
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Cooperative {
    pub id: String,
    pub name: String,
    pub resources: HashMap<String, f64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Member {
    pub id: String,
    pub name: String,
    pub skills: HashMap<String, f64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Community {
    pub id: String,
    pub name: String,
    pub members: HashMap<String, Member>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Resource {
    pub name: String,
    pub quantity: f64,
    pub unit: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Labor {
    pub skill: String,
    pub hours: f64,
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_market/src/entities.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_market/src/lib.rs =====
pub mod entities;
pub mod market;
pub mod transaction;

pub use entities::*;
pub use market::*;
pub use transaction::*;
===== END OF /home/matt/InterCooperative-Network/crates/icn_market/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_market/src/market.rs =====
use crate::entities::{Cooperative, Community, Member, Resource, Labor};
use crate::transaction::{Transaction, TransactionType, TransactionResult};
use std::collections::HashMap;

#[derive(Debug, Clone)]
pub struct Market {
    pub cooperatives: HashMap<String, Cooperative>,
    pub communities: HashMap<String, Community>,
    pub members: HashMap<String, Member>,
    pub transactions: Vec<Transaction>,
}

impl Market {
    pub fn new() -> Self {
        Market {
            cooperatives: HashMap::new(),
            communities: HashMap::new(),
            members: HashMap::new(),
            transactions: Vec::new(),
        }
    }

    pub fn add_cooperative(&mut self, cooperative: Cooperative) {
        self.cooperatives.insert(cooperative.id.clone(), cooperative);
    }

    pub fn add_community(&mut self, community: Community) {
        self.communities.insert(community.id.clone(), community);
    }

    pub fn add_member(&mut self, member: Member) {
        self.members.insert(member.id.clone(), member);
    }

    pub fn trade_resource(&mut self, from_id: &str, to_id: &str, resource: Resource) -> TransactionResult {
        let transaction = Transaction::new(
            TransactionType::ResourceTrade,
            from_id.to_string(),
            to_id.to_string(),
            Some(resource.clone()),
            None,
        );

        if let Some(from_coop) = self.cooperatives.get_mut(from_id) {
            if let Some(to_coop) = self.cooperatives.get_mut(to_id) {
                from_coop.resources.entry(resource.name.clone()).and_modify(|e| *e -= resource.quantity);
                to_coop.resources.entry(resource.name.clone()).and_modify(|e| *e += resource.quantity).or_insert(resource.quantity);
                self.transactions.push(transaction);
                return Ok(());
            }
        }

        if let Some(from_comm) = self.communities.get_mut(from_id) {
            if let Some(to_comm) = self.communities.get_mut(to_id) {
                from_comm.members.get_mut(&resource.name).unwrap().skills.entry(resource.name.clone()).and_modify(|e| *e -= resource.quantity);
                to_comm.members.get_mut(&resource.name).unwrap().skills.entry(resource.name.clone()).and_modify(|e| *e += resource.quantity).or_insert(resource.quantity);
                self.transactions.push(transaction);
                return Ok(());
            }
        }

        if let Some(from_mem) = self.members.get_mut(from_id) {
            if let Some(to_mem) = self.members.get_mut(to_id) {
                from_mem.skills.entry(resource.name.clone()).and_modify(|e| *e -= resource.quantity);
                to_mem.skills.entry(resource.name.clone()).and_modify(|e| *e += resource.quantity).or_insert(resource.quantity);
                self.transactions.push(transaction);
                return Ok(());
            }
        }

        Err("Invalid trade".into())
    }

    pub fn exchange_labor(&mut self, from_id: &str, to_id: &str, labor: Labor) -> TransactionResult {
        let transaction = Transaction::new(
            TransactionType::LaborExchange,
            from_id.to_string(),
            to_id.to_string(),
            None,
            Some(labor.clone()),
        );

        if let Some(from_mem) = self.members.get_mut(from_id) {
            if let Some(to_mem) = self.members.get_mut(to_id) {
                from_mem.skills.entry(labor.skill.clone()).and_modify(|e| *e -= labor.hours);
                to_mem.skills.entry(labor.skill.clone()).and_modify(|e| *e += labor.hours).or_insert(labor.hours);
                self.transactions.push(transaction);
                return Ok(());
            }
        }

        Err("Invalid exchange".into())
    }
}

impl Default for Market {
    fn default() -> Self {
        Self::new()
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_market/src/market.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_market/src/market_tests.rs =====
use icn_market::{Market, Cooperative, Community, Member, Resource, Labor};
use std::collections::HashMap;

#[test]
fn test_trade_resource_between_cooperatives() {
    let mut market = Market::new();
    
    let mut coop1 = Cooperative {
        id: "coop1".to_string(),
        name: "Cooperative 1".to_string(),
        resources: HashMap::new(),
    };
    coop1.resources.insert("Wheat".to_string(), 100.0);
    
    let coop2 = Cooperative {
        id: "coop2".to_string(),
        name: "Cooperative 2".to_string(),
        resources: HashMap::new(),
    };
    
    market.add_cooperative(coop1);
    market.add_cooperative(coop2);
    
    let resource = Resource {
        name: "Wheat".to_string(),
        quantity: 50.0,
        unit: "kg".to_string(),
    };
    
    assert!(market.trade_resource("coop1", "coop2", resource).is_ok());
}

#[test]
fn test_exchange_labor_between_members() {
    let mut market = Market::new();
    
    let mut member1 = Member {
        id: "member1".to_string(),
        name: "Member 1".to_string(),
        skills: HashMap::new(),
    };
    member1.skills.insert("Carpentry".to_string(), 20.0);
    
    let member2 = Member {
        id: "member2".to_string(),
        name: "Member 2".to_string(),
        skills: HashMap::new(),
    };
    
    market.add_member(member1);
    market.add_member(member2);
    
    let labor = Labor {
        skill: "Carpentry".to_string(),
        hours: 10.0,
    };
    
    assert!(market.exchange_labor("member1", "member2", labor).is_ok());
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_market/src/market_tests.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_market/src/transaction.rs =====
use crate::entities::{Resource, Labor};
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TransactionType {
    ResourceTrade,
    LaborExchange,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Transaction {
    pub transaction_type: TransactionType,
    pub from_id: String,
    pub to_id: String,
    pub resource: Option<Resource>,
    pub labor: Option<Labor>,
}

impl Transaction {
    pub fn new(
        transaction_type: TransactionType,
        from_id: String,
        to_id: String,
        resource: Option<Resource>,
        labor: Option<Labor>,
    ) -> Self {
        Transaction {
            transaction_type,
            from_id,
            to_id,
            resource,
            labor,
        }
    }
}

pub type TransactionResult = Result<(), String>;
===== END OF /home/matt/InterCooperative-Network/crates/icn_market/src/transaction.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/Cargo.toml =====
[package]
name = "icn_network"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
icn_blockchain = { path = "../icn_blockchain" }
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
log = "0.4"
thiserror = "1.0"
tokio = { version = "1.0", features = ["full"] }

===== END OF /home/matt/InterCooperative-Network/crates/icn_network/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/src/discovery.rs =====
use icn_common::{IcnError, IcnResult};
use std::sync::{Arc, RwLock};
use log::{info, error};

/// Represents a node discovery mechanism in the network.
pub struct NodeDiscovery {
    discovered_nodes: Arc<RwLock<Vec<String>>>,
}

impl NodeDiscovery {
    /// Creates a new instance of NodeDiscovery.
    pub fn new() -> Self {
        NodeDiscovery {
            discovered_nodes: Arc::new(RwLock::new(Vec::new())),
        }
    }

    /// Starts the node discovery process.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn start(&self) -> IcnResult<()> {
        info!("Node discovery started");
        // Simulated discovery process
        let nodes = vec!["Node1".to_string(), "Node2".to_string()];
        let mut discovered_nodes = self.discovered_nodes.write().unwrap();
        *discovered_nodes = nodes;
        Ok(())
    }

    /// Stops the node discovery process.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn stop(&self) -> IcnResult<()> {
        info!("Node discovery stopped");
        let mut discovered_nodes = self.discovered_nodes.write().unwrap();
        discovered_nodes.clear();
        Ok(())
    }

    /// Retrieves the list of discovered nodes.
    ///
    /// # Returns
    ///
    /// * `Vec<String>` - A vector containing the discovered nodes.
    pub fn get_discovered_nodes(&self) -> Vec<String> {
        let discovered_nodes = self.discovered_nodes.read().unwrap();
        discovered_nodes.clone()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_node_discovery() {
        let discovery = NodeDiscovery::new();
        assert!(discovery.start().is_ok());
        assert_eq!(discovery.get_discovered_nodes().len(), 2);
        assert!(discovery.stop().is_ok());
        assert!(discovery.get_discovered_nodes().is_empty());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_network/src/discovery.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/src/lib.rs =====
use icn_common::{IcnResult, IcnError, Transaction};
use icn_blockchain::Block; // Correct import
use std::net::SocketAddr;
use std::collections::HashMap;
use std::time::{Duration, Instant};
use tokio::sync::mpsc;
use log::{info};

pub struct Network {
    local_addr: SocketAddr,
    peers: HashMap<SocketAddr, PeerInfo>,
    start_time: Option<Instant>,
    event_sender: mpsc::Sender<NetworkEvent>,
    event_receiver: mpsc::Receiver<NetworkEvent>,
}

#[allow(dead_code)]
struct PeerInfo {
    last_seen: Instant,
}

#[derive(Debug)]
pub enum NetworkEvent {
    NewTransaction(Transaction),
    NewBlock(Block),
    PeerConnected(SocketAddr),
    PeerDisconnected(SocketAddr),
}

impl Network {
    pub fn new(local_addr: SocketAddr) -> Self {
        let (event_sender, event_receiver) = mpsc::channel(100); // Adjust buffer size as needed
        Network {
            local_addr,
            peers: HashMap::new(),
            start_time: None,
            event_sender,
            event_receiver,
        }
    }

    pub async fn start(&mut self) -> IcnResult<()> {
        info!("Starting network on {}", self.local_addr);
        self.start_time = Some(Instant::now());
        // Implement actual network initialization here
        Ok(())
    }

    pub async fn stop(&mut self) -> IcnResult<()> {
        info!("Stopping network");
        self.start_time = None;
        // Implement network shutdown here
        Ok(())
    }

    pub fn get_connected_peers(&self) -> Vec<SocketAddr> {
        self.peers.keys().cloned().collect()
    }

    pub fn get_uptime(&self) -> Duration {
        self.start_time.map_or(Duration::from_secs(0), |start| start.elapsed())
    }

    pub async fn connect_to_peer(&mut self, peer_addr: SocketAddr) -> IcnResult<()> {
        // Implement peer connection logic
        self.peers.insert(peer_addr, PeerInfo { last_seen: Instant::now() });
        self.event_sender.send(NetworkEvent::PeerConnected(peer_addr)).await
            .map_err(|e| IcnError::Network(format!("Failed to send peer connected event: {}", e)))?;
        Ok(())
    }

    pub async fn disconnect_from_peer(&mut self, peer_addr: &SocketAddr) -> IcnResult<()> {
        // Implement peer disconnection logic
        self.peers.remove(peer_addr);
        self.event_sender.send(NetworkEvent::PeerDisconnected(*peer_addr)).await
            .map_err(|e| IcnError::Network(format!("Failed to send peer disconnected event: {}", e)))?;
        Ok(())
    }

    pub async fn broadcast_transaction(&self, transaction: Transaction) -> IcnResult<()> {
        // Implement transaction broadcasting to all peers
        for peer_addr in self.peers.keys() {
            info!("Broadcasting transaction to peer: {}", peer_addr);
        }
        self.event_sender.send(NetworkEvent::NewTransaction(transaction)).await
            .map_err(|e| IcnError::Network(format!("Failed to send new transaction event: {}", e)))?;
        Ok(())
    }

    pub async fn broadcast_block(&self, block: Block) -> IcnResult<()> {
        // Implement block broadcasting to all peers
        for peer_addr in self.peers.keys() {
            info!("Broadcasting block to peer: {}", peer_addr);
        }
        self.event_sender.send(NetworkEvent::NewBlock(block)).await
            .map_err(|e| IcnError::Network(format!("Failed to send new block event: {}", e)))?;
        Ok(())
    }

    pub async fn receive_event(&mut self) -> Option<NetworkEvent> {
        self.event_receiver.recv().await
    }

    pub async fn handle_incoming_message(&mut self, peer_addr: SocketAddr, message: &[u8]) -> IcnResult<()> {
        info!("Received message from peer {}: {:?}", peer_addr, message);
        Ok(())
    }

    pub async fn broadcast_cross_shard_transaction(&self, _cross_shard_tx: CrossShardTransaction) -> IcnResult<()> {
        for peer_addr in self.peers.keys() {
            info!("Broadcasting cross-shard transaction to peer: {}", peer_addr);
        }
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct CrossShardTransaction {
    pub transaction: Transaction,
    pub from_shard: u64,
    pub to_shard: u64,
}

#[cfg(test)]
mod tests {
    use super::*;
    use tokio::runtime::Runtime;
    use icn_common::CurrencyType;

    #[test]
    fn test_network_operations() {
        let rt = Runtime::new().unwrap();
        rt.block_on(async {
            let mut network = Network::new("127.0.0.1:8000".parse().unwrap());

            assert!(network.start().await.is_ok());

            let peer_addr: SocketAddr = "127.0.0.1:8001".parse().unwrap();
            assert!(network.connect_to_peer(peer_addr).await.is_ok());
            assert_eq!(network.get_connected_peers().len(), 1);

            assert!(network.disconnect_from_peer(&peer_addr).await.is_ok());
            assert_eq!(network.get_connected_peers().len(), 0);

            let transaction = Transaction {
                from: "Alice".to_string(),
                to: "Bob".to_string(),
                amount: 100.0,
                currency_type: CurrencyType::BasicNeeds,
                timestamp: chrono::Utc::now().timestamp(),
                signature: None,
            };
            assert!(network.broadcast_transaction(transaction).await.is_ok());

            let block = Block {
                index: 1,
                timestamp: chrono::Utc::now().timestamp(),
                transactions: vec![],
                previous_hash: "previous_hash".to_string(),
                hash: "current_hash".to_string(),
            };
            assert!(network.broadcast_block(block).await.is_ok());

            if let Some(event) = network.receive_event().await {
                match event {
                    NetworkEvent::NewTransaction(_) => println!("Received new transaction event"),
                    NetworkEvent::NewBlock(_) => println!("Received new block event"),
                    NetworkEvent::PeerConnected(_) => println!("Received peer connected event"),
                    NetworkEvent::PeerDisconnected(_) => println!("Received peer disconnected event"),
                }
            }

            assert!(network.stop().await.is_ok());
        });
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_network/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/src/naming.rs =====
use icn_common::{IcnError, IcnResult};
use log::{info, error};

/// Represents a naming service in the ICN project.
pub struct NamingService;

impl NamingService {
    /// Creates a new instance of NamingService.
    pub fn new() -> Self {
        NamingService
    }

    /// Starts the naming service.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn start(&self) -> IcnResult<()> {
        info!("Naming service started");
        // Simulated naming service start process
        Ok(())
    }

    /// Stops the naming service.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn stop(&self) -> IcnResult<()> {
        info!("Naming service stopped");
        // Simulated naming service stop process
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_naming_service_start_and_stop() {
        let naming_service = NamingService::new();
        assert!(naming_service.start().is_ok());
        assert!(naming_service.stop().is_ok());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_network/src/naming.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/src/network.rs =====
use crate::{discovery::NodeDiscovery, protocol::NetworkProtocol, routing::Router, security::NetworkSecurity};
use icn_common::{IcnError, IcnResult};
use std::sync::{Arc, RwLock};

/// Represents a network in the ICN project.
pub struct Network {
    discovery: Arc<RwLock<NodeDiscovery>>,
    protocol: Arc<RwLock<NetworkProtocol>>,
    router: Arc<RwLock<Router>>,
    security: Arc<RwLock<NetworkSecurity>>,
}

impl Network {
    /// Creates a new network instance.
    ///
    /// # Arguments
    ///
    /// * `discovery` - Arc to the node discovery module.
    /// * `protocol` - Arc to the network protocol module.
    /// * `router` - Arc to the routing module.
    /// * `security` - Arc to the network security module.
    ///
    /// # Returns
    ///
    /// * `Network` - A new instance of Network.
    pub fn new(
        discovery: Arc<RwLock<NodeDiscovery>>,
        protocol: Arc<RwLock<NetworkProtocol>>,
        router: Arc<RwLock<Router>>,
        security: Arc<RwLock<NetworkSecurity>>,
    ) -> Self {
        Network {
            discovery,
            protocol,
            router,
            security,
        }
    }

    /// Starts the network.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn start(&self) -> IcnResult<()> {
        let discovery = self.discovery.read().unwrap();
        discovery.start()?;

        let protocol = self.protocol.read().unwrap();
        protocol.start()?;

        let router = self.router.read().unwrap();
        router.start()?;

        let security = self.security.read().unwrap();
        security.start()?;

        Ok(())
    }

    /// Stops the network.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn stop(&self) -> IcnResult<()> {
        let discovery = self.discovery.read().unwrap();
        discovery.stop()?;

        let protocol = self.protocol.read().unwrap();
        protocol.stop()?;

        let router = self.router.read().unwrap();
        router.stop()?;

        let security = self.security.read().unwrap();
        security.stop()?;

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::discovery::MockNodeDiscovery;
    use crate::protocol::MockNetworkProtocol;
    use crate::routing::MockRouter;
    use crate::security::MockNetworkSecurity;
    use std::sync::Arc;

    #[test]
    fn test_network_start_and_stop() {
        let discovery = Arc::new(RwLock::new(MockNodeDiscovery::new()));
        let protocol = Arc::new(RwLock::new(MockNetworkProtocol::new()));
        let router = Arc::new(RwLock::new(MockRouter::new()));
        let security = Arc::new(RwLock::new(MockNetworkSecurity::new()));

        let network = Network::new(discovery, protocol, router, security);

        assert!(network.start().is_ok());
        assert!(network.stop().is_ok());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_network/src/network.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/src/node.rs =====
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub enum NodeType {
    PersonalDevice,
    CooperativeServer,
    GovernmentServer,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Node {
    pub id: String,
    pub node_type: NodeType,
    pub address: String,
}

impl Node {
    pub fn new(id: &str, node_type: NodeType, address: &str) -> Self {
        Node {
            id: id.to_string(),
            node_type,
            address: address.to_string(),
        }
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_network/src/node.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/src/packet.rs =====
use icn_common::{IcnError, IcnResult};
use serde::{Serialize, Deserialize};

/// Represents a network packet in the ICN project.
#[derive(Serialize, Deserialize, Debug)]
pub struct Packet {
    pub source: String,
    pub destination: String,
    pub payload: Vec<u8>,
}

impl Packet {
    /// Creates a new packet.
    ///
    /// # Arguments
    ///
    /// * `source` - The source address.
    /// * `destination` - The destination address.
    /// * `payload` - The packet payload.
    ///
    /// # Returns
    ///
    /// * `Packet` - A new instance of Packet.
    pub fn new(source: String, destination: String, payload: Vec<u8>) -> Self {
        Packet {
            source,
            destination,
            payload,
        }
    }

    /// Validates the packet.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the packet is invalid.
    pub fn validate(&self) -> IcnResult<()> {
        if self.source.is_empty() || self.destination.is_empty() {
            return Err(IcnError::Network("Invalid packet: source or destination is empty".into()));
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_packet_creation_and_validation() {
        let packet = Packet::new("Source".to_string(), "Destination".to_string(), vec![1, 2, 3]);
        assert!(packet.validate().is_ok());

        let invalid_packet = Packet::new("".to_string(), "Destination".to_string(), vec![1, 2, 3]);
        assert!(invalid_packet.validate().is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_network/src/packet.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/src/protocol.rs =====
use icn_common::{IcnError, IcnResult};
use log::{info, error};

/// Represents a network protocol in the ICN project.
pub struct NetworkProtocol;

impl NetworkProtocol {
    /// Creates a new instance of NetworkProtocol.
    pub fn new() -> Self {
        NetworkProtocol
    }

    /// Starts the network protocol.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn start(&self) -> IcnResult<()> {
        info!("Network protocol started");
        // Simulated protocol start process
        Ok(())
    }

    /// Stops the network protocol.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn stop(&self) -> IcnResult<()> {
        info!("Network protocol stopped");
        // Simulated protocol stop process
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_protocol_start_and_stop() {
        let protocol = NetworkProtocol::new();
        assert!(protocol.start().is_ok());
        assert!(protocol.stop().is_ok());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_network/src/protocol.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/src/routing.rs =====
use icn_common::{IcnError, IcnResult};
use log::{info, error};

/// Represents a router in the ICN project.
pub struct Router;

impl Router {
    /// Creates a new instance of Router.
    pub fn new() -> Self {
        Router
    }

    /// Starts the router.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn start(&self) -> IcnResult<()> {
        info!("Router started");
        // Simulated router start process
        Ok(())
    }

    /// Stops the router.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn stop(&self) -> IcnResult<()> {
        info!("Router stopped");
        // Simulated router stop process
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_router_start_and_stop() {
        let router = Router::new();
        assert!(router.start().is_ok());
        assert!(router.stop().is_ok());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_network/src/routing.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/src/security.rs =====
use icn_common::{IcnError, IcnResult};
use log::{info, error};

/// Represents network security in the ICN project.
pub struct NetworkSecurity;

impl NetworkSecurity {
    /// Creates a new instance of NetworkSecurity.
    pub fn new() -> Self {
        NetworkSecurity
    }

    /// Starts the network security module.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn start(&self) -> IcnResult<()> {
        info!("Network security started");
        // Simulated security start process
        Ok(())
    }

    /// Stops the network security module.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn stop(&self) -> IcnResult<()> {
        info!("Network security stopped");
        // Simulated security stop process
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_security_start_and_stop() {
        let security = NetworkSecurity::new();
        assert!(security.start().is_ok());
        assert!(security.stop().is_ok());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_network/src/security.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_node_management/Cargo.toml =====
[package]
name = "icn_node_management"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_core = { path = "../icn_core" }
icn_network = { path = "../icn_network" }
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
log = "0.4"
thiserror = "1.0"

[dev-dependencies]
tokio = { version = "1.0", features = ["full"] }
===== END OF /home/matt/InterCooperative-Network/crates/icn_node_management/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/content_store.rs =====
use icn_common::{IcnError, IcnResult};
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use log::{info, error};

/// Represents a content store in the ICN project.
pub struct ContentStore {
    store: Arc<RwLock<HashMap<String, Vec<u8>>>>,
}

impl ContentStore {
    /// Creates a new instance of ContentStore.
    pub fn new() -> Self {
        ContentStore {
            store: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// Stores content in the content store.
    ///
    /// # Arguments
    ///
    /// * `content_id` - The ID of the content.
    /// * `data` - The content data.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn store(&self, content_id: String, data: Vec<u8>) -> IcnResult<()> {
        let mut store = self.store.write().unwrap();
        store.insert(content_id.clone(), data);
        info!("Content stored with ID: {}", content_id);
        Ok(())
    }

    /// Retrieves content from the content store.
    ///
    /// # Arguments
    ///
    /// * `content_id` - The ID of the content to be retrieved.
    ///
    /// # Returns
    ///
    /// * `IcnResult<Vec<u8>>` - The retrieved content data.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn retrieve(&self, content_id: &str) -> IcnResult<Vec<u8>> {
        let store = self.store.read().unwrap();
        store.get(content_id).cloned().ok_or_else(|| IcnError::Storage("Content not found".into()))
    }

    /// Removes content from the content store.
    ///
    /// # Arguments
    ///
    /// * `content_id` - The ID of the content to be removed.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn remove(&self, content_id: &str) -> IcnResult<()> {
        let mut store = self.store.write().unwrap();
        store.remove(content_id);
        info!("Content removed with ID: {}", content_id);
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_store_and_retrieve_content() {
        let content_store = ContentStore::new();
        let content_id = "content_1".to_string();
        let data = vec![1, 2, 3];
        assert!(content_store.store(content_id.clone(), data.clone()).is_ok());
        let retrieved_data = content_store.retrieve(&content_id).unwrap();
        assert_eq!(retrieved_data, data);
    }

    #[test]
    fn test_retrieve_non_existent_content() {
        let content_store = ContentStore::new();
        assert!(content_store.retrieve("non_existent_content").is_err());
    }

    #[test]
    fn test_remove_content() {
        let content_store = ContentStore::new();
        let content_id = "content_1".to_string();
        let data = vec![1, 2, 3];
        content_store.store(content_id.clone(), data).unwrap();
        assert!(content_store.remove(&content_id).is_ok());
        assert!(content_store.retrieve(&content_id).is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/content_store.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/fib.rs =====
use icn_common::{IcnError, IcnResult};
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use log::{info, error};

/// Represents a Forwarding Information Base (FIB) in the ICN project.
pub struct FIB {
    table: Arc<RwLock<HashMap<String, String>>>,
}

impl FIB {
    /// Creates a new instance of FIB.
    pub fn new() -> Self {
        FIB {
            table: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// Adds an entry to the FIB.
    ///
    /// # Arguments
    ///
    /// * `prefix` - The prefix of the entry.
    /// * `next_hop` - The next hop for the entry.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn add_entry(&self, prefix: String, next_hop: String) -> IcnResult<()> {
        let mut table = self.table.write().unwrap();
        table.insert(prefix.clone(), next_hop);
        info!("FIB entry added: {} -> {}", prefix, next_hop);
        Ok(())
    }

    /// Retrieves the next hop for a given prefix.
    ///
    /// # Arguments
    ///
    /// * `prefix` - The prefix to retrieve the next hop for.
    ///
    /// # Returns
    ///
    /// * `IcnResult<String>` - The next hop.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn get_next_hop(&self, prefix: &str) -> IcnResult<String> {
        let table = self.table.read().unwrap();
        table.get(prefix).cloned().ok_or_else(|| IcnError::Network("Next hop not found".into()))
    }

    /// Removes an entry from the FIB.
    ///
    /// # Arguments
    ///
    /// * `prefix` - The prefix of the entry to be removed.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn remove_entry(&self, prefix: &str) -> IcnResult<()> {
        let mut table = self.table.write().unwrap();
        table.remove(prefix);
        info!("FIB entry removed: {}", prefix);
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add_and_get_next_hop() {
        let fib = FIB::new();
        let prefix = "prefix_1".to_string();
        let next_hop = "next_hop_1".to_string();
        assert!(fib.add_entry(prefix.clone(), next_hop.clone()).is_ok());
        let retrieved_next_hop = fib.get_next_hop(&prefix).unwrap();
        assert_eq!(retrieved_next_hop, next_hop);
    }

    #[test]
    fn test_get_non_existent_next_hop() {
        let fib = FIB::new();
        assert!(fib.get_next_hop("non_existent_prefix").is_err());
    }

    #[test]
    fn test_remove_entry() {
        let fib = FIB::new();
        let prefix = "prefix_1".to_string();
        let next_hop = "next_hop_1".to_string();
        fib.add_entry(prefix.clone(), next_hop).unwrap();
        assert!(fib.remove_entry(&prefix).is_ok());
        assert!(fib.get_next_hop(&prefix).is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/fib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/icn_node.rs =====
use crate::{content_store::ContentStore, fib::FIB, pit::PIT};
use icn_common::{IcnError, IcnResult};
use log::{info, error};
use std::sync::{Arc, RwLock};

/// Represents an ICN node.
pub struct IcnNode {
    content_store: Arc<ContentStore>,
    fib: Arc<FIB>,
    pit: Arc<PIT>,
}

impl IcnNode {
    /// Creates a new instance of IcnNode.
    ///
    /// # Arguments
    ///
    /// * `content_store` - Arc to the content store.
    /// * `fib` - Arc to the FIB.
    /// * `pit` - Arc to the PIT.
    ///
    /// # Returns
    ///
    /// * `IcnNode` - A new instance of IcnNode.
    pub fn new(content_store: Arc<ContentStore>, fib: Arc<FIB>, pit: Arc<PIT>) -> Self {
        IcnNode {
            content_store,
            fib,
            pit,
        }
    }

    /// Processes an interest packet.
    ///
    /// # Arguments
    ///
    /// * `interest` - The interest packet to be processed.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn process_interest(&self, interest: &str) -> IcnResult<()> {
        // Check content store for the data
        if let Ok(data) = self.content_store.retrieve(interest) {
            // Data found, send data packet
            info!("Data found for interest: {}", interest);
            self.send_data_packet(interest, data)?;
        } else {
            // Data not found, forward interest packet
            info!("Data not found for interest: {}, forwarding", interest);
            let next_hop = self.fib.get_next_hop(interest)?;
            self.forward_interest_packet(interest, &next_hop)?;
        }
        Ok(())
    }

    /// Sends a data packet.
    ///
    /// # Arguments
    ///
    /// * `interest` - The interest associated with the data.
    /// * `data` - The data to be sent.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    fn send_data_packet(&self, interest: &str, data: Vec<u8>) -> IcnResult<()> {
        info!("Sending data packet for interest: {}", interest);
        // Simulate sending data packet
        Ok(())
    }

    /// Forwards an interest packet.
    ///
    /// # Arguments
    ///
    /// * `interest` - The interest packet to be forwarded.
    /// * `next_hop` - The next hop to forward the interest packet to.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    fn forward_interest_packet(&self, interest: &str, next_hop: &str) -> IcnResult<()> {
        info!("Forwarding interest packet: {} to next hop: {}", interest, next_hop);
        // Simulate forwarding interest packet
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::content_store::MockContentStore;
    use crate::fib::MockFIB;
    use crate::pit::MockPIT;

    #[test]
    fn test_process_interest() {
        let content_store = Arc::new(MockContentStore::new());
        let fib = Arc::new(MockFIB::new());
        let pit = Arc::new(MockPIT::new());

        let node = IcnNode::new(content_store, fib, pit);

        assert!(node.process_interest("interest_1").is_ok());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/icn_node.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/lib.rs =====
/// The ICN node management module.
pub mod content_store;
pub mod fib;
pub mod icn_node;
pub mod node;
pub mod pit;
===== END OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/node.rs =====
// ===============================================
// Content Store, FIB, and PIT Implementation
// ===============================================
// This file defines the structures and methods for the Content Store, Forwarding Information Base (FIB),
// and Pending Interest Table (PIT) used in the ICN Node.
//
// Key concepts:
// - Content Store: A cache for storing data packets temporarily.
// - Forwarding Information Base (FIB): A table that stores routing information for named data.
// - Pending Interest Table (PIT): A table that keeps track of interests that have been forwarded but not yet satisfied.

use std::collections::HashMap;

/// A struct representing a packet in the ICN Node.
#[derive(Clone)]
pub struct Packet {
    pub packet_type: PacketType,
    pub name: String,
    pub content: Vec<u8>,
}

/// Enum representing the type of a packet, either Interest or Data.
#[derive(Clone)]
pub enum PacketType {
    Interest,
    Data,
}

/// A struct representing the Content Store.
pub struct ContentStore {
    store: HashMap<String, Vec<u8>>,
}

impl ContentStore {
    /// Creates a new Content Store.
    pub fn new() -> Self {
        ContentStore {
            store: HashMap::new(),
        }
    }

    /// Inserts data into the Content Store.
    /// # Arguments
    /// * `name` - The name of the data.
    /// * `content` - The content of the data.
    pub fn insert(&mut self, name: String, content: Vec<u8>) {
        self.store.insert(name, content);
    }

    /// Retrieves data from the Content Store.
    /// # Arguments
    /// * `name` - The name of the data.
    /// # Returns
    /// An optional reference to the content if it exists.
    pub fn get(&self, name: &str) -> Option<&Vec<u8>> {
        self.store.get(name)
    }

    /// Checks if the Content Store is empty.
    /// # Returns
    /// True if the Content Store is empty, otherwise false.
    pub fn is_empty(&self) -> bool {
        self.store.is_empty()
    }
}

/// A struct representing the Forwarding Information Base (FIB).
pub struct ForwardingInformationBase {
    table: HashMap<String, Vec<String>>,
}

impl ForwardingInformationBase {
    /// Creates a new FIB.
    pub fn new() -> Self {
        ForwardingInformationBase {
            table: HashMap::new(),
        }
    }

    /// Adds an entry to the FIB.
    /// # Arguments
    /// * `name` - The name of the data.
    /// * `interface` - The interface to forward the data.
    pub fn add_entry(&mut self, name: String, interface: String) {
        self.table.entry(name).or_insert(Vec::new()).push(interface);
    }

    /// Retrieves the interfaces for a given name from the FIB.
    /// # Arguments
    /// * `name` - The name of the data.
    /// # Returns
    /// An optional reference to a vector of interfaces if they exist.
    pub fn get_interfaces(&self, name: &str) -> Option<&Vec<String>> {
        self.table.get(name)
    }

    /// Checks if the FIB is empty.
    /// # Returns
    /// True if the FIB is empty, otherwise false.
    pub fn is_empty(&self) -> bool {
        self.table.is_empty()
    }
}

/// A struct representing the Pending Interest Table (PIT).
pub struct PendingInterestTable {
    table: HashMap<String, Vec<String>>,
}

impl PendingInterestTable {
    /// Creates a new PIT.
    pub fn new() -> Self {
        PendingInterestTable {
            table: HashMap::new(),
        }
    }

    /// Adds an interest to the PIT.
    /// # Arguments
    /// * `name` - The name of the interest.
    /// * `interface` - The interface from which the interest came.
    pub fn add_interest(&mut self, name: String, interface: String) {
        self.table.entry(name).or_insert(Vec::new()).push(interface);
    }

    /// Retrieves the incoming interfaces for a given name from the PIT.
    /// # Arguments
    /// * `name` - The name of the interest.
    /// # Returns
    /// An optional reference to a vector of interfaces if they exist.
    pub fn get_incoming_interfaces(&self, name: &str) -> Option<&Vec<String>> {
        self.table.get(name)
    }

    /// Checks if the PIT is empty.
    /// # Returns
    /// True if the PIT is empty, otherwise false.
    pub fn is_empty(&self) -> bool {
        self.table.is_empty()
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/node.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/pit.rs =====
use icn_common::{IcnError, IcnResult};
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use log::{info, error};

/// Represents a Pending Interest Table (PIT) in the ICN project.
pub struct PIT {
    table: Arc<RwLock<HashMap<String, Vec<String>>>>,
}

impl PIT {
    /// Creates a new instance of PIT.
    pub fn new() -> Self {
        PIT {
            table: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// Adds an interest to the PIT.
    ///
    /// # Arguments
    ///
    /// * `interest` - The interest to be added.
    /// * `requester` - The requester of the interest.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn add_interest(&self, interest: String, requester: String) -> IcnResult<()> {
        let mut table = self.table.write().unwrap();
        table.entry(interest.clone()).or_default().push(requester.clone());
        info!("PIT entry added: {} requested by {}", interest, requester);
        Ok(())
    }

    /// Retrieves the requesters for a given interest.
    ///
    /// # Arguments
    ///
    /// * `interest` - The interest to retrieve the requesters for.
    ///
    /// # Returns
    ///
    /// * `IcnResult<Vec<String>>` - The list of requesters.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn get_requesters(&self, interest: &str) -> IcnResult<Vec<String>> {
        let table = self.table.read().unwrap();
        table.get(interest).cloned().ok_or_else(|| IcnError::Network("Interest not found".into()))
    }

    /// Removes an interest from the PIT.
    ///
    /// # Arguments
    ///
    /// * `interest` - The interest to be removed.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn remove_interest(&self, interest: &str) -> IcnResult<()> {
        let mut table = self.table.write().unwrap();
        table.remove(interest);
        info!("PIT entry removed: {}", interest);
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add_and_get_requesters() {
        let pit = PIT::new();
        let interest = "interest_1".to_string();
        let requester = "requester_1".to_string();
        assert!(pit.add_interest(interest.clone(), requester.clone()).is_ok());
        let requesters = pit.get_requesters(&interest).unwrap();
        assert_eq!(requesters, vec![requester]);
    }

    #[test]
    fn test_get_non_existent_requesters() {
        let pit = PIT::new();
        assert!(pit.get_requesters("non_existent_interest").is_err());
    }

    #[test]
    fn test_remove_interest() {
        let pit = PIT::new();
        let interest = "interest_1".to_string();
        let requester = "requester_1".to_string();
        pit.add_interest(interest.clone(), requester).unwrap();
        assert!(pit.remove_interest(&interest).is_ok());
        assert!(pit.get_requesters(&interest).is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/pit.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_reputation/Cargo.toml =====
[package]
name = "icn_reputation"
version = "0.1.0"
edition = "2021"

[dependencies]
===== END OF /home/matt/InterCooperative-Network/crates/icn_reputation/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_reputation/src/lib.rs =====
// File: crates/icn_common/src/lib.rs

pub mod error;
pub mod bit_utils;

pub use crate::error::{IcnError, IcnResult};

use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};
use ed25519_dalek::{Keypair, PublicKey, Signature, Signer, Verifier}; // Importing the necessary traits and types
use rand_chacha::ChaCha20Rng;
use rand::RngCore; // Importing necessary traits for random number generation
use rand::SeedableRng;
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Config {
    pub shard_count: u64,
    pub consensus_threshold: f64,
    pub consensus_quorum: f64,
    pub network_port: u16,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct Transaction {
    pub from: String,
    pub to: String,
    pub amount: f64,
    pub currency_type: CurrencyType,
    pub timestamp: i64,
    pub signature: Option<Vec<u8>>,
}

impl Transaction {
    pub fn new(from: String, to: String, amount: f64, currency_type: CurrencyType, timestamp: i64) -> Self {
        Transaction {
            from,
            to,
            amount,
            currency_type,
            timestamp,
            signature: None,
        }
    }

    pub fn sign(&mut self, keypair: &Keypair) -> IcnResult<()> {
        let message = format!("{}{}{}{}", self.from, self.to, self.amount, self.timestamp);
        let signature = keypair.sign(message.as_bytes()).to_bytes().to_vec();
        self.signature = Some(signature);
        Ok(())
    }

    pub fn verify(&self) -> IcnResult<bool> {
        if let Some(signature) = &self.signature {
            let message = format!("{}{}{}{}", self.from, self.to, self.amount, self.timestamp);
            let public_key = PublicKey::from_bytes(&self.from.as_bytes())
                .map_err(|e| IcnError::Identity(format!("PublicKey conversion failed: {}", e)))?;
            let signature = Signature::from_bytes(signature)
                .map_err(|e| IcnError::Identity(format!("Signature conversion failed: {}", e)))?;
            public_key
                .verify(message.as_bytes(), &signature)
                .map_err(|e| IcnError::Identity(format!("Signature verification failed: {}", e)))?;
            Ok(true)
        } else {
            Ok(false)
        }
    }

    pub fn get_fee(&self) -> f64 {
        // Simplified fee calculation; in a real implementation, fees would be more complex
        0.01
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proposal {
    pub id: String,
    pub title: String,
    pub description: String,
    pub proposer: String,
    pub created_at: DateTime<Utc>,
    pub voting_ends_at: DateTime<Utc>,
    pub status: ProposalStatus,
    pub proposal_type: ProposalType,
    pub category: ProposalCategory,
    pub required_quorum: f64,
    pub execution_timestamp: Option<DateTime<Utc>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vote {
    pub voter: String,
    pub proposal_id: String,
    pub in_favor: bool,
    pub weight: f64,
    pub timestamp: i64,
    pub zkp: Option<Vec<u8>>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProposalStatus {
    Active,
    Passed,
    Rejected,
    Executed,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProposalType {
    Constitutional,
    EconomicAdjustment,
    NetworkUpgrade,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProposalCategory {
    Economic,
    Technical,
    Social,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum CurrencyType {
    BasicNeeds,
    Education,
    Environmental,
    Community,
    Custom(String),
}

#[derive(Debug, Serialize, Deserialize)]
pub struct NetworkStats {
    pub node_count: usize,
    pub total_transactions: usize,
    pub active_proposals: usize,
}

#[cfg(test)]
mod tests {
    use super::*;
    use ed25519_dalek::Signer;
    use rand_chacha::ChaCha20Rng;
    use rand::SeedableRng;

    #[test]
    fn test_transaction_equality() {
        let tx1 = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 50.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: 0,
            signature: None,
        };

        let tx2 = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 50.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: 0,
            signature: None,
        };

        assert_eq!(tx1, tx2);
    }

    #[test]
    fn test_currency_type_equality() {
        assert_eq!(CurrencyType::BasicNeeds, CurrencyType::BasicNeeds);
        assert_ne!(CurrencyType::BasicNeeds, CurrencyType::Education);
    }

    #[test]
    fn test_proposal_status() {
        let status1 = ProposalStatus::Active;
        let status2 = ProposalStatus::Passed;
        assert_ne!(status1, status2);
    }

    #[test]
    fn test_network_stats() {
        let stats = NetworkStats {
            node_count: 5,
            total_transactions: 100,
            active_proposals: 3,
        };
        assert_eq!(stats.node_count, 5);
        assert_eq!(stats.total_transactions, 100);
        assert_eq!(stats.active_proposals, 3);
    }

    #[test]
    fn test_transaction_signing_and_verification() {
        let mut rng = ChaCha20Rng::seed_from_u64(0); // Use a deterministic seed for testing
        let keypair: Keypair = Keypair::generate(&mut rng);

        let mut tx = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 50.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: 0,
            signature: None,
        };

        tx.sign(&keypair).expect("Signing failed");
        assert!(tx.signature.is_some());

        let verified = tx.verify().expect("Verification failed");
        assert!(verified);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_reputation/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_sharding/Cargo.toml =====
[package]
name = "icn_sharding"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
icn_blockchain = { path = "../icn_blockchain" }
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
log = "0.4"
thiserror = "1.0"
chrono = { version = "0.4", features = ["serde"] }
rand = "0.8"
sha2 = "0.9"

[dev-dependencies]
tokio-test = "0.4"===== END OF /home/matt/InterCooperative-Network/crates/icn_sharding/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_sharding/src/cross_shard_communication.rs =====
use crate::blockchain::Transaction;
use crate::sharding::ShardingManager;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{Mutex, mpsc};
use uuid::Uuid;
use icn_common::{Error, Result};

#[derive(Clone, Debug)]
pub struct CrossShardTransaction {
    pub transaction: Transaction,
    pub from_shard: u64,
    pub to_shard: u64,
    pub status: CrossShardTransactionStatus,
}

#[derive(Clone, Debug, PartialEq)]
pub enum CrossShardTransactionStatus {
    Initiated,
    LockAcquired,
    Committed,
    Failed(String),
}

pub struct CrossShardCommunicator {
    sharding_manager: Arc<Mutex<ShardingManager>>,
    pending_transactions: Arc<Mutex<HashMap<String, CrossShardTransaction>>>,
    tx_channels: HashMap<u64, mpsc::Sender<CrossShardTransaction>>,
}

impl CrossShardCommunicator {
    pub fn new(sharding_manager: Arc<Mutex<ShardingManager>>) -> Self {
        let pending_transactions = Arc::new(Mutex::new(HashMap::new()));
        let mut tx_channels = HashMap::new();
        let shard_count = sharding_manager.lock().unwrap().get_shard_count();
        
        for i in 0..shard_count {
            let (tx, mut rx) = mpsc::channel(100);
            tx_channels.insert(i, tx);
            let sm = Arc::clone(&sharding_manager);
            let pt = Arc::clone(&pending_transactions);
            
            tokio::spawn(async move {
                while let Some(transaction) = rx.recv().await {
                    if let Err(e) = Self::process_transaction(sm.clone(), pt.clone(), transaction).await {
                        log::error!("Error processing cross-shard transaction: {}", e);
                    }
                }
            });
        }

        CrossShardCommunicator {
            sharding_manager,
            pending_transactions,
            tx_channels,
        }
    }

    pub async fn initiate_cross_shard_transaction(&self, transaction: Transaction) -> Result<String> {
        let sharding_manager = self.sharding_manager.lock().await;
        let from_shard = sharding_manager.get_shard_for_address(&transaction.from);
        let to_shard = sharding_manager.get_shard_for_address(&transaction.to);

        if from_shard == to_shard {
            return Err(Error::ShardingError("Not a cross-shard transaction".to_string()));
        }

        let cross_shard_tx = CrossShardTransaction {
            transaction: transaction.clone(),
            from_shard,
            to_shard,
            status: CrossShardTransactionStatus::Initiated,
        };

        let tx_id = Uuid::new_v4().to_string();
        self.pending_transactions.lock().await.insert(tx_id.clone(), cross_shard_tx.clone());

        if let Some(tx) = self.tx_channels.get(&from_shard) {
            tx.send(cross_shard_tx).await.map_err(|e| Error::CommunicationError(e.to_string()))?;
        } else {
            return Err(Error::ShardingError(format!("Channel for shard {} not found", from_shard)));
        }

        Ok(tx_id)
    }

    async fn process_transaction(
        sharding_manager: Arc<Mutex<ShardingManager>>,
        pending_transactions: Arc<Mutex<HashMap<String, CrossShardTransaction>>>,
        mut transaction: CrossShardTransaction
    ) -> Result<()> {
        // Phase 1: Lock funds in the source shard
        {
            let mut sm = sharding_manager.lock().await;
            sm.lock_funds_in_shard(
                transaction.from_shard,
                &transaction.transaction.from,
                &transaction.transaction.currency_type,
                transaction.transaction.amount
            )?;
        }
        transaction.status = CrossShardTransactionStatus::LockAcquired;

        // Phase 2: Transfer funds to the destination shard
        {
            let mut sm = sharding_manager.lock().await;
            sm.transfer_between_shards(transaction.from_shard, transaction.to_shard, &transaction.transaction)?;
        }

        // Phase 3: Commit the transaction
        {
            let mut sm = sharding_manager.lock().await;
            sm.commit_cross_shard_transaction(&transaction.transaction, transaction.from_shard, transaction.to_shard)?;
        }

        transaction.status = CrossShardTransactionStatus::Committed;
        pending_transactions.lock().await.insert(Uuid::new_v4().to_string(), transaction);
        Ok(())
    }

    pub async fn get_transaction_status(&self, tx_id: &str) -> Option<CrossShardTransactionStatus> {
        self.pending_transactions.lock().await.get(tx_id).map(|tx| tx.status.clone())
    }

    pub async fn wait_for_transaction(&self, tx_id: &str, timeout: std::time::Duration) -> Result<CrossShardTransactionStatus> {
        let start_time = std::time::Instant::now();
        while start_time.elapsed() < timeout {
            if let Some(status) = self.get_transaction_status(tx_id).await {
                match status {
                    CrossShardTransactionStatus::Committed => return Ok(status),
                    CrossShardTransactionStatus::Failed(reason) => return Err(Error::TransactionFailed(reason)),
                    _ => tokio::time::sleep(std::time::Duration::from_millis(100)).await,
                }
            }
            tokio::time::sleep(std::time::Duration::from_millis(100)).await;
        }
        Err(Error::Timeout("Transaction timeout".to_string()))
    }

    pub async fn cleanup_completed_transactions(&self) {
        let mut pending_transactions = self.pending_transactions.lock().await;
        pending_transactions.retain(|_, tx| {
            match tx.status {
                CrossShardTransactionStatus::Committed => false,
                CrossShardTransactionStatus::Failed(_) => false,
                _ => true,
            }
        });
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_common::CurrencyType;
    use ed25519_dalek::Keypair;
    use rand::rngs::OsRng;

    #[tokio::test]
    async fn test_cross_shard_transaction() {
        let sharding_manager = Arc::new(Mutex::new(ShardingManager::new(2, 10)));
        let communicator = CrossShardCommunicator::new(sharding_manager.clone());

        {
            let mut sm = sharding_manager.lock().await;
            sm.add_address_to_shard("Alice".to_string(), 0);
            sm.add_address_to_shard("Bob".to_string(), 1);
            sm.initialize_balance("Alice".to_string(), CurrencyType::BasicNeeds, 1000.0).unwrap();
        }

        let mut csprng = OsRng{};
        let keypair: Keypair = Keypair::generate(&mut csprng);

        let mut transaction = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            200.0,
            CurrencyType::BasicNeeds,
            1000,
        );
        transaction.sign(&keypair).unwrap();

        let tx_id = communicator.initiate_cross_shard_transaction(transaction).await.unwrap();

        // Wait for the transaction to be processed
        let status = communicator.wait_for_transaction(&tx_id, std::time::Duration::from_secs(5)).await.unwrap();
        assert_eq!(status, CrossShardTransactionStatus::Committed);

        let sm = sharding_manager.lock().await;
        let alice_balance = sm.get_balance("Alice".to_string(), CurrencyType::BasicNeeds).unwrap();
        let bob_balance = sm.get_balance("Bob".to_string(), CurrencyType::BasicNeeds).unwrap();
        
        assert_eq!(alice_balance, 800.0);
        assert_eq!(bob_balance, 200.0);
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_sharding/src/cross_shard_communication.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_sharding/src/cross_shard_sync.rs =====
use icn_common::{Result, Error};
use icn_blockchain::Block;
use std::collections::HashMap;
use tokio::sync::RwLock;
use std::sync::Arc;

pub struct CrossShardSyncManager {
    shard_data: Arc<RwLock<HashMap<u64, Vec<Block>>>>,
}

impl CrossShardSyncManager {
    pub fn new() -> Self {
        CrossShardSyncManager {
            shard_data: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    pub async fn synchronize(&self, shard_id: u64, blocks: Vec<Block>) -> Result<()> {
        let mut shard_data = self.shard_data.write().await;
        shard_data.insert(shard_id, blocks);
        Ok(())
    }

    pub async fn get_shard_data(&self, shard_id: u64) -> Result<Vec<Block>> {
        let shard_data = self.shard_data.read().await;
        shard_data.get(&shard_id)
            .cloned()
            .ok_or_else(|| Error::ShardingError(format!("No data for shard {}", shard_id)))
    }

    pub async fn validate_cross_shard_state(&self) -> Result<bool> {
        // Implement cross-shard state validation logic here
        // This is a placeholder implementation
        Ok(true)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_blockchain::Transaction;

    #[tokio::test]
    async fn test_cross_shard_sync() {
        let sync_manager = CrossShardSyncManager::new();
        
        let block = Block {
            index: 1,
            timestamp: chrono::Utc::now().timestamp(),
            transactions: vec![Transaction::new(
                "Alice".to_string(),
                "Bob".to_string(),
                100.0,
                icn_common::CurrencyType::BasicNeeds,
                0,
            )],
            previous_hash: "previous_hash".to_string(),
            hash: "current_hash".to_string(),
        };

        sync_manager.synchronize(1, vec![block.clone()]).await.unwrap();
        
        let retrieved_blocks = sync_manager.get_shard_data(1).await.unwrap();
        assert_eq!(retrieved_blocks.len(), 1);
        assert_eq!(retrieved_blocks[0].hash, block.hash);

        assert!(sync_manager.validate_cross_shard_state().await.unwrap());
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_sharding/src/cross_shard_sync.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_sharding/src/cross_shard_transaction_manager.rs =====
use icn_common::{IcnResult, IcnError, Block, Transaction, CurrencyType};
use std::collections::HashMap;
use sha2::{Sha256, Digest};

pub struct Shard {
    pub id: u64,
    pub blockchain: Vec<Block>,
    pub balances: HashMap<String, HashMap<CurrencyType, f64>>,
    pub pending_transactions: Vec<Transaction>,
}

pub struct ShardingManager {
    shards: HashMap<u64, Shard>,
    shard_count: u64,
    address_to_shard: HashMap<String, u64>,
}

impl ShardingManager {
    pub fn new(shard_count: u64) -> Self {
        let mut shards = HashMap::new();
        for i in 0..shard_count {
            shards.insert(i, Shard {
                id: i,
                blockchain: vec![Block::genesis()],
                balances: HashMap::new(),
                pending_transactions: Vec::new(),
            });
        }
        
        ShardingManager {
            shards,
            shard_count,
            address_to_shard: HashMap::new(),
        }
    }

    pub fn get_shard_count(&self) -> u64 {
        self.shard_count
    }

    pub fn process_transaction(&mut self, transaction: &Transaction) -> IcnResult<()> {
        let shard_id = self.get_shard_for_address(&transaction.from);
        {
            let shard = self.shards.get_mut(&shard_id).ok_or_else(|| IcnError::Sharding("Shard not found".to_string()))?;
            if !self.verify_transaction(shard, transaction) {
                return Err(IcnError::Sharding("Invalid transaction".to_string()));
            }
            shard.pending_transactions.push(transaction.clone());
        }
        let shard = self.shards.get_mut(&shard_id).ok_or_else(|| IcnError::Sharding("Shard not found".to_string()))?;
        self.update_balances(shard, transaction)
    }

    fn update_balances(&mut self, shard: &mut Shard, transaction: &Transaction) -> IcnResult<()> {
        let sender_balances = shard.balances.entry(transaction.from.clone()).or_insert_with(HashMap::new);
        let sender_balance = sender_balances.entry(transaction.currency_type.clone()).or_insert(0.0);
        
        if *sender_balance < transaction.amount {
            return Err(IcnError::Sharding("Insufficient balance".to_string()));
        }
        
        *sender_balance -= transaction.amount;

        let recipient_balances = shard.balances.entry(transaction.to.clone()).or_insert_with(HashMap::new);
        let recipient_balance = recipient_balances.entry(transaction.currency_type.clone()).or_insert(0.0);
        *recipient_balance += transaction.amount;

        Ok(())
    }

    pub fn create_block(&mut self, shard_id: u64) -> IcnResult<Block> {
        let new_block;
        {
            let shard = self.shards.get_mut(&shard_id).ok_or_else(|| IcnError::Sharding("Shard not found".to_string()))?;
            let previous_block = shard.blockchain.last().ok_or_else(|| IcnError::Sharding("No previous block found".to_string()))?;
            
            new_block = Block {
                index: shard.blockchain.len() as u64,
                timestamp: chrono::Utc::now().timestamp(),
                transactions: shard.pending_transactions.clone(),
                previous_hash: previous_block.hash.clone(),
                hash: String::new(), // Will be set later
            };

            shard.pending_transactions.clear();
        }
        let new_block = self.calculate_block_hash(new_block);
        let shard = self.shards.get_mut(&shard_id).ok_or_else(|| IcnError::Sharding("Shard not found".to_string()))?;
        shard.blockchain.push(new_block.clone());
        Ok(new_block)
    }

    pub fn get_shard_for_address(&self, address: &str) -> u64 {
        *self.address_to_shard.get(address).unwrap_or(&(self.hash_address(address) % self.shard_count))
    }

    pub fn add_address_to_shard(&mut self, address: String, shard_id: u64) -> IcnResult<()> {
        if shard_id >= self.shard_count {
            return Err(IcnError::Sharding("Invalid shard ID".to_string()));
        }
        self.address_to_shard.insert(address, shard_id);
        Ok(())
    }

    pub fn get_balance(&self, address: &str, currency_type: &CurrencyType) -> IcnResult<f64> {
        let shard_id = self.get_shard_for_address(address);
        let shard = self.shards.get(&shard_id).ok_or_else(|| IcnError::Sharding("Shard not found".to_string()))?;
        
        Ok(shard.balances
            .get(address)
            .and_then(|balances| balances.get(currency_type))
            .cloned()
            .unwrap_or(0.0))
    }

    fn verify_transaction(&self, shard: &Shard, transaction: &Transaction) -> bool {
        if let Some(sender_balances) = shard.balances.get(&transaction.from) {
            if let Some(balance) = sender_balances.get(&transaction.currency_type) {
                return *balance >= transaction.amount;
            }
        }
        false
    }

    fn hash_address(&self, address: &str) -> u64 {
        let mut hasher = Sha256::new();
        hasher.update(address.as_bytes());
        let result = hasher.finalize();
        let hash_bytes: [u8; 8] = result[..8].try_into().unwrap_or([0; 8]);
        u64::from_le_bytes(hash_bytes)
    }

    fn calculate_block_hash(&self, mut block: Block) -> Block {
        let mut hasher = Sha256::new();
        hasher.update(block.index.to_string().as_bytes());
        hasher.update(block.timestamp.to_string().as_bytes());
        for transaction in &block.transactions {
            hasher.update(transaction.from.as_bytes());
            hasher.update(transaction.to.as_bytes());
            hasher.update(transaction.amount.to_string().as_bytes());
            hasher.update(format!("{:?}", transaction.currency_type).as_bytes());
        }
        hasher.update(block.previous_hash.as_bytes());
        
        let hash = format!("{:x}", hasher.finalize());
        block.hash = hash;
        block
    }

    pub fn transfer_between_shards(&mut self, from_shard_id: u64, to_shard_id: u64, transaction: &Transaction) -> IcnResult<()> {
        {
            // Deduct from the source shard
            let from_shard = self.shards.get_mut(&from_shard_id).ok_or_else(|| IcnError::Sharding("Source shard not found".to_string()))?;
            self.update_balances(from_shard, transaction)?;
        }

        // Add to the destination shard
        let mut reverse_transaction = transaction.clone();
        reverse_transaction.from = transaction.to.clone();
        reverse_transaction.to = transaction.from.clone();
        {
            let to_shard = self.shards.get_mut(&to_shard_id).ok_or_else(|| IcnError::Sharding("Destination shard not found".to_string()))?;
            self.update_balances(to_shard, &reverse_transaction)?;
        }

        Ok(())
    }

    pub fn get_shard_state(&self, shard_id: u64) -> IcnResult<&Shard> {
        self.shards.get(&shard_id).ok_or_else(|| IcnError::Sharding("Shard not found".to_string()))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sharding_manager() {
        let mut manager = ShardingManager::new(4);
        assert_eq!(manager.get_shard_count(), 4);

        let transaction = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 100.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: 0,
            signature: None,
        };

        manager.add_address_to_shard("Alice".to_string(), 0).unwrap();
        manager.add_address_to_shard("Bob".to_string(), 1).unwrap();

        // Initialize Alice's balance
        let alice_shard = manager.shards.get_mut(&0).unwrap();
        alice_shard.balances.entry("Alice".to_string()).or_insert_with(HashMap::new).insert(CurrencyType::BasicNeeds, 200.0);

        assert!(manager.process_transaction(&transaction).is_ok());

        assert_eq!(manager.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap(), 100.0);
        assert_eq!(manager.get_balance("Bob", &CurrencyType::BasicNeeds).unwrap(), 100.0);

        // Test block creation
        let block = manager.create_block(0).unwrap();
        assert_eq!(block.index, 1);
        assert_eq!(block.transactions.len(), 1);

        // Test cross-shard transaction
        let cross_shard_tx = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 50.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: 1,
            signature: None,
        };

        assert!(manager.transfer_between_shards(0, 1, &cross_shard_tx).is_ok());
        assert_eq!(manager.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap(), 50.0);
        assert_eq!(manager.get_balance("Bob", &CurrencyType::BasicNeeds).unwrap(), 150.0);

        // Test getting shard state
        let shard_state = manager.get_shard_state(0).unwrap();
        assert_eq!(shard_state.id, 0);
        assert_eq!(shard_state.blockchain.len(), 2); // Genesis block + 1 new block

        // Test invalid shard access
        assert!(manager.get_shard_state(10).is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_sharding/src/cross_shard_transaction_manager.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_sharding/src/lib.rs =====
// File: crates/icn_sharding/src/lib.rs

use icn_common::{IcnResult, IcnError, Transaction, CurrencyType};
use std::collections::{HashMap, HashSet};
use std::sync::{Arc, RwLock};
use log::{info, warn, error};
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ShardData {
    pub transactions: Vec<Transaction>,
    pub balances: HashMap<String, HashMap<CurrencyType, f64>>,
}

pub struct ShardingManager {
    shard_count: u64,
    address_to_shard: Arc<RwLock<HashMap<String, u64>>>,
    shard_data: Arc<RwLock<Vec<ShardData>>>,
}

impl ShardingManager {
    pub fn new(shard_count: u64) -> Self {
        let mut shard_data = Vec::with_capacity(shard_count as usize);
        for _ in 0..shard_count {
            shard_data.push(ShardData {
                transactions: Vec::new(),
                balances: HashMap::new(),
            });
        }

        ShardingManager {
            shard_count,
            address_to_shard: Arc::new(RwLock::new(HashMap::new())),
            shard_data: Arc::new(RwLock::new(shard_data)),
        }
    }

    pub fn get_shard_count(&self) -> u64 {
        self.shard_count
    }

    pub fn get_shard_for_address(&self, address: &str) -> u64 {
        let address_to_shard = self.address_to_shard.read().unwrap();
        *address_to_shard.get(address).unwrap_or(&(self.hash_address(address) % self.shard_count))
    }

    pub fn add_address_to_shard(&self, address: String, shard_id: u64) -> IcnResult<()> {
        if shard_id >= self.shard_count {
            return Err(IcnError::Sharding(format!("Invalid shard ID: {}", shard_id)));
        }
        let mut address_to_shard = self.address_to_shard.write().unwrap();
        address_to_shard.insert(address, shard_id);
        Ok(())
    }

    pub fn process_transaction(&self, transaction: &Transaction) -> IcnResult<()> {
        let from_shard = self.get_shard_for_address(&transaction.from);
        let to_shard = self.get_shard_for_address(&transaction.to);

        if from_shard == to_shard {
            self.process_intra_shard_transaction(from_shard, transaction)
        } else {
            self.process_cross_shard_transaction(from_shard, to_shard, transaction)
        }
    }

    fn process_intra_shard_transaction(&self, shard_id: u64, transaction: &Transaction) -> IcnResult<()> {
        let mut shard_data = self.shard_data.write().unwrap();
        let shard = &mut shard_data[shard_id as usize];

        let from_balance = shard.balances
            .entry(transaction.from.clone())
            .or_default()
            .entry(transaction.currency_type.clone())
            .or_insert(0.0);

        if *from_balance < transaction.amount {
            return Err(IcnError::Sharding("Insufficient balance".into()));
        }

        *from_balance -= transaction.amount;
        *shard.balances
            .entry(transaction.to.clone())
            .or_default()
            .entry(transaction.currency_type.clone())
            .or_insert(0.0) += transaction.amount;

        shard.transactions.push(transaction.clone());

        Ok(())
    }

    fn process_cross_shard_transaction(&self, from_shard: u64, to_shard: u64, transaction: &Transaction) -> IcnResult<()> {
        self.lock_funds(from_shard, &transaction.from, transaction.amount, &transaction.currency_type)?;
        self.transfer_between_shards(from_shard, to_shard, transaction)?;
        Ok(())
    }

    fn lock_funds(&self, shard_id: u64, address: &str, amount: f64, currency_type: &CurrencyType) -> IcnResult<()> {
        let mut shard_data = self.shard_data.write().unwrap();
        let shard = &mut shard_data[shard_id as usize];

        let balance = shard.balances
            .entry(address.to_string())
            .or_default()
            .entry(currency_type.clone())
            .or_insert(0.0);

        if *balance < amount {
            return Err(IcnError::Sharding("Insufficient balance to lock".into()));
        }

        *balance -= amount;
        Ok(())
    }

    fn transfer_between_shards(&self, from_shard: u64, to_shard: u64, transaction: &Transaction) -> IcnResult<()> {
        let mut shard_data = self.shard_data.write().unwrap();

        let to_shard_data = &mut shard_data[to_shard as usize];
        *to_shard_data.balances
            .entry(transaction.to.clone())
            .or_default()
            .entry(transaction.currency_type.clone())
            .or_insert(0.0) += transaction.amount;

        shard_data[from_shard as usize].transactions.push(transaction.clone());
        shard_data[to_shard as usize].transactions.push(transaction.clone());

        Ok(())
    }

    pub fn get_balance(&self, address: &str, currency_type: &CurrencyType) -> IcnResult<f64> {
        let shard_id = self.get_shard_for_address(address);
        let shard_data = self.shard_data.read().unwrap();
        let shard = &shard_data[shard_id as usize];
        
        Ok(shard.balances
            .get(address)
            .and_then(|balances| balances.get(currency_type))
            .cloned()
            .unwrap_or(0.0))
    }

    pub fn get_total_balance(&self, address: &str, currency_type: &CurrencyType) -> IcnResult<f64> {
        let mut total_balance = 0.0;
        let shard_data = self.shard_data.read().unwrap();
        
        for shard in shard_data.iter() {
            if let Some(balances) = shard.balances.get(address) {
                if let Some(balance) = balances.get(currency_type) {
                    total_balance += balance;
                }
            }
        }

        Ok(total_balance)
    }

    pub fn initialize_balance(&self, address: &str, currency_type: &CurrencyType, amount: f64) -> IcnResult<()> {
        let shard_id = self.get_shard_for_address(address);
        let mut shard_data = self.shard_data.write().unwrap();
        let shard = &mut shard_data[shard_id as usize];

        shard.balances
            .entry(address.to_string())
            .or_default()
            .insert(currency_type.clone(), amount);

        Ok(())
    }

    pub fn get_shard_transactions(&self, shard_id: u64) -> IcnResult<Vec<Transaction>> {
        if shard_id >= self.shard_count {
            return Err(IcnError::Sharding(format!("Invalid shard ID: {}", shard_id)));
        }

        let shard_data = self.shard_data.read().unwrap();
        Ok(shard_data[shard_id as usize].transactions.clone())
    }

    pub fn get_shard_addresses(&self, shard_id: u64) -> IcnResult<Vec<String>> {
        if shard_id >= self.shard_count {
            return Err(IcnError::Sharding(format!("Invalid shard ID: {}", shard_id)));
        }

        let shard_data = self.shard_data.read().unwrap();
        Ok(shard_data[shard_id as usize].balances.keys().cloned().collect())
    }

    pub fn get_shard_currencies(&self, shard_id: u64) -> IcnResult<Vec<CurrencyType>> {
        if shard_id >= self.shard_count {
            return Err(IcnError::Sharding(format!("Invalid shard ID: {}", shard_id)));
        }

        let shard_data = self.shard_data.read().unwrap();
        let mut currencies = HashSet::new();
        for balances in shard_data[shard_id as usize].balances.values() {
            currencies.extend(balances.keys().cloned());
        }

        Ok(currencies.into_iter().collect())
    }

    pub fn resize_shards(&mut self, new_shard_count: u64) -> IcnResult<()> {
        if new_shard_count == 0 {
            return Err(IcnError::Sharding("Shard count must be greater than zero".into()));
        }

        let mut new_shard_data = Vec::with_capacity(new_shard_count as usize);
        for _ in 0..new_shard_count {
            new_shard_data.push(ShardData {
                transactions: Vec::new(),
                balances: HashMap::new(),
            });
        }

        let old_shard_data = std::mem::replace(&mut *self.shard_data.write().unwrap(), new_shard_data);

        // Redistribute balances and transactions
        for (old_shard_id, old_shard) in old_shard_data.into_iter().enumerate() {
            for (address, balances) in old_shard.balances {
                let new_shard_id = self.hash_address(&address) % new_shard_count;
                let new_shard = &mut self.shard_data.write().unwrap()[new_shard_id as usize];
                new_shard.balances.insert(address, balances);
            }

            for transaction in old_shard.transactions {
                let new_shard_id = self.get_shard_for_address(&transaction.from);
                let new_shard = &mut self.shard_data.write().unwrap()[new_shard_id as usize];
                new_shard.transactions.push(transaction);
            }
        }

        self.shard_count = new_shard_count;
        Ok(())
    }

    fn hash_address(&self, address: &str) -> u64 {
        use std::hash::{Hash, Hasher};
        use std::collections::hash_map::DefaultHasher;

        let mut hasher = DefaultHasher::new();
        address.hash(&mut hasher);
        hasher.finish()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_shard_assignment() {
        let manager = ShardingManager::new(4);
        let address = "0x1234567890123456789012345678901234567890".to_string();
        let shard_id = manager.get_shard_for_address(&address);
        assert!(shard_id < 4);

        manager.add_address_to_shard(address.clone(), 2).unwrap();
        assert_eq!(manager.get_shard_for_address(&address), 2);
    }

    #[test]
    fn test_intra_shard_transaction() {
        let manager = ShardingManager::new(4);
        let from_address = "0x1111111111111111111111111111111111111111".to_string();
        let to_address = "0x2222222222222222222222222222222222222222".to_string();
        manager.add_address_to_shard(from_address.clone(), 1).unwrap();
        manager.add_address_to_shard(to_address.clone(), 1).unwrap();

        manager.initialize_balance(&from_address, &CurrencyType::BasicNeeds, 100.0).unwrap();

        let transaction = Transaction {
            from: from_address.clone(),
            to: to_address.clone(),
            amount: 50.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: 0,
            signature: None,
        };

        assert!(manager.process_transaction(&transaction).is_ok());

        assert_eq!(manager.get_balance(&from_address, &CurrencyType::BasicNeeds).unwrap(), 50.0);
        assert_eq!(manager.get_balance(&to_address, &CurrencyType::BasicNeeds).unwrap(), 50.0);
    }

    #[test]
    fn test_cross_shard_transaction() {
        let manager = ShardingManager::new(4);
        let from_address = "0x3333333333333333333333333333333333333333".to_string();
        let to_address = "0x4444444444444444444444444444444444444444".to_string();
        manager.add_address_to_shard(from_address.clone(), 1).unwrap();
        manager.add_address_to_shard(to_address.clone(), 2).unwrap();

        manager.initialize_balance(&from_address, &CurrencyType::BasicNeeds, 100.0).unwrap();

        let transaction = Transaction {
            from: from_address.clone(),
            to: to_address.clone(),
            amount: 50.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: 0,
            signature: None,
        };

        assert!(manager.process_transaction(&transaction).is_ok());

        assert_eq!(manager.get_balance(&from_address, &CurrencyType::BasicNeeds).unwrap(), 50.0);
        assert_eq!(manager.get_balance(&to_address, &CurrencyType::BasicNeeds).unwrap(), 50.0);
    }

    #[test]
    fn test_get_total_balance() {
        let manager = ShardingManager::new(4);
        let address = "0x5555555555555555555555555555555555555555".to_string();

        manager.initialize_balance(&address, &CurrencyType::BasicNeeds, 25.0).unwrap();
        manager.initialize_balance(&address, &CurrencyType::Education, 50.0).unwrap();

        assert_eq!(manager.get_total_balance(&address, &CurrencyType::BasicNeeds).unwrap(), 25.0);
        assert_eq!(manager.get_total_balance(&address, &CurrencyType::Education).unwrap(), 50.0);
    }

    #[test]
    fn test_resize_shards() {
        let mut manager = ShardingManager::new(2);
        let address1 = "0x6666666666666666666666666666666666666666".to_string();
        let address2 = "0x7777777777777777777777777777777777777777".to_string();

        manager.initialize_balance(&address1, &CurrencyType::BasicNeeds, 100.0).unwrap();
        manager.initialize_balance(&address2, &CurrencyType::Education, 200.0).unwrap();

        manager.resize_shards(4).unwrap();

        assert_eq!(manager.get_shard_count(), 4);
        
        // Check if balances are preserved after resizing
        assert_eq!(manager.get_total_balance(&address1, &CurrencyType::BasicNeeds).unwrap(), 100.0);
        assert_eq!(manager.get_total_balance(&address2, &CurrencyType::Education).unwrap(), 200.0);
    }

    #[test]
    fn test_get_shard_transactions() {
        let manager = ShardingManager::new(2);
        let address1 = "0x8888888888888888888888888888888888888888".to_string();
        let address2 = "0x9999999999999999999999999999999999999999".to_string();

        manager.add_address_to_shard(address1.clone(), 0).unwrap();
        manager.add_address_to_shard(address2.clone(), 0).unwrap();

        manager.initialize_balance(&address1, &CurrencyType::BasicNeeds, 100.0).unwrap();

        let transaction = Transaction {
            from: address1.clone(),
            to: address2.clone(),
            amount: 50.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: 0,
            signature: None,
        };

        manager.process_transaction(&transaction).unwrap();

        let shard_transactions = manager.get_shard_transactions(0).unwrap();
        assert_eq!(shard_transactions.len(), 1);
        assert_eq!(shard_transactions[0].from, address1);
        assert_eq!(shard_transactions[0].to, address2);
    }

    #[test]
    fn test_get_shard_addresses() {
        let manager = ShardingManager::new(2);
        let address1 = "0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa".to_string();
        let address2 = "0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb".to_string();

        manager.add_address_to_shard(address1.clone(), 0).unwrap();
        manager.add_address_to_shard(address2.clone(), 0).unwrap();

        let shard_addresses = manager.get_shard_addresses(0).unwrap();
        assert_eq!(shard_addresses.len(), 2);
        assert!(shard_addresses.contains(&address1));
        assert!(shard_addresses.contains(&address2));
    }

    #[test]
    fn test_get_shard_currencies() {
        let manager = ShardingManager::new(2);
        let address = "0xcccccccccccccccccccccccccccccccccccccccc".to_string();

        manager.add_address_to_shard(address.clone(), 0).unwrap();
        manager.initialize_balance(&address, &CurrencyType::BasicNeeds, 100.0).unwrap();
        manager.initialize_balance(&address, &CurrencyType::Education, 50.0).unwrap();

        let shard_currencies = manager.get_shard_currencies(0).unwrap();
        assert_eq!(shard_currencies.len(), 2);
        assert!(shard_currencies.contains(&CurrencyType::BasicNeeds));
        assert!(shard_currencies.contains(&CurrencyType::Education));
    }

    #[test]
    fn test_insufficient_balance() {
        let manager = ShardingManager::new(2);
        let address1 = "0xdddddddddddddddddddddddddddddddddddddddd".to_string();
        let address2 = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee".to_string();

        manager.add_address_to_shard(address1.clone(), 0).unwrap();
        manager.add_address_to_shard(address2.clone(), 0).unwrap();

        manager.initialize_balance(&address1, &CurrencyType::BasicNeeds, 50.0).unwrap();

        let transaction = Transaction {
            from: address1.clone(),
            to: address2.clone(),
            amount: 100.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: 0,
            signature: None,
        };

        assert!(manager.process_transaction(&transaction).is_err());
    }

    #[test]
    #[should_panic(expected = "Invalid shard ID")]
    fn test_invalid_shard_id() {
        let manager = ShardingManager::new(2);
        manager.get_shard_transactions(2).unwrap();
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_sharding/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_smart_contracts/Cargo.toml =====
# File: /home/matt/InterCooperative-Network/crates/icn_smart_contracts/Cargo.toml

[package]
name = "icn_smart_contracts"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
icn_vm = { path = "../icn_vm" }
icn_language = { path = "../icn_language" }  # Add this line
serde = { workspace = true }
thiserror = { workspace = true }
log = { workspace = true }
pest = "2.1"
pest_derive = "2.1"===== END OF /home/matt/InterCooperative-Network/crates/icn_smart_contracts/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_smart_contracts/src/lib.rs =====
// File: crates/icn_smart_contracts/src/lib.rs

use pest::Parser;
use pest_derive::Parser;
use icn_common::{IcnResult, IcnError};
use icn_vm::{CoopVM, Opcode, Value};
use std::collections::HashMap;
use std::fmt;

#[derive(Parser)]
#[grammar = "contract.pest"]
struct ContractParser;

#[derive(Debug, Clone)]
pub enum SmartContractType {
    AssetTransfer,
    VotingSystem,
    ReputationManagement,
    ResourceAllocation,
    CustomLogic,
}

#[derive(Debug)]
pub struct CompiledContract {
    contract_type: SmartContractType,
    bytecode: Vec<Opcode>,
    abi: ContractABI,
}

#[derive(Debug)]
pub struct ContractABI {
    functions: Vec<ContractFunction>,
    events: Vec<ContractEvent>,
}

#[derive(Debug)]
pub struct ContractFunction {
    name: String,
    inputs: Vec<ContractParameter>,
    outputs: Vec<ContractParameter>,
}

#[derive(Debug)]
pub struct ContractEvent {
    name: String,
    parameters: Vec<ContractParameter>,
}

#[derive(Debug)]
pub struct ContractParameter {
    name: String,
    param_type: ContractValueType,
}

#[derive(Debug, Clone)]
pub enum ContractValueType {
    Integer,
    Float,
    Boolean,
    String,
    Address,
    List(Box<ContractValueType>),
    Map(Box<ContractValueType>, Box<ContractValueType>),
}

impl fmt::Display for ContractValueType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ContractValueType::Integer => write!(f, "Integer"),
            ContractValueType::Float => write!(f, "Float"),
            ContractValueType::Boolean => write!(f, "Boolean"),
            ContractValueType::String => write!(f, "String"),
            ContractValueType::Address => write!(f, "Address"),
            ContractValueType::List(inner) => write!(f, "List<{}>", inner),
            ContractValueType::Map(key, value) => write!(f, "Map<{}, {}>", key, value),
        }
    }
}

pub struct NaturalLanguageCompiler;

impl NaturalLanguageCompiler {
    pub fn compile(input: &str) -> IcnResult<CompiledContract> {
        let pairs = ContractParser::parse(Rule::contract, input)
            .map_err(|e| IcnError::SmartContract(format!("Parsing error: {}", e)))?;

        let mut bytecode = Vec::new();
        let mut abi = ContractABI {
            functions: Vec::new(),
            events: Vec::new(),
        };
        let mut contract_type = SmartContractType::CustomLogic;

        for pair in pairs {
            match pair.as_rule() {
                Rule::contract_type => {
                    contract_type = Self::parse_contract_type(pair.into_inner().next().unwrap().as_str())?;
                }
                Rule::function_definition => {
                    let (func_bytecode, func_abi) = Self::compile_function(pair)?;
                    bytecode.extend(func_bytecode);
                    abi.functions.push(func_abi);
                }
                Rule::statement => {
                    bytecode.extend(Self::compile_statement(pair)?);
                }
                Rule::event_definition => {
                    abi.events.push(Self::compile_event(pair)?);
                }
                _ => {}
            }
        }

        Ok(CompiledContract {
            contract_type,
            bytecode,
            abi,
        })
    }

    fn parse_contract_type(type_str: &str) -> IcnResult<SmartContractType> {
        match type_str {
            "AssetTransfer" => Ok(SmartContractType::AssetTransfer),
            "VotingSystem" => Ok(SmartContractType::VotingSystem),
            "ReputationManagement" => Ok(SmartContractType::ReputationManagement),
            "ResourceAllocation" => Ok(SmartContractType::ResourceAllocation),
            "CustomLogic" => Ok(SmartContractType::CustomLogic),
            _ => Err(IcnError::SmartContract(format!("Unknown contract type: {}", type_str))),
        }
    }

    fn compile_function(pair: pest::iterators::Pair<Rule>) -> IcnResult<(Vec<Opcode>, ContractFunction)> {
        // Implementation for compile_function
        // This is a placeholder and should be implemented based on your specific grammar rules
        unimplemented!()
    }

    fn compile_statement(pair: pest::iterators::Pair<Rule>) -> IcnResult<Vec<Opcode>> {
        // Implementation for compile_statement
        // This is a placeholder and should be implemented based on your specific grammar rules
        unimplemented!()
    }

    fn compile_event(pair: pest::iterators::Pair<Rule>) -> IcnResult<ContractEvent> {
        // Implementation for compile_event
        // This is a placeholder and should be implemented based on your specific grammar rules
        unimplemented!()
    }

    fn parse_type(type_str: &str) -> IcnResult<ContractValueType> {
        match type_str {
            "int" => Ok(ContractValueType::Integer),
            "float" => Ok(ContractValueType::Float),
            "bool" => Ok(ContractValueType::Boolean),
            "string" => Ok(ContractValueType::String),
            "address" => Ok(ContractValueType::Address),
            _ if type_str.starts_with("list<") => {
                let inner_type = &type_str[5..type_str.len()-1];
                Ok(ContractValueType::List(Box::new(Self::parse_type(inner_type)?)))
            }
            _ if type_str.starts_with("map<") => {
                let inner_types: Vec<&str> = type_str[4..type_str.len()-1].split(',').collect();
                if inner_types.len() != 2 {
                    return Err(IcnError::SmartContract("Invalid map type format".into()));
                }
                Ok(ContractValueType::Map(
                    Box::new(Self::parse_type(inner_types[0].trim())?),
                    Box::new(Self::parse_type(inner_types[1].trim())?)))
            }
            _ => Err(IcnError::SmartContract(format!("Unknown type: {}", type_str))),
        }
    }
}

pub struct SmartContractExecutor {
    vm: CoopVM,
}

impl SmartContractExecutor {
    pub fn new() -> Self {
        SmartContractExecutor {
            vm: CoopVM::new(),
        }
    }

    pub fn execute(&mut self, contract: &CompiledContract, function: &str, args: Vec<Value>) -> IcnResult<Option<Value>> {
        self.vm.load_program(contract.bytecode.clone());

        // Find the function in the ABI
        let function_abi = contract.abi.functions.iter()
            .find(|f| f.name == function)
            .ok_or_else(|| IcnError::SmartContract(format!("Function {} not found", function)))?;

        // Check argument count
        if args.len() != function_abi.inputs.len() {
            return Err(IcnError::SmartContract("Incorrect number of arguments".into()));
        }

        // Push arguments onto the stack
        for arg in args {
            self.vm.push(arg);
        }

        // Call the function
        self.vm.call(function)?;

        // Run the VM
        self.vm.run()?;

        // Return the top value from the stack, if any
        Ok(self.vm.pop())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_contract_type() {
        assert!(matches!(NaturalLanguageCompiler::parse_contract_type("AssetTransfer"), Ok(SmartContractType::AssetTransfer)));
        assert!(matches!(NaturalLanguageCompiler::parse_contract_type("VotingSystem"), Ok(SmartContractType::VotingSystem)));
        assert!(matches!(NaturalLanguageCompiler::parse_contract_type("CustomLogic"), Ok(SmartContractType::CustomLogic)));
        assert!(NaturalLanguageCompiler::parse_contract_type("InvalidType").is_err());
    }

    #[test]
    fn test_parse_type() {
        assert!(matches!(NaturalLanguageCompiler::parse_type("int"), Ok(ContractValueType::Integer)));
        assert!(matches!(NaturalLanguageCompiler::parse_type("float"), Ok(ContractValueType::Float)));
        assert!(matches!(NaturalLanguageCompiler::parse_type("bool"), Ok(ContractValueType::Boolean)));
        assert!(matches!(NaturalLanguageCompiler::parse_type("string"), Ok(ContractValueType::String)));
        assert!(matches!(NaturalLanguageCompiler::parse_type("address"), Ok(ContractValueType::Address)));
        
        if let Ok(ContractValueType::List(inner)) = NaturalLanguageCompiler::parse_type("list<int>") {
            assert!(matches!(*inner, ContractValueType::Integer));
        } else {
            panic!("Failed to parse list<int>");
        }

        if let Ok(ContractValueType::Map(key, value)) = NaturalLanguageCompiler::parse_type("map<string, int>") {
            assert!(matches!(*key, ContractValueType::String));
            assert!(matches!(*value, ContractValueType::Integer));
        } else {
            panic!("Failed to parse map<string, int>");
        }

        assert!(NaturalLanguageCompiler::parse_type("invalid_type").is_err());
    }

    // Add more tests as needed for other functions
}===== END OF /home/matt/InterCooperative-Network/crates/icn_smart_contracts/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_storage/Cargo.toml =====
[package]
name = "icn_storage"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
log = "0.4"
thiserror = "1.0"
sha2 = "0.9"

[dev-dependencies]
tokio-test = "0.4"===== END OF /home/matt/InterCooperative-Network/crates/icn_storage/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_storage/src/lib.rs =====
use icn_common::{IcnResult, IcnError};
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use log::{info, warn, error};
use serde::{Serialize, Deserialize};
use sha2::{Sha256, Digest};

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct StorageNode {
    id: String,
    data: HashMap<String, Vec<u8>>,
}

pub struct StorageManager {
    replication_factor: usize,
    nodes: Arc<RwLock<Vec<StorageNode>>>,
    data_location: Arc<RwLock<HashMap<String, Vec<usize>>>>,
}

impl StorageManager {
    pub fn new(replication_factor: usize) -> Self {
        StorageManager {
            replication_factor,
            nodes: Arc::new(RwLock::new(Vec::new())),
            data_location: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    pub fn add_node(&self, id: String) -> IcnResult<()> {
        let mut nodes = self.nodes.write().map_err(|_| IcnError::Storage("Failed to lock nodes".into()))?;
        nodes.push(StorageNode {
            id: id.clone(),
            data: HashMap::new(),
        });
        info!("Added new storage node with ID: {}", id);
        Ok(())
    }

    pub fn store_data(&self, key: &str, value: Vec<u8>) -> IcnResult<()> {
        let nodes = self.nodes.read().map_err(|_| IcnError::Storage("Failed to lock nodes".into()))?;
        if nodes.is_empty() {
            return Err(IcnError::Storage("No storage nodes available".into()));
        }

        let node_count = nodes.len();
        let mut data_location = self.data_location.write().map_err(|_| IcnError::Storage("Failed to lock data location".into()))?;

        let selected_nodes = self.select_nodes(key, node_count);
        data_location.insert(key.to_string(), selected_nodes.clone());

        drop(nodes);
        drop(data_location);

        for &node_id in &selected_nodes {
            self.store_on_node(node_id, key, value.clone())?;
        }

        info!("Stored data with key: {} on {} nodes", key, selected_nodes.len());
        Ok(())
    }

    pub fn retrieve_data(&self, key: &str) -> IcnResult<Vec<u8>> {
        let data_location = self.data_location.read().map_err(|_| IcnError::Storage("Failed to lock data location".into()))?;
        let node_ids = data_location.get(key).ok_or_else(|| IcnError::Storage("Data not found".into()))?;

        for &node_id in node_ids {
            if let Ok(data) = self.retrieve_from_node(node_id, key) {
                return Ok(data);
            }
        }

        Err(IcnError::Storage("Failed to retrieve data from any node".into()))
    }

    pub fn delete_data(&self, key: &str) -> IcnResult<()> {
        let mut data_location = self.data_location.write().map_err(|_| IcnError::Storage("Failed to lock data location".into()))?;
        let node_ids = data_location.remove(key).ok_or_else(|| IcnError::Storage("Data not found".into()))?;

        for &node_id in &node_ids {
            self.delete_from_node(node_id, key)?;
        }

        info!("Deleted data with key: {} from {} nodes", key, node_ids.len());
        Ok(())
    }

    fn select_nodes(&self, key: &str, node_count: usize) -> Vec<usize> {
        let mut hasher = Sha256::new();
        hasher.update(key.as_bytes());
        let hash = hasher.finalize();
        let mut selected_nodes = Vec::new();
        let mut start = u64::from_be_bytes(hash[0..8].try_into().unwrap()) as usize;

        for _ in 0..self.replication_factor.min(node_count) {
            selected_nodes.push(start % node_count);
            start = start.wrapping_add(1);
        }

        selected_nodes
    }

    fn store_on_node(&self, node_id: usize, key: &str, value: Vec<u8>) -> IcnResult<()> {
        let mut nodes = self.nodes.write().map_err(|_| IcnError::Storage("Failed to lock nodes".into()))?;
        let node = nodes.get_mut(node_id).ok_or_else(|| IcnError::Storage("Node not found".into()))?;
        node.data.insert(key.to_string(), value);
        Ok(())
    }

    fn retrieve_from_node(&self, node_id: usize, key: &str) -> IcnResult<Vec<u8>> {
        let nodes = self.nodes.read().map_err(|_| IcnError::Storage("Failed to lock nodes".into()))?;
        let node = nodes.get(node_id).ok_or_else(|| IcnError::Storage("Node not found".into()))?;
        node.data.get(key).cloned().ok_or_else(|| IcnError::Storage("Data not found on node".into()))
    }

    fn delete_from_node(&self, node_id: usize, key: &str) -> IcnResult<()> {
        let mut nodes = self.nodes.write().map_err(|_| IcnError::Storage("Failed to lock nodes".into()))?;
        let node = nodes.get_mut(node_id).ok_or_else(|| IcnError::Storage("Node not found".into()))?;
        node.data.remove(key);
        Ok(())
    }

    pub fn get_node_count(&self) -> usize {
        self.nodes.read().unwrap().len()
    }

    pub fn get_data_distribution(&self) -> IcnResult<HashMap<String, Vec<String>>> {
        let nodes = self.nodes.read().map_err(|_| IcnError::Storage("Failed to lock nodes".into()))?;
        let data_location = self.data_location.read().map_err(|_| IcnError::Storage("Failed to lock data location".into()))?;
        
        let mut distribution = HashMap::new();
        for (key, node_ids) in data_location.iter() {
            let node_names: Vec<String> = node_ids.iter()
                .filter_map(|&id| nodes.get(id).map(|node| node.id.clone()))
                .collect();
            distribution.insert(key.clone(), node_names);
        }
        
        Ok(distribution)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_store_and_retrieve_data() {
        let storage_manager = StorageManager::new(3);
        for i in 0..5 {
            storage_manager.add_node(format!("node{}", i)).unwrap();
        }

        let key = "test_key";
        let value = b"test_value".to_vec();

        assert!(storage_manager.store_data(key, value.clone()).is_ok());
        let retrieved_value = storage_manager.retrieve_data(key).unwrap();
        assert_eq!(retrieved_value, value);
    }

    #[test]
    fn test_delete_data() {
        let storage_manager = StorageManager::new(3);
        for i in 0..5 {
            storage_manager.add_node(format!("node{}", i)).unwrap();
        }

        let key = "delete_test_key";
        let value = b"delete_test_value".to_vec();

        storage_manager.store_data(key, value).unwrap();
        assert!(storage_manager.delete_data(key).is_ok());
        assert!(storage_manager.retrieve_data(key).is_err());
    }

    #[test]
    fn test_replication() {
        let storage_manager = StorageManager::new(3);
        for i in 0..5 {
            storage_manager.add_node(format!("node{}", i)).unwrap();
        }

        let key = "replication_test_key";
        let value = b"replication_test_value".to_vec();

        storage_manager.store_data(key, value.clone()).unwrap();

        let data_location = storage_manager.data_location.read().unwrap();
        let stored_nodes = data_location.get(key).unwrap();
        assert_eq!(stored_nodes.len(), 3);

        let node_to_fail = stored_nodes[0];
        {
            let mut nodes = storage_manager.nodes.write().unwrap();
            nodes[node_to_fail].data.clear();
        }

        let retrieved_value = storage_manager.retrieve_data(key).unwrap();
        assert_eq!(retrieved_value, value);
    }

    #[test]
    fn test_node_selection() {
        let storage_manager = StorageManager::new(3);
        for i in 0..10 {
            storage_manager.add_node(format!("node{}", i)).unwrap();
        }

        let key1 = "test_key_1";
        let key2 = "test_key_2";
        let value = b"test_value".to_vec();

        storage_manager.store_data(key1, value.clone()).unwrap();
        storage_manager.store_data(key2, value.clone()).unwrap();

        let data_location = storage_manager.data_location.read().unwrap();
        let nodes1 = data_location.get(key1).unwrap();
        let nodes2 = data_location.get(key2).unwrap();

        assert_ne!(nodes1, nodes2);

        assert_eq!(nodes1.len(), 3);
        assert_eq!(nodes2.len(), 3);
    }

    #[test]
    fn test_insufficient_nodes() {
        let storage_manager = StorageManager::new(3);
        storage_manager.add_node("node1".to_string()).unwrap();
        storage_manager.add_node("node2".to_string()).unwrap();

        let key = "insufficient_nodes_key";
        let value = b"test_value".to_vec();

        assert!(storage_manager.store_data(key, value.clone()).is_ok());

        let data_location = storage_manager.data_location.read().unwrap();
        let stored_nodes = data_location.get(key).unwrap();
        assert_eq!(stored_nodes.len(), 2);

        let retrieved_value = storage_manager.retrieve_data(key).unwrap();
        assert_eq!(retrieved_value, value);
    }

    #[test]
    fn test_get_node_count() {
        let storage_manager = StorageManager::new(3);
        assert_eq!(storage_manager.get_node_count(), 0);

        for i in 0..5 {
            storage_manager.add_node(format!("node{}", i)).unwrap();
        }

        assert_eq!(storage_manager.get_node_count(), 5);
    }

    #[test]
    fn test_get_data_distribution() {
        let storage_manager = StorageManager::new(2);
        for i in 0..4 {
            storage_manager.add_node(format!("node{}", i)).unwrap();
        }

        let key1 = "key1";
        let key2 = "key2";
        let value = b"test_value".to_vec();

        storage_manager.store_data(key1, value.clone()).unwrap();
        storage_manager.store_data(key2, value.clone()).unwrap();

        let distribution = storage_manager.get_data_distribution().unwrap();
        
        assert_eq!(distribution.len(), 2);
        assert!(distribution.contains_key(key1));
        assert!(distribution.contains_key(key2));
        assert_eq!(distribution[key1].len(), 2);
        assert_eq!(distribution[key2].len(), 2);
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_storage/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_storage/src/storage_manager.rs =====
use crate::storage_node::StorageNode;
use icn_common::{IcnError, IcnResult};
use std::sync::{Arc, RwLock};
use log::{info, error};

/// Manages storage nodes and handles data storage operations.
pub struct StorageManager {
    nodes: Arc<RwLock<Vec<StorageNode>>>,
}

impl StorageManager {
    /// Creates a new instance of StorageManager.
    pub fn new() -> Self {
        StorageManager {
            nodes: Arc::new(RwLock::new(Vec::new())),
        }
    }

    /// Adds a storage node to the manager.
    ///
    /// # Arguments
    ///
    /// * `node` - The storage node to be added.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn add_node(&self, node: StorageNode) -> IcnResult<()> {
        let mut nodes = self.nodes.write().unwrap();
        nodes.push(node);
        info!("Storage node added");
        Ok(())
    }

    /// Removes a storage node from the manager.
    ///
    /// # Arguments
    ///
    /// * `node_id` - The ID of the storage node to be removed.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn remove_node(&self, node_id: &str) -> IcnResult<()> {
        let mut nodes = self.nodes.write().unwrap();
        nodes.retain(|node| node.id != node_id);
        info!("Storage node removed");
        Ok(())
    }

    /// Stores data across available storage nodes.
    ///
    /// # Arguments
    ///
    /// * `data` - The data to be stored.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn store_data(&self, data: Vec<u8>) -> IcnResult<()> {
        let nodes = self.nodes.read().unwrap();
        if nodes.is_empty() {
            return Err(IcnError::Storage("No available storage nodes".into()));
        }
        // Simple round-robin distribution of data
        let node = &nodes[0];
        node.store(data)?;
        info!("Data stored");
        Ok(())
    }

    /// Retrieves data from storage nodes.
    ///
    /// # Arguments
    ///
    /// * `data_id` - The ID of the data to be retrieved.
    ///
    /// # Returns
    ///
    /// * `IcnResult<Vec<u8>>` - The retrieved data.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn retrieve_data(&self, data_id: &str) -> IcnResult<Vec<u8>> {
        let nodes = self.nodes.read().unwrap();
        for node in nodes.iter() {
            if let Ok(data) = node.retrieve(data_id) {
                return Ok(data);
            }
        }
        Err(IcnError::Storage("Data not found".into()))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::storage_node::MockStorageNode;

    #[test]
    fn test_add_and_remove_node() {
        let manager = StorageManager::new();
        let node = MockStorageNode::new("Node1".to_string());
        assert!(manager.add_node(node).is_ok());
        assert!(manager.remove_node("Node1").is_ok());
    }

    #[test]
    fn test_store_and_retrieve_data() {
        let manager = StorageManager::new();
        let node = MockStorageNode::new("Node1".to_string());
        manager.add_node(node).unwrap();

        let data = vec![1, 2, 3];
        assert!(manager.store_data(data.clone()).is_ok());
        let retrieved_data = manager.retrieve_data("data_id").unwrap();
        assert_eq!(retrieved_data, data);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_storage/src/storage_manager.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_storage/src/storage_node.rs =====
use icn_common::{IcnError, IcnResult};
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use log::{info, error};

/// Represents a storage node in the ICN project.
pub struct StorageNode {
    pub id: String,
    data_store: Arc<RwLock<HashMap<String, Vec<u8>>>>,
}

impl StorageNode {
    /// Creates a new instance of StorageNode.
    ///
    /// # Arguments
    ///
    /// * `id` - The ID of the storage node.
    ///
    /// # Returns
    ///
    /// * `StorageNode` - A new instance of StorageNode.
    pub fn new(id: String) -> Self {
        StorageNode {
            id,
            data_store: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// Stores data in the storage node.
    ///
    /// # Arguments
    ///
    /// * `data` - The data to be stored.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn store(&self, data: Vec<u8>) -> IcnResult<()> {
        let mut data_store = self.data_store.write().unwrap();
        let data_id = format!("data_{}", data_store.len() + 1);
        data_store.insert(data_id.clone(), data);
        info!("Data stored with ID: {}", data_id);
        Ok(())
    }

    /// Retrieves data from the storage node.
    ///
    /// # Arguments
    ///
    /// * `data_id` - The ID of the data to be retrieved.
    ///
    /// # Returns
    ///
    /// * `IcnResult<Vec<u8>>` - The retrieved data.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn retrieve(&self, data_id: &str) -> IcnResult<Vec<u8>> {
        let data_store = self.data_store.read().unwrap();
        data_store.get(data_id).cloned().ok_or_else(|| IcnError::Storage("Data not found".into()))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_store_and_retrieve_data() {
        let node = StorageNode::new("Node1".to_string());
        let data = vec![1, 2, 3];
        assert!(node.store(data.clone()).is_ok());
        let retrieved_data = node.retrieve("data_1").unwrap();
        assert_eq!(retrieved_data, data);
    }

    #[test]
    fn test_retrieve_non_existent_data() {
        let node = StorageNode::new("Node1".to_string());
        assert!(node.retrieve("non_existent_data").is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_storage/src/storage_node.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_testnet/Cargo.toml =====
[package]
name = "icn_testnet"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
icn_blockchain = { path = "../icn_blockchain" }
icn_consensus = { path = "../icn_consensus" }
icn_currency = { path = "../icn_currency" }
icn_governance = { path = "../icn_governance" }
icn_identity = { path = "../icn_identity" }
icn_network = { path = "../icn_network" }
icn_sharding = { path = "../icn_sharding" }
icn_storage = { path = "../icn_storage" }
icn_vm = { path = "../icn_vm" }
icn_core = { path = "../icn_core" }
icn_api = { path = "../icn_api" }
tokio = { version = "1.0", features = ["full"] }
log = "0.4"
env_logger = "0.9"
rand = "0.8"===== END OF /home/matt/InterCooperative-Network/crates/icn_testnet/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_testnet/src/main.rs =====
// File: crates/icn_testnet/src/main.rs

use icn_core::{IcnNode, Config};
use icn_common::{Transaction, Proposal, ProposalType, ProposalCategory, CurrencyType, ProposalStatus};
use std::io::{self, Write};
use chrono::{Duration, Utc};
use log::{info, warn, error};
use uuid::Uuid;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    env_logger::init();

    let config = Config {
        shard_count: 4,
        consensus_threshold: 0.66,
        consensus_quorum: 0.51,
        network_port: 8080,
    };

    info!("Starting InterCooperative Network testnet...");
    let node = IcnNode::new(config).await?;
    node.start().await?;

    info!("Node started successfully. Type 'help' for available commands.");

    loop {
        print!("> ");
        io::stdout().flush()?;

        let mut input = String::new();
        io::stdin().read_line(&mut input)?;
        let input = input.trim();

        match input {
            "help" => print_help(),
            "exit" => break,
            "transaction" => process_transaction(&node).await?,
            "proposal" => create_proposal(&node).await?,
            "balance" => check_balance(&node).await?,
            "identity" => create_identity(&node).await?,
            "allocate" => allocate_resource(&node).await?,
            "network" => get_network_stats(&node).await?,
            _ => println!("Unknown command. Type 'help' for available commands."),
        }
    }

    info!("Stopping node...");
    node.stop().await?;
    info!("Node stopped. Goodbye!");

    Ok(())
}

fn print_help() {
    println!("Available commands:");
    println!("  help        - Show this help message");
    println!("  transaction - Create a new transaction");
    println!("  proposal    - Create a new proposal");
    println!("  balance     - Check account balance");
    println!("  identity    - Create a new identity");
    println!("  allocate    - Allocate a resource");
    println!("  network     - Get network statistics");
    println!("  exit        - Exit the application");
}

async fn process_transaction(node: &IcnNode) -> Result<(), Box<dyn std::error::Error>> {
    println!("Creating a new transaction...");
    
    let from = get_input("From: ")?;
    let to = get_input("To: ")?;
    let amount: f64 = get_input("Amount: ")?.parse()?;
    let currency_type = get_currency_type()?;

    let transaction = Transaction {
        from,
        to,
        amount,
        currency_type,
        timestamp: Utc::now().timestamp(),
        signature: None,
    };

    node.process_transaction(transaction).await?;
    println!("Transaction processed successfully");
    Ok(())
}

async fn create_proposal(node: &IcnNode) -> Result<(), Box<dyn std::error::Error>> {
    println!("Creating a new proposal...");
    
    let title = get_input("Title: ")?;
    let description = get_input("Description: ")?;
    let proposer = get_input("Proposer: ")?;
    let proposal_type = get_proposal_type()?;
    let category = get_proposal_category()?;

    let proposal = Proposal {
        id: Uuid::new_v4().to_string(),
        title,
        description,
        proposer,
        created_at: Utc::now(),
        voting_ends_at: Utc::now() + Duration::days(7),
        status: ProposalStatus::Active,
        proposal_type,
        category,
        required_quorum: 0.66,
        execution_timestamp: None,
    };

    let proposal_id = node.create_proposal(proposal).await?;
    println!("Proposal created successfully. ID: {}", proposal_id);
    Ok(())
}

async fn check_balance(node: &IcnNode) -> Result<(), Box<dyn std::error::Error>> {
    let address = get_input("Enter address: ")?;
    let currency_type = get_currency_type()?;
    
    let balance = node.get_balance(&address, &currency_type).await?;
    println!("Balance: {} {:?}", balance, currency_type);
    Ok(())
}

async fn create_identity(node: &IcnNode) -> Result<(), Box<dyn std::error::Error>> {
    println!("Creating a new identity...");
    
    let name = get_input("Enter name: ")?;
    
    let mut attributes = std::collections::HashMap::new();
    attributes.insert("name".to_string(), name);
    
    let identity_id = node.create_identity(attributes).await?;
    println!("Identity created successfully. ID: {}", identity_id);
    Ok(())
}

async fn allocate_resource(node: &IcnNode) -> Result<(), Box<dyn std::error::Error>> {
    println!("Allocating a resource...");

    let resource_type = get_input("Enter resource type: ")?;
    let amount: u64 = get_input("Enter amount: ")?.parse()?;

    node.allocate_resource(&resource_type, amount).await?;
    println!("Resource allocated successfully");
    Ok(())
}

async fn get_network_stats(node: &IcnNode) -> Result<(), Box<dyn std::error::Error>> {
    let stats = node.get_network_stats().await?;
    println!("Network Statistics:");
    println!("  Connected Peers: {}", stats.node_count);
    println!("  Total Transactions: {}", stats.total_transactions);
    println!("  Active Proposals: {}", stats.active_proposals);
    Ok(())
}

fn get_input(prompt: &str) -> io::Result<String> {
    print!("{}", prompt);
    io::stdout().flush()?;
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    Ok(input.trim().to_string())
}

fn get_currency_type() -> Result<CurrencyType, Box<dyn std::error::Error>> {
    println!("Select currency type:");
    println!("1. BasicNeeds");
    println!("2. Education");
    println!("3. Environmental");
    println!("4. Community");
    let choice: u32 = get_input("Enter choice (1-4): ")?.parse()?;
    match choice {
        1 => Ok(CurrencyType::BasicNeeds),
        2 => Ok(CurrencyType::Education),
        3 => Ok(CurrencyType::Environmental),
        4 => Ok(CurrencyType::Community),
        _ => Err("Invalid currency type choice".into()),
    }
}

fn get_proposal_type() -> Result<ProposalType, Box<dyn std::error::Error>> {
    println!("Select proposal type:");
    println!("1. Constitutional");
    println!("2. EconomicAdjustment");
    println!("3. NetworkUpgrade");
    let choice: u32 = get_input("Enter choice (1-3): ")?.parse()?;
    match choice {
        1 => Ok(ProposalType::Constitutional),
        2 => Ok(ProposalType::EconomicAdjustment),
        3 => Ok(ProposalType::NetworkUpgrade),
        _ => Err("Invalid proposal type choice".into()),
    }
}

fn get_proposal_category() -> Result<ProposalCategory, Box<dyn std::error::Error>> {
    println!("Select proposal category:");
    println!("1. Economic");
    println!("2. Technical");
    println!("3. Social");
    let choice: u32 = get_input("Enter choice (1-3): ")?.parse()?;
    match choice {
        1 => Ok(ProposalCategory::Economic),
        2 => Ok(ProposalCategory::Technical),
        3 => Ok(ProposalCategory::Social),
        _ => Err("Invalid proposal category choice".into()),
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_testnet/src/main.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_utils/Cargo.toml =====
# File: icn_utils/Cargo.toml

[package]
name = "icn_utils"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
sha2 = "0.9"
ed25519-dalek = "1.0"
rand = "0.7"
thiserror = "1.0"
serde_json = "1.0"
bincode = "1.3"
hex = "0.4"
icn_common = { path = "../icn_common" }

[dev-dependencies]
serde_json = "1.0"
===== END OF /home/matt/InterCooperative-Network/crates/icn_utils/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_utils/src/error.rs =====
use thiserror::Error;

#[derive(Error, Debug)]
pub enum IcnError {
    #[error("Blockchain error: {0}")]
    Blockchain(String),

    #[error("Consensus error: {0}")]
    Consensus(String),

    #[error("Currency error: {0}")]
    Currency(String),

    #[error("Governance error: {0}")]
    Governance(String),

    #[error("Identity error: {0}")]
    Identity(String),

    #[error("Network error: {0}")]
    Network(String),

    #[error("Node management error: {0}")]
    NodeManagement(String),

    #[error("Sharding error: {0}")]
    Sharding(String),

    #[error("Storage error: {0}")]
    Storage(String),

    #[error("VM error: {0}")]
    Vm(String),

    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),

    #[error("Serialization error: {0}")]
    Serialization(#[from] serde_json::Error),

    #[error("Database error: {0}")]
    Database(String),

    #[error("Configuration error: {0}")]
    Config(String),

    #[error("Unknown error: {0}")]
    Unknown(String),
}

pub type IcnResult<T> = std::result::Result<T, IcnError>;
===== END OF /home/matt/InterCooperative-Network/crates/icn_utils/src/error.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_utils/src/lib.rs =====
// File: icn_utils/src/lib.rs

// Import necessary modules and crates
use sha2::{Digest, Sha256};
use chrono::{DateTime, Duration, Utc};
use hex::FromHexError;

// Function to encode data to a hexadecimal string
pub fn hex_encode(data: &[u8]) -> String {
    hex::encode(data)
}

// Function to decode a hexadecimal string to data
pub fn hex_decode(s: &str) -> Result<Vec<u8>, FromHexError> {
    hex::decode(s)
}

// Function to hash data using SHA-256
pub fn hash_data(data: &[u8]) -> Vec<u8> {
    let mut hasher = Sha256::new();
    hasher.update(data);
    hasher.finalize().to_vec()
}

// Function to calculate the Merkle root from a list of hashes
pub fn calculate_merkle_root(hashes: &[Vec<u8>]) -> Vec<u8> {
    if hashes.is_empty() {
        return vec![];
    }
    if hashes.len() == 1 {
        return hashes[0].clone();
    }
    let mut next_level = Vec::new();
    for chunk in hashes.chunks(2) {
        let mut hasher = Sha256::new();
        hasher.update(&chunk[0]);
        if chunk.len() > 1 {
            hasher.update(&chunk[1]);
        } else {
            hasher.update(&chunk[0]);
        }
        next_level.push(hasher.finalize().to_vec());
    }
    calculate_merkle_root(&next_level)
}

// Time-related utilities
pub mod time {
    use super::*;

    // Function to get the current UTC time
    pub fn now() -> DateTime<Utc> {
        Utc::now()
    }

    // Function to check if a given timestamp is expired based on a duration
    pub fn is_expired(timestamp: DateTime<Utc>, duration: Duration) -> bool {
        now() > timestamp + duration
    }
}

// Cryptographic utilities
pub mod crypto {
    use ed25519_dalek::{Keypair, PublicKey, SecretKey, Signature, Signer, Verifier};
    use rand::rngs::OsRng;

    // Function to generate a new key pair (public and private keys)
    pub fn generate_keypair() -> Keypair {
        let mut csprng = OsRng {};
        Keypair::generate(&mut csprng)
    }

    // Function to sign a message with a given secret key
    pub fn sign(secret_key: &SecretKey, message: &[u8]) -> Signature {
        let keypair = Keypair {
            public: PublicKey::from(secret_key),
            secret: *secret_key,
        };
        keypair.sign(message)
    }

    // Function to verify a signature with a given public key and message
    pub fn verify(public_key: &PublicKey, message: &[u8], signature: &Signature) -> bool {
        public_key.verify(message, signature).is_ok()
    }
}

// Unit tests for the utility functions
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_hex_encode_decode() {
        let data = vec![0x12, 0x34, 0x56, 0x78];
        let encoded = hex_encode(&data);
        assert_eq!(encoded, "12345678");
        let decoded = hex_decode(&encoded).unwrap();
        assert_eq!(decoded, data);
    }

    #[test]
    fn test_hash_data() {
        let data = b"test data";
        let hash = hash_data(data);
        assert_eq!(hash.len(), 32);
    }

    #[test]
    fn test_calculate_merkle_root() {
        let hashes = vec![
            vec![1; 32],
            vec![2; 32],
            vec![3; 32],
            vec![4; 32],
        ];
        let root = calculate_merkle_root(&hashes);
        assert_eq!(root.len(), 32);

        // Test with odd number of hashes
        let odd_hashes = vec![
            vec![1; 32],
            vec![2; 32],
            vec![3; 32],
        ];
        let odd_root = calculate_merkle_root(&odd_hashes);
        assert_eq!(odd_root.len(), 32);
    }

    #[test]
    fn test_time_utils() {
        let now = time::now();
        let duration = Duration::seconds(10);
        assert!(!time::is_expired(now, duration));
        assert!(time::is_expired(now - Duration::seconds(20), duration));
    }

    #[test]
    fn test_crypto_utils() {
        let keypair = crypto::generate_keypair();
        let message = b"test message";
        let signature = crypto::sign(&keypair.secret, message);
        assert!(crypto::verify(&keypair.public, message, &signature));
        
        // Test with incorrect message
        let wrong_message = b"wrong message";
        assert!(!crypto::verify(&keypair.public, wrong_message, &signature));
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_utils/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_utils/src/types/block.rs =====
// icn_utils/src/types/block.rs

use serde::{Serialize, Deserialize};
use sha2::{Sha256, Digest};
use crate::types::transaction::Transaction;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Block {
    pub index: u64,
    pub previous_hash: String,
    pub timestamp: u64,
    pub transactions: Vec<Transaction>,
    pub hash: String,
}

impl Block {
    pub fn new(index: u64, transactions: Vec<Transaction>, previous_hash: String) -> Self {
        let timestamp = chrono::Utc::now().timestamp() as u64;
        let mut block = Block {
            index,
            previous_hash,
            timestamp,
            transactions,
            hash: String::new(),
        };
        block.hash = block.calculate_hash();
        block
    }

    pub fn calculate_hash(&self) -> String {
        let input = format!(
            "{}{}{}{:?}",
            self.index, self.previous_hash, self.timestamp, self.transactions
        );
        let mut hasher = Sha256::new();
        hasher.update(input.as_bytes());
        format!("{:x}", hasher.finalize())
    }

    pub fn genesis() -> Self {
        Block::new(0, vec![], String::from("0"))
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_utils/src/types/block.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_utils/src/types/mod.rs =====
pub mod block;
pub mod transaction;

pub use self::block::Block;
pub use self::transaction::Transaction;

use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Error {
    pub message: String,
}

pub type Result<T> = std::result::Result<T, Error>;

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, Hash)]
pub enum CurrencyType {
    BasicNeeds,
    Education,
    Environmental,
    Community,
    Volunteer,
    Storage,
    Processing,
    Energy,
    Luxury,
    Service,
    Custom(String),
    AssetToken(String),
    Bond(String),
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Currency {
    pub currency_type: CurrencyType,
    pub total_supply: f64,
    pub creation_date: DateTime<Utc>,
    pub last_issuance: DateTime<Utc>,
    pub issuance_rate: f64,
}

impl Currency {
    pub fn new(currency_type: CurrencyType, initial_supply: f64, issuance_rate: f64) -> Self {
        let now = Utc::now();
        Currency {
            currency_type,
            total_supply: initial_supply,
            creation_date: now,
            last_issuance: now,
            issuance_rate,
        }
    }

    pub fn mint(&mut self, amount: f64) -> Result<()> {
        self.total_supply += amount;
        self.last_issuance = Utc::now();
        Ok(())
    }

    pub fn burn(&mut self, amount: f64) -> Result<()> {
        if amount > self.total_supply {
            return Err(Error {
                message: "Insufficient supply to burn".to_string(),
            });
        }
        self.total_supply -= amount;
        Ok(())
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CurrencySystem {
    pub currencies: HashMap<CurrencyType, Currency>,
}

impl CurrencySystem {
    pub fn new() -> Self {
        CurrencySystem {
            currencies: HashMap::new(),
        }
    }

    pub fn add_currency(&mut self, currency_type: CurrencyType, initial_supply: f64, issuance_rate: f64) {
        let currency = Currency::new(currency_type.clone(), initial_supply, issuance_rate);
        self.currencies.insert(currency_type, currency);
    }

    pub fn get_currency(&self, currency_type: &CurrencyType) -> Option<&Currency> {
        self.currencies.get(currency_type)
    }

    pub fn get_currency_mut(&mut self, currency_type: &CurrencyType) -> Option<&mut Currency> {
        self.currencies.get_mut(currency_type)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_currency_mint_burn() {
        let mut currency = Currency::new(CurrencyType::BasicNeeds, 1000.0, 0.01);
        assert!(currency.mint(100.0).is_ok());
        assert_eq!(currency.total_supply, 1100.0);
        assert!(currency.burn(200.0).is_ok());
        assert_eq!(currency.total_supply, 900.0);
        assert!(currency.burn(1000.0).is_err());
    }

    #[test]
    fn test_currency_system() {
        let mut system = CurrencySystem::new();
        system.add_currency(CurrencyType::BasicNeeds, 1000.0, 0.01);
        system.add_currency(CurrencyType::Education, 500.0, 0.005);

        assert!(system.get_currency(&CurrencyType::BasicNeeds).is_some());
        assert!(system.get_currency(&CurrencyType::Education).is_some());
        assert!(system.get_currency(&CurrencyType::Environmental).is_none());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_utils/src/types/mod.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_utils/src/types/transaction.rs =====
use serde::{Deserialize, Serialize};
use ed25519_dalek::{Keypair, PublicKey, Signature, Signer, Verifier};
use crate::types::CurrencyType; // Import CurrencyType from crate
use bincode;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Transaction {
    pub from: String,
    pub to: String,
    pub amount: f64,
    pub gas_limit: u64,
    pub currency_type: CurrencyType, // Add this field
    pub signature: Option<Vec<u8>>,
    pub public_key: Option<Vec<u8>>,
}

impl Transaction {
    pub fn new(from: String, to: String, amount: f64, gas_limit: u64, currency_type: CurrencyType) -> Self {
        Transaction {
            from,
            to,
            amount,
            gas_limit,
            currency_type, // Initialize the field
            signature: None,
            public_key: None,
        }
    }

    pub fn sign(&mut self, keypair: &Keypair) -> Result<(), String> {
        let message = self.to_bytes();
        let signature = keypair.sign(&message);
        self.signature = Some(signature.to_bytes().to_vec());
        self.public_key = Some(keypair.public.to_bytes().to_vec());
        Ok(())
    }

    pub fn verify(&self) -> Result<bool, String> {
        let public_key_bytes = self.public_key.as_ref().ok_or("No public key present")?;
        let signature_bytes = self.signature.as_ref().ok_or("No signature present")?;

        let public_key = PublicKey::from_bytes(public_key_bytes).map_err(|e| e.to_string())?;
        let signature = Signature::from_bytes(signature_bytes).map_err(|e| e.to_string())?;

        let message = self.to_bytes();
        Ok(public_key.verify(&message, &signature).is_ok())
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut bytes = Vec::new();
        bytes.extend_from_slice(self.from.as_bytes());
        bytes.extend_from_slice(self.to.as_bytes());
        bytes.extend_from_slice(&self.amount.to_le_bytes());
        bytes.extend_from_slice(&self.gas_limit.to_le_bytes());
        // Serialize currency_type and append to bytes
        let currency_type_bytes = bincode::serialize(&self.currency_type).unwrap();
        bytes.extend_from_slice(&currency_type_bytes);
        bytes
    }

    pub fn to_string(&self) -> String {
        format!("{}{}{}{}", self.from, self.to, self.amount, self.gas_limit)
    }

    pub fn is_signed(&self) -> bool {
        self.signature.is_some() && self.public_key.is_some()
    }

    pub fn get_fee(&self) -> f64 {
        self.gas_limit as f64 * 0.0001
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_utils/src/types/transaction.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_utils/src/utils.rs =====
// icn_utils/src/utils.rs

// Placeholder for utility functions
pub fn some_utility_function() {
    // Utility function implementation
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_utils/src/utils.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_vm/Cargo.toml =====
[package]
name = "icn_vm"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
log = "0.4"
thiserror = "1.0"
chrono = { version = "0.4", features = ["serde"] }

[dev-dependencies]
tokio-test = "0.4"===== END OF /home/matt/InterCooperative-Network/crates/icn_vm/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_vm/src/compiler.rs =====
use crate::{Statement, Expression, Value};
use icn_vm::{Opcode, Value as VMValue};

pub struct Compiler {
    opcodes: Vec<Opcode>,
}

impl Compiler {
    pub fn new() -> Self {
        Compiler { opcodes: Vec::new() }
    }

    pub fn compile(&mut self, statements: Vec<Statement>) -> Vec<Opcode> {
        for statement in statements {
            self.compile_statement(statement);
        }
        self.opcodes.clone()
    }

    fn compile_statement(&mut self, statement: Statement) {
        match statement {
            Statement::VariableDeclaration(name, expr) => {
                self.compile_expression(expr);
                self.opcodes.push(Opcode::Store(name));
            },
            Statement::FunctionCall(name, args) => {
                for arg in args {
                    self.compile_expression(arg);
                }
                self.opcodes.push(Opcode::MorphemicCall(name, args.len()));
            },
            Statement::IfStatement(condition, true_branch, false_branch) => {
                self.compile_expression(condition);
                let jump_false = self.opcodes.len();
                self.opcodes.push(Opcode::JumpIfFalse(0)); // Placeholder
                self.compile_statements(true_branch);
                if let Some(false_branch) = false_branch {
                    let jump_end = self.opcodes.len();
                    self.opcodes.push(Opcode::Jump(0)); // Placeholder
                    let false_start = self.opcodes.len();
                    self.compile_statements(false_branch);
                    let end = self.opcodes.len();
                    self.opcodes[jump_false] = Opcode::JumpIfFalse(false_start);
                    self.opcodes[jump_end] = Opcode::Jump(end);
                } else {
                    let end = self.opcodes.len();
                    self.opcodes[jump_false] = Opcode::JumpIfFalse(end);
                }
            },
            Statement::WhileLoop(condition, body) => {
                let loop_start = self.opcodes.len();
                self.compile_expression(condition);
                let jump_false = self.opcodes.len();
                self.opcodes.push(Opcode::JumpIfFalse(0)); // Placeholder
                self.compile_statements(body);
                self.opcodes.push(Opcode::Jump(loop_start));
                let end = self.opcodes.len();
                self.opcodes[jump_false] = Opcode::JumpIfFalse(end);
            },
        }
    }

    fn compile_statements(&mut self, statements: Vec<Statement>) {
        for statement in statements {
            self.compile_statement(statement);
        }
    }

    fn compile_expression(&mut self, expr: Expression) {
        match expr {
            Expression::Literal(value) => {
                self.opcodes.push(Opcode::Push(self.convert_value(value)));
            },
            Expression::Variable(name) => {
                self.opcodes.push(Opcode::Load(name));
            },
            Expression::FunctionCall(name, args) => {
                for arg in args {
                    self.compile_expression(arg);
                }
                self.opcodes.push(Opcode::MorphemicCall(name, args.len()));
            },
        }
    }

    fn convert_value(&self, value: Value) -> VMValue {
        match value {
            Value::Int(i) => VMValue::Int(i),
            Value::Float(f) => VMValue::Float(f),
            Value::Bool(b) => VMValue::Bool(b),
            Value::String(s) => VMValue::String(s),
            Value::Address(a) => VMValue::Address(a),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::compile;

    #[test]
    fn test_compile_program() {
        let source = r#"
            let x = 5
            while x < 10 {
                net-node-connect("node1", "node2")
                x = x + 1
            }
            if x == 10 {
                econ-currency-mint(100, "BasicNeeds")
            } else {
                gov-proposal-submit("Increase node count")
            }
        "#;
        let ast = compile(source).unwrap();
        let mut compiler = Compiler::new();
        let opcodes = compiler.compile(ast);
        
        // Assert the number of opcodes and some key instructions
        assert!(opcodes.len() > 10);
        assert!(opcodes.contains(&Opcode::Push(VMValue::Int(5))));
        assert!(opcodes.contains(&Opcode::MorphemicCall("net-node-connect".to_string(), 2)));
        assert!(opcodes.contains(&Opcode::MorphemicCall("econ-currency-mint".to_string(), 2)));
        assert!(opcodes.contains(&Opcode::MorphemicCall("gov-proposal-submit".to_string(), 1)));
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_vm/src/compiler.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_vm/src/coop_vm.rs =====
use super::opcode::{Opcode, Value};
use std::collections::HashMap;

pub struct CoopVM {
    stack: Vec<Value>,
    memory: HashMap<String, Value>,
    program: Vec<Opcode>,
    pc: usize,
}

impl CoopVM {
    pub fn new(program: Vec<Opcode>) -> Self {
        CoopVM {
            stack: Vec::new(),
            memory: HashMap::new(),
            program,
            pc: 0,
        }
    }

    pub fn load_program(&mut self, program: Vec<Opcode>) {
        self.program = program;
        self.pc = 0;
    }

    pub fn run(&mut self) -> Result<(), String> {
        while self.pc < self.program.len() {
            self.execute_instruction()?;
            self.pc += 1;
        }
        Ok(())
    }

    fn execute_instruction(&mut self) -> Result<(), String> {
        let opcode = self.program[self.pc].clone();
        match opcode {
            Opcode::Push(value) => self.stack.push(value),
            Opcode::Pop => {
                self.stack.pop().ok_or("Stack underflow")?;
            }
            Opcode::Add => self.binary_op(|a, b| a + b)?,
            Opcode::Sub => self.binary_op(|a, b| a - b)?,
            Opcode::Mul => self.binary_op(|a, b| a * b)?,
            Opcode::Div => self.binary_op(|a, b| a / b)?,
            Opcode::Eq => self.compare_op(|a, b| a == b)?,
            Opcode::Lt => self.compare_op(|a, b| a < b)?,
            Opcode::Gt => self.compare_op(|a, b| a > b)?,
            Opcode::And => self.logic_op(|a, b| a && b)?,
            Opcode::Or => self.logic_op(|a, b| a || b)?,
            Opcode::Not => {
                let a = self.pop_bool()?;
                self.stack.push(Value::Bool(!a));
            }
            Opcode::Return => return Ok(()), // For now, just return
            Opcode::Store(name) => {
                let value = self.stack.pop().ok_or("Stack underflow")?;
                self.memory.insert(name, value);
            }
            Opcode::Load(name) => {
                let value = self.memory.get(&name).ok_or("Variable not found")?.clone();
                self.stack.push(value);
            }
            Opcode::Call(_) => return Err("Function calls not implemented yet".to_string()),
            Opcode::Vote(proposal_id) => {
                let vote = self.pop_bool()?;
                println!("Voting {} on proposal {}", if vote { "Yes" } else { "No" }, proposal_id);
            }
            Opcode::AllocateResource(resource_id) => {
                let amount = self.pop_int()?;
                println!("Allocating {} units of resource {}", amount, resource_id);
            }
            Opcode::UpdateReputation(address) => {
                let change = self.pop_int()?;
                println!("Updating reputation of {} by {}", address, change);
            }
            Opcode::CreateProposal => {
                let description = self.pop_string()?;
                println!("Creating proposal: {}", description);
                self.stack.push(Value::String("new_proposal_id".to_string()));
            }
            Opcode::GetProposalStatus => {
                let proposal_id = self.pop_string()?;
                println!("Getting status of proposal: {}", proposal_id);
                self.stack.push(Value::String("Active".to_string()));
            }
            Opcode::Emit(event_name) => {
                let event_data = self.stack.pop().ok_or("Stack underflow")?;
                println!("Emitting event {}: {:?}", event_name, event_data);
            }
        }
        Ok(())
    }

    fn binary_op<F>(&mut self, op: F) -> Result<(), String>
    where
        F: Fn(i64, i64) -> i64,
    {
        let b = self.pop_int()?;
        let a = self.pop_int()?;
        self.stack.push(Value::Int(op(a, b)));
        Ok(())
    }

    fn compare_op<F>(&mut self, op: F) -> Result<(), String>
    where
        F: Fn(&Value, &Value) -> bool,
    {
        let b = self.stack.pop().ok_or("Stack underflow")?;
        let a = self.stack.pop().ok_or("Stack underflow")?;
        self.stack.push(Value::Bool(op(&a, &b)));
        Ok(())
    }

    fn logic_op<F>(&mut self, op: F) -> Result<(), String>
    where
        F: Fn(bool, bool) -> bool,
    {
        let b = self.pop_bool()?;
        let a = self.pop_bool()?;
        self.stack.push(Value::Bool(op(a, b)));
        Ok(())
    }

    fn pop_int(&mut self) -> Result<i64, String> {
        match self.stack.pop().ok_or("Stack underflow")? {
            Value::Int(i) => Ok(i),
            _ => Err("Expected integer value".to_string()),
        }
    }

    fn pop_bool(&mut self) -> Result<bool, String> {
        match self.stack.pop().ok_or("Stack underflow")? {
            Value::Bool(b) => Ok(b),
            _ => Err("Expected boolean value".to_string()),
        }
    }

    fn pop_string(&mut self) -> Result<String, String> {
        match self.stack.pop().ok_or("Stack underflow")? {
            Value::String(s) => Ok(s),
            _ => Err("Expected string value".to_string()),
        }
    }

    pub fn get_stack(&self) -> &Vec<Value> {
        &self.stack
    }

    pub fn get_memory(&self) -> &HashMap<String, Value> {
        &self.memory
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_vm/src/coop_vm.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_vm/src/lib.rs =====
use icn_common::{IcnError, IcnResult};
use std::cmp::Ordering;
use std::collections::HashMap;

#[derive(Clone, Debug, PartialEq)]
pub enum Value {
    Int(i64),
    Float(f64),
    Bool(bool),
    String(String),
}

impl PartialOrd for Value {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        match (self, other) {
            (Value::Int(a), Value::Int(b)) => a.partial_cmp(b),
            (Value::Float(a), Value::Float(b)) => a.partial_cmp(b),
            (Value::Bool(a), Value::Bool(b)) => a.partial_cmp(b),
            (Value::String(a), Value::String(b)) => a.partial_cmp(b),
            (Value::Int(a), Value::Float(b)) => (*a as f64).partial_cmp(b),
            (Value::Float(a), Value::Int(b)) => a.partial_cmp(&(*b as f64)),
            _ => None,
        }
    }
}

#[derive(Clone, Debug)]
pub enum Opcode {
    Push(Value),
    Pop,
    Add,
    Sub,
    Mul,
    Div,
    Mod,
    Eq,
    Neq,
    Gt,
    Lt,
    Gte,
    Lte,
    And,
    Or,
    Not,
    Store(String),
    Load(String),
    JumpIf(usize),
    Jump(usize),
    Call(String),
    Return,
    NetNodeConnect,
    ChainBlockCreate,
    EconCurrencyMint,
    GovProposalSubmit,
    CoopMemberAdd,
    CommEventOrganize,
    VoteOnProposal,
    AllocateResource,
    UpdateReputation,
    CreateProposal,
    GetProposalStatus,
    EmitEvent,
}

pub struct CoopVM {
    stack: Vec<Value>,
    memory: HashMap<String, Value>,
    program: Vec<Opcode>,
    pc: usize,
}

impl CoopVM {
    pub fn new(program: Vec<Opcode>) -> Self {
        CoopVM {
            stack: Vec::new(),
            memory: HashMap::new(),
            program,
            pc: 0,
        }
    }

    pub fn execute(&mut self) -> IcnResult<()> {
        while self.pc < self.program.len() {
            self.execute_instruction()?;
            self.pc += 1;
        }
        Ok(())
    }

    fn execute_instruction(&mut self) -> IcnResult<()> {
        let instruction = self.program[self.pc].clone();
        match instruction {
            Opcode::Push(value) => self.stack.push(value),
            Opcode::Pop => {
                self.stack.pop().ok_or_else(|| IcnError::Vm("Stack underflow".into()))?;
            }
            Opcode::Add => self.binary_op(|a, b| a + b)?,
            Opcode::Sub => self.binary_op(|a, b| a - b)?,
            Opcode::Mul => self.binary_op(|a, b| a * b)?,
            Opcode::Div => self.binary_op(|a, b| a / b)?,
            Opcode::Mod => self.binary_op(|a, b| a % b)?,
            Opcode::Eq => self.compare_op(|a, b| a == b)?,
            Opcode::Neq => self.compare_op(|a, b| a != b)?,
            Opcode::Gt => self.compare_op(|a, b| a > b)?,
            Opcode::Lt => self.compare_op(|a, b| a < b)?,
            Opcode::Gte => self.compare_op(|a, b| a >= b)?,
            Opcode::Lte => self.compare_op(|a, b| a <= b)?,
            Opcode::And => {
                let b = self.pop_bool()?;
                let a = self.pop_bool()?;
                self.stack.push(Value::Bool(a && b));
            }
            Opcode::Or => {
                let b = self.pop_bool()?;
                let a = self.pop_bool()?;
                self.stack.push(Value::Bool(a || b));
            }
            Opcode::Not => {
                let a = self.pop_bool()?;
                self.stack.push(Value::Bool(!a));
            }
            Opcode::Store(name) => {
                let value = self.stack.pop().ok_or_else(|| IcnError::Vm("Stack underflow".into()))?;
                self.memory.insert(name, value);
            }
            Opcode::Load(name) => {
                let value = self.memory.get(&name).ok_or_else(|| IcnError::Vm("Variable not found".into()))?.clone();
                self.stack.push(value);
            }
            Opcode::JumpIf(target) => {
                let condition = self.pop_bool()?;
                if condition {
                    self.pc = target - 1; // -1 because pc will be incremented after this
                }
            }
            Opcode::Jump(target) => {
                self.pc = target - 1; // -1 because pc will be incremented after this
            }
            Opcode::Call(_) => return Err(IcnError::Vm("Function calls not implemented".into())),
            Opcode::Return => return Ok(()),
            Opcode::NetNodeConnect => println!("Executing NetNodeConnect"),
            Opcode::ChainBlockCreate => println!("Executing ChainBlockCreate"),
            Opcode::EconCurrencyMint => println!("Executing EconCurrencyMint"),
            Opcode::GovProposalSubmit => println!("Executing GovProposalSubmit"),
            Opcode::CoopMemberAdd => println!("Executing CoopMemberAdd"),
            Opcode::CommEventOrganize => println!("Executing CommEventOrganize"),
            Opcode::VoteOnProposal => println!("Executing VoteOnProposal"),
            Opcode::AllocateResource => println!("Executing AllocateResource"),
            Opcode::UpdateReputation => println!("Executing UpdateReputation"),
            Opcode::CreateProposal => println!("Executing CreateProposal"),
            Opcode::GetProposalStatus => println!("Executing GetProposalStatus"),
            Opcode::EmitEvent => println!("Executing EmitEvent"),
        }
        Ok(())
    }

    fn binary_op<F>(&mut self, op: F) -> IcnResult<()>
    where
        F: Fn(f64, f64) -> f64,
    {
        let b = self.pop_float()?;
        let a = self.pop_float()?;
        self.stack.push(Value::Float(op(a, b)));
        Ok(())
    }

    fn compare_op<F>(&mut self, op: F) -> IcnResult<()>
    where
        F: Fn(&Value, &Value) -> bool,
    {
        let b = self.stack.pop().ok_or_else(|| IcnError::Vm("Stack underflow".into()))?;
        let a = self.stack.pop().ok_or_else(|| IcnError::Vm("Stack underflow".into()))?;
        self.stack.push(Value::Bool(op(&a, &b)));
        Ok(())
    }

    fn pop_float(&mut self) -> IcnResult<f64> {
        match self.stack.pop().ok_or_else(|| IcnError::Vm("Stack underflow".into()))? {
            Value::Float(f) => Ok(f),
            Value::Int(i) => Ok(i as f64),
            _ => Err(IcnError::Vm("Expected float value".into())),
        }
    }

    fn pop_bool(&mut self) -> IcnResult<bool> {
        match self.stack.pop().ok_or_else(|| IcnError::Vm("Stack underflow".into()))? {
            Value::Bool(b) => Ok(b),
            _ => Err(IcnError::Vm("Expected boolean value".into())),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_operations() {
        let program = vec![
            Opcode::Push(Value::Float(5.0)),
            Opcode::Push(Value::Float(3.0)),
            Opcode::Add,
            Opcode::Push(Value::Float(2.0)),
            Opcode::Mul,
        ];

        let mut vm = CoopVM::new(program);
        assert!(vm.execute().is_ok());
        
        assert_eq!(vm.stack, vec![Value::Float(16.0)]);
    }

    #[test]
    fn test_comparison_operations() {
        let program = vec![
            Opcode::Push(Value::Int(5)),
            Opcode::Push(Value::Int(3)),
            Opcode::Gt,
            Opcode::Push(Value::Int(5)),
            Opcode::Push(Value::Int(5)),
            Opcode::Eq,
            Opcode::And,
        ];

        let mut vm = CoopVM::new(program);
        assert!(vm.execute().is_ok());
        
        assert_eq!(vm.stack, vec![Value::Bool(true)]);
    }

    #[test]
    fn test_logical_operations() {
        let program = vec![
            Opcode::Push(Value::Bool(true)),
            Opcode::Push(Value::Bool(false)),
            Opcode::Or,
            Opcode::Push(Value::Bool(true)),
            Opcode::And,
            Opcode::Not,
        ];

        let mut vm = CoopVM::new(program);
        assert!(vm.execute().is_ok());
        
        assert_eq!(vm.stack, vec![Value::Bool(false)]);
    }

    #[test]
    fn test_conditional_jump() {
        let program = vec![
            Opcode::Push(Value::Bool(true)),
            Opcode::JumpIf(4),
            Opcode::Push(Value::Int(1)),
            Opcode::Jump(5),
            Opcode::Push(Value::Int(2)),
        ];

        let mut vm = CoopVM::new(program);
        assert!(vm.execute().is_ok());
        
        assert_eq!(vm.stack, vec![Value::Int(2)]);
    }

    #[test]
    fn test_store_and_load() {
        let program = vec![
            Opcode::Push(Value::Int(42)),
            Opcode::Store("x".to_string()),
            Opcode::Push(Value::Int(10)),
            Opcode::Load("x".to_string()),
            Opcode::Add,
        ];

        let mut vm = CoopVM::new(program);
        assert!(vm.execute().is_ok());
        
        assert_eq!(vm.stack, vec![Value::Float(52.0)]);
    }

    #[test]
    fn test_error_handling() {
        let program = vec![
            Opcode::Push(Value::Int(1)),
            Opcode::Pop,
            Opcode::Pop, // This should cause an error
        ];

        let mut vm = CoopVM::new(program);
        assert!(vm.execute().is_err());
    }

    #[test]
    fn test_complex_program() {
        let program = vec![
            Opcode::Push(Value::Int(10)),
            Opcode::Store("x".to_string()),
            Opcode::Push(Value::Int(0)),
            Opcode::Store("sum".to_string()),
            Opcode::Push(Value::Int(1)),
            Opcode::Store("i".to_string()),
            // Loop start
            Opcode::Load("i".to_string()),
            Opcode::Load("x".to_string()),
            Opcode::Lte,
            Opcode::JumpIf(17), // Jump to end if false
            Opcode::Load("sum".to_string()),
            Opcode::Load("i".to_string()),
            Opcode::Add,
            Opcode::Store("sum".to_string()),
            Opcode::Load("i".to_string()),
            Opcode::Push(Value::Int(1)),
            Opcode::Add,
            Opcode::Store("i".to_string()),
            Opcode::Jump(6), // Jump back to loop start
            // Loop end
            Opcode::Load("sum".to_string()),
        ];

        let mut vm = CoopVM::new(program);
        assert!(vm.execute().is_ok());
        
        // Sum of numbers from 1 to 10 is 55
        assert_eq!(vm.stack, vec![Value::Float(55.0)]);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_vm/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_vm/src/opcode.rs =====
#[derive(Debug, Clone, PartialEq, PartialOrd)] // Add PartialOrd here
pub enum Value {
    Int(i64),
    Float(f64),
    Bool(bool),
    String(String),
}

#[derive(Debug, Clone, PartialEq)]
pub enum Opcode {
    Push(Value),
    Pop,
    Add,
    Sub,
    Mul,
    Div,
    Eq,
    Lt,
    Gt,
    And,
    Or,
    Not,
    Return,
    Store(String),
    Load(String),
    Call(String),
    Vote(String),
    AllocateResource(String),
    UpdateReputation(String),
    CreateProposal,
    GetProposalStatus,
    Emit(String),
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_vm/src/opcode.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_vm/src/smart_contract.rs =====
// File: icn_vm/src/smart_contract.rs

use icn_common::{IcnResult, IcnError, Transaction, CurrencyType};
use std::collections::HashMap;
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct SmartContract {
    pub id: String,
    pub code: String,
    pub state: HashMap<String, Value>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub enum Value {
    Int(i64),
    Float(f64),
    Bool(bool),
    String(String),
    List(Vec<Value>),
    Map(HashMap<String, Value>),
}

pub struct SmartContractExecutor {
    contracts: HashMap<String, SmartContract>,
}

impl SmartContractExecutor {
    pub fn new() -> Self {
        SmartContractExecutor {
            contracts: HashMap::new(),
        }
    }

    pub fn deploy_contract(&mut self, id: String, code: String) -> IcnResult<()> {
        if self.contracts.contains_key(&id) {
            return Err(IcnError::VM(format!("Contract with id {} already exists", id)));
        }

        let contract = SmartContract {
            id: id.clone(),
            code,
            state: HashMap::new(),
        };

        self.contracts.insert(id, contract);
        Ok(())
    }

    pub fn execute_contract(&mut self, id: &str, function: &str, args: Vec<Value>) -> IcnResult<Value> {
        let contract = self.contracts.get_mut(id)
            .ok_or_else(|| IcnError::VM(format!("Contract with id {} not found", id)))?;

        // In a real implementation, you would parse and execute the contract code here.
        // For this example, we'll simulate a simple token transfer function.
        match function {
            "transfer" => self.execute_transfer(contract, args),
            _ => Err(IcnError::VM(format!("Unknown function: {}", function))),
        }
    }

    fn execute_transfer(&mut self, contract: &mut SmartContract, args: Vec<Value>) -> IcnResult<Value> {
        if args.len() != 3 {
            return Err(IcnError::VM("transfer function requires 3 arguments: from, to, and amount".into()));
        }

        let from = match &args[0] {
            Value::String(s) => s,
            _ => return Err(IcnError::VM("'from' argument must be a string".into())),
        };

        let to = match &args[1] {
            Value::String(s) => s,
            _ => return Err(IcnError::VM("'to' argument must be a string".into())),
        };

        let amount = match &args[2] {
            Value::Int(n) => *n as f64,
            Value::Float(n) => *n,
            _ => return Err(IcnError::VM("'amount' argument must be a number".into())),
        };

        let balances = contract.state.entry("balances".to_string())
            .or_insert_with(|| Value::Map(HashMap::new()));

        if let Value::Map(ref mut balance_map) = balances {
            let from_balance = balance_map.entry(from.to_string())
                .or_insert(Value::Float(0.0));
            
            let to_balance = balance_map.entry(to.to_string())
                .or_insert(Value::Float(0.0));

            if let (Value::Float(from_amount), Value::Float(to_amount)) = (from_balance, to_balance) {
                if *from_amount < amount {
                    return Err(IcnError::VM("Insufficient balance for transfer".into()));
                }

                *from_amount -= amount;
                *to_amount += amount;

                Ok(Value::Bool(true))
            } else {
                Err(IcnError::VM("Invalid balance type".into()))
            }
        } else {
            Err(IcnError::VM("Invalid state structure".into()))
        }
    }

    pub fn get_contract_state(&self, id: &str) -> IcnResult<&HashMap<String, Value>> {
        self.contracts.get(id)
            .map(|contract| &contract.state)
            .ok_or_else(|| IcnError::VM(format!("Contract with id {} not found", id)))
    }

    pub fn update_contract_state(&mut self, id: &str, key: String, value: Value) -> IcnResult<()> {
        let contract = self.contracts.get_mut(id)
            .ok_or_else(|| IcnError::VM(format!("Contract with id {} not found", id)))?;

        contract.state.insert(key, value);
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_smart_contract_deployment_and_execution() {
        let mut executor = SmartContractExecutor::new();

        // Deploy a simple token contract
        let contract_id = "token_contract".to_string();
        let contract_code = r#"
            function transfer(from, to, amount) {
                // Transfer logic is implemented in the executor
            }
        "#.to_string();

        executor.deploy_contract(contract_id.clone(), contract_code).unwrap();

        // Initialize some balances
        executor.update_contract_state(&contract_id, "balances".to_string(), Value::Map(HashMap::new())).unwrap();
        let mut initial_balances = HashMap::new();
        initial_balances.insert("Alice".to_string(), Value::Float(100.0));
        initial_balances.insert("Bob".to_string(), Value::Float(50.0));
        executor.update_contract_state(&contract_id, "balances".to_string(), Value::Map(initial_balances)).unwrap();

        // Execute a transfer
        let result = executor.execute_contract(
            &contract_id,
            "transfer",
            vec![
                Value::String("Alice".to_string()),
                Value::String("Bob".to_string()),
                Value::Float(30.0),
            ],
        ).unwrap();

        assert_eq!(result, Value::Bool(true));

        // Check the updated balances
        let state = executor.get_contract_state(&contract_id).unwrap();
        if let Value::Map(balances) = &state["balances"] {
            assert_eq!(balances["Alice"], Value::Float(70.0));
            assert_eq!(balances["Bob"], Value::Float(80.0));
        } else {
            panic!("Invalid state structure");
        }

        // Test insufficient balance
        let result = executor.execute_contract(
            &contract_id,
            "transfer",
            vec![
                Value::String("Alice".to_string()),
                Value::String("Bob".to_string()),
                Value::Float(100.0),
            ],
        );

        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err().to_string(),
            IcnError::VM("Insufficient balance for transfer".into()).to_string()
        );
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_vm/src/smart_contract.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_vm/src/templates.rs =====
===== END OF /home/matt/InterCooperative-Network/crates/icn_vm/src/templates.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_vm/src/vm.rs =====
// File: src/vm.rs

use std::collections::HashMap;
use std::fmt;

#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub enum Value {
    Int(i64),
    Float(f64),
    Bool(bool),
    String(String),
    Address(String),
    List(Vec<Value>),
}

impl fmt::Display for Value {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Value::Int(i) => write!(f, "{}", i),
            Value::Float(fl) => write!(f, "{}", fl),
            Value::Bool(b) => write!(f, "{}", b),
            Value::String(s) => write!(f, "\"{}\"", s),
            Value::Address(a) => write!(f, "Address({})", a),
            Value::List(l) => write!(f, "{:?}", l),
        }
    }
}

#[derive(Debug, Clone)]
pub enum Opcode {
    Push(Value),
    Pop,
    Add,
    Sub,
    Mul,
    Div,
    Mod,
    Eq,
    Neq,
    Gt,
    Lt,
    Gte,
    Lte,
    And,
    Or,
    Not,
    Store(String),
    Load(String),
    JumpIf(usize),
    Jump(usize),
    Call(String),
    Return,
    CreateList,
    AppendList,
    GetListItem,
    SetListItem,
    Vote(String),
    AllocateResource(String),
    UpdateReputation(String),
    CreateProposal,
    GetProposalStatus,
    Emit(String),
}

pub struct CoopVM {
    stack: Vec<Value>,
    memory: HashMap<String, Value>,
    program: Vec<Opcode>,
    pc: usize,
    call_stack: Vec<usize>,
    functions: HashMap<String, usize>,
}

impl CoopVM {
    pub fn new(program: Vec<Opcode>) -> Self {
        CoopVM {
            stack: Vec::new(),
            memory: HashMap::new(),
            program,
            pc: 0,
            call_stack: Vec::new(),
            functions: HashMap::new(),
        }
    }

    pub fn run(&mut self) -> Result<(), String> {
        while self.pc < self.program.len() {
            self.execute_instruction()?;
            self.pc += 1;
        }
        Ok(())
    }

    fn execute_instruction(&mut self) -> Result<(), String> {
        let current_instruction = &self.program[self.pc].clone();
        match current_instruction {
            Opcode::Push(value) => self.stack.push(value.clone()),
            Opcode::Pop => {
                self.stack.pop().ok_or("Stack underflow")?;
            }
            Opcode::Add => self.binary_op(|a, b| a + b)?,
            Opcode::Sub => self.binary_op(|a, b| a - b)?,
            Opcode::Mul => self.binary_op(|a, b| a * b)?,
            Opcode::Div => self.binary_op(|a, b| a / b)?,
            Opcode::Mod => self.binary_op(|a, b| a % b)?,
            Opcode::Eq => self.compare_op(|a, b| a == b)?,
            Opcode::Neq => self.compare_op(|a, b| a != b)?,
            Opcode::Gt => self.compare_op(|a, b| a > b)?,
            Opcode::Lt => self.compare_op(|a, b| a < b)?,
            Opcode::Gte => self.compare_op(|a, b| a >= b)?,
            Opcode::Lte => self.compare_op(|a, b| a <= b)?,
            Opcode::And => self.logic_op(|a, b| a && b)?,
            Opcode::Or => self.logic_op(|a, b| a || b)?,
            Opcode::Not => {
                let a = self.pop_bool()?;
                self.stack.push(Value::Bool(!a));
            }
            Opcode::Store(name) => {
                let value = self.stack.pop().ok_or("Stack underflow")?;
                self.memory.insert(name.clone(), value);
            }
            Opcode::Load(name) => {
                let value = self.memory.get(name).ok_or("Variable not found")?.clone();
                self.stack.push(value);
            }
            Opcode::JumpIf(target) => {
                if self.pop_bool()? {
                    self.pc = *target - 1;
                }
            }
            Opcode::Jump(target) => {
                self.pc = *target - 1;
            }
            Opcode::Call(func_name) => {
                let func_pc = self.functions.get(func_name).ok_or("Function not found")?;
                self.call_stack.push(self.pc);
                self.pc = *func_pc - 1;
            }
            Opcode::Return => {
                self.pc = self.call_stack.pop().ok_or("Return without call")?;
            }
            Opcode::CreateList => {
                self.stack.push(Value::List(Vec::new()));
            }
            Opcode::AppendList => {
                let value = self.stack.pop().ok_or("Stack underflow")?;
                if let Some(Value::List(list)) = self.stack.last_mut() {
                    list.push(value);
                } else {
                    return Err("Expected list on top of stack".to_string());
                }
            }
            Opcode::GetListItem => {
                let index = self.pop_int()?;
                if let Some(Value::List(list)) = self.stack.pop() {
                    let item = list.get(index as usize).ok_or("List index out of bounds")?.clone();
                    self.stack.push(item);
                } else {
                    return Err("Expected list on top of stack".to_string());
                }
            }
            Opcode::SetListItem => {
                let value = self.stack.pop().ok_or("Stack underflow")?;
                let index = self.pop_int()?;
                if let Some(Value::List(list)) = self.stack.last_mut() {
                    if (index as usize) < list.len() {
                        list[index as usize] = value;
                    } else {
                        return Err("List index out of bounds".to_string());
                    }
                } else {
                    return Err("Expected list on top of stack".to_string());
                }
            }
            Opcode::Vote(proposal_id) => {
                let vote = self.pop_bool()?;
                println!("Voting {} on proposal {}", if vote { "Yes" } else { "No" }, proposal_id);
            }
            Opcode::AllocateResource(resource_id) => {
                let amount = self.pop_int()?;
                println!("Allocating {} units of resource {}", amount, resource_id);
            }
            Opcode::UpdateReputation(address) => {
                let change = self.pop_int()?;
                println!("Updating reputation of {} by {}", address, change);
            }
            Opcode::CreateProposal => {
                let description = self.pop_string()?;
                println!("Creating proposal: {}", description);
                self.stack.push(Value::String("new_proposal_id".to_string()));
            }
            Opcode::GetProposalStatus => {
                let proposal_id = self.pop_string()?;
                println!("Getting status of proposal: {}", proposal_id);
                self.stack.push(Value::String("Active".to_string()));
            }
            Opcode::Emit(event_name) => {
                let event_data = self.stack.pop().ok_or("Stack underflow")?;
                println!("Emitting event {}: {}", event_name, event_data);
            }
        }
        Ok(())
    }

    fn binary_op<F>(&mut self, op: F) -> Result<(), String>
    where
        F: Fn(i64, i64) -> i64,
    {
        let b = self.pop_int()?;
        let a = self.pop_int()?;
        self.stack.push(Value::Int(op(a, b)));
        Ok(())
    }

    fn compare_op<F>(&mut self, op: F) -> Result<(), String>
    where
        F: Fn(&Value, &Value) -> bool,
    {
        let b = self.stack.pop().ok_or("Stack underflow")?;
        let a = self.stack.pop().ok_or("Stack underflow")?;
        self.stack.push(Value::Bool(op(&a, &b)));
        Ok(())
    }

    fn logic_op<F>(&mut self, op: F) -> Result<(), String>
    where
        F: Fn(bool, bool) -> bool,
    {
        let b = self.pop_bool()?;
        let a = self.pop_bool()?;
        self.stack.push(Value::Bool(op(a, b)));
        Ok(())
    }

    fn pop_int(&mut self) -> Result<i64, String> {
        match self.stack.pop().ok_or("Stack underflow")? {
            Value::Int(i) => Ok(i),
            _ => Err("Expected integer value".to_string()),
        }
    }

    fn pop_bool(&mut self) -> Result<bool, String> {
        match self.stack.pop().ok_or("Stack underflow")? {
            Value::Bool(b) => Ok(b),
            _ => Err("Expected boolean value".to_string()),
        }
    }

    fn pop_string(&mut self) -> Result<String, String> {
        match self.stack.pop().ok_or("Stack underflow")? {
            Value::String(s) => Ok(s),
            _ => Err("Expected string value".to_string()),
        }
    }

    pub fn register_function(&mut self, name: String, pc: usize) {
        self.functions.insert(name, pc);
    }

    pub fn get_stack(&self) -> &Vec<Value> {
        &self.stack
    }

    pub fn get_memory(&self) -> &HashMap<String, Value> {
        &self.memory
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_operations() {
        let program = vec![
            Opcode::Push(Value::Int(5)),
            Opcode::Push(Value::Int(3)),
            Opcode::Add,
            Opcode::Push(Value::Int(2)),
            Opcode::Mul,
        ];

        let mut vm = CoopVM::new(program);
        vm.run().unwrap();

        assert_eq!(vm.stack, vec![Value::Int(16)]);
    }

    #[test]
    fn test_store_and_load() {
        let program = vec![
            Opcode::Push(Value::Int(42)),
            Opcode::Store("x".to_string()),
            Opcode::Push(Value::Int(10)),
            Opcode::Load("x".to_string()),
            Opcode::Add,
        ];

        let mut vm = CoopVM::new(program);
        vm.run().unwrap();

        assert_eq!(vm.stack, vec![Value::Int(52)]);
    }

    #[test]
    fn test_conditional_jump() {
        let program = vec![
            Opcode::Push(Value::Bool(true)),
            Opcode::JumpIf(3),
            Opcode::Push(Value::Int(1)),
            Opcode::Push(Value::Int(2)),
            Opcode::Add,
        ];

        let mut vm = CoopVM::new(program);
        vm.run().unwrap();

        assert_eq!(vm.stack, vec![Value::Int(2)]);
    }

    #[test]
    fn test_list_operations() {
        let program = vec![
            Opcode::CreateList,
            Opcode::Push(Value::Int(1)),
            Opcode::AppendList,
            Opcode::Push(Value::Int(2)),
            Opcode::AppendList,
            Opcode::Push(Value::Int(0)),
            Opcode::GetListItem,
        ];

        let mut vm = CoopVM::new(program);
        vm.run().unwrap();

        assert_eq!(vm.stack, vec![Value::List(vec![Value::Int(1), Value::Int(2)]), Value::Int(1)]);
    }

    #[test]
    fn test_cooperative_operations() {
        let program = vec![
            Opcode::Push(Value::String("Proposal 1".to_string())),
            Opcode::CreateProposal,
            Opcode::Push(Value::Bool(true)),
            Opcode::Vote("proposal_1".to_string()),
            Opcode::Push(Value::Int(100)),
            Opcode::AllocateResource("computing_power".to_string()),
            Opcode::Push(Value::Int(5)),
            Opcode::UpdateReputation("user1".to_string()),
            Opcode::Push(Value::String("proposal_1".to_string())),
            Opcode::GetProposalStatus,
        ];

        let mut vm = CoopVM::new(program);
        vm.run().unwrap();

        assert_eq!(vm.stack, vec![Value::String("new_proposal_id".to_string()), Value::String("Active".to_string())]);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_vm/src/vm.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_zkp/Cargo.toml =====
# File: crates/icn_zkp/Cargo.toml
[package]
name = "icn_zkp"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
bulletproofs = "4.0.0"
curve25519-dalek = "3.2.0"
merlin = "3.0.0"
rand = "0.8.5"
subtle = "2.4.1"
rayon = "1.5.1"
serde = { version = "1.0", features = ["derive"] }
thiserror = "1.0"

[dev-dependencies]
criterion = "0.3"===== END OF /home/matt/InterCooperative-Network/crates/icn_zkp/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_zkp/src/circuits.rs =====
// File: crates/icn_zkp/src/circuits.rs
use bulletproofs::r1cs::{ConstraintSystem, R1CSProof, Verifier};
use bulletproofs::{BulletproofGens, PedersenGens};
use curve25519_dalek::scalar::Scalar;
use merlin::Transcript;
use rand::thread_rng;

use icn_common::Transaction;

pub struct TransactionCircuit {
    amount: u64,
    balance: u64,
}

impl TransactionCircuit {
    pub fn new(transaction: &Transaction, balance: u64) -> Self {
        TransactionCircuit {
            amount: transaction.amount as u64,
            balance,
        }
    }

    pub fn prove(&self) -> (R1CSProof, Vec<Scalar>) {
        let pc_gens = PedersenGens::default();
        let bp_gens = BulletproofGens::new(128, 1);

        let (proof, commitments) = bulletproofs::r1cs::Prover::new(&pc_gens)
            .prove(
                &bp_gens,
                &mut Transcript::new(b"TransactionProof"),
                &|mut cs| {
                    let amount = cs.allocate_multiplier(self.amount.into())?;
                    let balance = cs.allocate_multiplier(self.balance.into())?;

                    cs.constrain(amount.0 - balance.0);

                    Ok(())
                },
                &mut thread_rng(),
            )
            .expect("Proof creation failed");

        (proof, commitments)
    }

    pub fn verify(proof: &R1CSProof, commitments: &[Scalar]) -> bool {
        let pc_gens = PedersenGens::default();
        let bp_gens = BulletproofGens::new(128, 1);

        let mut verifier_transcript = Transcript::new(b"TransactionProof");
        let mut verifier = Verifier::new(&mut verifier_transcript);

        let result = verifier
            .verify(
                &proof,
                &pc_gens,
                &bp_gens,
                &|mut cs| {
                    let amount = cs.allocate_multiplier(commitments[0])?;
                    let balance = cs.allocate_multiplier(commitments[1])?;

                    cs.constrain(amount.0 - balance.0);

                    Ok(())
                },
            )
            .is_ok();

        result
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_common::CurrencyType;

    #[test]
    fn test_transaction_proof() {
        let transaction = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 50.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: 1234567890,
            signature: None,
        };

        let balance = 100;
        let circuit = TransactionCircuit::new(&transaction, balance);

        let (proof, commitments) = circuit.prove();
        assert!(TransactionCircuit::verify(&proof, &commitments));
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_zkp/src/circuits.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_zkp/src/lib.rs =====
// File: crates/icn_zkp/src/lib.rs

use bulletproofs::{BulletproofGens, PedersenGens, RangeProof};
use curve25519_dalek::scalar::Scalar;
use merlin::Transcript;
use rand::thread_rng;
use icn_common::{IcnResult, IcnError, Transaction};

pub struct ZKPManager {
    bp_gens: BulletproofGens,
    pc_gens: PedersenGens,
}

impl ZKPManager {
    pub fn new(max_bitsize: usize) -> Self {
        ZKPManager {
            bp_gens: BulletproofGens::new(max_bitsize, 1),
            pc_gens: PedersenGens::default(),
        }
    }

    pub fn create_proof(&self, transaction: &Transaction) -> IcnResult<(RangeProof, Vec<Scalar>)> {
        let amount = (transaction.amount * 100.0) as u64; // Convert to cents for integer representation
        let (proof, committed_value) = self.create_range_proof(amount)?;
        Ok((proof, vec![committed_value]))
    }

    pub fn verify_proof(&self, proof: &RangeProof, committed_values: &[Scalar]) -> IcnResult<bool> {
        if committed_values.len() != 1 {
            return Err(IcnError::ZKP("Invalid number of committed values".into()));
        }

        let mut transcript = Transcript::new(b"TransactionRangeProof");
        proof
            .verify_single(&self.bp_gens, &self.pc_gens, &mut transcript, &committed_values[0], 64)
            .map_err(|e| IcnError::ZKP(format!("Proof verification failed: {}", e)))
    }

    fn create_range_proof(&self, value: u64) -> IcnResult<(RangeProof, Scalar)> {
        let mut transcript = Transcript::new(b"TransactionRangeProof");
        let (proof, committed_value) = RangeProof::prove_single(
            &self.bp_gens,
            &self.pc_gens,
            &mut transcript,
            value,
            &Scalar::random(&mut thread_rng()),
            64,
        )
        .map_err(|e| IcnError::ZKP(format!("Failed to create range proof: {}", e)))?;

        Ok((proof, committed_value))
    }

    pub fn create_multi_proof(&self, values: &[u64]) -> IcnResult<(RangeProof, Vec<Scalar>)> {
        let mut transcript = Transcript::new(b"MultiRangeProof");
        let (proof, committed_values) = RangeProof::prove_multiple(
            &self.bp_gens,
            &self.pc_gens,
            &mut transcript,
            values,
            &vec![64; values.len()],
            &Scalar::random(&mut thread_rng()),
            &mut thread_rng(),
        )
        .map_err(|e| IcnError::ZKP(format!("Failed to create multi-range proof: {}", e)))?;

        Ok((proof, committed_values))
    }

    pub fn verify_multi_proof(&self, proof: &RangeProof, committed_values: &[Scalar]) -> IcnResult<bool> {
        let mut transcript = Transcript::new(b"MultiRangeProof");
        proof
            .verify_multiple(&self.bp_gens, &self.pc_gens, &mut transcript, committed_values, &vec![64; committed_values.len()])
            .map_err(|e| IcnError::ZKP(format!("Multi-proof verification failed: {}", e)))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_common::CurrencyType;

    #[test]
    fn test_create_and_verify_proof() {
        let zkp_manager = ZKPManager::new(64);
        let transaction = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 50.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: 1234567890,
            signature: None,
        };

        let (proof, committed_value) = zkp_manager.create_proof(&transaction).unwrap();
        assert!(zkp_manager.verify_proof(&proof, &committed_value).unwrap());
    }

    #[test]
    fn test_invalid_proof() {
        let zkp_manager = ZKPManager::new(64);
        let transaction = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 50.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: 1234567890,
            signature: None,
        };

        let (proof, mut committed_value) = zkp_manager.create_proof(&transaction).unwrap();
        committed_value[0] += Scalar::one(); // Tamper with the committed value
        assert!(!zkp_manager.verify_proof(&proof, &committed_value).unwrap());
    }

    #[test]
    fn test_multi_proof() {
        let zkp_manager = ZKPManager::new(64);
        let values = vec![100, 200, 300];

        let (proof, committed_values) = zkp_manager.create_multi_proof(&values).unwrap();
        assert!(zkp_manager.verify_multi_proof(&proof, &committed_values).unwrap());
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_zkp/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/Cargo.toml =====
[workspace]
members = [
    "crates/icn_common",
    "crates/icn_blockchain",
    "crates/icn_consensus",
    "crates/icn_currency",
    "crates/icn_governance",
    "crates/icn_identity",
    "crates/icn_network",
    "crates/icn_sharding",
    "crates/icn_storage",
    "crates/icn_vm",
    "crates/icn_api",
    "crates/icn_testnet",
    "crates/icn_core",
    "crates/icn_zkp",
    "crates/icn_smart_contracts",
    "crates/icn_reputation",
    "crates/icn_market",
    "crates/icn_incentives",
    "crates/icn_language",
    "crates/icn_demo"
]

resolver = "2"

[workspace.dependencies]
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
chrono = { version = "0.4", features = ["serde"] }
thiserror = "1.0"
log = "0.4"
env_logger = "0.9"
===== END OF /home/matt/InterCooperative-Network/Cargo.toml =====

