===== START OF FILE STRUCTURE =====
/home/matt/InterCooperative-Network
├── Cargo.lock
├── Cargo.toml
├── CHANGELOG.md
├── cliff.toml
├── crates
│   ├── icn_api
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── lib.rs
│   ├── icn_blockchain
│   │   ├── Cargo.toml
│   │   ├── README.md
│   │   └── src
│   │       ├── asset_tokenization.rs
│   │       ├── blockchain.rs
│   │       ├── lib.rs
│   │       └── transaction_validator.rs
│   ├── icn_common
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── error.rs
│   │       ├── lib.rs
│   │       └── main.rs
│   ├── icn_consensus
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── bft_poc.rs
│   │       ├── consensus.rs
│   │       ├── lib.rs
│   │       └── proof_of_cooperation.rs
│   ├── icn_core
│   │   ├── Cargo.toml
│   │   ├── src
│   │   │   ├── cli
│   │   │   │   └── mod.rs
│   │   │   ├── config.rs
│   │   │   ├── error.rs
│   │   │   ├── lib.rs
│   │   │   ├── logging
│   │   │   │   └── mod.rs
│   │   │   ├── main.rs
│   │   │   └── security
│   │   │       └── mod.rs
│   │   └── tests
│   │       ├── blockchain_and_consensus_tests.rs
│   │       ├── blockchain_tests.rs
│   │       ├── icn_node_tests.rs
│   │       ├── integration_tests.rs
│   │       ├── mod.rs
│   │       └── smart_contract_tests.rs
│   ├── icn_currency
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── asset_token.rs
│   │       ├── bond.rs
│   │       ├── currency.rs
│   │       ├── lib.rs
│   │       └── wallet.rs
│   ├── icn_governance
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── democracy.rs
│   │       ├── governance.rs
│   │       ├── lib.rs
│   │       ├── proposal.rs
│   │       └── voting.rs
│   ├── icn_identity
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── did.rs
│   │       ├── identity_manager.rs
│   │       └── lib.rs
│   ├── icn_incentives
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── lib.rs
│   ├── icn_language
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── lib.rs
│   ├── icn_market
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── entities.rs
│   │       ├── lib.rs
│   │       ├── market.rs
│   │       ├── market_tests.rs
│   │       └── transaction.rs
│   ├── icn_network
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── discovery.rs
│   │       ├── lib.rs
│   │       ├── naming.rs
│   │       ├── network.rs
│   │       ├── node.rs
│   │       ├── packet.rs
│   │       ├── protocol.rs
│   │       ├── routing.rs
│   │       └── security.rs
│   ├── icn_node_management
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── content_store.rs
│   │       ├── fib.rs
│   │       ├── icn_node.rs
│   │       ├── lib.rs
│   │       ├── node.rs
│   │       └── pit.rs
│   ├── icn_reputation
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── lib.rs
│   ├── icn_sharding
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── cross_shard_communication.rs
│   │       ├── cross_shard_sync.rs
│   │       ├── cross_shard_transaction_manager.rs
│   │       └── lib.rs
│   ├── icn_smart_contracts
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── contract.pest
│   │       └── lib.rs
│   ├── icn_storage
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── lib.rs
│   │       ├── storage_manager.rs
│   │       └── storage_node.rs
│   ├── icn_testnet
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── main.rs
│   ├── icn_utils
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── error.rs
│   │       ├── lib.rs
│   │       ├── types
│   │       │   ├── block.rs
│   │       │   ├── mod.rs
│   │       │   └── transaction.rs
│   │       └── utils.rs
│   ├── icn_vm
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── compiler.rs
│   │       ├── coop_vm.rs
│   │       ├── lib.rs
│   │       ├── opcode.rs
│   │       ├── smart_contract.rs
│   │       ├── templates.rs
│   │       └── vm.rs
│   └── icn_zkp
│       ├── Cargo.toml
│       └── src
│           ├── circuits.rs
│           └── lib.rs
├── docs
│   ├── API.md
│   ├── ARCHITECTURE.md
│   ├── CONTRIBUTING.md
│   └── README.md
├── examples
│   └── voting_contract.coop
├── PROJECT_STRUCTURE_AND_CODE_CONTENTS.txt
├── README.md
├── update_project.sh
└── vendor
    ├── bitvec
    │   ├── AUTHORS.txt
    │   ├── benches
    │   │   ├── eq.rs
    │   │   ├── macros.rs
    │   │   ├── memcpy.rs
    │   │   ├── mut_access.rs
    │   │   └── slice.rs
    │   ├── book
    │   │   ├── bit-ordering.md
    │   │   ├── data-structures
    │   │   │   ├── bitarray.md
    │   │   │   ├── bitslice.md
    │   │   │   └── bitvec.md
    │   │   ├── data-structures.md
    │   │   ├── dedication.md
    │   │   ├── introduction.md
    │   │   ├── memory-model.md
    │   │   ├── pointer-encoding.md
    │   │   ├── practical-use
    │   │   │   ├── bitfields.md
    │   │   │   └── collections.md
    │   │   ├── practical-use.md
    │   │   ├── SUMMARY.md
    │   │   ├── type-parameters
    │   │   │   ├── bitorder.md
    │   │   │   └── bitstore.md
    │   │   └── type-parameters.md
    │   ├── book.toml
    │   ├── Cargo.toml
    │   ├── CHANGELOG.md
    │   ├── ci
    │   │   ├── coverage.sh
    │   │   ├── install_rust.sh
    │   │   ├── install_tarpaulin.sh
    │   │   ├── script.sh
    │   │   ├── target_local.txt
    │   │   ├── target_notest.txt
    │   │   └── target_test.txt
    │   ├── clippy.toml
    │   ├── CODE_OF_CONDUCT.md
    │   ├── CONTRIBUTING.md
    │   ├── examples
    │   │   ├── aliasing.rs
    │   │   ├── ipv4.rs
    │   │   ├── sieve.rs
    │   │   └── tour.rs
    │   ├── Justfile
    │   ├── LICENSE.txt
    │   ├── README.md
    │   ├── rustfmt-nightly.toml
    │   ├── rustfmt.toml
    │   ├── rust-toolchain
    │   ├── SECURITY.md
    │   ├── src
    │   │   ├── access.rs
    │   │   ├── array
    │   │   │   ├── iter.rs
    │   │   │   ├── ops.rs
    │   │   │   ├── tests.rs
    │   │   │   └── traits.rs
    │   │   ├── array.rs
    │   │   ├── boxed
    │   │   │   ├── api.rs
    │   │   │   ├── iter.rs
    │   │   │   ├── ops.rs
    │   │   │   ├── tests.rs
    │   │   │   └── traits.rs
    │   │   ├── boxed.rs
    │   │   ├── devel.rs
    │   │   ├── domain.rs
    │   │   ├── field
    │   │   │   ├── io.rs
    │   │   │   ├── permutation_tests.rs
    │   │   │   └── tests.rs
    │   │   ├── field.rs
    │   │   ├── index.rs
    │   │   ├── lib.rs
    │   │   ├── macros
    │   │   │   ├── internal.rs
    │   │   │   └── tests.rs
    │   │   ├── macros.rs
    │   │   ├── mem.rs
    │   │   ├── order.rs
    │   │   ├── prelude.rs
    │   │   ├── ptr
    │   │   │   ├── address.rs
    │   │   │   ├── proxy.rs
    │   │   │   ├── range.rs
    │   │   │   ├── single.rs
    │   │   │   ├── span.rs
    │   │   │   └── tests.rs
    │   │   ├── ptr.rs
    │   │   ├── serdes.rs
    │   │   ├── slice
    │   │   │   ├── api.rs
    │   │   │   ├── iter.rs
    │   │   │   ├── ops.rs
    │   │   │   ├── specialization.rs
    │   │   │   ├── tests.rs
    │   │   │   └── traits.rs
    │   │   ├── slice.rs
    │   │   ├── store.rs
    │   │   ├── vec
    │   │   │   ├── api.rs
    │   │   │   ├── iter.rs
    │   │   │   ├── ops.rs
    │   │   │   ├── tests.rs
    │   │   │   └── traits.rs
    │   │   ├── vec.rs
    │   │   └── view.rs
    │   ├── tarpaulin.toml
    │   └── tests
    │       ├── bincode.rs
    │       ├── equality.rs
    │       ├── foreign_order.rs
    │       ├── issues.rs
    │       ├── readme.rs
    │       └── serdes.rs
    └── funty
        ├── AUTHORS.txt
        ├── Cargo.toml
        ├── CHANGELOG.md
        ├── CODE_OF_CONDUCT.md
        ├── CONTRIBUTING.md
        ├── Justfile
        ├── LICENSE.txt
        ├── README.md
        ├── rustfmt-nightly.toml
        ├── rustfmt.toml
        ├── rust-toolchain
        ├── src
        │   └── lib.rs
        └── tests
            └── readme.rs

72 directories, 235 files
===== END OF FILE STRUCTURE =====

===== START OF /home/matt/InterCooperative-Network/Cargo.toml =====
[workspace]
members = [
    "crates/icn_common",
    "crates/icn_blockchain",
    "crates/icn_consensus",
    "crates/icn_currency",
    "crates/icn_governance",
    "crates/icn_identity",
    "crates/icn_network",
    "crates/icn_sharding",
    "crates/icn_storage",
    "crates/icn_vm",
    "crates/icn_api",
    "crates/icn_testnet",
    "crates/icn_core",
    "crates/icn_zkp",
    "crates/icn_smart_contracts",
    "crates/icn_reputation",
    "crates/icn_market",
    "crates/icn_incentives",
    "crates/icn_language"
]

resolver = "2"

[workspace.dependencies]
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
chrono = { version = "0.4", features = ["serde"] }
thiserror = "1.0"
log = "0.4"
env_logger = "0.9"

[patch.crates-io]
bitvec = { version = "0.19.5" }
funty = { version = "1.1.0" }===== END OF /home/matt/InterCooperative-Network/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_api/Cargo.toml =====
[package]
name = "icn_api"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
icn_blockchain = { path = "../icn_blockchain" }
icn_consensus = { path = "../icn_consensus" }
icn_currency = { path = "../icn_currency" }
icn_governance = { path = "../icn_governance" }
icn_identity = { path = "../icn_identity" }
icn_network = { path = "../icn_network" }
icn_sharding = { path = "../icn_sharding" }
icn_storage = { path = "../icn_storage" }
icn_vm = { path = "../icn_vm" }
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
log = "0.4"
thiserror = "1.0"

[dev-dependencies]
tokio-test = "0.4"
===== END OF /home/matt/InterCooperative-Network/crates/icn_api/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_api/src/lib.rs =====
use icn_common::{Block, Transaction, Proposal, ProposalStatus, CurrencyType};
use icn_common::{CommonError, CommonResult};
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};
use std::sync::Arc;
use tokio::sync::RwLock;
use log::{info, error};

/// A generic API response structure.
#[derive(Serialize, Deserialize)]
pub struct ApiResponse<T> {
    /// Indicates whether the API call was successful.
    pub success: bool,
    /// Contains the data returned by the API call, if any.
    pub data: Option<T>,
    /// Contains the error message, if any.
    pub error: Option<String>,
}

/// API Layer struct to manage different modules.
pub struct ApiLayer {
    blockchain: Arc<RwLock<dyn BlockchainInterface>>,
    consensus: Arc<RwLock<dyn ConsensusInterface>>,
    currency_system: Arc<RwLock<dyn CurrencySystemInterface>>,
    governance: Arc<RwLock<dyn GovernanceInterface>>,
}

/// Struct containing information about the blockchain.
#[derive(Clone, Serialize, Deserialize)]
pub struct BlockchainInfo {
    pub block_count: usize,
    pub last_block_hash: Option<String>,
}

/// Struct representing a vote in the governance system.
#[derive(Serialize, Deserialize)]
pub struct Vote {
    pub voter: String,
    pub proposal_id: String,
    pub in_favor: bool,
    pub weight: f64,
}

impl ApiLayer {
    /// Creates a new instance of ApiLayer.
    ///
    /// # Arguments
    ///
    /// * `blockchain` - A reference to the blockchain module.
    /// * `consensus` - A reference to the consensus module.
    /// * `currency_system` - A reference to the currency system module.
    /// * `governance` - A reference to the governance module.
    pub fn new(
        blockchain: Arc<RwLock<dyn BlockchainInterface>>,
        consensus: Arc<RwLock<dyn ConsensusInterface>>,
        currency_system: Arc<RwLock<dyn CurrencySystemInterface>>,
        governance: Arc<RwLock<dyn GovernanceInterface>>,
    ) -> Self {
        ApiLayer {
            blockchain,
            consensus,
            currency_system,
            governance,
        }
    }

    /// Fetches information about the blockchain.
    ///
    /// # Returns
    ///
    /// * `CommonResult<ApiResponse<BlockchainInfo>>` - The result of the API call containing blockchain information.
    pub async fn get_blockchain_info(&self) -> CommonResult<ApiResponse<BlockchainInfo>> {
        info!("Fetching blockchain info");
        let blockchain = self.blockchain.read().await;
        match blockchain.get_info().await {
            Ok(info) => Ok(ApiResponse {
                success: true,
                data: Some(info),
                error: None,
            }),
            Err(e) => {
                error!("Failed to fetch blockchain info: {:?}", e);
                Ok(ApiResponse {
                    success: false,
                    data: None,
                    error: Some(e.to_string()),
                })
            }
        }
    }

    /// Submits a transaction to the blockchain.
    ///
    /// # Arguments
    ///
    /// * `transaction` - The transaction to be submitted.
    ///
    /// # Returns
    ///
    /// * `CommonResult<ApiResponse<String>>` - The result of the API call.
    pub async fn submit_transaction(&self, transaction: Transaction) -> CommonResult<ApiResponse<String>> {
        info!("Submitting transaction: {:?}", transaction);
        let mut blockchain = self.blockchain.write().await;
        match blockchain.add_transaction(transaction).await {
            Ok(_) => Ok(ApiResponse {
                success: true,
                data: Some("Transaction submitted successfully".to_string()),
                error: None,
            }),
            Err(e) => {
                error!("Failed to submit transaction: {:?}", e);
                Ok(ApiResponse {
                    success: false,
                    data: None,
                    error: Some(e.to_string()),
                })
            }
        }
    }

    /// Fetches the balance for a given address and currency type.
    ///
    /// # Arguments
    ///
    /// * `address` - The address to fetch the balance for.
    /// * `currency_type` - The type of currency to fetch the balance of.
    ///
    /// # Returns
    ///
    /// * `CommonResult<ApiResponse<f64>>` - The result of the API call.
    pub async fn get_balance(&self, address: &str, currency_type: &CurrencyType) -> CommonResult<ApiResponse<f64>> {
        info!("Fetching balance for address: {}, currency type: {:?}", address, currency_type);
        let currency_system = self.currency_system.read().await;
        match currency_system.get_balance(address, currency_type).await {
            Ok(balance) => Ok(ApiResponse {
                success: true,
                data: Some(balance),
                error: None,
            }),
            Err(e) => {
                error!("Failed to fetch balance: {:?}", e);
                Ok(ApiResponse {
                    success: false,
                    data: None,
                    error: Some(e.to_string()),
                })
            }
        }
    }

    /// Creates a new proposal in the governance system.
    ///
    /// # Arguments
    ///
    /// * `proposal` - The proposal to be created.
    ///
    /// # Returns
    ///
    /// * `CommonResult<ApiResponse<String>>` - The result of the API call.
    pub async fn create_proposal(&self, proposal: Proposal) -> CommonResult<ApiResponse<String>> {
        info!("Creating proposal: {:?}", proposal);
        let mut governance = self.governance.write().await;
        match governance.create_proposal(proposal).await {
            Ok(proposal_id) => Ok(ApiResponse {
                success: true,
                data: Some(proposal_id),
                error: None,
            }),
            Err(e) => {
                error!("Failed to create proposal: {:?}", e);
                Ok(ApiResponse {
                    success: false,
                    data: None,
                    error: Some(e.to_string()),
                })
            }
        }
    }

    /// Votes on an existing proposal.
    ///
    /// # Arguments
    ///
    /// * `vote` - The vote to be cast.
    ///
    /// # Returns
    ///
    /// * `CommonResult<ApiResponse<String>>` - The result of the API call.
    pub async fn vote_on_proposal(&self, vote: Vote) -> CommonResult<ApiResponse<String>> {
        info!("Voting on proposal: {:?}", vote);
        let mut governance = self.governance.write().await;
        match governance.vote_on_proposal(vote).await {
            Ok(_) => Ok(ApiResponse {
                success: true,
                data: Some("Vote recorded successfully".to_string()),
                error: None,
            }),
            Err(e) => {
                error!("Failed to vote on proposal: {:?}", e);
                Ok(ApiResponse {
                    success: false,
                    data: None,
                    error: Some(e.to_string()),
                })
            }
        }
    }

    /// Fetches the status of a given proposal.
    ///
    /// # Arguments
    ///
    /// * `proposal_id` - The ID of the proposal to fetch the status of.
    ///
    /// # Returns
    ///
    /// * `CommonResult<ApiResponse<ProposalStatus>>` - The result of the API call.
    pub async fn get_proposal_status(&self, proposal_id: &str) -> CommonResult<ApiResponse<ProposalStatus>> {
        info!("Fetching proposal status for ID: {}", proposal_id);
        let governance = self.governance.read().await;
        match governance.get_proposal_status(proposal_id).await {
            Ok(status) => Ok(ApiResponse {
                success: true,
                data: Some(status),
                error: None,
            }),
            Err(e) => {
                error!("Failed to fetch proposal status: {:?}", e);
                Ok(ApiResponse {
                    success: false,
                    data: None,
                    error: Some(e.to_string()),
                })
            }
        }
    }
}

#[async_trait::async_trait]
pub trait BlockchainInterface {
    async fn get_info(&self) -> CommonResult<BlockchainInfo>;
    async fn add_transaction(&mut self, transaction: Transaction) -> CommonResult<()>;
}

#[async_trait::async_trait]
pub trait ConsensusInterface {
    async fn validate_block(&self, block: &Block) -> CommonResult<()>;
}

#[async_trait::async_trait]
pub trait CurrencySystemInterface {
    async fn get_balance(&self, address: &str, currency_type: &CurrencyType) -> CommonResult<f64>;
}

#[async_trait::async_trait]
pub trait GovernanceInterface {
    async fn create_proposal(&mut self, proposal: Proposal) -> CommonResult<String>;
    async fn vote_on_proposal(&mut self, vote: Vote) -> CommonResult<()>;
    async fn get_proposal_status(&self, proposal_id: &str) -> CommonResult<ProposalStatus>;
}

#[cfg(test)]
mod tests {
    use super::*;
    use tokio;

    struct MockBlockchain;
    struct MockConsensus;
    struct MockCurrencySystem;
    struct MockGovernance;

    #[async_trait::async_trait]
    impl BlockchainInterface for MockBlockchain {
        async fn get_info(&self) -> CommonResult<BlockchainInfo> {
            Ok(BlockchainInfo {
                block_count: 1,
                last_block_hash: Some("0000000000000000000000000000000000000000000000000000000000000000".to_string()),
            })
        }

        async fn add_transaction(&mut self, _transaction: Transaction) -> CommonResult<()> {
            Ok(())
        }
    }

    #[async_trait::async_trait]
    impl ConsensusInterface for MockConsensus {
        async fn validate_block(&self, _block: &Block) -> CommonResult<()> {
            Ok(())
        }
    }

    #[async_trait::async_trait]
    impl CurrencySystemInterface for MockCurrencySystem {
        async fn get_balance(&self, _address: &str, _currency_type: &CurrencyType) -> CommonResult<f64> {
            Ok(100.0)
        }
    }

    #[async_trait::async_trait]
    impl GovernanceInterface for MockGovernance {
        async fn create_proposal(&mut self, _proposal: Proposal) -> CommonResult<String> {
            Ok("new_proposal_id".to_string())
        }

        async fn vote_on_proposal(&mut self, _vote: Vote) -> CommonResult<()> {
            Ok(())
        }

        async fn get_proposal_status(&self, _proposal_id: &str) -> CommonResult<ProposalStatus> {
            Ok(ProposalStatus::Active)
        }
    }

    #[tokio::test]
    async fn test_api_layer() {
        let api = ApiLayer::new(
            Arc::new(RwLock::new(MockBlockchain)),
            Arc::new(RwLock::new(MockConsensus)),
            Arc::new(RwLock::new(MockCurrencySystem)),
            Arc::new(RwLock::new(MockGovernance)),
        );

        let blockchain_info = api.get_blockchain_info().await.unwrap();
        assert!(blockchain_info.success);
        assert_eq!(blockchain_info.data.unwrap().block_count, 1);

        let transaction = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 50.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: Utc::now().timestamp(),
            signature: None,
        };
        let submit_result = api.submit_transaction(transaction).await.unwrap();
        assert!(submit_result.success);

        let balance_result = api.get_balance("Alice", &CurrencyType::BasicNeeds).await.unwrap();
        assert!(balance_result.success);
        assert_eq!(balance_result.data.unwrap(), 100.0);

        let proposal = Proposal {
            id: "".to_string(),
            title: "Test Proposal".to_string(),
            description: "This is a test proposal".to_string(),
            proposer: "Alice".to_string(),
            created_at: Utc::now(),
            voting_ends_at: Utc::now() + chrono::Duration::days(7),
            status: ProposalStatus::Active,
            proposal_type: ProposalType::Constitutional,
            category: ProposalCategory::Economic,
            required_quorum: 0.66,
            execution_timestamp: None,
        };
        let create_proposal_result = api.create_proposal(proposal).await.unwrap();
        assert!(create_proposal_result.success);

        let vote = Vote {
            voter: "Bob".to_string(),
            proposal_id: "new_proposal_id".to_string(),
            in_favor: true,
            weight: 1.0,
        };
        let vote_result = api.vote_on_proposal(vote).await.unwrap();
        assert!(vote_result.success);

        let status_result = api.get_proposal_status("new_proposal_id").await.unwrap();
        assert!(status_result.success);
        assert_eq!(status_result.data.unwrap(), ProposalStatus::Active);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_api/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_blockchain/Cargo.toml =====
[package]
name = "icn_blockchain"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
sha2 = "0.10"
log = "0.4"
thiserror = "1.0"

[dev-dependencies]
tokio-test = "0.4"
===== END OF /home/matt/InterCooperative-Network/crates/icn_blockchain/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_blockchain/src/asset_tokenization.rs =====
use crate::{Transaction, Blockchain};
use icn_common::error::{IcnError, IcnResult};

/// A struct for validating transactions.
pub struct TransactionValidator;

impl TransactionValidator {
    /// Validates a transaction within the context of a blockchain.
    ///
    /// # Arguments
    ///
    /// * `transaction` - The transaction to validate.
    /// * `blockchain` - The blockchain context.
    ///
    /// # Returns
    ///
    /// `IcnResult<()>` indicating whether the transaction is valid.
    pub fn validate_transaction(transaction: &Transaction, blockchain: &Blockchain) -> IcnResult<()> {
        if Self::is_double_spend(transaction, blockchain)? {
            return Err(IcnError::Blockchain("Double spend detected".to_string()));
        }

        if !Self::validate_currency_and_amount(transaction) {
            return Err(IcnError::Currency("Invalid currency or amount".to_string()));
        }

        if !Self::check_sufficient_balance(transaction, blockchain)? {
            return Err(IcnError::Currency("Insufficient balance".to_string()));
        }

        if !Self::validate_signature(transaction)? {
            return Err(IcnError::Identity("Invalid signature".to_string()));
        }

        Ok(())
    }

    fn is_double_spend(transaction: &Transaction, blockchain: &Blockchain) -> IcnResult<bool> {
        for block in &blockchain.chain {
            for tx in &block.transactions {
                if tx == transaction {
                    return Ok(true);
                }
            }
        }
        Ok(false)
    }

    fn validate_currency_and_amount(transaction: &Transaction) -> bool {
        transaction.amount > 0.0
    }

    fn check_sufficient_balance(transaction: &Transaction, blockchain: &Blockchain) -> IcnResult<bool> {
        let balance = blockchain.get_balance(&transaction.from, &transaction.currency_type)?;
        Ok(balance >= transaction.amount + transaction.get_fee())
    }

    fn validate_signature(transaction: &Transaction) -> IcnResult<bool> {
        transaction.verify().map_err(|e| IcnError::Identity(format!("Signature verification failed: {}", e)))
    }

    /// Checks if a transaction can be processed by the blockchain.
    ///
    /// # Arguments
    ///
    /// * `transaction` - The transaction to check.
    /// * `blockchain` - The blockchain context.
    ///
    /// # Returns
    ///
    /// `IcnResult<()>` indicating whether the transaction can be processed.
    pub fn can_process_transaction(transaction: &Transaction, blockchain: &Blockchain) -> IcnResult<()> {
        Self::validate_transaction(transaction, blockchain)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::currency::CurrencyType;
    use icn_common::{Transaction, Blockchain};
    use ed25519_dalek::Keypair;
    use rand::rngs::OsRng;

    fn create_signed_transaction(from: &str, to: &str, amount: f64) -> Transaction {
        let mut tx = Transaction::new(
            from.to_string(),
            to.to_string(),
            amount,
            CurrencyType::BasicNeeds,
            1000,
        );
        let mut csprng = OsRng{};
        let keypair: Keypair = Keypair::generate(&mut csprng);
        tx.sign(&keypair).unwrap();
        tx
    }

    #[test]
    fn test_validate_transaction() {
        let mut blockchain = Blockchain::new(Box::new(MockTransactionValidator));
        let tx = create_signed_transaction("Alice", "Bob", 50.0);

        blockchain.add_transaction(create_signed_transaction("Genesis", "Alice", 100.0)).unwrap();
        blockchain.create_block().unwrap();

        assert!(TransactionValidator::validate_transaction(&tx, &blockchain).is_ok());
    }

    #[test]
    fn test_insufficient_balance() {
        let mut blockchain = Blockchain::new(Box::new(MockTransactionValidator));
        let tx = create_signed_transaction("Alice", "Bob", 150.0);

        blockchain.add_transaction(create_signed_transaction("Genesis", "Alice", 100.0)).unwrap();
        blockchain.create_block().unwrap();

        assert!(TransactionValidator::validate_transaction(&tx, &blockchain).is_err());
    }

    #[test]
    fn test_double_spend() {
        let mut blockchain = Blockchain::new(Box::new(MockTransactionValidator));
        let tx = create_signed_transaction("Alice", "Bob", 50.0);

        blockchain.add_transaction(create_signed_transaction("Genesis", "Alice", 100.0)).unwrap();
        blockchain.create_block().unwrap();

        blockchain.add_transaction(tx.clone()).unwrap();
        blockchain.create_block().unwrap();

        assert!(TransactionValidator::validate_transaction(&tx, &blockchain).is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_blockchain/src/asset_tokenization.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_blockchain/src/blockchain.rs =====
// icn_blockchain/src/blockchain.rs
use icn_common::{Block, Transaction, IcnResult, IcnError, Hashable};
use std::collections::HashMap;
use chrono::Utc;
use log::{info, warn, error};
use std::sync::{Arc, RwLock};
use crate::consensus::ConsensusAlgorithm;

/// Represents a blockchain, maintaining a list of blocks and pending transactions.
pub struct Blockchain {
    chain: Vec<Block>,
    pending_transactions: Vec<Transaction>,
    transaction_validator: Arc<dyn TransactionValidator>,
    consensus: Arc<RwLock<dyn ConsensusAlgorithm>>,
}

impl Blockchain {
    /// Creates a new blockchain with a genesis block.
    ///
    /// # Arguments
    ///
    /// * `transaction_validator` - A validator for verifying transactions.
    /// * `consensus` - The consensus algorithm.
    pub fn new(transaction_validator: Arc<dyn TransactionValidator>, consensus: Arc<RwLock<dyn ConsensusAlgorithm>>) -> Self {
        Blockchain {
            chain: vec![Block::genesis()],
            pending_transactions: Vec::new(),
            transaction_validator,
            consensus,
        }
    }

    /// Adds a new transaction to the list of pending transactions.
    ///
    /// # Arguments
    ///
    /// * `transaction` - The transaction to add.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Blockchain` if the transaction is invalid.
    pub fn add_transaction(&mut self, transaction: Transaction) -> IcnResult<()> {
        self.transaction_validator.validate(&transaction, self)?;
        self.pending_transactions.push(transaction);
        Ok(())
    }

    /// Creates a new block with all pending transactions.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Blockchain` if no previous block is found or if `calculate_hash` fails.
    pub fn create_block(&mut self) -> IcnResult<Block> {
        let previous_block = self.chain.last()
            .ok_or_else(|| IcnError::Blockchain("No previous block found".to_string()))?;

        let mut new_block = Block {
            index: self.chain.len() as u64,
            timestamp: Utc::now().timestamp(),
            transactions: self.pending_transactions.clone(),
            previous_hash: previous_block.hash.clone(),
            hash: String::new(),
        };

        new_block.hash = new_block.hash();
        self.consensus.read().unwrap().validate_block(&new_block)?;

        self.chain.push(new_block.clone());
        self.pending_transactions.clear();

        Ok(new_block)
    }

    /// Validates the integrity of the blockchain.
    ///
    /// # Returns
    ///
    /// `true` if the blockchain is valid, `false` otherwise.
    pub fn validate_chain(&self) -> bool {
        for i in 1..self.chain.len() {
            let current_block = &self.chain[i];
            let previous_block = &self.chain[i - 1];

            if current_block.hash != current_block.hash() {
                return false;
            }

            if current_block.previous_hash != previous_block.hash {
                return false;
            }
        }
        true
    }

    /// Returns the latest block in the blockchain.
    pub fn get_latest_block(&self) -> Option<&Block> {
        self.chain.last()
    }

    /// Returns a block by its index.
    ///
    /// # Arguments
    ///
    /// * `index` - The index of the block.
    ///
    /// # Returns
    ///
    /// The block if found, `None` otherwise.
    pub fn get_block_by_index(&self, index: u64) -> Option<&Block> {
        self.chain.get(index as usize)
    }

    /// Returns a block by its hash.
    ///
    /// # Arguments
    ///
    /// * `hash` - The hash of the block.
    ///
    /// # Returns
    ///
    /// The block if found, `None` otherwise.
    pub fn get_block_by_hash(&self, hash: &str) -> Option<&Block> {
        self.chain.iter().find(|block| block.hash == hash)
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_blockchain/src/blockchain.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_blockchain/src/lib.rs =====
use icn_common::{Block, Transaction, IcnResult, IcnError, Hashable};
use std::collections::HashMap;
use chrono::Utc;
use log::{info, warn, error};
use std::sync::{Arc, RwLock};
use crate::consensus::ConsensusAlgorithm;

/// Represents a blockchain, maintaining a list of blocks and pending transactions.
pub struct Blockchain {
    chain: Vec<Block>,
    pending_transactions: Vec<Transaction>,
    transaction_validator: Arc<dyn TransactionValidator>,
    consensus: Arc<RwLock<dyn ConsensusAlgorithm>>,
}

/// A trait for validating transactions within a blockchain.
pub trait TransactionValidator: Send + Sync {
    /// Validates a transaction within the context of a blockchain.
    ///
    /// # Arguments
    ///
    /// * `transaction` - The transaction to validate.
    /// * `blockchain` - The blockchain context.
    ///
    /// # Returns
    ///
    /// `IcnResult<bool>` indicating whether the transaction is valid.
    fn validate(&self, transaction: &Transaction, blockchain: &Blockchain) -> IcnResult<()>;
}

impl Blockchain {
    /// Creates a new blockchain with a genesis block.
    ///
    /// # Arguments
    ///
    /// * `transaction_validator` - A validator for verifying transactions.
    /// * `consensus` - The consensus algorithm.
    pub fn new(transaction_validator: Arc<dyn TransactionValidator>, consensus: Arc<RwLock<dyn ConsensusAlgorithm>>) -> Self {
        Blockchain {
            chain: vec![Block::genesis()],
            pending_transactions: Vec::new(),
            transaction_validator,
            consensus,
        }
    }

    /// Adds a new transaction to the list of pending transactions.
    ///
    /// # Arguments
    ///
    /// * `transaction` - The transaction to add.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Blockchain` if the transaction is invalid.
    pub fn add_transaction(&mut self, transaction: Transaction) -> IcnResult<()> {
        self.transaction_validator.validate(&transaction, self)?;
        self.pending_transactions.push(transaction);
        Ok(())
    }

    /// Creates a new block with all pending transactions.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Blockchain` if no previous block is found or if `calculate_hash` fails.
    pub fn create_block(&mut self) -> IcnResult<Block> {
        let previous_block = self.chain.last()
            .ok_or_else(|| IcnError::Blockchain("No previous block found".to_string()))?;

        let mut new_block = Block {
            index: self.chain.len() as u64,
            timestamp: Utc::now().timestamp(),
            transactions: self.pending_transactions.clone(),
            previous_hash: previous_block.hash.clone(),
            hash: String::new(),
        };

        new_block.hash = new_block.hash();
        self.consensus.read().unwrap().validate_block(&new_block)?;

        self.chain.push(new_block.clone());
        self.pending_transactions.clear();

        Ok(new_block)
    }

    /// Validates the entire blockchain.
    ///
    /// # Returns
    ///
    /// `bool` indicating whether the blockchain is valid.
    pub fn validate_chain(&self) -> bool {
        for i in 1..self.chain.len() {
            let previous_block = &self.chain[i - 1];
            let current_block = &self.chain[i];

            if current_block.hash != current_block.hash() {
                return false;
            }

            if current_block.previous_hash != previous_block.hash {
                return false;
            }
        }
        true
    }

    /// Returns the latest block in the blockchain.
    pub fn get_latest_block(&self) -> Option<&Block> {
        self.chain.last()
    }

    /// Returns a block by its index.
    ///
    /// # Arguments
    ///
    /// * `index` - The index of the block.
    ///
    /// # Returns
    ///
    /// The block if found, `None` otherwise.
    pub fn get_block_by_index(&self, index: u64) -> Option<&Block> {
        self.chain.get(index as usize)
    }

    /// Returns a block by its hash.
    ///
    /// # Arguments
    ///
    /// * `hash` - The hash of the block.
    ///
    /// # Returns
    ///
    /// The block if found, `None` otherwise.
    pub fn get_block_by_hash(&self, hash: &str) -> Option<&Block> {
        self.chain.iter().find(|block| block.hash == hash)
    }

    /// Stops the blockchain.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn stop(&self) -> IcnResult<()> {
        info!("Blockchain stopped");
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_common::CurrencyType;
    use std::sync::Arc;
    use crate::consensus::PoCConsensus;

    struct MockTransactionValidator;

    impl TransactionValidator for MockTransactionValidator {
        fn validate(&self, _transaction: &Transaction, _blockchain: &Blockchain) -> IcnResult<()> {
            Ok(())
        }
    }

    #[test]
    fn test_blockchain_creation() {
        let consensus = Arc::new(RwLock::new(PoCConsensus::new(0.66, 0.51).unwrap()));
        let blockchain = Blockchain::new(Arc::new(MockTransactionValidator), consensus);
        assert_eq!(blockchain.chain.len(), 1);
        assert_eq!(blockchain.chain[0].index, 0);
    }

    #[test]
    fn test_add_block() {
        let consensus = Arc::new(RwLock::new(PoCConsensus::new(0.66, 0.51).unwrap()));
        let mut blockchain = Blockchain::new(Arc::new(MockTransactionValidator), consensus);
        let transaction = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            100.0,
            CurrencyType::BasicNeeds,
            Utc::now().timestamp(),
        );
        blockchain.add_transaction(transaction).unwrap();
        assert!(blockchain.create_block().is_ok());
        assert_eq!(blockchain.chain.len(), 2);
    }

    #[test]
    fn test_blockchain_validity() {
        let consensus = Arc::new(RwLock::new(PoCConsensus::new(0.66, 0.51).unwrap()));
        let mut blockchain = Blockchain::new(Arc::new(MockTransactionValidator), consensus);
        let transaction = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            100.0,
            CurrencyType::BasicNeeds,
            Utc::now().timestamp(),
        );
        blockchain.add_transaction(transaction).unwrap();
        blockchain.create_block().unwrap();
        assert!(blockchain.validate_chain());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_blockchain/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_blockchain/src/transaction_validator.rs =====
use crate::{Transaction, Blockchain};
use icn_common::error::{IcnError, IcnResult};
use chrono::{DateTime, Utc};

pub struct TransactionValidator;

impl TransactionValidator {
    /// Validates a transaction within the context of a blockchain.
    ///
    /// # Arguments
    ///
    /// * `transaction` - The transaction to validate.
    /// * `blockchain` - The blockchain context.
    ///
    /// # Returns
    ///
    /// Returns `IcnResult` if the transaction is valid, otherwise an error.
    pub fn validate_transaction(transaction: &Transaction, blockchain: &Blockchain) -> IcnResult<()> {
        if Self::is_double_spend(transaction, blockchain)? {
            return Err(IcnError::Blockchain("Double spend detected".to_string()));
        }

        if !Self::validate_currency_and_amount(transaction) {
            return Err(IcnError::Currency("Invalid currency or amount".to_string()));
        }

        if !Self::check_sufficient_balance(transaction, blockchain)? {
            return Err(IcnError::Currency("Insufficient balance".to_string()));
        }

        if !Self::validate_signature(transaction)? {
            return Err(IcnError::Identity("Invalid signature".to_string()));
        }

        if !Self::validate_timestamp(transaction) {
            return Err(IcnError::Blockchain("Transaction timestamp is not valid".to_string()));
        }

        Ok(())
    }

    fn is_double_spend(transaction: &Transaction, blockchain: &Blockchain) -> IcnResult<bool> {
        for block in &blockchain.chain {
            for tx in &block.transactions {
                if tx == transaction {
                    return Ok(true);
                }
            }
        }
        Ok(false)
    }

    fn validate_currency_and_amount(transaction: &Transaction) -> bool {
        transaction.amount > 0.0
    }

    fn check_sufficient_balance(transaction: &Transaction, blockchain: &Blockchain) -> IcnResult<bool> {
        let balance = blockchain.get_balance(&transaction.from, &transaction.currency_type)?;
        Ok(balance >= transaction.amount + transaction.get_fee())
    }

    fn validate_signature(transaction: &Transaction) -> IcnResult<bool> {
        transaction.verify().map_err(|e| IcnError::Identity(format!("Signature verification failed: {}", e)))
    }

    fn validate_timestamp(transaction: &Transaction) -> bool {
        let current_time = Utc::now().timestamp();
        transaction.timestamp <= current_time && transaction.timestamp >= (current_time - 60 * 60) // within the last hour
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_common::{Transaction, Blockchain};
    use ed25519_dalek::Keypair;
    use rand::rngs::OsRng;
    use std::sync::Arc;

    fn create_signed_transaction(from: &str, to: &str, amount: f64) -> Transaction {
        let mut tx = Transaction::new(
            from.to_string(),
            to.to_string(),
            amount,
            CurrencyType::BasicNeeds,
            1000,
        );
        let mut csprng = OsRng{};
        let keypair: Keypair = Keypair::generate(&mut csprng);
        tx.sign(&keypair).unwrap();
        tx
    }

    #[test]
    fn test_validate_transaction() {
        let mut blockchain = Blockchain::new(Arc::new(TransactionValidator));
        let tx = create_signed_transaction("Alice", "Bob", 50.0);

        blockchain.add_transaction(create_signed_transaction("Genesis", "Alice", 100.0)).unwrap();
        blockchain.create_block().unwrap();

        assert!(TransactionValidator::validate_transaction(&tx, &blockchain).is_ok());
    }

    #[test]
    fn test_insufficient_balance() {
        let mut blockchain = Blockchain::new(Arc::new(TransactionValidator));
        let tx = create_signed_transaction("Alice", "Bob", 150.0);

        blockchain.add_transaction(create_signed_transaction("Genesis", "Alice", 100.0)).unwrap();
        blockchain.create_block().unwrap();

        assert!(TransactionValidator::validate_transaction(&tx, &blockchain).is_err());
    }

    #[test]
    fn test_double_spend() {
        let mut blockchain = Blockchain::new(Arc::new(TransactionValidator));
        let tx = create_signed_transaction("Alice", "Bob", 50.0);

        blockchain.add_transaction(create_signed_transaction("Genesis", "Alice", 100.0)).unwrap();
        blockchain.create_block().unwrap();

        blockchain.add_transaction(tx.clone()).unwrap();
        blockchain.create_block().unwrap();

        assert!(TransactionValidator::validate_transaction(&tx, &blockchain).is_err());
    }

    #[test]
    fn test_invalid_timestamp() {
        let mut blockchain = Blockchain::new(Arc::new(TransactionValidator));
        let mut tx = create_signed_transaction("Alice", "Bob", 50.0);
        tx.timestamp = Utc::now().timestamp() + 60 * 60; // Set to future time

        assert!(TransactionValidator::validate_transaction(&tx, &blockchain).is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_blockchain/src/transaction_validator.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_common/Cargo.toml =====
[package]
name = "icn_common"
version = "0.1.0"
authors = ["Your Name <your.email@example.com>"]
edition = "2018"

[dependencies]
chrono = "0.4"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
sha2 = "0.9"
rand = "0.8"
rand_chacha = "0.3"
ed25519-dalek = "1.0"
thiserror = "1.0"

[dev-dependencies]
rand = "0.8"
rand_chacha = "0.3"
===== END OF /home/matt/InterCooperative-Network/crates/icn_common/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_common/src/error.rs =====
use thiserror::Error;

/// Custom error type for the ICN project.
#[derive(Error, Debug)]
pub enum IcnError {
    #[error("Blockchain error: {0}")]
    Blockchain(String),

    #[error("Consensus error: {0}")]
    Consensus(String),

    #[error("Currency error: {0}")]
    Currency(String),

    #[error("Governance error: {0}")]
    Governance(String),

    #[error("Identity error: {0}")]
    Identity(String),

    #[error("Network error: {0}")]
    Network(String),

    #[error("Node management error: {0}")]
    NodeManagement(String),

    #[error("Sharding error: {0}")]
    Sharding(String),

    #[error("Storage error: {0}")]
    Storage(String),

    #[error("VM error: {0}")]
    Vm(String),

    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),

    #[error("Serialization error: {0}")]
    Serialization(#[from] serde_json::Error),

    #[error("Database error: {0}")]
    Database(String),

    #[error("Configuration error: {0}")]
    Config(String),

    #[error("Zero-Knowledge Proof error: {0}")]
    ZKP(String),

    #[error("Unknown error: {0}")]
    Unknown(String),
}

/// Result type for the ICN project.
pub type IcnResult<T> = std::result::Result<T, IcnError>;
===== END OF /home/matt/InterCooperative-Network/crates/icn_common/src/error.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_common/src/lib.rs =====
/// Module for common types and utilities used across the ICN project.
use chrono::{DateTime, Utc};
use rand_chacha::ChaChaRng;
use rand_chacha::rand_core::SeedableRng;
use rand::RngCore;
use ed25519_dalek::Keypair;
use bellman::{Circuit, ConstraintSystem, SynthesisError};
use bls12_381::Bls12;

pub mod error;
pub use error::{IcnError, IcnResult};

/// Enumeration representing different types of currencies.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum CurrencyType {
    BasicNeeds,
    Education,
    Environmental,
    Community,
    Volunteer,
    Storage,
    Processing,
    Energy,
    Luxury,
    Service,
    Custom(String),
    AssetToken(String),
    Bond(String),
}

/// Structure representing a transaction.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Transaction {
    pub from: String,
    pub to: String,
    pub amount: f64,
    pub currency_type: CurrencyType,
    pub timestamp: i64,
    pub signature: Option<Vec<u8>>,
    pub zkp: Option<ZKProof>,
}

/// Structure representing a block in the blockchain.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Block {
    pub index: u64,
    pub timestamp: i64,
    pub transactions: Vec<Transaction>,
    pub previous_hash: String,
    pub hash: String,
    pub zkp_accumulator: Option<ZKAccumulator>,
}

/// Structure representing a proposal for governance.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proposal {
    pub id: String,
    pub title: String,
    pub description: String,
    pub proposer: String,
    pub created_at: DateTime<Utc>,
    pub voting_ends_at: DateTime<Utc>,
    pub status: ProposalStatus,
    pub proposal_type: ProposalType,
    pub category: ProposalCategory,
    pub required_quorum: f64,
    pub execution_timestamp: Option<DateTime<Utc>>,
}

/// Enumeration representing the status of a proposal.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProposalStatus {
    Active,
    Passed,
    Rejected,
    Implemented,
}

/// Enumeration representing the type of a proposal.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProposalType {
    Constitutional,
    EconomicAdjustment,
    NetworkUpgrade,
}

/// Enumeration representing the category of a proposal.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProposalCategory {
    Constitutional,
    Economic,
    Technical,
}

/// Structure representing a vote on a proposal.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vote {
    pub voter: String,
    pub proposal_id: String,
    pub in_favor: bool,
    pub weight: f64,
    pub timestamp: DateTime<Utc>,
    pub zkp: Option<ZKProof>,
}

/// Trait defining an object that can be hashed.
pub trait Hashable {
    fn hash(&self) -> String;
}

/// Structure representing a zero-knowledge proof.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ZKProof {
    pub proof: Vec<u8>,
    pub public_inputs: Vec<Vec<u8>>,
}

/// Structure representing a zero-knowledge proof accumulator.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ZKAccumulator {
    pub value: Vec<u8>,
}

/// Trait for synthesizing zero-knowledge circuits.
pub trait ZKCircuit<E: bellman::Engine> {
    fn synthesize<CS: ConstraintSystem<E>>(self, cs: &mut CS) -> Result<(), SynthesisError>;
}

/// Implementation of the Hashable trait for Block.
impl Hashable for Block {
    fn hash(&self) -> String {
        use sha2::{Sha256, Digest};
        let mut hasher = Sha256::new();
        hasher.update(self.index.to_string());
        hasher.update(&self.timestamp.to_string());
        for transaction in &self.transactions {
            hasher.update(&transaction.hash());
        }
        hasher.update(&self.previous_hash);
        format!("{:x}", hasher.finalize())
    }
}

/// Implementation of the Hashable trait for Transaction.
impl Hashable for Transaction {
    fn hash(&self) -> String {
        use sha2::{Sha256, Digest};
        let mut hasher = Sha256::new();
        hasher.update(&self.from);
        hasher.update(&self.to);
        hasher.update(self.amount.to_string().as_bytes());
        hasher.update(format!("{:?}", self.currency_type).as_bytes());
        hasher.update(self.timestamp.to_string().as_bytes());
        if let Some(signature) = &self.signature {
            hasher.update(signature);
        }
        if let Some(zkp) = &self.zkp {
            hasher.update(&zkp.proof);
            for input in &zkp.public_inputs {
                hasher.update(input);
            }
        }
        format!("{:x}", hasher.finalize())
    }
}

/// Implementation of methods for Transaction.
impl Transaction {
    /// Creates a new transaction
    pub fn new(from: String, to: String, amount: f64, currency_type: CurrencyType, timestamp: i64) -> Self {
        Transaction {
            from,
            to,
            amount,
            currency_type,
            timestamp,
            signature: None,
            zkp: None,
        }
    }

    /// Signs the transaction using the provided private key
    pub fn sign(&mut self, private_key: &[u8]) -> IcnResult<()> {
        use ed25519_dalek::{Keypair, Signer};
        let keypair = Keypair::from_bytes(private_key)
            .map_err(|e| IcnError::Identity(format!("Invalid private key: {}", e)))?;
        let message = self.hash().as_bytes().to_vec();
        let signature = keypair.sign(&message);
        self.signature = Some(signature.to_bytes().to_vec());
        Ok(())
    }

    /// Verifies the transaction using the provided public key
    pub fn verify(&self, public_key: &[u8]) -> IcnResult<bool> {
        use ed25519_dalek::{PublicKey, Verifier};
        let public_key = PublicKey::from_bytes(public_key)
            .map_err(|e| IcnError::Identity(format!("Invalid public key: {}", e)))?;
        let message = self.hash().as_bytes().to_vec();
        if let Some(signature) = &self.signature {
            let signature = ed25519_dalek::Signature::from_bytes(signature)
                .map_err(|e| IcnError::Identity(format!("Invalid signature: {}", e)))?;
            Ok(public_key.verify(&message, &signature).is_ok())
        } else {
            Ok(false)
        }
    }

    /// Adds a zero-knowledge proof to the transaction
    pub fn add_zkp(&mut self, proof: Vec<u8>, public_inputs: Vec<Vec<u8>>) {
        self.zkp = Some(ZKProof {
            proof,
            public_inputs,
        });
    }

    /// Verifies the zero-knowledge proof of the transaction
    pub fn verify_zkp<E: bellman::Engine, C: ZKCircuit<E>>(&self, circuit: C, verifying_key: &bellman::groth16::VerifyingKey<E>) -> IcnResult<bool> {
        if let Some(zkp) = &self.zkp {
            let proof = bellman::groth16::Proof::<E>::read(&zkp.proof[..])
                .map_err(|e| IcnError::ZKP(format!("Invalid ZKP: {}", e)))?;
            
            let public_inputs: Vec<E::Fr> = zkp.public_inputs.iter()
                .map(|input| E::Fr::from_str(&hex::encode(input)).unwrap())
                .collect();

            Ok(bellman::groth16::verify_proof(verifying_key, &proof, &public_inputs)
                .map_err(|e| IcnError::ZKP(format!("ZKP verification failed: {}", e)))?)
        } else {
            Ok(false)
        }
    }
}

/// Implementation of methods for Block.
impl Block {
    /// Creates a new block
    pub fn new(index: u64, transactions: Vec<Transaction>, previous_hash: String) -> Self {
        let timestamp = Utc::now().timestamp();
        let mut block = Block {
            index,
            timestamp,
            transactions,
            previous_hash,
            hash: String::new(),
            zkp_accumulator: None,
        };
        block.hash = block.hash();
        block
    }

    /// Creates a genesis block
    pub fn genesis() -> Self {
        Block::new(0, Vec::new(), "0".repeat(64))
    }

    /// Adds a zero-knowledge proof accumulator to the block
    pub fn add_zkp_accumulator(&mut self, accumulator: ZKAccumulator) {
        self.zkp_accumulator = Some(accumulator);
    }
}

/// Structure representing a ZK accumulator circuit.
pub struct ZKAccumulatorCircuit<E: bellman::Engine> {
    pub transactions: Vec<Transaction>,
    pub previous_accumulator: Option<E::Fr>,
}

/// Implementation of the ZKCircuit trait for ZKAccumulatorCircuit.
impl<E: bellman::Engine> ZKCircuit<E> for ZKAccumulatorCircuit<E> {
    fn synthesize<CS: ConstraintSystem<E>>(
        self,
        cs: &mut CS
    ) -> Result<(), SynthesisError> {
        // Implementation of the ZKP circuit for accumulating transactions
        // This is a placeholder and should be implemented based on the specific requirements
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand::rngs::OsRng;
    use rand::SeedableRng;
    use rand_chacha::ChaChaRng;

    #[test]
    fn test_transaction_hash() {
        let tx = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            100.0,
            CurrencyType::BasicNeeds,
            1234567890,
        );
        let hash = tx.hash();
        assert!(!hash.is_empty());
        assert_eq!(hash.len(), 64);
    }

    #[test]
    fn test_block_hash() {
        let tx = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            100.0,
            CurrencyType::BasicNeeds,
            1234567890,
        );
        let block = Block::new(1, vec![tx], "previous_hash".to_string());
        let hash = block.hash();
        assert!(!hash.is_empty());
        assert_eq!(hash.len(), 64);
        assert_eq!(block.hash, hash);
    }

    #[test]
    fn test_transaction_sign_and_verify() {
        use ed25519_dalek::{Keypair, Signer};

        let mut rng = ChaChaRng::from_entropy();
        let keypair: Keypair = Keypair::generate(&mut rng);

        let mut tx = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            100.0,
            CurrencyType::BasicNeeds,
            1234567890,
        );

        tx.sign(keypair.to_bytes().as_ref()).unwrap();
        assert!(tx.verify(keypair.public.as_bytes()).unwrap());

        // Test with wrong public key
        let wrong_keypair: Keypair = Keypair::generate(&mut rng);
        assert!(!tx.verify(wrong_keypair.public.as_bytes()).unwrap());
    }

    #[test]
    fn test_zkp_integration() {
        use bellman::groth16;
        use bls12_381::Bls12;

        // This is a dummy circuit for testing purposes
        struct DummyCircuit;
        impl ZKCircuit<Bls12> for DummyCircuit {
            fn synthesize<CS: ConstraintSystem<Bls12>>(
                self,
                _cs: &mut CS
            ) -> Result<(), SynthesisError> {
                Ok(())
            }
        }

        let mut rng = ChaChaRng::from_entropy();
        let params = groth16::generate_random_parameters::<Bls12, _, _>(DummyCircuit, &mut rng).unwrap();
        let pvk = groth16::prepare_verifying_key(&params.vk);

        let mut tx = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            100.0,
            CurrencyType::BasicNeeds,
            1234567890,
        );

        let proof = groth16::create_random_proof(DummyCircuit, &params, &mut rng).unwrap();
        let proof_vec = proof.write(&mut vec![]).unwrap();
        tx.add_zkp(proof_vec, vec![]);

        assert!(tx.verify_zkp(DummyCircuit, &pvk).unwrap());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_common/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_common/src/main.rs =====
fn main() {
    println!("Hello, world!");
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_common/src/main.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_consensus/Cargo.toml =====
[package]
name = "icn_consensus"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
icn_blockchain = { path = "../icn_blockchain" }
serde = { version = "1.0", features = ["derive"] }
log = "0.4"
thiserror = "1.0"
chrono = { version = "0.4", features = ["serde"] }
rand = "0.8"

[dev-dependencies]
tokio = { version = "1.0", features = ["full"] }
===== END OF /home/matt/InterCooperative-Network/crates/icn_consensus/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_consensus/src/bft_poc.rs =====
use icn_utils::{error::IcnError, IcnResult};
use serde::{Serialize, Deserialize};

#[derive(Debug)]
pub enum ProposalStatus {
    Pending,
    Approved,
    Rejected,
}

impl Clone for ProposalStatus {
    fn clone(&self) -> Self {
        match self {
            ProposalStatus::Pending => ProposalStatus::Pending,
            ProposalStatus::Approved => ProposalStatus::Approved,
            ProposalStatus::Rejected => ProposalStatus::Rejected,
        }
    }
}

#[derive(Debug)]
pub struct Proposal {
    pub id: String,
    pub status: ProposalStatus,
    pub votes: Vec<Vote>,
}

#[derive(Clone)]
pub struct Vote {
    pub member_id: String,
    pub vote: bool,
}

pub struct BFTPoC {
    pub proposals: Vec<Proposal>,
}

impl BFTPoC {
    pub fn new() -> Self {
        BFTPoC {
            proposals: Vec::new(),
        }
    }

    pub fn create_proposal(&mut self, proposal_id: String) -> IcnResult<()> {
        if self.proposals.iter().any(|p| p.id == proposal_id) {
            return Err(IcnError::Governance("Proposal already exists".to_string()));
        }

        let proposal = Proposal {
            id: proposal_id,
            status: ProposalStatus::Pending,
            votes: Vec::new(),
        };

        self.proposals.push(proposal);
        Ok(())
    }

    pub fn vote_on_proposal(&mut self, proposal_id: &str, member_id: String, vote: bool) -> IcnResult<()> {
        let proposal = self.proposals.iter_mut().find(|p| p.id == proposal_id).ok_or_else(|| IcnError::Governance("Proposal not found".to_string()))?;

        if proposal.votes.iter().any(|v| v.member_id == member_id) {
            return Err(IcnError::Governance("Member has already voted".to_string()));
        }

        // Validate the member ID
        if member_id.is_empty() {
            return Err(IcnError::Governance("Invalid member ID".to_string()));
        }

        proposal.votes.push(Vote { member_id, vote });
        Ok(())
    }

    pub fn finalize_proposal(&mut self, proposal_id: &str) -> IcnResult<ProposalStatus> {
        let proposal = self.proposals.iter_mut().find(|p| p.id == proposal_id).ok_or_else(|| IcnError::Governance("Proposal not found".to_string()))?;

        let positive_votes = proposal.votes.iter().filter(|v| v.vote).count();
        let negative_votes = proposal.votes.len() - positive_votes;

        proposal.status = if positive_votes > negative_votes {
            ProposalStatus::Approved
        } else {
            ProposalStatus::Rejected
        };

        Ok(proposal.status.clone())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_proposal() {
        let mut bft_poc = BFTPoC::new();

        assert!(bft_poc.create_proposal("proposal1".to_string()).is_ok());
        assert_eq!(bft_poc.proposals.len(), 1);

        assert!(bft_poc.create_proposal("proposal1".to_string()).is_err());
    }

    #[test]
    fn test_vote_on_proposal() {
        let mut bft_poc = BFTPoC::new();
        bft_poc.create_proposal("proposal1".to_string()).unwrap();

        assert!(bft_poc.vote_on_proposal("proposal1", "member1".to_string(), true).is_ok());
        assert_eq!(bft_poc.proposals[0].votes.len(), 1);

        assert!(bft_poc.vote_on_proposal("proposal1", "member1".to_string(), false).is_err());
    }

    #[test]
    fn test_finalize_proposal() {
        let mut bft_poc = BFTPoC::new();
        bft_poc.create_proposal("proposal1".to_string()).unwrap();

        bft_poc.vote_on_proposal("proposal1", "member1".to_string(), true).unwrap();
        bft_poc.vote_on_proposal("proposal1", "member2".to_string(), false).unwrap();

        let status = bft_poc.finalize_proposal("proposal1").unwrap();
        assert_eq!(status, ProposalStatus::Rejected);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_consensus/src/bft_poc.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_consensus/src/consensus.rs =====
use icn_common::{IcnResult, IcnError, Block, Transaction, CurrencyType};
use std::collections::HashMap;
use log::{info, warn};
use rand::Rng;

/// Represents a member of the consensus network.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Member {
    pub id: String,
    pub reputation: f64,
    pub is_validator: bool,
}

/// Proof of Cooperation (PoC) consensus mechanism.
#[derive(Debug, Serialize, Deserialize)]
pub struct PoCConsensus {
    pub members: HashMap<String, Member>,
    pub threshold: f64,
    pub quorum: f64,
}

impl PoCConsensus {
    /// Creates a new PoCConsensus with the specified threshold and quorum.
    ///
    /// # Arguments
    ///
    /// * `threshold` - The threshold for consensus.
    /// * `quorum` - The quorum for consensus.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Consensus` if the threshold or quorum values are invalid.
    pub fn new(threshold: f64, quorum: f64) -> IcnResult<Self> {
        if threshold <= 0.0 || threshold > 1.0 || quorum <= 0.0 || quorum > 1.0 {
            return Err(IcnError::Consensus("Invalid threshold or quorum value".into()));
        }

        Ok(PoCConsensus {
            members: HashMap::new(),
            threshold,
            quorum,
        })
    }

    /// Adds a new member to the consensus network.
    ///
    /// # Arguments
    ///
    /// * `id` - The ID of the new member.
    /// * `is_validator` - Whether the new member is a validator.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Consensus` if the member already exists.
    pub fn add_member(&mut self, id: String, is_validator: bool) -> IcnResult<()> {
        if self.members.contains_key(&id) {
            return Err(IcnError::Consensus("Member already exists".into()));
        }
        self.members.insert(id.clone(), Member {
            id,
            reputation: 1.0,
            is_validator,
        });
        Ok(())
    }

    /// Removes a member from the consensus network.
    ///
    /// # Arguments
    ///
    /// * `id` - The ID of the member to remove.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Consensus` if the member is not found.
    pub fn remove_member(&mut self, id: &str) -> IcnResult<()> {
        if self.members.remove(id).is_none() {
            return Err(IcnError::Consensus("Member not found".into()));
        }
        Ok(())
    }

    /// Updates the reputation of a member.
    ///
    /// # Arguments
    ///
    /// * `id` - The ID of the member.
    /// * `change` - The amount to change the reputation by.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Consensus` if the member is not found.
    pub fn update_reputation(&mut self, id: &str, change: f64) -> IcnResult<()> {
        let member = self.members.get_mut(id).ok_or_else(|| IcnError::Consensus("Member not found".into()))?;
        member.reputation += change;
        member.reputation = member.reputation.max(0.0); // Ensure reputation doesn't go negative
        Ok(())
    }

    /// Validates a block.
    ///
    /// # Arguments
    ///
    /// * `block` - The block to validate.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Consensus` if the block is invalid.
    pub fn validate_block(&self, block: &Block) -> IcnResult<bool> {
        // In a real implementation, this would involve more complex validation logic
        if block.transactions.is_empty() {
            return Err(IcnError::Consensus("Block has no transactions".into()));
        }
        Ok(true)
    }

    /// Reaches consensus on a block.
    ///
    /// # Arguments
    ///
    /// * `block` - The block to reach consensus on.
    /// * `votes` - The votes for the block.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Consensus` if consensus is not reached.
    pub fn reach_consensus(&self, block: &Block, votes: &[(&str, bool)]) -> IcnResult<bool> {
        let total_reputation: f64 = self.members.values().filter(|m| m.is_validator).map(|m| m.reputation).sum();

        let mut positive_reputation = 0.0;
        let mut participating_reputation = 0.0;

        for (member_id, vote) in votes {
            if let Some(member) = self.members.get(*member_id) {
                if member.is_validator {
                    participating_reputation += member.reputation;
                    if *vote {
                        positive_reputation += member.reputation;
                    }
                }
            } else {
                return Err(IcnError::Consensus("Invalid member in votes".into()));
            }
        }

        if participating_reputation / total_reputation < self.quorum {
            return Err(IcnError::Consensus("Quorum not reached".into()));
        }

        Ok(positive_reputation / participating_reputation >= self.threshold)
    }

    /// Returns a list of all validators.
    pub fn get_validators(&self) -> Vec<&Member> {
        self.members.values().filter(|m| m.is_validator).collect()
    }

    /// Selects a proposer for the next block.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Consensus` if no validators are available.
    pub fn select_proposer(&self) -> IcnResult<&Member> {
        let validators: Vec<&Member> = self.get_validators();
        if validators.is_empty() {
            return Err(IcnError::Consensus("No validators available".into()));
        }

        let total_reputation: f64 = validators.iter().map(|m| m.reputation).sum();
        let mut rng = rand::thread_rng();
        let random_point = rng.gen::<f64>() * total_reputation;

        let mut cumulative_reputation = 0.0;
        for validator in &validators {
            cumulative_reputation += validator.reputation;
            if cumulative_reputation > random_point {
                return Ok(validator);
            }
        }

        // This should never happen, but we'll return the last validator if it does
        Ok(validators.last().unwrap())
    }

    /// Starts the PoC consensus mechanism.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn start(&self) -> IcnResult<()> {
        info!("PoC Consensus mechanism started");
        Ok(())
    }

    /// Stops the PoC consensus mechanism.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn stop(&self) -> IcnResult<()> {
        info!("PoC Consensus mechanism stopped");
        Ok(())
    }
}

/// Trait defining the methods required for a consensus algorithm.
pub trait ConsensusAlgorithm {
    fn validate_block(&self, block: &Block) -> IcnResult<bool>;
    fn reach_consensus(&self, block: &Block, votes: &[(&str, bool)]) -> IcnResult<bool>;
}

impl ConsensusAlgorithm for PoCConsensus {
    fn validate_block(&self, block: &Block) -> IcnResult<bool> {
        self.validate_block(block)
    }

    fn reach_consensus(&self, block: &Block, votes: &[(&str, bool)]) -> IcnResult<bool> {
        self.reach_consensus(block, votes)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_common::CurrencyType;

    #[test]
    fn test_add_and_remove_member() {
        let mut consensus = PoCConsensus::new(0.66, 0.51).unwrap();
        assert!(consensus.add_member("Alice".to_string(), true).is_ok());
        assert!(consensus.add_member("Bob".to_string(), false).is_ok());
        assert_eq!(consensus.members.len(), 2);
        assert!(consensus.remove_member("Alice").is_ok());
        assert_eq!(consensus.members.len(), 1);
        assert!(consensus.remove_member("Charlie").is_err());
    }

    #[test]
    fn test_update_reputation() {
        let mut consensus = PoCConsensus::new(0.66, 0.51).unwrap();
        consensus.add_member("Alice".to_string(), true).unwrap();
        assert!(consensus.update_reputation("Alice", 0.5).is_ok());
        assert_eq!(consensus.members.get("Alice").unwrap().reputation, 1.5);
        assert!(consensus.update_reputation("Bob", 1.0).is_err());
    }

    #[test]
    fn test_reach_consensus() {
        let mut consensus = PoCConsensus::new(0.66, 0.51).unwrap();
        consensus.add_member("Alice".to_string(), true).unwrap();
        consensus.add_member("Bob".to_string(), true).unwrap();
        consensus.add_member("Charlie".to_string(), true).unwrap();

        let block = Block {
            index: 1,
            timestamp: chrono::Utc::now().timestamp(),
            transactions: vec![Transaction::new(
                "Alice".to_string(),
                "Bob".to_string(),
                100.0,
                CurrencyType::BasicNeeds,
                1000,
            )],
            previous_hash: "previous_hash".to_string(),
            hash: "hash".to_string(),
        };

        let votes = vec![
            ("Alice", true),
            ("Bob", true),
            ("Charlie", false),
        ];

        assert!(consensus.reach_consensus(&block, &votes).unwrap());

        let insufficient_votes = vec![
            ("Alice", true),
            ("Bob", true),
        ];

        assert!(consensus.reach_consensus(&block, &insufficient_votes).is_err());
    }

    #[test]
    fn test_select_proposer() {
        let mut consensus = PoCConsensus::new(0.66, 0.51).unwrap();
        consensus.add_member("Alice".to_string(), true).unwrap();
        consensus.add_member("Bob".to_string(), true).unwrap();
        consensus.add_member("Charlie".to_string(), false).unwrap();

        let proposer = consensus.select_proposer().unwrap();
        assert!(proposer.is_validator);
        assert!(proposer.id == "Alice" || proposer.id == "Bob");

        // Test when there are no validators
        let mut consensus_no_validators = PoCConsensus::new(0.66, 0.51).unwrap();
        consensus_no_validators.add_member("Dave".to_string(), false).unwrap();
        assert!(consensus_no_validators.select_proposer().is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_consensus/src/consensus.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_consensus/src/lib.rs =====
use icn_common::{IcnResult, IcnError, Block, Transaction, CurrencyType};
use std::collections::HashMap;
use log::{info, warn};
use rand::Rng;

/// Represents a member of the consensus network.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Member {
    pub id: String,
    pub reputation: f64,
    pub is_validator: bool,
}

/// Proof of Cooperation (PoC) consensus mechanism.
#[derive(Debug, Serialize, Deserialize)]
pub struct PoCConsensus {
    pub members: HashMap<String, Member>,
    pub threshold: f64,
    pub quorum: f64,
}

impl PoCConsensus {
    /// Creates a new PoCConsensus with the specified threshold and quorum.
    ///
    /// # Arguments
    ///
    /// * `threshold` - The threshold for consensus.
    /// * `quorum` - The quorum for consensus.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Consensus` if the threshold or quorum values are invalid.
    pub fn new(threshold: f64, quorum: f64) -> IcnResult<Self> {
        if threshold <= 0.0 || threshold > 1.0 || quorum <= 0.0 || quorum > 1.0 {
            return Err(IcnError::Consensus("Invalid threshold or quorum value".into()));
        }

        Ok(PoCConsensus {
            members: HashMap::new(),
            threshold,
            quorum,
        })
    }

    /// Adds a new member to the consensus network.
    ///
    /// # Arguments
    ///
    /// * `id` - The ID of the new member.
    /// * `is_validator` - Whether the new member is a validator.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Consensus` if the member already exists.
    pub fn add_member(&mut self, id: String, is_validator: bool) -> IcnResult<()> {
        if self.members.contains_key(&id) {
            return Err(IcnError::Consensus("Member already exists".into()));
        }
        self.members.insert(id.clone(), Member {
            id,
            reputation: 1.0,
            is_validator,
        });
        Ok(())
    }

    /// Removes a member from the consensus network.
    ///
    /// # Arguments
    ///
    /// * `id` - The ID of the member to remove.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Consensus` if the member is not found.
    pub fn remove_member(&mut self, id: &str) -> IcnResult<()> {
        if self.members.remove(id).is_none() {
            return Err(IcnError::Consensus("Member not found".into()));
        }
        Ok(())
    }

    /// Updates the reputation of a member.
    ///
    /// # Arguments
    ///
    /// * `id` - The ID of the member.
    /// * `change` - The amount to change the reputation by.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Consensus` if the member is not found.
    pub fn update_reputation(&mut self, id: &str, change: f64) -> IcnResult<()> {
        let member = self.members.get_mut(id).ok_or_else(|| IcnError::Consensus("Member not found".into()))?;
        member.reputation += change;
        member.reputation = member.reputation.max(0.0); // Ensure reputation doesn't go negative
        Ok(())
    }

    /// Validates a block.
    ///
    /// # Arguments
    ///
    /// * `block` - The block to validate.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Consensus` if the block is invalid.
    pub fn validate_block(&self, block: &Block) -> IcnResult<bool> {
        // In a real implementation, this would involve more complex validation logic
        if block.transactions.is_empty() {
            return Err(IcnError::Consensus("Block has no transactions".into()));
        }
        Ok(true)
    }

    /// Reaches consensus on a block.
    ///
    /// # Arguments
    ///
    /// * `block` - The block to reach consensus on.
    /// * `votes` - The votes for the block.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Consensus` if consensus is not reached.
    pub fn reach_consensus(&self, block: &Block, votes: &[(&str, bool)]) -> IcnResult<bool> {
        let total_reputation: f64 = self.members.values().filter(|m| m.is_validator).map(|m| m.reputation).sum();

        let mut positive_reputation = 0.0;
        let mut participating_reputation = 0.0;

        for (member_id, vote) in votes {
            if let Some(member) = self.members.get(*member_id) {
                if member.is_validator {
                    participating_reputation += member.reputation;
                    if *vote {
                        positive_reputation += member.reputation;
                    }
                }
            } else {
                return Err(IcnError::Consensus("Invalid member in votes".into()));
            }
        }

        if participating_reputation / total_reputation < self.quorum {
            return Err(IcnError::Consensus("Quorum not reached".into()));
        }

        Ok(positive_reputation / participating_reputation >= self.threshold)
    }

    /// Returns a list of all validators.
    pub fn get_validators(&self) -> Vec<&Member> {
        self.members.values().filter(|m| m.is_validator).collect()
    }

    /// Selects a proposer for the next block.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Consensus` if no validators are available.
    pub fn select_proposer(&self) -> IcnResult<&Member> {
        let validators: Vec<&Member> = self.get_validators();
        if validators.is_empty() {
            return Err(IcnError::Consensus("No validators available".into()));
        }

        let total_reputation: f64 = validators.iter().map(|m| m.reputation).sum();
        let mut rng = rand::thread_rng();
        let random_point = rng.gen::<f64>() * total_reputation;

        let mut cumulative_reputation = 0.0;
        for validator in &validators {
            cumulative_reputation += validator.reputation;
            if cumulative_reputation > random_point {
                return Ok(validator);
            }
        }

        // This should never happen, but we'll return the last validator if it does
        Ok(validators.last().unwrap())
    }

    /// Starts the PoC consensus mechanism.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn start(&self) -> IcnResult<()> {
        info!("PoC Consensus mechanism started");
        Ok(())
    }

    /// Stops the PoC consensus mechanism.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn stop(&self) -> IcnResult<()> {
        info!("PoC Consensus mechanism stopped");
        Ok(())
    }
}

/// Trait defining the methods required for a consensus algorithm.
pub trait ConsensusAlgorithm {
    fn validate_block(&self, block: &Block) -> IcnResult<bool>;
    fn reach_consensus(&self, block: &Block, votes: &[(&str, bool)]) -> IcnResult<bool>;
}

impl ConsensusAlgorithm for PoCConsensus {
    fn validate_block(&self, block: &Block) -> IcnResult<bool> {
        self.validate_block(block)
    }

    fn reach_consensus(&self, block: &Block, votes: &[(&str, bool)]) -> IcnResult<bool> {
        self.reach_consensus(block, votes)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_common::CurrencyType;

    #[test]
    fn test_add_and_remove_member() {
        let mut consensus = PoCConsensus::new(0.66, 0.51).unwrap();
        assert!(consensus.add_member("member1".to_string(), true).is_ok());
        assert!(consensus.add_member("member2".to_string(), false).is_ok());
        assert!(consensus.remove_member("member1").is_ok());
        assert!(consensus.remove_member("member3").is_err());
    }

    #[test]
    fn test_update_reputation() {
        let mut consensus = PoCConsensus::new(0.66, 0.51).unwrap();
        consensus.add_member("member1".to_string(), true).unwrap();
        assert!(consensus.update_reputation("member1", 0.5).is_ok());
        assert_eq!(consensus.members.get("member1").unwrap().reputation, 1.5);
        assert!(consensus.update_reputation("member1", -2.0).is_ok());
        assert_eq!(consensus.members.get("member1").unwrap().reputation, 0.0);
        assert!(consensus.update_reputation("member2", 0.5).is_err());
    }

    #[test]
    fn test_reach_consensus() {
        let mut consensus = PoCConsensus::new(0.66, 0.51).unwrap();
        consensus.add_member("member1".to_string(), true).unwrap();
        consensus.add_member("member2".to_string(), true).unwrap();
        consensus.add_member("member3".to_string(), true).unwrap();

        let block = Block::new(1, vec![], "previous_hash".to_string());
        let votes = vec![("member1", true), ("member2", true), ("member3", false)];

        assert!(consensus.reach_consensus(&block, &votes).is_ok());
    }

    #[test]
    fn test_select_proposer() {
        let mut consensus = PoCConsensus::new(0.66, 0.51).unwrap();
        consensus.add_member("member1".to_string(), true).unwrap();
        consensus.add_member("member2".to_string(), true).unwrap();
        consensus.add_member("member3".to_string(), true).unwrap();

        let proposer = consensus.select_proposer();
        assert!(proposer.is_ok());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_consensus/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_consensus/src/proof_of_cooperation.rs =====
use icn_utils::{error::IcnError, IcnResult};
use sha2::{Sha256, Digest};
use serde::{Serialize, Deserialize};
use chrono::Utc;

#[derive(Debug, Serialize, Deserialize)]
pub struct ProofOfCooperation {
    pub blocks: Vec<Block>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Block {
    pub index: u64,
    pub previous_hash: String,
    pub timestamp: u64,
    pub data: String,
    pub hash: String,
}

impl Block {
    pub fn new(index: u64, previous_hash: String, timestamp: u64, data: String) -> Self {
        let mut block = Block {
            index,
            previous_hash,
            timestamp,
            data,
            hash: String::new(),
        };
        block.hash = block.calculate_hash();
        block
    }

    pub fn calculate_hash(&self) -> String {
        let input = format!("{}{}{}{}", self.index, self.previous_hash, self.timestamp, self.data);
        let mut hasher = Sha256::new();
        hasher.update(input.as_bytes());
        format!("{:x}", hasher.finalize())
    }
}

impl ProofOfCooperation {
    pub fn new() -> Self {
        ProofOfCooperation {
            blocks: Vec::new(),
        }
    }

    pub fn add_block(&mut self, data: String) -> IcnResult<()> {
        let previous_hash = if let Some(last_block) = self.blocks.last() {
            last_block.hash.clone()
        } else {
            String::new()
        };

        let new_block = Block::new(
            self.blocks.len() as u64,
            previous_hash,
            Utc::now().timestamp_millis() as u64,
            data,
        );

        self.blocks.push(new_block);
        Ok(())
    }

    pub fn validate_chain(&self) -> IcnResult<()> {
        for i in 1..self.blocks.len() {
            let previous_block = &self.blocks[i - 1];
            let current_block = &self.blocks[i];

            if current_block.previous_hash != previous_block.hash {
                return Err(IcnError::Blockchain("Invalid previous hash".to_string()));
            }

            if current_block.hash != current_block.calculate_hash() {
                return Err(IcnError::Blockchain("Invalid block hash".to_string()));
            }
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add_and_validate_blocks() {
        let mut poc = ProofOfCooperation::new();
        
        poc.add_block("Block 1 Data".to_string()).unwrap();
        poc.add_block("Block 2 Data".to_string()).unwrap();

        assert_eq!(poc.blocks.len(), 2);
        assert!(poc.validate_chain().is_ok());

        // Tamper with a block
        poc.blocks[1].data = "Tampered Data".to_string();
        assert!(poc.validate_chain().is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_consensus/src/proof_of_cooperation.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/Cargo.toml =====
# File: /home/matt/InterCooperative-Network/crates/icn_core/Cargo.toml

[package]
name = "icn_core"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
icn_blockchain = { path = "../icn_blockchain" }
icn_consensus = { path = "../icn_consensus" }
icn_currency = { path = "../icn_currency" }
icn_governance = { path = "../icn_governance" }
icn_identity = { path = "../icn_identity" }
icn_network = { path = "../icn_network" }
icn_sharding = { path = "../icn_sharding" }
icn_vm = { path = "../icn_vm" }
icn_language = { path = "../icn_language" }  # Add this line
tokio = { workspace = true }
log = { workspace = true }
thiserror = { workspace = true }
chrono = { workspace = true }

[dev-dependencies]
tokio-test = "0.4"===== END OF /home/matt/InterCooperative-Network/crates/icn_core/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/src/config.rs =====
// icn_core/src/config.rs

use serde::{Deserialize, Serialize};
use serde_json;
use std::fs;
use icn_types::{IcnResult, IcnError};

#[derive(Debug, Serialize, Deserialize)]
pub struct Config {
    pub shard_count: u64,
    pub consensus_threshold: f64,
    pub consensus_quorum: f64,
    pub network_port: u16,
}

impl Config {
    pub fn load(path: &str) -> IcnResult<Self> {
        let config_str = fs::read_to_string(path).map_err(|e| IcnError::ConfigError(e.to_string()))?;
        let config: Config = serde_json::from_str(&config_str).map_err(|e| IcnError::ConfigError(e.to_string()))?;
        Ok(config)
    }

    pub fn save(&self, path: &str) -> IcnResult<()> {
        let config_str = serde_json::to_string_pretty(self).map_err(|e| IcnError::ConfigError(e.to_string()))?;
        fs::write(path, config_str).map_err(|e| IcnError::ConfigError(e.to_string()))?;
        Ok(())
    }
}

impl Default for Config {
    fn default() -> Self {
        Config {
            shard_count: 4,
            consensus_threshold: 0.66,
            consensus_quorum: 0.51,
            network_port: 8080,
        }
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_core/src/config.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/src/error.rs =====
use thiserror::Error;

#[derive(Error, Debug)]
pub enum Error {
    #[error("Blockchain error: {0}")]
    BlockchainError(String),
    
    #[error("Consensus error: {0}")]
    ConsensusError(String),
    
    #[error("Sharding error: {0}")]
    ShardingError(String),
    
    #[error("VM error: {0}")]
    VmError(String),
    
    #[error("Network error: {0}")]
    NetworkError(String),
    
    #[error("Smart contract error: {0}")]
    SmartContractError(String),
    
    #[error("I/O error: {0}")]
    IoError(#[from] std::io::Error),

    #[error("Lock error: {0}")]
    LockError(String),

    #[error("Communication error: {0}")]
    CommunicationError(String),

    #[error("Transaction failed: {0}")]
    TransactionFailed(String),

    #[error("Timeout: {0}")]
    Timeout(String),

    #[error("Currency error: {0}")]
    CurrencyError(String),

    #[error("Identity error: {0}")]
    IdentityError(String),

    #[error("Governance error: {0}")]
    GovernanceError(String),
}

pub type Result<T> = std::result::Result<T, Error>;===== END OF /home/matt/InterCooperative-Network/crates/icn_core/src/error.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/src/lib.rs =====
use icn_blockchain::Blockchain;
use icn_consensus::PoCConsensus;
use icn_currency::CurrencySystem;
use icn_governance::GovernanceSystem;
use icn_identity::IdentityManager;
use icn_network::Network;
use icn_sharding::ShardingManager;
use icn_storage::StorageManager;
use icn_vm::CoopVM;
use icn_zkp::ZKPManager;

use icn_common::{Block, Transaction, Proposal, IcnResult, IcnError, CurrencyType};
use std::sync::{Arc, RwLock};
use tokio::sync::Mutex as AsyncMutex;

/// Configuration for the ICN Node
pub struct Config {
    pub shard_count: u64,
    pub consensus_threshold: f64,
    pub consensus_quorum: f64,
    pub network_port: u16,
}

/// The main struct representing an InterCooperative Network node
pub struct IcnNode {
    blockchain: Arc<RwLock<Blockchain>>,
    consensus: Arc<RwLock<PoCConsensus>>,
    currency_system: Arc<RwLock<CurrencySystem>>,
    governance: Arc<RwLock<GovernanceSystem>>,
    identity_manager: Arc<RwLock<IdentityManager>>,
    network: Arc<AsyncMutex<Network>>,
    sharding_manager: Arc<RwLock<ShardingManager>>,
    storage_manager: Arc<RwLock<StorageManager>>,
    vm: Arc<RwLock<CoopVM>>,
    zkp_manager: Arc<RwLock<ZKPManager>>,
}

impl IcnNode {
    /// Create a new ICN Node with the given configuration
    pub fn new(config: Config) -> IcnResult<Self> {
        let blockchain = Arc::new(RwLock::new(Blockchain::new()?));
        let consensus = Arc::new(RwLock::new(PoCConsensus::new(config.consensus_threshold, config.consensus_quorum)?));
        let currency_system = Arc::new(RwLock::new(CurrencySystem::new()));
        let governance = Arc::new(RwLock::new(GovernanceSystem::new(
            Arc::clone(&blockchain),
            Arc::clone(&consensus),
        )));
        let identity_manager = Arc::new(RwLock::new(IdentityManager::new()));
        let network = Arc::new(AsyncMutex::new(Network::new(format!("127.0.0.1:{}", config.network_port).parse().map_err(|e| IcnError::Network(e.to_string()))?)));
        let sharding_manager = Arc::new(RwLock::new(ShardingManager::new(config.shard_count)));
        let storage_manager = Arc::new(RwLock::new(StorageManager::new(3))); // Replication factor of 3
        let vm = Arc::new(RwLock::new(CoopVM::new(Vec::new()))); // Empty program for now
        let zkp_manager = Arc::new(RwLock::new(ZKPManager::new()?));

        Ok(IcnNode {
            blockchain,
            consensus,
            currency_system,
            governance,
            identity_manager,
            network,
            sharding_manager,
            storage_manager,
            vm,
            zkp_manager,
        })
    }

    /// Start the ICN Node
    pub async fn start(&self) -> IcnResult<()> {
        // Start all components
        self.blockchain.read().unwrap().start()?;
        self.consensus.read().unwrap().start()?;
        self.network.lock().await.start().await?;
        
        // Start listening for network events
        self.listen_for_network_events();

        Ok(())
    }

    /// Stop the ICN Node
    pub async fn stop(&self) -> IcnResult<()> {
        // Stop all components
        self.blockchain.read().unwrap().stop()?;
        self.consensus.read().unwrap().stop()?;
        self.network.lock().await.stop().await?;

        Ok(())
    }

    /// Process a new transaction
    pub async fn process_transaction(&self, transaction: Transaction) -> IcnResult<()> {
        // Verify the transaction
        self.verify_transaction(&transaction)?;

        // If it's a cross-shard transaction, handle it accordingly
        let from_shard = self.sharding_manager.read().unwrap().get_shard_for_address(&transaction.from);
        let to_shard = self.sharding_manager.read().unwrap().get_shard_for_address(&transaction.to);

        if from_shard != to_shard {
            self.process_cross_shard_transaction(transaction, from_shard, to_shard).await?;
        } else {
            // Add the transaction to the blockchain
            self.blockchain.write().unwrap().add_transaction(transaction)?;
        }

        Ok(())
    }

    /// Verify a transaction
    fn verify_transaction(&self, transaction: &Transaction) -> IcnResult<()> {
        // Check if the sender has sufficient balance
        let balance = self.get_balance(&transaction.from, &transaction.currency_type)?;
        if balance < transaction.amount {
            return Err(IcnError::InsufficientFunds);
        }

        // Verify the transaction signature
        if !transaction.verify()? {
            return Err(IcnError::InvalidSignature);
        }

        Ok(())
    }

    /// Process a cross-shard transaction
    async fn process_cross_shard_transaction(&self, transaction: Transaction, from_shard: u64, to_shard: u64) -> IcnResult<()> {
        // Lock funds in the source shard
        self.sharding_manager.write().unwrap().lock_funds(from_shard, &transaction.from, transaction.amount)?;

        // Create a cross-shard transaction record
        let cross_shard_tx = self.sharding_manager.write().unwrap().create_cross_shard_transaction(transaction.clone(), from_shard, to_shard)?;

        // Broadcast the cross-shard transaction to the network
        self.network.lock().await.broadcast_cross_shard_transaction(cross_shard_tx).await?;

        Ok(())
    }

    /// Create a new proposal
    pub fn create_proposal(&self, proposal: Proposal) -> IcnResult<String> {
        self.governance.write().unwrap().create_proposal(proposal)
    }

    /// Vote on a proposal
    pub fn vote_on_proposal(&self, proposal_id: &str, voter: &str, vote: bool) -> IcnResult<()> {
        self.governance.write().unwrap().vote_on_proposal(proposal_id, voter, vote)
    }

   /// Get the balance of an address
   pub fn get_balance(&self, address: &str, currency_type: &CurrencyType) -> IcnResult<f64> {
    self.currency_system.read().unwrap().get_balance(address, currency_type)
}

/// Create a new identity
pub fn create_identity(&self, attributes: std::collections::HashMap<String, String>) -> IcnResult<DecentralizedIdentity> {
    self.identity_manager.write().unwrap().create_identity(attributes)
}

/// Allocate a resource
pub fn allocate_resource(&self, resource_id: &str, amount: u64) -> IcnResult<()> {
    // In a real implementation, this would interact with a resource management system
    // For now, we'll just log the allocation
    log::info!("Allocating {} units of resource {}", amount, resource_id);
    Ok(())
}

/// Get network statistics
pub async fn get_network_stats(&self) -> IcnResult<NetworkStats> {
    let network = self.network.lock().await;
    Ok(NetworkStats {
        connected_peers: network.get_connected_peers().len() as u32,
        total_transactions: self.blockchain.read().unwrap().get_total_transactions(),
        uptime: network.get_uptime(),
    })
}

/// Execute a smart contract
pub fn execute_smart_contract(&self, contract: &str) -> IcnResult<Value> {
    let mut vm = self.vm.write().unwrap();
    let compiled_contract = vm.compile(contract)?;
    vm.execute(&compiled_contract)
}

/// Create a zero-knowledge proof
pub fn create_zkproof(&self, statement: &str, witness: &[u8]) -> IcnResult<ZKProof> {
    self.zkp_manager.read().unwrap().create_proof(statement, witness)
}

/// Verify a zero-knowledge proof
pub fn verify_zkproof(&self, proof: &ZKProof, statement: &str) -> IcnResult<bool> {
    self.zkp_manager.read().unwrap().verify_proof(proof, statement)
}

/// Listen for network events
fn listen_for_network_events(&self) {
    let blockchain = Arc::clone(&self.blockchain);
    let consensus = Arc::clone(&self.consensus);
    let network = Arc::clone(&self.network);

    tokio::spawn(async move {
        loop {
            let event = network.lock().await.receive_event().await;
            match event {
                NetworkEvent::NewTransaction(transaction) => {
                    if let Err(e) = blockchain.write().unwrap().add_transaction(transaction) {
                        log::error!("Failed to add transaction: {:?}", e);
                    }
                }
                NetworkEvent::NewBlock(block) => {
                    if let Err(e) = consensus.write().unwrap().process_new_block(block) {
                        log::error!("Failed to process new block: {:?}", e);
                    }
                }
                NetworkEvent::ConsensusMessage(message) => {
                    if let Err(e) = consensus.write().unwrap().handle_consensus_message(message) {
                        log::error!("Failed to handle consensus message: {:?}", e);
                    }
                }
                NetworkEvent::PeerConnected(peer_id) => {
                    log::info!("New peer connected: {:?}", peer_id);
                }
                NetworkEvent::PeerDisconnected(peer_id) => {
                    log::info!("Peer disconnected: {:?}", peer_id);
                }
            }
        }
    });
}
}

/// Network statistics
pub struct NetworkStats {
pub connected_peers: u32,
pub total_transactions: u64,
pub uptime: std::time::Duration,
}

/// Network events
enum NetworkEvent {
NewTransaction(Transaction),
NewBlock(Block),
ConsensusMessage(ConsensusMessage),
PeerConnected(String),
PeerDisconnected(String),
}

/// Consensus messages
enum ConsensusMessage {
// Define consensus message types here
// For example: Proposal, Vote, Commit, etc.
}

/// Value returned by smart contract execution
pub enum Value {
Int(i64),
Float(f64),
Bool(bool),
String(String),
List(Vec<Value>),
}

/// Zero-knowledge proof
pub struct ZKProof {
// Define ZKProof structure here
}

#[cfg(test)]
mod tests {
use super::*;

#[tokio::test]
async fn test_icn_node() {
    let config = Config {
        shard_count: 4,
        consensus_threshold: 0.66,
        consensus_quorum: 0.51,
        network_port: 8080,
    };

    let node = IcnNode::new(config).unwrap();
    
    // Test starting and stopping the node
    assert!(node.start().await.is_ok());
    assert!(node.stop().await.is_ok());

    // Test creating a new identity
    let mut attributes = std::collections::HashMap::new();
    attributes.insert("name".to_string(), "Alice".to_string());
    let identity = node.create_identity(attributes).unwrap();
    assert_eq!(identity.attributes.get("name"), Some(&"Alice".to_string()));

    // Test processing a transaction
    let transaction = Transaction {
        from: "Alice".to_string(),
        to: "Bob".to_string(),
        amount: 100.0,
        currency_type: CurrencyType::BasicNeeds,
        timestamp: chrono::Utc::now().timestamp(),
        signature: None, // In a real scenario, this should be properly signed
    };
    assert!(node.process_transaction(transaction).await.is_ok());

    // Test creating a proposal
    let proposal = Proposal {
        id: "proposal1".to_string(),
        title: "Test Proposal".to_string(),
        description: "This is a test proposal".to_string(),
        proposer: "Alice".to_string(),
        created_at: chrono::Utc::now(),
        voting_ends_at: chrono::Utc::now() + chrono::Duration::days(7),
        status: ProposalStatus::Active,
        proposal_type: ProposalType::Constitutional,
        category: ProposalCategory::Economic,
        required_quorum: 0.66,
        execution_timestamp: None,
    };
    let proposal_id = node.create_proposal(proposal).unwrap();
    assert!(!proposal_id.is_empty());

    // Test voting on a proposal
    assert!(node.vote_on_proposal(&proposal_id, "Alice", true).is_ok());

    // Test getting network stats
    let stats = node.get_network_stats().await.unwrap();
    assert_eq!(stats.connected_peers, 0); // No peers in test environment
    assert_eq!(stats.total_transactions, 1);

    // Test executing a smart contract
    let contract = "function add(a, b) { return a + b; }";
    let result = node.execute_smart_contract(contract).unwrap();
    assert!(matches!(result, Value::Int(_)));

    // Test creating and verifying a ZK proof
    let statement = "I know the factors of N";
    let witness = &[1, 2, 3, 4]; // Some dummy witness data
    let proof = node.create_zkproof(statement, witness).unwrap();
    assert!(node.verify_zkproof(&proof, statement).unwrap());

    // Test allocating a resource
    assert!(node.allocate_resource("computing_power", 100).is_ok());

    // Test getting balance
    let balance = node.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap();
    assert!(balance >= 0.0);

    // Test cross-shard transaction
    node.sharding_manager.write().unwrap().add_address_to_shard("Alice".to_string(), 0).unwrap();
    node.sharding_manager.write().unwrap().add_address_to_shard("Bob".to_string(), 1).unwrap();
    let cross_shard_tx = Transaction {
        from: "Alice".to_string(),
        to: "Bob".to_string(),
        amount: 50.0,
        currency_type: CurrencyType::BasicNeeds,
        timestamp: chrono::Utc::now().timestamp(),
        signature: None, // In a real scenario, this should be properly signed
    };
    assert!(node.process_transaction(cross_shard_tx).await.is_ok());

    // Test handling network events
    let blockchain = Arc::clone(&node.blockchain);
    let consensus = Arc::clone(&node.consensus);
    
    // Simulate receiving a new transaction
    let new_tx = Transaction {
        from: "Charlie".to_string(),
        to: "Dave".to_string(),
        amount: 25.0,
        currency_type: CurrencyType::Education,
        timestamp: chrono::Utc::now().timestamp(),
        signature: None,
    };
    blockchain.write().unwrap().add_transaction(new_tx.clone()).unwrap();
    
    // Simulate receiving a new block
    let new_block = Block {
        index: blockchain.read().unwrap().chain().len() as u64,
        timestamp: chrono::Utc::now().timestamp(),
        transactions: vec![new_tx],
        previous_hash: "previous_hash".to_string(),
        hash: "new_block_hash".to_string(),
    };
    consensus.write().unwrap().process_new_block(new_block.clone()).unwrap();

    // Verify that the new block was added to the blockchain
    assert_eq!(blockchain.read().unwrap().chain().last().unwrap().hash, new_block.hash);

    // Test handling consensus messages
    let consensus_message = ConsensusMessage::Proposal(new_block.clone());
    consensus.write().unwrap().handle_consensus_message(consensus_message).unwrap();

    // Test peer connection events
    let peer_id = "peer1".to_string();
    node.network.lock().await.add_peer(peer_id.clone()).await.unwrap();
    assert!(node.network.lock().await.get_connected_peers().contains(&peer_id));

    // Test peer disconnection
    node.network.lock().await.remove_peer(&peer_id).await.unwrap();
    assert!(!node.network.lock().await.get_connected_peers().contains(&peer_id));
}

#[tokio::test]
async fn test_concurrent_transactions() {
    let config = Config {
        shard_count: 4,
        consensus_threshold: 0.66,
        consensus_quorum: 0.51,
        network_port: 8081,
    };

    let node = Arc::new(IcnNode::new(config).unwrap());
    node.start().await.unwrap();

    let mut handles = vec![];

    for i in 0..100 {
        let node_clone = Arc::clone(&node);
        let handle = tokio::spawn(async move {
            let tx = Transaction {
                from: format!("User{}", i),
                to: format!("User{}", (i + 1) % 100),
                amount: 1.0,
                currency_type: CurrencyType::BasicNeeds,
                timestamp: chrono::Utc::now().timestamp(),
                signature: None,
            };
            node_clone.process_transaction(tx).await.unwrap();
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.await.unwrap();
    }

    let total_transactions = node.blockchain.read().unwrap().get_total_transactions();
    assert_eq!(total_transactions, 100);

    node.stop().await.unwrap();
}

#[tokio::test]
async fn test_governance_workflow() {
    let config = Config {
        shard_count: 4,
        consensus_threshold: 0.66,
        consensus_quorum: 0.51,
        network_port: 8082,
    };

    let node = IcnNode::new(config).unwrap();
    node.start().await.unwrap();

    // Create a proposal
    let proposal = Proposal {
        id: "gov_proposal1".to_string(),
        title: "Increase Education Currency Supply".to_string(),
        description: "Proposal to increase the supply of Education currency by 10%".to_string(),
        proposer: "Alice".to_string(),
        created_at: chrono::Utc::now(),
        voting_ends_at: chrono::Utc::now() + chrono::Duration::days(7),
        status: ProposalStatus::Active,
        proposal_type: ProposalType::EconomicAdjustment,
        category: ProposalCategory::Economic,
        required_quorum: 0.75,
        execution_timestamp: None,
    };

    let proposal_id = node.create_proposal(proposal).unwrap();

    // Simulate voting
    for i in 0..10 {
        let voter = format!("Voter{}", i);
        let vote = i % 2 == 0; // Alternating yes/no votes
        node.vote_on_proposal(&proposal_id, &voter, vote).unwrap();
    }

    // Fast-forward time to end of voting period
    // In a real scenario, you'd use a time mocking library
    node.governance.write().unwrap().update_proposal_status(&proposal_id).unwrap();

    // Check proposal status
    let final_status = node.governance.read().unwrap().get_proposal_status(&proposal_id).unwrap();
    assert_eq!(final_status, ProposalStatus::Passed);

    // Execute the proposal
    node.governance.write().unwrap().execute_proposal(&proposal_id).unwrap();

    // Verify the outcome (in this case, check if Education currency supply increased)
    let education_supply = node.currency_system.read().unwrap().get_total_supply(&CurrencyType::Education).unwrap();
    assert!(education_supply > 0.0); // Assuming initial supply was 0

    node.stop().await.unwrap();
}
}===== END OF /home/matt/InterCooperative-Network/crates/icn_core/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/src/logging/mod.rs =====
use log::{info, warn, error, debug};

pub fn log_info(message: &str) {
    info!("{}", message);
}

pub fn log_warn(message: &str) {
    warn!("{}", message);
}

pub fn log_error(message: &str) {
    error!("{}", message);
}

pub fn log_debug(message: &str) {
    debug!("{}", message);
}===== END OF /home/matt/InterCooperative-Network/crates/icn_core/src/logging/mod.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/src/main.rs =====
// icn_core/src/main.rs

use icn_core::{IcnNode, Config};
use icn_types::{IcnResult, IcnError, Transaction, Proposal, ProposalType, ProposalCategory, CurrencyType, ProposalStatus};
use std::io::{self, Write};
use chrono::{Duration, Utc};
use log::{info, warn, error};
use uuid::Uuid;

fn main() -> IcnResult<()> {
    env_logger::init();

    let config = Config::load("config.json").unwrap_or_else(|_| {
        warn!("Failed to load config.json, using default configuration");
        Config::default()
    });

    info!("Starting InterCooperative Network node...");
    let node = IcnNode::new(config)?;
    node.start()?;

    info!("Node started successfully. Type 'help' for available commands.");

    loop {
        print!("> ");
        io::stdout().flush().unwrap();

        let mut input = String::new();
        io::stdin().read_line(&mut input).unwrap();
        let input = input.trim();

        match input {
            "help" => print_help(),
            "exit" => break,
            "transaction" => process_transaction(&node)?,
            "proposal" => create_proposal(&node)?,
            "balance" => check_balance(&node)?,
            _ => println!("Unknown command. Type 'help' for available commands."),
        }
    }

    info!("Stopping node...");
    node.stop()?;
    info!("Node stopped. Goodbye!");

    Ok(())
}

fn print_help() {
    println!("Available commands:");
    println!("  help        - Show this help message");
    println!("  transaction - Create a new transaction");
    println!("  proposal    - Create a new proposal");
    println!("  balance     - Check account balance");
    println!("  exit        - Exit the application");
}

fn process_transaction(node: &IcnNode) -> IcnResult<()> {
    info!("Processing a new transaction");
    
    print!("From: ");
    io::stdout().flush().unwrap();
    let mut from = String::new();
    io::stdin().read_line(&mut from).unwrap();
    
    print!("To: ");
    io::stdout().flush().unwrap();
    let mut to = String::new();
    io::stdin().read_line(&mut to).unwrap();
    
    print!("Amount: ");
    io::stdout().flush().unwrap();
    let mut amount_str = String::new();
    io::stdin().read_line(&mut amount_str).unwrap();
    let amount: f64 = amount_str.trim().parse().map_err(|_| IcnError::InvalidInput("Invalid amount".to_string()))?;

    let transaction = Transaction {
        from: from.trim().to_string(),
        to: to.trim().to_string(),
        amount,
        currency_type: CurrencyType::BasicNeeds,
        timestamp: Utc::now().timestamp(),
        signature: None,
    };

    node.process_transaction(transaction)?;
    info!("Transaction processed successfully");
    Ok(())
}

fn create_proposal(node: &IcnNode) -> IcnResult<()> {
    info!("Creating a new proposal");
    
    print!("Title: ");
    io::stdout().flush().unwrap();
    let mut title = String::new();
    io::stdin().read_line(&mut title).unwrap();
    
    print!("Description: ");
    io::stdout().flush().unwrap();
    let mut description = String::new();
    io::stdin().read_line(&mut description).unwrap();
    
    print!("Proposer: ");
    io::stdout().flush().unwrap();
    let mut proposer = String::new();
    io::stdin().read_line(&mut proposer).unwrap();

    let proposal = Proposal {
        id: Uuid::new_v4().to_string(),
        title: title.trim().to_string(),
        description: description.trim().to_string(),
        proposer: proposer.trim().to_string(),
        created_at: Utc::now(),
        voting_ends_at: Utc::now() + Duration::days(7),
        status: ProposalStatus::Active,
        proposal_type: ProposalType::Constitutional,
        category: ProposalCategory::Economic,
        required_quorum: 0.66,
        execution_timestamp: None,
    };

    node.create_proposal(proposal)?;
    info!("Proposal created successfully");
    Ok(())
}

fn check_balance(node: &IcnNode) -> IcnResult<()> {
    info!("Checking balance");
    
    print!("Address: ");
    io::stdout().flush().unwrap();
    let mut address = String::new();
    io::stdin().read_line(&mut address).unwrap();
    
    let balance = node.get_balance(address.trim(), &CurrencyType::BasicNeeds)?;
    println!("Balance: {}", balance);
    Ok(())
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_core/src/main.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/src/security/mod.rs =====
use crate::error::Result;
use ed25519_dalek::{Keypair, PublicKey, Signature, Verifier};

pub struct SecurityManager {
    // Add fields as needed
}

impl SecurityManager {
    pub fn new() -> Self {
        SecurityManager {
            // Initialize fields
        }
    }

    pub fn verify_signature(&self, public_key: &PublicKey, message: &[u8], signature: &Signature) -> Result<bool> {
        Ok(public_key.verify(message, signature).is_ok())
    }

    pub fn generate_keypair() -> Keypair {
        Keypair::generate(&mut rand::thread_rng())
    }

    // Add more security-related methods as needed
}===== END OF /home/matt/InterCooperative-Network/crates/icn_core/src/security/mod.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/tests/blockchain_and_consensus_tests.rs =====
// Filename: src/tests/blockchain_and_consensus_tests.rs

use crate::blockchain::{Blockchain, Transaction};
use crate::currency::CurrencyType;
use crate::consensus::Consensus;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_blockchain_creation() {
        let blockchain = Blockchain::new();
        assert_eq!(blockchain.chain.len(), 1, "Blockchain should be initialized with one genesis block");
        assert_eq!(blockchain.chain[0].index, 0, "Genesis block should have index 0");
    }

    #[test]
    fn test_block_creation() {
        let mut blockchain = Blockchain::new();
        blockchain.consensus.add_member("Alice".to_string());
        let transactions = vec![
            Transaction::new("Alice".to_string(), "Bob".to_string(), 100.0, CurrencyType::BasicNeeds, 1000),
            Transaction::new("Bob".to_string(), "Charlie".to_string(), 50.0, CurrencyType::Education, 1000),
        ];
        let result = blockchain.create_block("Alice".to_string());
        assert!(result.is_ok(), "Block creation failed: {:?}", result.err());
        assert_eq!(blockchain.chain.len(), 2, "Blockchain should have two blocks after creation");
    }

    #[test]
    fn test_reputation_update() {
        let mut blockchain = Blockchain::new();
        blockchain.consensus.add_member("Alice".to_string());
        blockchain.consensus.update_reputation("Alice", 0.5);
        assert_eq!(blockchain.consensus.get_reputation("Alice"), Some(1.5), 
                   "Alice's reputation should be updated to 1.5");
    }

    #[test]
    fn test_voting() {
        let mut blockchain = Blockchain::new();
        blockchain.consensus.add_member("Alice".to_string());
        blockchain.consensus.add_member("Bob".to_string());
        blockchain.consensus.add_member("Charlie".to_string());
        
        let transactions = vec![
            Transaction::new("Alice".to_string(), "Bob".to_string(), 100.0, CurrencyType::BasicNeeds, 1000),
        ];
        blockchain.create_block("Alice".to_string()).expect("Block creation should succeed");
        
        assert!(blockchain.vote_on_block("Alice", 1, true).is_ok(), "Alice should be able to vote");
        assert!(blockchain.vote_on_block("Bob", 1, true).is_ok(), "Bob should be able to vote");
        assert!(blockchain.vote_on_block("Charlie", 1, true).is_ok(), "Charlie should be able to vote");
        
        assert!(blockchain.consensus.is_block_valid(1), "Block should be valid after voting");
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_core/tests/blockchain_and_consensus_tests.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/tests/blockchain_tests.rs =====
// Filename: src/tests/blockchain_tests.rs

use crate::blockchain::{Blockchain, Transaction};
use crate::currency::CurrencyType;

#[test]
fn test_blockchain_creation() {
    let blockchain = Blockchain::new();
    assert_eq!(blockchain.chain.len(), 1);
    assert_eq!(blockchain.chain[0].index, 0);
}

#[test]
fn test_add_block() {
    let mut blockchain = Blockchain::new();
    let transaction = Transaction::new(
        "Alice".to_string(),
        "Bob".to_string(),
        100.0,
        CurrencyType::BasicNeeds,
        1000,
    );
    blockchain.add_transaction(transaction);
    assert!(blockchain.create_block("Node1".to_string()).is_ok());
    assert_eq!(blockchain.chain.len(), 2);
}

#[test]
fn test_blockchain_validity() {
    let mut blockchain = Blockchain::new();
    let transaction = Transaction::new(
        "Alice".to_string(),
        "Bob".to_string(),
        100.0,
        CurrencyType::BasicNeeds,
        1000,
    );
    blockchain.add_transaction(transaction);
    assert!(blockchain.create_block("Node1".to_string()).is_ok());
    assert!(blockchain.is_chain_valid());
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_core/tests/blockchain_tests.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/tests/icn_node_tests.rs =====
// Filename: src/tests/icn_node_tests.rs

// Import necessary modules and types
use crate::icn_node::{IcnNode, Packet, PacketType};
use std::net::SocketAddr;

#[test]
fn test_fib_functionality() {
    let mut node = IcnNode::new();
    let addr1: SocketAddr = "127.0.0.1:8000".parse().unwrap();
    let addr2: SocketAddr = "127.0.0.1:8001".parse().unwrap();

    node.fib.add_entry("/example/path".to_string(), addr1);
    node.fib.add_entry("/example/path".to_string(), addr2);

    let next_hops = node.fib.get_next_hops("/example/path");
    assert!(next_hops.is_some());
    assert_eq!(next_hops.unwrap().len(), 2);
    assert!(next_hops.unwrap().contains(&addr1));
    assert!(next_hops.unwrap().contains(&addr2));

    let longest_match = node.fib.longest_prefix_match("/example/path/subpath");
    assert!(longest_match.is_some());
    assert_eq!(longest_match.unwrap().name, "/example/path");
}

#[test]
fn test_content_store() {
    let mut node = IcnNode::new();
    let packet = Packet {
        packet_type: PacketType::Data,
        name: "/test/data".to_string(),
        content: vec![1, 2, 3, 4],
    };

    node.content_store.add(packet.name.clone(), packet.clone());
    let retrieved = node.content_store.get(&packet.name);
    assert!(retrieved.is_some());
    assert_eq!(retrieved.unwrap().content, vec![1, 2, 3, 4]);
}

#[test]
fn test_packet_processing() {
    let mut node = IcnNode::new();
    let addr: SocketAddr = "127.0.0.1:8000".parse().unwrap();
    node.add_interface("eth0".to_string(), addr);
    node.fib.add_entry("/test".to_string(), addr);

    let interest_packet = Packet {
        packet_type: PacketType::Interest,
        name: "/test/data".to_string(),
        content: vec![],
    };

    node.process_packet(interest_packet.clone(), "eth0");
    assert!(node.pit.has_pending_interest(&interest_packet.name));

    let data_packet = Packet {
        packet_type: PacketType::Data,
        name: "/test/data".to_string(),
        content: vec![1, 2, 3, 4],
    };

    node.process_packet(data_packet.clone(), "eth0");
    assert!(!node.pit.has_pending_interest(&data_packet.name));
    assert!(node.content_store.get(&data_packet.name).is_some());
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_core/tests/icn_node_tests.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/tests/integration_tests.rs =====
// icn_core/tests/integration_tests.rs

use icn_core::{IcnNode, Config};
use icn_common::{Transaction, Proposal, ProposalType, ProposalCategory, CurrencyType, ProposalStatus};
use chrono::Duration;
use log::info;
use uuid::Uuid;

#[cfg(test)]
mod tests {
    use super::*;

    fn setup() -> IcnResult<IcnNode> {
        let config = Config::default();
        let node = IcnNode::new(config)?;
        node.start()?;
        Ok(node)
    }

    fn teardown(node: &IcnNode) -> IcnResult<()> {
        node.stop()
    }

    #[test]
    fn test_node_initialization() {
        let config = Config::default();
        let node = IcnNode::new(config);
        assert!(node.is_ok());
    }

    #[test]
    fn test_node_start_stop() {
        let config = Config::default();
        let node = IcnNode::new(config).unwrap();
        assert!(node.start().is_ok());
        assert!(node.stop().is_ok());
    }

    #[test]
    fn test_process_transaction() {
        let config = Config::default();
        let node = IcnNode::new(config).unwrap();
        node.start().unwrap();

        let transaction = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 100.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: chrono::Utc::now().timestamp(),
            signature: None,
        };

        assert!(node.process_transaction(transaction).is_ok());
        node.stop().unwrap();
    }

    #[test]
    fn test_create_proposal() {
        let config = Config::default();
        let node = IcnNode::new(config).unwrap();
        node.start().unwrap();

        let proposal = Proposal {
            id: Uuid::new_v4().to_string(),
            title: "Test Proposal".to_string(),
            description: "This is a test proposal".to_string(),
            proposer: "Alice".to_string(),
            created_at: chrono::Utc::now(),
            voting_ends_at: chrono::Utc::now() + Duration::days(7),
            status: ProposalStatus::Active,
            proposal_type: ProposalType::Constitutional,
            category: ProposalCategory::Economic,
            required_quorum: 0.66,
            execution_timestamp: None,
        };

        assert!(node.create_proposal(proposal).is_ok());
        node.stop().unwrap();
    }

    #[test]
    fn test_get_balance() {
        let node = setup().unwrap();

        // First, we need to add some balance to an account
        let deposit_transaction = Transaction {
            from: "Genesis".to_string(),
            to: "Alice".to_string(),
            amount: 1000.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: chrono::Utc::now().timestamp(),
            signature: None,
        };

        node.process_transaction(deposit_transaction).unwrap();

        // Now, let's check the balance
        let balance = node.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap();
        assert_eq!(balance, 1000.0, "Balance should be 1000.0 after deposit");

        teardown(&node).unwrap();
    }

    #[test]
    fn test_cross_shard_transaction() {
        let node = setup().unwrap();

        // Assume Alice and Bob are on different shards
        // First, add balance to Alice's account
        let deposit_transaction = Transaction {
            from: "Genesis".to_string(),
            to: "Alice".to_string(),
            amount: 1000.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: chrono::Utc::now().timestamp(),
            signature: None,
        };

        node.process_transaction(deposit_transaction).unwrap();

        // Now, perform a cross-shard transaction from Alice to Bob
        let cross_shard_transaction = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 500.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: chrono::Utc::now().timestamp(),
            signature: None,
        };

        node.process_transaction(cross_shard_transaction).unwrap();

        // Check balances after the transaction
        let alice_balance = node.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap();
        let bob_balance = node.get_balance("Bob", &CurrencyType::BasicNeeds).unwrap();

        assert_eq!(alice_balance, 500.0, "Alice's balance should be 500.0 after transfer");
        assert_eq!(bob_balance, 500.0, "Bob's balance should be 500.0 after receiving transfer");

        teardown(&node).unwrap();
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_core/tests/integration_tests.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/tests/mod.rs =====
// ===============================================
// Tests Module
// ===============================================
// This module re-exports the contents of the tests submodules.
// The tests submodules contain various test cases to ensure
// the correctness and reliability of the blockchain implementation.

#[cfg(test)]
mod tests {
    use super::*;
    use crate::currency::CurrencyType;
    use ed25519_dalek::Keypair;
    use rand::rngs::OsRng;

    #[test]
    fn test_cross_shard_transaction() {
        let node = IcnNode::new();

        // Initialize balances
        {
            let mut sharding_manager = node.sharding_manager.write().unwrap();
            sharding_manager.add_address_to_shard("Alice".to_string(), 0);
            sharding_manager.add_address_to_shard("Bob".to_string(), 1);
            sharding_manager.initialize_balance("Alice".to_string(), CurrencyType::BasicNeeds, 1000.0);
        }

        let mut csprng = OsRng{};
        let keypair: Keypair = Keypair::generate(&mut csprng);

        let mut transaction = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            500.0,
            CurrencyType::BasicNeeds,
            1000,
        );
        if let Err(e) = transaction.sign(&keypair) {
            panic!("Failed to sign transaction: {}", e);
        }

        println!("Signed transaction: {:?}", transaction);

        assert!(node.process_cross_shard_transaction(&transaction).is_ok(), "Cross-shard transaction failed");

        // Check balances after transaction
        let sharding_manager = node.sharding_manager.read().unwrap();
        assert_eq!(sharding_manager.get_balance("Alice".to_string(), CurrencyType::BasicNeeds), 500.0);
        assert_eq!(sharding_manager.get_balance("Bob".to_string(), CurrencyType::BasicNeeds), 500.0);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_core/tests/mod.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_core/tests/smart_contract_tests.rs =====
// Filename: src/tests/smart_contract_tests.rs

use crate::blockchain::Blockchain;
use crate::smart_contract::{parse_contract, ContractType};

#[test]
fn test_smart_contract_integration() {
    let mut blockchain = Blockchain::new();

    // Deploy an asset transfer contract
    let contract_input = "Asset Transfer
Creator: Alice
From: Alice
To: Bob
Asset: ICN_TOKEN
Amount: 100.0";

    let contract = parse_contract(contract_input).unwrap();
    blockchain.deploy_smart_contract(contract).unwrap();

    // Deploy a proposal contract
    let proposal_input = "Proposal
Creator: Charlie
Title: New Community Project
Description: Implement a recycling program
Voting Period: 604800
Option 1: Approve
Option 2: Reject
Quorum: 0.5";

    let proposal_contract = parse_contract(proposal_input).unwrap();
    blockchain.deploy_smart_contract(proposal_contract).unwrap();

    // Execute smart contracts
    blockchain.execute_smart_contracts().unwrap();

    // Verify blockchain state
    assert_eq!(blockchain.chain.len(), 2); // Genesis block + 1 block with contracts
    assert_eq!(blockchain.chain.last().unwrap().smart_contracts.len(), 2);

    // Verify contract execution results
    let env = &blockchain.execution_environment;
    assert_eq!(env.balances.get("Bob").unwrap().get("ICN_TOKEN").unwrap(), &100.0);
    assert!(env.votes.contains_key(&blockchain.chain.last().unwrap().smart_contracts[1].id));
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_core/tests/smart_contract_tests.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_currency/Cargo.toml =====
[package]
name = "icn_currency"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
serde = { version = "1.0", features = ["derive"] }
log = "0.4"
thiserror = "1.0"
chrono = { version = "0.4", features = ["serde"] }

[dev-dependencies]
tokio = { version = "1.0", features = ["full"] }===== END OF /home/matt/InterCooperative-Network/crates/icn_currency/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_currency/src/asset_token.rs =====
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct AssetToken {
    pub asset_id: String,
    pub name: String,
    pub description: String,
    pub owner: String,
    pub value: f64,
}

impl AssetToken {
    pub fn new(asset_id: String, name: String, description: String, owner: String, value: f64) -> Self {
        AssetToken {
            asset_id,
            name,
            description,
            owner,
            value,
        }
    }

    pub fn transfer(&mut self, new_owner: String) {
        self.owner = new_owner;
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_currency/src/asset_token.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_currency/src/bond.rs =====
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Bond {
    pub bond_id: String,
    pub name: String,
    pub description: String,
    pub issuer: String,
    pub face_value: f64,
    pub maturity_date: DateTime<Utc>,
    pub interest_rate: f64,
    pub owner: String,
}

impl Bond {
    pub fn new(bond_id: String, name: String, description: String, issuer: String, face_value: f64, maturity_date: DateTime<Utc>, interest_rate: f64, owner: String) -> Self {
        Bond {
            bond_id,
            name,
            description,
            issuer,
            face_value,
            maturity_date,
            interest_rate,
            owner,
        }
    }

    pub fn transfer(&mut self, new_owner: String) {
        self.owner = new_owner;
    }

    pub fn calculate_current_value(&self, current_date: DateTime<Utc>) -> f64 {
        if current_date >= self.maturity_date {
            self.face_value
        } else {
            let years_to_maturity = (self.maturity_date - current_date).num_days() as f64 / 365.0;
            self.face_value * (1.0 + self.interest_rate).powf(years_to_maturity)
        }
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_currency/src/bond.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_currency/src/currency.rs =====
use icn_common::{IcnResult, IcnError, CurrencyType, Transaction};
use std::collections::HashMap;
use chrono::{DateTime, Utc};
use log::{info, warn};

/// Represents the balance of a particular currency for a given account.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Balance {
    pub currency: CurrencyType,
    pub amount: f64,
}

/// Represents a currency system managing multiple currencies.
pub struct CurrencySystem {
    pub accounts: HashMap<String, Vec<Balance>>,
}

impl CurrencySystem {
    /// Creates a new CurrencySystem.
    pub fn new() -> Self {
        CurrencySystem {
            accounts: HashMap::new(),
        }
    }

    /// Mints a specified amount of a currency to a given account.
    ///
    /// # Arguments
    ///
    /// * `account` - The account to mint the currency to.
    /// * `currency` - The type of currency to mint.
    /// * `amount` - The amount of currency to mint.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Currency` if the operation fails.
    pub fn mint(&mut self, account: &str, currency: CurrencyType, amount: f64) -> IcnResult<()> {
        let balances = self.accounts.entry(account.to_string()).or_insert_with(Vec::new);
        if let Some(balance) = balances.iter_mut().find(|b| b.currency == currency) {
            balance.amount += amount;
        } else {
            balances.push(Balance { currency, amount });
        }
        info!("Minted {} of {:?} to {}", amount, currency, account);
        Ok(())
    }

    /// Burns a specified amount of a currency from a given account.
    ///
    /// # Arguments
    ///
    /// * `account` - The account to burn the currency from.
    /// * `currency` - The type of currency to burn.
    /// * `amount` - The amount of currency to burn.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Currency` if the account has insufficient balance.
    pub fn burn(&mut self, account: &str, currency: CurrencyType, amount: f64) -> IcnResult<()> {
        let balances = self.accounts.entry(account.to_string()).or_insert_with(Vec::new);
        if let Some(balance) = balances.iter_mut().find(|b| b.currency == currency) {
            if balance.amount < amount {
                return Err(IcnError::Currency("Insufficient balance".into()));
            }
            balance.amount -= amount;
            info!("Burned {} of {:?} from {}", amount, currency, account);
            Ok(())
        } else {
            Err(IcnError::Currency("Currency not found in account".into()))
        }
    }

    /// Transfers a specified amount of a currency from one account to another.
    ///
    /// # Arguments
    ///
    /// * `from` - The account to transfer the currency from.
    /// * `to` - The account to transfer the currency to.
    /// * `currency` - The type of currency to transfer.
    /// * `amount` - The amount of currency to transfer.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Currency` if the sender has insufficient balance or if the operation fails.
    pub fn transfer(&mut self, from: &str, to: &str, currency: CurrencyType, amount: f64) -> IcnResult<()> {
        self.burn(from, currency.clone(), amount)?;
        self.mint(to, currency, amount)?;
        info!("Transferred {} of {:?} from {} to {}", amount, currency, from, to);
        Ok(())
    }

    /// Gets the balance of a particular currency for a given account.
    ///
    /// # Arguments
    ///
    /// * `account` - The account to get the balance for.
    /// * `currency` - The type of currency to get the balance of.
    ///
    /// # Returns
    ///
    /// The balance of the specified currency for the given account.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Currency` if the currency is not found in the account.
    pub fn get_balance(&self, account: &str, currency: &CurrencyType) -> IcnResult<f64> {
        let balances = self.accounts.get(account)
            .ok_or_else(|| IcnError::Currency("Account not found".into()))?;
        
        let balance = balances.iter()
            .find(|b| &b.currency == currency)
            .ok_or_else(|| IcnError::Currency("Currency not found in account".into()))?;
        
        Ok(balance.amount)
    }

    /// Lists all balances for a given account.
    ///
    /// # Arguments
    ///
    /// * `account` - The account to list the balances for.
    ///
    /// # Returns
    ///
    /// A list of balances for the specified account.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Currency` if the account is not found.
    pub fn list_balances(&self, account: &str) -> IcnResult<Vec<Balance>> {
        let balances = self.accounts.get(account)
            .ok_or_else(|| IcnError::Currency("Account not found".into()))?;
        Ok(balances.clone())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_mint() {
        let mut currency_system = CurrencySystem::new();
        assert!(currency_system.mint("Alice", CurrencyType::BasicNeeds, 100.0).is_ok());
        assert_eq!(currency_system.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap(), 100.0);
    }

    #[test]
    fn test_burn() {
        let mut currency_system = CurrencySystem::new();
        currency_system.mint("Alice", CurrencyType::BasicNeeds, 100.0).unwrap();
        assert!(currency_system.burn("Alice", CurrencyType::BasicNeeds, 50.0).is_ok());
        assert_eq!(currency_system.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap(), 50.0);
        assert!(currency_system.burn("Alice", CurrencyType::BasicNeeds, 60.0).is_err());
    }

    #[test]
    fn test_transfer() {
        let mut currency_system = CurrencySystem::new();
        currency_system.mint("Alice", CurrencyType::BasicNeeds, 100.0).unwrap();
        assert!(currency_system.transfer("Alice", "Bob", CurrencyType::BasicNeeds, 50.0).is_ok());
        assert_eq!(currency_system.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap(), 50.0);
        assert_eq!(currency_system.get_balance("Bob", &CurrencyType::BasicNeeds).unwrap(), 50.0);
        assert!(currency_system.transfer("Alice", "Bob", CurrencyType::BasicNeeds, 60.0).is_err());
    }

    #[test]
    fn test_get_balance() {
        let mut currency_system = CurrencySystem::new();
        currency_system.mint("Alice", CurrencyType::BasicNeeds, 100.0).unwrap();
        assert_eq!(currency_system.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap(), 100.0);
        assert!(currency_system.get_balance("Alice", &CurrencyType::Education).is_err());
        assert!(currency_system.get_balance("Bob", &CurrencyType::BasicNeeds).is_err());
    }

    #[test]
    fn test_list_balances() {
        let mut currency_system = CurrencySystem::new();
        currency_system.mint("Alice", CurrencyType::BasicNeeds, 100.0).unwrap();
        currency_system.mint("Alice", CurrencyType::Education, 50.0).unwrap();
        let balances = currency_system.list_balances("Alice").unwrap();
        assert_eq!(balances.len(), 2);
        assert_eq!(balances[0].amount, 100.0);
        assert_eq!(balances[1].amount, 50.0);
        assert!(currency_system.list_balances("Bob").is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_currency/src/currency.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_currency/src/lib.rs =====
/// Module for managing various types of currencies within the InterCooperative Network.
use icn_common::{IcnResult, IcnError, CurrencyType, Transaction};
use std::collections::HashMap;
use chrono::{DateTime, Utc};
use log::{info, warn};

/// Represents the balance of a particular currency for a given account.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Balance {
    pub currency: CurrencyType,
    pub amount: f64,
}

/// Represents a currency system managing multiple currencies.
pub struct CurrencySystem {
    pub accounts: HashMap<String, Vec<Balance>>,
}

impl CurrencySystem {
    /// Creates a new CurrencySystem.
    pub fn new() -> Self {
        CurrencySystem {
            accounts: HashMap::new(),
        }
    }

    /// Mints a specified amount of a currency to a given account.
    ///
    /// # Arguments
    ///
    /// * `account` - The account to mint the currency to.
    /// * `currency` - The type of currency to mint.
    /// * `amount` - The amount of currency to mint.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Currency` if the operation fails.
    pub fn mint(&mut self, account: &str, currency: CurrencyType, amount: f64) -> IcnResult<()> {
        let balances = self.accounts.entry(account.to_string()).or_insert_with(Vec::new);
        if let Some(balance) = balances.iter_mut().find(|b| b.currency == currency) {
            balance.amount += amount;
        } else {
            balances.push(Balance { currency, amount });
        }
        info!("Minted {} of {:?} to {}", amount, currency, account);
        Ok(())
    }

    /// Burns a specified amount of a currency from a given account.
    ///
    /// # Arguments
    ///
    /// * `account` - The account to burn the currency from.
    /// * `currency` - The type of currency to burn.
    /// * `amount` - The amount of currency to burn.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Currency` if the account has insufficient balance.
    pub fn burn(&mut self, account: &str, currency: CurrencyType, amount: f64) -> IcnResult<()> {
        let balances = self.accounts.entry(account.to_string()).or_insert_with(Vec::new);
        if let Some(balance) = balances.iter_mut().find(|b| b.currency == currency) {
            if balance.amount < amount {
                return Err(IcnError::Currency("Insufficient balance".into()));
            }
            balance.amount -= amount;
            info!("Burned {} of {:?} from {}", amount, currency, account);
            Ok(())
        } else {
            Err(IcnError::Currency("Currency not found in account".into()))
        }
    }

    /// Transfers a specified amount of a currency from one account to another.
    ///
    /// # Arguments
    ///
    /// * `from` - The account to transfer the currency from.
    /// * `to` - The account to transfer the currency to.
    /// * `currency` - The type of currency to transfer.
    /// * `amount` - The amount of currency to transfer.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Currency` if the sender has insufficient balance or if the operation fails.
    pub fn transfer(&mut self, from: &str, to: &str, currency: CurrencyType, amount: f64) -> IcnResult<()> {
        self.burn(from, currency.clone(), amount)?;
        self.mint(to, currency, amount)?;
        info!("Transferred {} of {:?} from {} to {}", amount, currency, from, to);
        Ok(())
    }

    /// Gets the balance of a particular currency for a given account.
    ///
    /// # Arguments
    ///
    /// * `account` - The account to get the balance for.
    /// * `currency` - The type of currency to get the balance of.
    ///
    /// # Returns
    ///
    /// The balance of the specified currency for the given account.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Currency` if the currency is not found in the account.
    pub fn get_balance(&self, account: &str, currency: &CurrencyType) -> IcnResult<f64> {
        let balances = self.accounts.get(account)
            .ok_or_else(|| IcnError::Currency("Account not found".into()))?;
        
        let balance = balances.iter()
            .find(|b| &b.currency == currency)
            .ok_or_else(|| IcnError::Currency("Currency not found in account".into()))?;
        
        Ok(balance.amount)
    }

    /// Lists all balances for a given account.
    ///
    /// # Arguments
    ///
    /// * `account` - The account to list the balances for.
    ///
    /// # Returns
    ///
    /// A list of balances for the specified account.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Currency` if the account is not found.
    pub fn list_balances(&self, account: &str) -> IcnResult<Vec<Balance>> {
        let balances = self.accounts.get(account)
            .ok_or_else(|| IcnError::Currency("Account not found".into()))?;
        Ok(balances.clone())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_mint() {
        let mut currency_system = CurrencySystem::new();
        assert!(currency_system.mint("Alice", CurrencyType::BasicNeeds, 100.0).is_ok());
        assert_eq!(currency_system.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap(), 100.0);
    }

    #[test]
    fn test_burn() {
        let mut currency_system = CurrencySystem::new();
        currency_system.mint("Alice", CurrencyType::BasicNeeds, 100.0).unwrap();
        assert!(currency_system.burn("Alice", CurrencyType::BasicNeeds, 50.0).is_ok());
        assert_eq!(currency_system.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap(), 50.0);
        assert!(currency_system.burn("Alice", CurrencyType::BasicNeeds, 60.0).is_err());
    }

    #[test]
    fn test_transfer() {
        let mut currency_system = CurrencySystem::new();
        currency_system.mint("Alice", CurrencyType::BasicNeeds, 100.0).unwrap();
        assert!(currency_system.transfer("Alice", "Bob", CurrencyType::BasicNeeds, 50.0).is_ok());
        assert_eq!(currency_system.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap(), 50.0);
        assert_eq!(currency_system.get_balance("Bob", &CurrencyType::BasicNeeds).unwrap(), 50.0);
        assert!(currency_system.transfer("Alice", "Bob", CurrencyType::BasicNeeds, 60.0).is_err());
    }

    #[test]
    fn test_get_balance() {
        let mut currency_system = CurrencySystem::new();
        currency_system.mint("Alice", CurrencyType::BasicNeeds, 100.0).unwrap();
        assert_eq!(currency_system.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap(), 100.0);
        assert!(currency_system.get_balance("Alice", &CurrencyType::Education).is_err());
        assert!(currency_system.get_balance("Bob", &CurrencyType::BasicNeeds).is_err());
    }

    #[test]
    fn test_list_balances() {
        let mut currency_system = CurrencySystem::new();
        currency_system.mint("Alice", CurrencyType::BasicNeeds, 100.0).unwrap();
        currency_system.mint("Alice", CurrencyType::Education, 50.0).unwrap();
        let balances = currency_system.list_balances("Alice").unwrap();
        assert_eq!(balances.len(), 2);
        assert_eq!(balances[0].amount, 100.0);
        assert_eq!(balances[1].amount, 50.0);
        assert!(currency_system.list_balances("Bob").is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_currency/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_currency/src/wallet.rs =====
use super::CurrencyType;
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use log::{info, error, debug};
use icn_core::error::{Error, Result};

#[derive(Debug, Serialize, Deserialize)]
pub struct Wallet {
    balances: HashMap<CurrencyType, f64>,
}

impl Wallet {
    pub fn new() -> Self {
        debug!("Creating new Wallet");
        Wallet {
            balances: HashMap::new(),
        }
    }

    pub fn deposit(&mut self, currency_type: CurrencyType, amount: f64) -> Result<()> {
        if amount < 0.0 {
            return Err(Error::CurrencyError("Cannot deposit negative amount".to_string()));
        }
        *self.balances.entry(currency_type.clone()).or_insert(0.0) += amount;
        info!("Deposited {} of {:?} into wallet", amount, currency_type);
        Ok(())
    }

    pub fn withdraw(&mut self, currency_type: CurrencyType, amount: f64) -> Result<()> {
        if amount < 0.0 {
            return Err(Error::CurrencyError("Cannot withdraw negative amount".to_string()));
        }
        let balance = self.balances.entry(currency_type.clone()).or_insert(0.0);
        if *balance < amount {
            error!("Insufficient balance for withdrawal. Requested: {}, Available: {}", amount, balance);
            return Err(Error::CurrencyError(format!("Insufficient balance for {:?}", currency_type)));
        }
        *balance -= amount;
        info!("Withdrawn {} of {:?} from wallet", amount, currency_type);
        Ok(())
    }

    pub fn get_balance(&self, currency_type: &CurrencyType) -> f64 {
        *self.balances.get(currency_type).unwrap_or(&0.0)
    }

    pub fn print_balances(&self) {
        info!("Wallet Balances:");
        for (currency_type, balance) in &self.balances {
            info!("{:?}: {}", currency_type, balance);
        }
    }

    pub fn transfer(&mut self, to: &mut Wallet, currency_type: CurrencyType, amount: f64) -> Result<()> {
        self.withdraw(currency_type.clone(), amount)?;
        to.deposit(currency_type, amount)?;
        Ok(())
    }
}


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_wallet_operations() {
        let mut wallet = Wallet::new();
        
        // Test deposit
        assert!(wallet.deposit(CurrencyType::BasicNeeds, 100.0).is_ok());
        assert_eq!(wallet.get_balance(&CurrencyType::BasicNeeds), 100.0);

        // Test withdraw
        assert!(wallet.withdraw(CurrencyType::BasicNeeds, 50.0).is_ok());
        assert_eq!(wallet.get_balance(&CurrencyType::BasicNeeds), 50.0);

        // Test insufficient balance
        assert!(wallet.withdraw(CurrencyType::BasicNeeds, 100.0).is_err());

        // Test transfer
        let mut wallet2 = Wallet::new();
        assert!(wallet.transfer(&mut wallet2, CurrencyType::BasicNeeds, 25.0).is_ok());
        assert_eq!(wallet.get_balance(&CurrencyType::BasicNeeds), 25.0);
        assert_eq!(wallet2.get_balance(&CurrencyType::BasicNeeds), 25.0);
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_currency/src/wallet.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_governance/Cargo.toml =====
[package]
name = "icn_governance"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
log = "0.4"
thiserror = "1.0"

[dev-dependencies]
tokio = { version = "1.0", features = ["full"] }===== END OF /home/matt/InterCooperative-Network/crates/icn_governance/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_governance/src/democracy.rs =====
use icn_utils::{Error, Result, Proposal, Vote};
use chrono::{DateTime, Utc, Duration};
use serde::{Serialize, Deserialize};
use std::collections::HashMap;
use log::{info, error, debug, warn};

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum ProposalCategory {
    Constitutional,
    Economic,
    Technical,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum ProposalStatus {
    Active,
    Passed,
    Rejected,
    Implemented,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum ProposalType {
    Constitutional,
    EconomicAdjustment,
    NetworkUpgrade,
}

pub struct DemocraticSystem {
    proposals: HashMap<String, Proposal>,
    votes: HashMap<String, Vec<Vote>>,
}

impl DemocraticSystem {
    pub fn new() -> Self {
        debug!("Creating new DemocraticSystem");
        DemocraticSystem {
            proposals: HashMap::new(),
            votes: HashMap::new(),
        }
    }

    pub fn create_proposal(
        &mut self,
        title: String,
        description: String,
        proposer: String,
        voting_period: Duration,
        proposal_type: ProposalType,
        category: ProposalCategory,
        required_quorum: f64,
        execution_timestamp: Option<DateTime<Utc>>,
    ) -> Result<String> {
        let id = format!("prop_{}", Utc::now().timestamp());
        let proposal = Proposal::new(
            id.clone(),
            title,
            description,
            proposer,
            voting_period,
            proposal_type,
            category,
            required_quorum,
            execution_timestamp,
        );
        self.proposals.insert(id.clone(), proposal);
        info!("New proposal created: {}", id);
        Ok(id)
    }

    pub fn vote(&mut self, voter: String, proposal_id: String, in_favor: bool, weight: f64) -> Result<()> {
        let proposal = self.proposals.get(&proposal_id).ok_or(Error::GovernanceError("Proposal not found".to_string()))?;
        
        if proposal.status != ProposalStatus::Active {
            error!("Attempted to vote on inactive proposal: {}", proposal_id);
            return Err(Error::GovernanceError("Voting is not active for this proposal".to_string()));
        }

        if Utc::now() > proposal.voting_ends_at {
            error!("Attempted to vote on expired proposal: {}", proposal_id);
            return Err(Error::GovernanceError("Voting period has ended".to_string()));
        }

        let vote = Vote::new(voter, proposal_id.clone(), in_favor, weight);
        self.votes.entry(proposal_id.clone()).or_insert_with(Vec::new).push(vote);
        info!("Vote recorded for proposal: {}", proposal_id);
        Ok(())
    }

    pub fn tally_votes(&mut self, proposal_id: &str) -> Result<()> {
        let proposal = self.proposals.get_mut(proposal_id).ok_or(Error::GovernanceError("Proposal not found".to_string()))?;
        
        if proposal.status != ProposalStatus::Active {
            error!("Attempted to tally votes for inactive proposal: {}", proposal_id);
            return Err(Error::GovernanceError("Proposal is not active".to_string()));
        }

        if Utc::now() < proposal.voting_ends_at {
            warn!("Attempted to tally votes before voting period ended: {}", proposal_id);
            return Err(Error::GovernanceError("Voting period has not ended yet".to_string()));
        }

        let votes = self.votes.get(proposal_id).ok_or(Error::GovernanceError("No votes found for this proposal".to_string()))?;
        
        let total_weight: f64 = votes.iter().map(|v| v.weight).sum();
        let weight_in_favor: f64 = votes.iter().filter(|v| v.in_favor).map(|v| v.weight).sum();

        if total_weight < proposal.required_quorum {
            proposal.status = ProposalStatus::Rejected;
            info!("Proposal {} rejected due to insufficient quorum", proposal_id);
            return Ok(());
        }

        if weight_in_favor / total_weight > 0.5 {
            proposal.status = ProposalStatus::Passed;
            info!("Proposal {} passed", proposal_id);
        } else {
            proposal.status = ProposalStatus::Rejected;
            info!("Proposal {} rejected", proposal_id);
        }

        Ok(())
    }

    pub fn get_proposal(&self, proposal_id: &str) -> Option<&Proposal> {
        self.proposals.get(proposal_id)
    }

    pub fn get_votes(&self, proposal_id: &str) -> Option<&Vec<Vote>> {
        self.votes.get(proposal_id)
    }

    pub fn list_active_proposals(&self) -> Vec<&Proposal> {
        self.proposals.values()
            .filter(|p| p.status == ProposalStatus::Active)
            .collect()
    }

    pub fn mark_as_implemented(&mut self, proposal_id: &str) -> Result<()> {
        let proposal = self.proposals.get_mut(proposal_id).ok_or(Error::GovernanceError("Proposal not found".to_string()))?;
        
        if proposal.status != ProposalStatus::Passed {
            error!("Attempted to mark non-passed proposal as implemented: {}", proposal_id);
            return Err(Error::GovernanceError("Proposal has not passed".to_string()));
        }

        proposal.status = ProposalStatus::Implemented;
        info!("Proposal {} marked as implemented", proposal_id);
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_utils::ProposalStatus;

    #[test]
    fn test_democratic_system() {
        let mut system = DemocraticSystem::new();
        
        // Create proposal
        let proposal_id = system.create_proposal(
            "Test Proposal".to_string(),
            "This is a test proposal".to_string(),
            "Alice".to_string(),
            Duration::days(7),
            ProposalType::Constitutional,
            ProposalCategory::Technical,
            0.5,
            None,
        ).unwrap();

        // Vote on proposal
        assert!(system.vote("Bob".to_string(), proposal_id.clone(), true, 1.0).is_ok());
        assert!(system.vote("Charlie".to_string(), proposal_id.clone(), false, 1.0).is_ok());
        assert!(system.vote("David".to_string(), proposal_id.clone(), true, 1.0).is_ok());

        // Try to tally votes before voting period ends (should fail)
        assert!(system.tally_votes(&proposal_id).is_err());

        // Simulate voting period end
        let proposal = system.proposals.get_mut(&proposal_id).unwrap();
        proposal.voting_ends_at = Utc::now() - Duration::hours(1);

        // Tally votes
        assert!(system.tally_votes(&proposal_id).is_ok());

        // Check proposal status
        let proposal = system.get_proposal(&proposal_id).unwrap();
        assert_eq!(proposal.status, ProposalStatus::Passed);

        // Mark as implemented
        assert!(system.mark_as_implemented(&proposal_id).is_ok());
        let updated_proposal = system.get_proposal(&proposal_id).unwrap();
        assert_eq!(updated_proposal.status, ProposalStatus::Implemented);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_governance/src/democracy.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_governance/src/governance.rs =====
use icn_common::{IcnResult, IcnError, Proposal, ProposalStatus, Vote};
use std::collections::HashMap;
use chrono::{DateTime, Utc};
use log::{info, warn};

/// Represents the governance system managing proposals and votes.
pub struct Governance {
    pub proposals: HashMap<String, Proposal>,
    pub votes: HashMap<String, Vec<Vote>>,
}

impl Governance {
    /// Creates a new Governance system.
    pub fn new() -> Self {
        Governance {
            proposals: HashMap::new(),
            votes: HashMap::new(),
        }
    }

    /// Creates a new proposal in the governance system.
    ///
    /// # Arguments
    ///
    /// * `proposal` - The proposal to be created.
    ///
    /// # Returns
    ///
    /// The ID of the created proposal.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Governance` if the proposal already exists.
    pub fn create_proposal(&mut self, proposal: Proposal) -> IcnResult<String> {
        if self.proposals.contains_key(&proposal.id) {
            return Err(IcnError::Governance("Proposal already exists".into()));
        }
        self.proposals.insert(proposal.id.clone(), proposal);
        info!("Created proposal with ID: {}", proposal.id);
        Ok(proposal.id.clone())
    }

    /// Votes on an existing proposal.
    ///
    /// # Arguments
    ///
    /// * `vote` - The vote to be cast.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Governance` if the proposal is not found.
    pub fn vote_on_proposal(&mut self, vote: Vote) -> IcnResult<()> {
        if !self.proposals.contains_key(&vote.proposal_id) {
            return Err(IcnError::Governance("Proposal not found".into()));
        }
        self.votes.entry(vote.proposal_id.clone()).or_insert_with(Vec::new).push(vote);
        info!("Vote recorded for proposal ID: {}", vote.proposal_id);
        Ok(())
    }

    /// Fetches the status of a given proposal.
    ///
    /// # Arguments
    ///
    /// * `proposal_id` - The ID of the proposal to fetch the status of.
    ///
    /// # Returns
    ///
    /// The status of the specified proposal.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Governance` if the proposal is not found.
    pub fn get_proposal_status(&self, proposal_id: &str) -> IcnResult<ProposalStatus> {
        let proposal = self.proposals.get(proposal_id).ok_or_else(|| IcnError::Governance("Proposal not found".into()))?;
        Ok(proposal.status.clone())
    }

    /// Closes a proposal and determines its outcome.
    ///
    /// # Arguments
    ///
    /// * `proposal_id` - The ID of the proposal to close.
    ///
    /// # Returns
    ///
    /// The final status of the proposal.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Governance` if the proposal is not found or if the proposal is already closed.
    pub fn close_proposal(&mut self, proposal_id: &str) -> IcnResult<ProposalStatus> {
        let proposal = self.proposals.get_mut(proposal_id).ok_or_else(|| IcnError::Governance("Proposal not found".into()))?;
        if proposal.status != ProposalStatus::Active {
            return Err(IcnError::Governance("Proposal is already closed".into()));
        }

        let votes = self.votes.get(proposal_id).unwrap_or(&Vec::new());
        let mut in_favor = 0.0;
        let mut against = 0.0;
        for vote in votes {
            if vote.in_favor {
                in_favor += vote.weight;
            } else {
                against += vote.weight;
            }
        }

        if in_favor / (in_favor + against) >= proposal.required_quorum {
            proposal.status = ProposalStatus::Passed;
        } else {
            proposal.status = ProposalStatus::Rejected;
        }

        info!("Closed proposal ID: {} with status: {:?}", proposal_id, proposal.status);
        Ok(proposal.status.clone())
    }

    /// Lists all active proposals.
    ///
    /// # Returns
    ///
    /// A list of all active proposals.
    pub fn list_active_proposals(&self) -> Vec<&Proposal> {
        self.proposals.values().filter(|p| p.status == ProposalStatus::Active).collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_common::{ProposalType, ProposalCategory};

    #[test]
    fn test_create_proposal() {
        let mut governance = Governance::new();
        let proposal = Proposal {
            id: "proposal1".to_string(),
            title: "Test Proposal".to_string(),
            description: "This is a test proposal".to_string(),
            proposer: "Alice".to_string(),
            created_at: Utc::now(),
            voting_ends_at: Utc::now() + chrono::Duration::days(7),
            status: ProposalStatus::Active,
            proposal_type: ProposalType::Constitutional,
            category: ProposalCategory::Economic,
            required_quorum: 0.66,
            execution_timestamp: None,
        };
        assert!(governance.create_proposal(proposal).is_ok());
        assert!(governance.create_proposal(proposal).is_err());
    }

    #[test]
    fn test_vote_on_proposal() {
        let mut governance = Governance::new();
        let proposal = Proposal {
            id: "proposal1".to_string(),
            title: "Test Proposal".to_string(),
            description: "This is a test proposal".to_string(),
            proposer: "Alice".to_string(),
            created_at: Utc::now(),
            voting_ends_at: Utc::now() + chrono::Duration::days(7),
            status: ProposalStatus::Active,
            proposal_type: ProposalType::Constitutional,
            category: ProposalCategory::Economic,
            required_quorum: 0.66,
            execution_timestamp: None,
        };
        governance.create_proposal(proposal).unwrap();
        let vote = Vote {
            voter: "Bob".to_string(),
            proposal_id: "proposal1".to_string(),
            in_favor: true,
            weight: 1.0,
            timestamp: Utc::now(),
            zkp: None,
        };
        assert!(governance.vote_on_proposal(vote).is_ok());
    }

    #[test]
    fn test_get_proposal_status() {
        let mut governance = Governance::new();
        let proposal = Proposal {
            id: "proposal1".to_string(),
            title: "Test Proposal".to_string(),
            description: "This is a test proposal".to_string(),
            proposer: "Alice".to_string(),
            created_at: Utc::now(),
            voting_ends_at: Utc::now() + chrono::Duration::days(7),
            status: ProposalStatus::Active,
            proposal_type: ProposalType::Constitutional,
            category: ProposalCategory::Economic,
            required_quorum: 0.66,
            execution_timestamp: None,
        };
        governance.create_proposal(proposal).unwrap();
        let status = governance.get_proposal_status("proposal1").unwrap();
        assert_eq!(status, ProposalStatus::Active);
    }

    #[test]
    fn test_close_proposal() {
        let mut governance = Governance::new();
        let proposal = Proposal {
            id: "proposal1".to_string(),
            title: "Test Proposal".to_string(),
            description: "This is a test proposal".to_string(),
            proposer: "Alice".to_string(),
            created_at: Utc::now(),
            voting_ends_at: Utc::now() + chrono::Duration::days(7),
            status: ProposalStatus::Active,
            proposal_type: ProposalType::Constitutional,
            category: ProposalCategory::Economic,
            required_quorum: 0.66,
            execution_timestamp: None,
        };
        governance.create_proposal(proposal).unwrap();
        let vote1 = Vote {
            voter: "Bob".to_string(),
            proposal_id: "proposal1".to_string(),
            in_favor: true,
            weight: 0.7,
            timestamp: Utc::now(),
            zkp: None,
        };
        let vote2 = Vote {
            voter: "Charlie".to_string(),
            proposal_id: "proposal1".to_string(),
            in_favor: false,
            weight: 0.3,
            timestamp: Utc::now(),
            zkp: None,
        };
        governance.vote_on_proposal(vote1).unwrap();
        governance.vote_on_proposal(vote2).unwrap();
        let status = governance.close_proposal("proposal1").unwrap();
        assert_eq!(status, ProposalStatus::Passed);
    }

    #[test]
    fn test_list_active_proposals() {
        let mut governance = Governance::new();
        let proposal1 = Proposal {
            id: "proposal1".to_string(),
            title: "Test Proposal 1".to_string(),
            description: "This is a test proposal 1".to_string(),
            proposer: "Alice".to_string(),
            created_at: Utc::now(),
            voting_ends_at: Utc::now() + chrono::Duration::days(7),
            status: ProposalStatus::Active,
            proposal_type: ProposalType::Constitutional,
            category: ProposalCategory::Economic,
            required_quorum: 0.66,
            execution_timestamp: None,
        };
        let proposal2 = Proposal {
            id: "proposal2".to_string(),
            title: "Test Proposal 2".to_string(),
            description: "This is a test proposal 2".to_string(),
            proposer: "Bob".to_string(),
            created_at: Utc::now(),
            voting_ends_at: Utc::now() + chrono::Duration::days(7),
            status: ProposalStatus::Passed,
            proposal_type: ProposalType::Constitutional,
            category: ProposalCategory::Economic,
            required_quorum: 0.66,
            execution_timestamp: None,
        };
        governance.create_proposal(proposal1).unwrap();
        governance.create_proposal(proposal2).unwrap();
        let active_proposals = governance.list_active_proposals();
        assert_eq!(active_proposals.len(), 1);
        assert_eq!(active_proposals[0].id, "proposal1");
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_governance/src/governance.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_governance/src/lib.rs =====
/// Module for governance mechanisms within the InterCooperative Network.
use icn_common::{IcnResult, IcnError, Proposal, ProposalStatus, Vote};
use std::collections::HashMap;
use chrono::{DateTime, Utc};
use log::{info, warn};

/// Represents the governance system managing proposals and votes.
pub struct GovernanceSystem {
    pub proposals: HashMap<String, Proposal>,
    pub votes: HashMap<String, Vec<Vote>>,
}

impl GovernanceSystem {
    /// Creates a new Governance system.
    pub fn new() -> Self {
        GovernanceSystem {
            proposals: HashMap::new(),
            votes: HashMap::new(),
        }
    }

    /// Creates a new proposal in the governance system.
    ///
    /// # Arguments
    ///
    /// * `proposal` - The proposal to be created.
    ///
    /// # Returns
    ///
    /// The ID of the created proposal.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Governance` if the proposal already exists.
    pub fn create_proposal(&mut self, proposal: Proposal) -> IcnResult<String> {
        if self.proposals.contains_key(&proposal.id) {
            return Err(IcnError::Governance("Proposal already exists".into()));
        }
        self.proposals.insert(proposal.id.clone(), proposal);
        info!("Created proposal with ID: {}", proposal.id);
        Ok(proposal.id.clone())
    }

    /// Votes on an existing proposal.
    ///
    /// # Arguments
    ///
    /// * `vote` - The vote to be cast.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Governance` if the proposal is not found.
    pub fn vote_on_proposal(&mut self, vote: Vote) -> IcnResult<()> {
        if !self.proposals.contains_key(&vote.proposal_id) {
            return Err(IcnError::Governance("Proposal not found".into()));
        }
        self.votes.entry(vote.proposal_id.clone()).or_insert_with(Vec::new).push(vote);
        info!("Vote recorded for proposal ID: {}", vote.proposal_id);
        Ok(())
    }

    /// Fetches the status of a given proposal.
    ///
    /// # Arguments
    ///
    /// * `proposal_id` - The ID of the proposal to fetch the status of.
    ///
    /// # Returns
    ///
    /// The status of the specified proposal.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Governance` if the proposal is not found.
    pub fn get_proposal_status(&self, proposal_id: &str) -> IcnResult<ProposalStatus> {
        let proposal = self.proposals.get(proposal_id).ok_or_else(|| IcnError::Governance("Proposal not found".into()))?;
        Ok(proposal.status.clone())
    }

    /// Closes a proposal and determines its outcome.
    ///
    /// # Arguments
    ///
    /// * `proposal_id` - The ID of the proposal to close.
    ///
    /// # Returns
    ///
    /// The final status of the proposal.
    ///
    /// # Errors
    ///
    /// Returns `IcnError::Governance` if the proposal is not found or if the proposal is already closed.
    pub fn close_proposal(&mut self, proposal_id: &str) -> IcnResult<ProposalStatus> {
        let proposal = self.proposals.get_mut(proposal_id).ok_or_else(|| IcnError::Governance("Proposal not found".into()))?;
        if proposal.status != ProposalStatus::Active {
            return Err(IcnError::Governance("Proposal is already closed".into()));
        }

        let votes = self.votes.get(proposal_id).unwrap_or(&Vec::new());
        let mut in_favor = 0.0;
        let mut against = 0.0;
        for vote in votes {
            if vote.in_favor {
                in_favor += vote.weight;
            } else {
                against += vote.weight;
            }
        }

        if in_favor / (in_favor + against) >= proposal.required_quorum {
            proposal.status = ProposalStatus::Passed;
        } else {
            proposal.status = ProposalStatus::Rejected;
        }

        info!("Closed proposal ID: {} with status: {:?}", proposal_id, proposal.status);
        Ok(proposal.status.clone())
    }

    /// Lists all active proposals.
    ///
    /// # Returns
    ///
    /// A list of all active proposals.
    pub fn list_active_proposals(&self) -> Vec<&Proposal> {
        self.proposals.values().filter(|p| p.status == ProposalStatus::Active).collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_common::{ProposalType, ProposalCategory};

    #[test]
    fn test_create_proposal() {
        let mut governance = GovernanceSystem::new();
        let proposal = Proposal {
            id: "proposal1".to_string(),
            title: "Test Proposal".to_string(),
            description: "This is a test proposal".to_string(),
            proposer: "Alice".to_string(),
            created_at: Utc::now(),
            voting_ends_at: Utc::now() + chrono::Duration::days(7),
            status: ProposalStatus::Active,
            proposal_type: ProposalType::Constitutional,
            category: ProposalCategory::Economic,
            required_quorum: 0.66,
            execution_timestamp: None,
        };
        assert!(governance.create_proposal(proposal).is_ok());
        assert!(governance.create_proposal(proposal).is_err());
    }

    #[test]
    fn test_vote_on_proposal() {
        let mut governance = GovernanceSystem::new();
        let proposal = Proposal {
            id: "proposal1".to_string(),
            title: "Test Proposal".to_string(),
            description: "This is a test proposal".to_string(),
            proposer: "Alice".to_string(),
            created_at: Utc::now(),
            voting_ends_at: Utc::now() + chrono::Duration::days(7),
            status: ProposalStatus::Active,
            proposal_type: ProposalType::Constitutional,
            category: ProposalCategory::Economic,
            required_quorum: 0.66,
            execution_timestamp: None,
        };
        governance.create_proposal(proposal).unwrap();
        let vote = Vote {
            voter: "Bob".to_string(),
            proposal_id: "proposal1".to_string(),
            in_favor: true,
            weight: 1.0,
            timestamp: Utc::now(),
        };
        assert!(governance.vote_on_proposal(vote).is_ok());
    }

    #[test]
    fn test_get_proposal_status() {
        let mut governance = GovernanceSystem::new();
        let proposal = Proposal {
            id: "proposal1".to_string(),
            title: "Test Proposal".to_string(),
            description: "This is a test proposal".to_string(),
            proposer: "Alice".to_string(),
            created_at: Utc::now(),
            voting_ends_at: Utc::now() + chrono::Duration::days(7),
            status: ProposalStatus::Active,
            proposal_type: ProposalType::Constitutional,
            category: ProposalCategory::Economic,
            required_quorum: 0.66,
            execution_timestamp: None,
        };
        governance.create_proposal(proposal).unwrap();
        let status = governance.get_proposal_status("proposal1").unwrap();
        assert_eq!(status, ProposalStatus::Active);
    }

    #[test]
    fn test_close_proposal() {
        let mut governance = GovernanceSystem::new();
        let proposal = Proposal {
            id: "proposal1".to_string(),
            title: "Test Proposal".to_string(),
            description: "This is a test proposal".to_string(),
            proposer: "Alice".to_string(),
            created_at: Utc::now(),
            voting_ends_at: Utc::now() + chrono::Duration::days(7),
            status: ProposalStatus::Active,
            proposal_type: ProposalType::Constitutional,
            category: ProposalCategory::Economic,
            required_quorum: 0.66,
            execution_timestamp: None,
        };
        governance.create_proposal(proposal).unwrap();
        let vote1 = Vote {
            voter: "Bob".to_string(),
            proposal_id: "proposal1".to_string(),
            in_favor: true,
            weight: 0.7,
            timestamp: Utc::now(),
        };
        let vote2 = Vote {
            voter: "Charlie".to_string(),
            proposal_id: "proposal1".to_string(),
            in_favor: false,
            weight: 0.3,
            timestamp: Utc::now(),
        };
        governance.vote_on_proposal(vote1).unwrap();
        governance.vote_on_proposal(vote2).unwrap();
        let status = governance.close_proposal("proposal1").unwrap();
        assert_eq!(status, ProposalStatus::Passed);
    }

    #[test]
    fn test_list_active_proposals() {
        let mut governance = GovernanceSystem::new();
        let proposal1 = Proposal {
            id: "proposal1".to_string(),
            title: "Test Proposal 1".to_string(),
            description: "This is a test proposal 1".to_string(),
            proposer: "Alice".to_string(),
            created_at: Utc::now(),
            voting_ends_at: Utc::now() + chrono::Duration::days(7),
            status: ProposalStatus::Active,
            proposal_type: ProposalType::Constitutional,
            category: ProposalCategory::Economic,
            required_quorum: 0.66,
            execution_timestamp: None,
        };
        let proposal2 = Proposal {
            id: "proposal2".to_string(),
            title: "Test Proposal 2".to_string(),
            description: "This is a test proposal 2".to_string(),
            proposer: "Bob".to_string(),
            created_at: Utc::now(),
            voting_ends_at: Utc::now() + chrono::Duration::days(7),
            status: ProposalStatus::Passed,
            proposal_type: ProposalType::Constitutional,
            category: ProposalCategory::Economic,
            required_quorum: 0.66,
            execution_timestamp: None,
        };
        governance.create_proposal(proposal1).unwrap();
        governance.create_proposal(proposal2).unwrap();
        let active_proposals = governance.list_active_proposals();
        assert_eq!(active_proposals.len(), 1);
        assert_eq!(active_proposals[0].id, "proposal1");
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_governance/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_governance/src/proposal.rs =====
use crate::democracy::{ProposalCategory, ProposalType, ProposalStatus};
use chrono::{DateTime, Utc, Duration};
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Proposal {
    pub id: String,
    pub title: String,
    pub description: String,
    pub proposer: String,
    pub created_at: DateTime<Utc>,
    pub voting_ends_at: DateTime<Utc>,
    pub status: ProposalStatus,
    pub proposal_type: ProposalType,
    pub category: ProposalCategory,
    pub required_quorum: f64,
    pub execution_timestamp: Option<DateTime<Utc>>,
}

impl Proposal {
    pub fn new(
        id: String,
        title: String,
        description: String,
        proposer: String,
        voting_period: Duration,
        proposal_type: ProposalType,
        category: ProposalCategory,
        required_quorum: f64,
        execution_timestamp: Option<DateTime<Utc>>,
    ) -> Self {
        let now = Utc::now();
        Proposal {
            id,
            title,
            description,
            proposer,
            created_at: now,
            voting_ends_at: now + voting_period,
            status: ProposalStatus::Active,
            proposal_type,
            category,
            required_quorum,
            execution_timestamp,
        }
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_governance/src/proposal.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_governance/src/voting.rs =====
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Vote {
    pub voter: String,
    pub proposal_id: String,
    pub in_favor: bool,
    pub weight: f64,
    pub timestamp: DateTime<Utc>,
}

impl Vote {
    pub fn new(voter: String, proposal_id: String, in_favor: bool, weight: f64) -> Self {
        Vote {
            voter,
            proposal_id,
            in_favor,
            weight,
            timestamp: Utc::now(),
        }
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_governance/src/voting.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_identity/Cargo.toml =====
[package]
name = "icn_identity"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
ed25519-dalek = "1.0"
rand = "0.7"
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
hex = "0.4"

[dev-dependencies]
tokio = { version = "1.0", features = ["full"] }===== END OF /home/matt/InterCooperative-Network/crates/icn_identity/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_identity/src/did.rs =====
use chrono::{DateTime, Utc};
use ed25519_dalek::{Keypair, PublicKey, Signature, Verifier};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct DecentralizedIdentity {
    pub id: String,
    #[serde(with = "public_key_serde")]
    pub public_key: PublicKey,
    pub created_at: DateTime<Utc>,
    pub reputation: f64,
    pub attributes: HashMap<String, String>,
}

mod public_key_serde {
    use ed25519_dalek::PublicKey;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};

    pub fn serialize<S>(public_key: &PublicKey, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let bytes = public_key.to_bytes();
        bytes.serialize(serializer)
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<PublicKey, D::Error>
    where
        D: Deserializer<'de>,
    {
        let bytes = Vec::<u8>::deserialize(deserializer)?;
        PublicKey::from_bytes(&bytes).map_err(serde::de::Error::custom)
    }
}

impl DecentralizedIdentity {
    pub fn new(attributes: HashMap<String, String>) -> (Self, Keypair) {
        let mut csprng = rand::rngs::OsRng {};
        let keypair: Keypair = Keypair::generate(&mut csprng);
        let public_key = keypair.public;
        let id = format!("did:icn:{}", hex::encode(public_key.to_bytes()));

        (
            Self {
                id,
                public_key,
                created_at: Utc::now(),
                reputation: 1.0,
                attributes,
            },
            keypair,
        )
    }

    pub fn verify_signature(&self, message: &[u8], signature: &Signature) -> bool {
        self.public_key.verify(message, signature).is_ok()
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_identity/src/did.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_identity/src/identity_manager.rs =====
use crate::DecentralizedIdentity;
use ed25519_dalek::Signature;
use icn_core::error::{Error, Result};
use std::collections::HashMap;

pub struct IdentityManager {
    identities: HashMap<String, DecentralizedIdentity>,
}

impl IdentityManager {
    pub fn new() -> Self {
        IdentityManager {
            identities: HashMap::new(),
        }
    }

    pub fn create_identity(&mut self, attributes: HashMap<String, String>) -> Result<DecentralizedIdentity> {
        let (identity, _) = DecentralizedIdentity::new(attributes);
        self.identities.insert(identity.id.clone(), identity.clone());
        Ok(identity)
    }

    pub fn get_identity(&self, id: &str) -> Option<&DecentralizedIdentity> {
        self.identities.get(id)
    }

    pub fn update_reputation(&mut self, id: &str, change: f64) -> Result<()> {
        let identity = self.identities.get_mut(id).ok_or(Error::IdentityError("Identity not found".to_string()))?;
        identity.reputation += change;
        Ok(())
    }

    pub fn verify_signature(&self, id: &str, message: &[u8], signature: &Signature) -> Result<bool> {
        let identity = self.identities.get(id).ok_or(Error::IdentityError("Identity not found".to_string()))?;
        Ok(identity.verify_signature(message, signature))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use ed25519_dalek::{Keypair, Signer};

    #[test]
    fn test_identity_management() {
        let mut manager = IdentityManager::new();
        
        // Create a new identity
        let mut attributes = HashMap::new();
        attributes.insert("name".to_string(), "Alice".to_string());
        let identity = manager.create_identity(attributes).unwrap();
        
        // Verify the identity exists
        assert!(manager.get_identity(&identity.id).is_some());
        
        // Update reputation
        assert!(manager.update_reputation(&identity.id, 0.5).is_ok());
        let updated_identity = manager.get_identity(&identity.id).unwrap();
        assert_eq!(updated_identity.reputation, 1.5);
        
        // Test signature verification
        let message = b"Hello, World!";
        let mut csprng = rand::rngs::OsRng {};
        let keypair = Keypair::generate(&mut csprng);
        let signature = keypair.sign(message);
        
        // This should fail because we're using a different keypair
        assert!(!manager.verify_signature(&identity.id, message, &signature).unwrap());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_identity/src/identity_manager.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_identity/src/lib.rs =====
use icn_common::{IcnResult, IcnError};
use ed25519_dalek::{Keypair, PublicKey, Signature, Signer, Verifier};
use rand::rngs::OsRng;
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};
use std::collections::HashMap;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct DecentralizedIdentity {
    pub id: String,
    #[serde(with = "public_key_serde")]
    pub public_key: PublicKey,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub reputation: f64,
    pub attributes: HashMap<String, String>,
    pub status: IdentityStatus,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub enum IdentityStatus {
    Active,
    Suspended,
    Revoked,
}

mod public_key_serde {
    use super::*;
    use serde::{Deserializer, Serializer};

    pub fn serialize<S>(public_key: &PublicKey, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let bytes = public_key.to_bytes();
        bytes.serialize(serializer)
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<PublicKey, D::Error>
    where
        D: Deserializer<'de>,
    {
        let bytes = Vec::<u8>::deserialize(deserializer)?;
        PublicKey::from_bytes(&bytes).map_err(serde::de::Error::custom)
    }
}

impl DecentralizedIdentity {
    pub fn new(attributes: HashMap<String, String>) -> IcnResult<(Self, Keypair)> {
        let mut csprng = OsRng {};
        let keypair: Keypair = Keypair::generate(&mut csprng);
        let public_key = keypair.public;
        let id = format!("did:icn:{}", hex::encode(public_key.to_bytes()));
        let now = Utc::now();

        Ok((
            Self {
                id,
                public_key,
                created_at: now,
                updated_at: now,
                reputation: 1.0,
                attributes,
                status: IdentityStatus::Active,
            },
            keypair,
        ))
    }

    pub fn verify_signature(&self, message: &[u8], signature: &Signature) -> bool {
        self.public_key.verify(message, signature).is_ok()
    }
}

pub struct IdentityManager {
    identities: HashMap<String, DecentralizedIdentity>,
}

impl IdentityManager {
    pub fn new() -> Self {
        IdentityManager {
            identities: HashMap::new(),
        }
    }

    pub fn create_identity(&mut self, attributes: HashMap<String, String>) -> IcnResult<DecentralizedIdentity> {
        let (identity, _) = DecentralizedIdentity::new(attributes)?;
        self.identities.insert(identity.id.clone(), identity.clone());
        Ok(identity)
    }

    pub fn get_identity(&self, id: &str) -> IcnResult<&DecentralizedIdentity> {
        self.identities.get(id).ok_or(IcnError::Identity("Identity not found".to_string()))
    }

    pub fn update_identity(&mut self, id: &str, attributes: HashMap<String, String>) -> IcnResult<()> {
        let identity = self.identities.get_mut(id).ok_or(IcnError::Identity("Identity not found".to_string()))?;
        identity.attributes.extend(attributes);
        identity.updated_at = Utc::now();
        Ok(())
    }

    pub fn suspend_identity(&mut self, id: &str) -> IcnResult<()> {
        let identity = self.identities.get_mut(id).ok_or(IcnError::Identity("Identity not found".to_string()))?;
        identity.status = IdentityStatus::Suspended;
        identity.updated_at = Utc::now();
        Ok(())
    }

    pub fn revoke_identity(&mut self, id: &str) -> IcnResult<()> {
        let identity = self.identities.get_mut(id).ok_or(IcnError::Identity("Identity not found".to_string()))?;
        identity.status = IdentityStatus::Revoked;
        identity.updated_at = Utc::now();
        Ok(())
    }

    pub fn update_reputation(&mut self, id: &str, change: f64) -> IcnResult<()> {
        let identity = self.identities.get_mut(id).ok_or(IcnError::Identity("Identity not found".to_string()))?;
        identity.reputation += change;
        Ok(())
    }

    pub fn verify_signature(&self, id: &str, message: &[u8], signature: &Signature) -> IcnResult<bool> {
        let identity = self.identities.get(id).ok_or(IcnError::Identity("Identity not found".to_string()))?;
        Ok(identity.verify_signature(message, signature))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use ed25519_dalek::Signer;

    #[test]
    fn test_identity_creation_and_verification() {
        let mut manager = IdentityManager::new();
        
        let mut attributes = HashMap::new();
        attributes.insert("name".to_string(), "Alice".to_string());
        
        let identity = manager.create_identity(attributes).unwrap();
        
        assert!(manager.get_identity(&identity.id).is_ok());
        
        let message = b"Hello, World!";
        let mut csprng = OsRng {};
        let keypair = Keypair::generate(&mut csprng);
        let signature = keypair.sign(message);
        
        // This should fail because we're using a different keypair
        assert!(!manager.verify_signature(&identity.id, message, &signature).unwrap());
        
        // Create a valid signature
        let (_, keypair) = DecentralizedIdentity::new(HashMap::new()).unwrap();
        let valid_signature = keypair.sign(message);
        
        // This should succeed
        assert!(manager.verify_signature(&identity.id, message, &valid_signature).unwrap());
    }

    #[test]
    fn test_identity_management() {
        let mut manager = IdentityManager::new();
        
        // Create an identity
        let mut attributes = HashMap::new();
        attributes.insert("name".to_string(), "Alice".to_string());
        let identity = manager.create_identity(attributes).unwrap();
        
        // Update identity
        let mut new_attributes = HashMap::new();
        new_attributes.insert("email".to_string(), "alice@example.com".to_string());
        assert!(manager.update_identity(&identity.id, new_attributes).is_ok());
        
        // Check updated identity
        let updated_identity = manager.get_identity(&identity.id).unwrap();
        assert_eq!(updated_identity.attributes.get("email"), Some(&"alice@example.com".to_string()));
        
        // Update reputation
        assert!(manager.update_reputation(&identity.id, 0.5).is_ok());
        let updated_identity = manager.get_identity(&identity.id).unwrap();
        assert_eq!(updated_identity.reputation, 1.5);
        
        // Suspend identity
        assert!(manager.suspend_identity(&identity.id).is_ok());
        let suspended_identity = manager.get_identity(&identity.id).unwrap();
        assert_eq!(suspended_identity.status, IdentityStatus::Suspended);
        
        // Revoke identity
        assert!(manager.revoke_identity(&identity.id).is_ok());
        let revoked_identity = manager.get_identity(&identity.id).unwrap();
        assert_eq!(revoked_identity.status, IdentityStatus::Revoked);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_identity/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_incentives/Cargo.toml =====
[package]
name = "icn_incentives"
version = "0.1.0"
edition = "2021"

[dependencies]
===== END OF /home/matt/InterCooperative-Network/crates/icn_incentives/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_incentives/src/lib.rs =====
pub fn add(left: usize, right: usize) -> usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_incentives/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_language/Cargo.toml =====
# File: /home/matt/InterCooperative-Network/crates/icn_language/Cargo.toml

[package]
name = "icn_language"
version = "0.1.0"
edition = "2021"

[dependencies]
nom = "7.1.0"
serde = { workspace = true }
thiserror = { workspace = true }
log = { workspace = true }

[dev-dependencies]
env_logger = { workspace = true }===== END OF /home/matt/InterCooperative-Network/crates/icn_language/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_language/src/lib.rs =====
// File: crates/icn_language/src/lib.rs

use nom::{
    IResult,
    branch::alt,
    bytes::complete::{tag, take_while1},
    character::complete::{alpha1, alphanumeric1, char, multispace0},
    combinator::{map, recognize},
    multi::many0,
    sequence::{delimited, pair, preceded, terminated},
};

#[derive(Debug, PartialEq)]
pub enum Statement {
    CoopCreate { name: String, coop_type: String },
    GovPolicyCreate { name: String, details: String },
    CommEventSchedule { name: String, date: String },
    // Add more statement types as needed
}

fn parse_identifier(input: &str) -> IResult<&str, &str> {
    recognize(pair(
        alt((alpha1, tag("_"))),
        many0(alt((alphanumeric1, tag("_"))))
    ))(input)
}

fn parse_string(input: &str) -> IResult<&str, &str> {
    delimited(
        char('"'),
        take_while1(|c| c != '"'),
        char('"')
    )(input)
}

fn parse_coop_create(input: &str) -> IResult<&str, Statement> {
    let (input, _) = tag("coop-create")(input)?;
    let (input, _) = multispace0(input)?;
    let (input, _) = char('(')(input)?;
    let (input, name) = preceded(tag("name:"), parse_string)(input)?;
    let (input, _) = char(',')(input)?;
    let (input, coop_type) = preceded(tag("type:"), parse_string)(input)?;
    let (input, _) = char(')')(input)?;
    
    Ok((input, Statement::CoopCreate { 
        name: name.to_string(), 
        coop_type: coop_type.to_string() 
    }))
}

// Implement other parsing functions for different statement types

pub fn parse_statement(input: &str) -> IResult<&str, Statement> {
    alt((
        parse_coop_create,
        // Add other statement parsers here
    ))(input)
}

pub fn compile(source: &str) -> Result<Vec<Statement>, String> {
    let mut statements = Vec::new();
    let mut remaining = source;

    while !remaining.is_empty() {
        match parse_statement(remaining) {
            Ok((rest, statement)) => {
                statements.push(statement);
                remaining = rest.trim();
            }
            Err(_) => return Err("Failed to parse statement".to_string()),
        }
    }

    Ok(statements)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_coop_create() {
        let input = r#"coop-create(name: "Green Community Cooperative", type: "Sustainability")"#;
        let result = parse_coop_create(input);
        assert!(result.is_ok());
        let (_, statement) = result.unwrap();
        assert_eq!(statement, Statement::CoopCreate {
            name: "Green Community Cooperative".to_string(),
            coop_type: "Sustainability".to_string(),
        });
    }

    // Add more tests for other statement types and the compile function
}===== END OF /home/matt/InterCooperative-Network/crates/icn_language/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_market/Cargo.toml =====
[package]
name = "icn_market"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
chrono = "0.4"
ed25519-dalek = "1.0"
rand = "0.8"
bitvec = { path = "../../vendor/bitvec" }
funty = { path = "../../vendor/funty" }
===== END OF /home/matt/InterCooperative-Network/crates/icn_market/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_market/src/entities.rs =====
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Cooperative {
    pub id: String,
    pub name: String,
    pub resources: HashMap<String, f64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Member {
    pub id: String,
    pub name: String,
    pub skills: HashMap<String, f64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Community {
    pub id: String,
    pub name: String,
    pub members: HashMap<String, Member>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Resource {
    pub name: String,
    pub quantity: f64,
    pub unit: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Labor {
    pub skill: String,
    pub hours: f64,
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_market/src/entities.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_market/src/lib.rs =====
pub mod entities;
pub mod market;
pub mod transaction;

pub use entities::*;
pub use market::*;
pub use transaction::*;
===== END OF /home/matt/InterCooperative-Network/crates/icn_market/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_market/src/market.rs =====
use crate::entities::{Cooperative, Community, Member, Resource, Labor};
use crate::transaction::{Transaction, TransactionType, TransactionResult};
use std::collections::HashMap;

#[derive(Debug, Clone)]
pub struct Market {
    pub cooperatives: HashMap<String, Cooperative>,
    pub communities: HashMap<String, Community>,
    pub members: HashMap<String, Member>,
    pub transactions: Vec<Transaction>,
}

impl Market {
    pub fn new() -> Self {
        Market {
            cooperatives: HashMap::new(),
            communities: HashMap::new(),
            members: HashMap::new(),
            transactions: Vec::new(),
        }
    }

    pub fn add_cooperative(&mut self, cooperative: Cooperative) {
        self.cooperatives.insert(cooperative.id.clone(), cooperative);
    }

    pub fn add_community(&mut self, community: Community) {
        self.communities.insert(community.id.clone(), community);
    }

    pub fn add_member(&mut self, member: Member) {
        self.members.insert(member.id.clone(), member);
    }

    pub fn trade_resource(&mut self, from_id: &str, to_id: &str, resource: Resource) -> TransactionResult {
        let transaction = Transaction::new(
            TransactionType::ResourceTrade,
            from_id.to_string(),
            to_id.to_string(),
            Some(resource.clone()),
            None,
        );

        if let Some(from_coop) = self.cooperatives.get_mut(from_id) {
            if let Some(to_coop) = self.cooperatives.get_mut(to_id) {
                from_coop.resources.entry(resource.name.clone()).and_modify(|e| *e -= resource.quantity);
                to_coop.resources.entry(resource.name.clone()).and_modify(|e| *e += resource.quantity).or_insert(resource.quantity);
                self.transactions.push(transaction);
                return Ok(());
            }
        }

        if let Some(from_comm) = self.communities.get_mut(from_id) {
            if let Some(to_comm) = self.communities.get_mut(to_id) {
                from_comm.members.get_mut(&resource.name).unwrap().skills.entry(resource.name.clone()).and_modify(|e| *e -= resource.quantity);
                to_comm.members.get_mut(&resource.name).unwrap().skills.entry(resource.name.clone()).and_modify(|e| *e += resource.quantity).or_insert(resource.quantity);
                self.transactions.push(transaction);
                return Ok(());
            }
        }

        if let Some(from_mem) = self.members.get_mut(from_id) {
            if let Some(to_mem) = self.members.get_mut(to_id) {
                from_mem.skills.entry(resource.name.clone()).and_modify(|e| *e -= resource.quantity);
                to_mem.skills.entry(resource.name.clone()).and_modify(|e| *e += resource.quantity).or_insert(resource.quantity);
                self.transactions.push(transaction);
                return Ok(());
            }
        }

        Err("Invalid trade".into())
    }

    pub fn exchange_labor(&mut self, from_id: &str, to_id: &str, labor: Labor) -> TransactionResult {
        let transaction = Transaction::new(
            TransactionType::LaborExchange,
            from_id.to_string(),
            to_id.to_string(),
            None,
            Some(labor.clone()),
        );

        if let Some(from_mem) = self.members.get_mut(from_id) {
            if let Some(to_mem) = self.members.get_mut(to_id) {
                from_mem.skills.entry(labor.skill.clone()).and_modify(|e| *e -= labor.hours);
                to_mem.skills.entry(labor.skill.clone()).and_modify(|e| *e += labor.hours).or_insert(labor.hours);
                self.transactions.push(transaction);
                return Ok(());
            }
        }

        Err("Invalid exchange".into())
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_market/src/market.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_market/src/market_tests.rs =====
use icn_market::{Market, Cooperative, Community, Member, Resource, Labor};
use std::collections::HashMap;

#[test]
fn test_trade_resource_between_cooperatives() {
    let mut market = Market::new();
    
    let mut coop1 = Cooperative {
        id: "coop1".to_string(),
        name: "Cooperative 1".to_string(),
        resources: HashMap::new(),
    };
    coop1.resources.insert("Wheat".to_string(), 100.0);
    
    let coop2 = Cooperative {
        id: "coop2".to_string(),
        name: "Cooperative 2".to_string(),
        resources: HashMap::new(),
    };
    
    market.add_cooperative(coop1);
    market.add_cooperative(coop2);
    
    let resource = Resource {
        name: "Wheat".to_string(),
        quantity: 50.0,
        unit: "kg".to_string(),
    };
    
    assert!(market.trade_resource("coop1", "coop2", resource).is_ok());
}

#[test]
fn test_exchange_labor_between_members() {
    let mut market = Market::new();
    
    let mut member1 = Member {
        id: "member1".to_string(),
        name: "Member 1".to_string(),
        skills: HashMap::new(),
    };
    member1.skills.insert("Carpentry".to_string(), 20.0);
    
    let member2 = Member {
        id: "member2".to_string(),
        name: "Member 2".to_string(),
        skills: HashMap::new(),
    };
    
    market.add_member(member1);
    market.add_member(member2);
    
    let labor = Labor {
        skill: "Carpentry".to_string(),
        hours: 10.0,
    };
    
    assert!(market.exchange_labor("member1", "member2", labor).is_ok());
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_market/src/market_tests.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_market/src/transaction.rs =====
use crate::entities::{Resource, Labor};
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TransactionType {
    ResourceTrade,
    LaborExchange,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Transaction {
    pub transaction_type: TransactionType,
    pub from_id: String,
    pub to_id: String,
    pub resource: Option<Resource>,
    pub labor: Option<Labor>,
}

impl Transaction {
    pub fn new(
        transaction_type: TransactionType,
        from_id: String,
        to_id: String,
        resource: Option<Resource>,
        labor: Option<Labor>,
    ) -> Self {
        Transaction {
            transaction_type,
            from_id,
            to_id,
            resource,
            labor,
        }
    }
}

pub type TransactionResult = Result<(), String>;
===== END OF /home/matt/InterCooperative-Network/crates/icn_market/src/transaction.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/Cargo.toml =====
[package]
name = "icn_network"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
log = "0.4"
thiserror = "1.0"

[dev-dependencies]
tokio = { version = "1.0", features = ["full"] }===== END OF /home/matt/InterCooperative-Network/crates/icn_network/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/src/discovery.rs =====
use icn_common::{IcnError, IcnResult};
use std::sync::{Arc, RwLock};
use log::{info, error};

/// Represents a node discovery mechanism in the network.
pub struct NodeDiscovery {
    discovered_nodes: Arc<RwLock<Vec<String>>>,
}

impl NodeDiscovery {
    /// Creates a new instance of NodeDiscovery.
    pub fn new() -> Self {
        NodeDiscovery {
            discovered_nodes: Arc::new(RwLock::new(Vec::new())),
        }
    }

    /// Starts the node discovery process.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn start(&self) -> IcnResult<()> {
        info!("Node discovery started");
        // Simulated discovery process
        let nodes = vec!["Node1".to_string(), "Node2".to_string()];
        let mut discovered_nodes = self.discovered_nodes.write().unwrap();
        *discovered_nodes = nodes;
        Ok(())
    }

    /// Stops the node discovery process.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn stop(&self) -> IcnResult<()> {
        info!("Node discovery stopped");
        let mut discovered_nodes = self.discovered_nodes.write().unwrap();
        discovered_nodes.clear();
        Ok(())
    }

    /// Retrieves the list of discovered nodes.
    ///
    /// # Returns
    ///
    /// * `Vec<String>` - A vector containing the discovered nodes.
    pub fn get_discovered_nodes(&self) -> Vec<String> {
        let discovered_nodes = self.discovered_nodes.read().unwrap();
        discovered_nodes.clone()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_node_discovery() {
        let discovery = NodeDiscovery::new();
        assert!(discovery.start().is_ok());
        assert_eq!(discovery.get_discovered_nodes().len(), 2);
        assert!(discovery.stop().is_ok());
        assert!(discovery.get_discovered_nodes().is_empty());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_network/src/discovery.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/src/lib.rs =====
use icn_common::{IcnResult, IcnError};
use serde::{Serialize, Deserialize};
use std::collections::{HashMap, HashSet};
use std::net::SocketAddr;
use tokio::sync::mpsc;
use log::{info, warn, error};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PacketType {
    Ping,
    Pong,
    PeerDiscovery,
    Transaction,
    Block,
    Consensus,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Packet {
    pub packet_type: PacketType,
    pub source: SocketAddr,
    pub destination: SocketAddr,
    pub content: Vec<u8>,
}

#[derive(Debug)]
pub struct Peer {
    pub address: SocketAddr,
    pub last_seen: std::time::Instant,
}

pub struct Network {
    local_addr: SocketAddr,
    peers: HashMap<SocketAddr, Peer>,
    pending_connections: HashSet<SocketAddr>,
    packet_sender: mpsc::Sender<Packet>,
    packet_receiver: mpsc::Receiver<Packet>,
}

impl Network {
    pub fn new(local_addr: SocketAddr) -> Self {
        let (packet_sender, packet_receiver) = mpsc::channel(100);
        Network {
            local_addr,
            peers: HashMap::new(),
            pending_connections: HashSet::new(),
            packet_sender,
            packet_receiver,
        }
    }

    pub async fn start(&mut self) -> IcnResult<()> {
        info!("Starting network on {}", self.local_addr);
        // TODO: Implement actual network initialization
        Ok(())
    }

    pub async fn stop(&mut self) -> IcnResult<()> {
        info!("Stopping network");
        // TODO: Implement network shutdown
        Ok(())
    }

    pub async fn connect_to_peer(&mut self, peer_addr: SocketAddr) -> IcnResult<()> {
        if self.peers.contains_key(&peer_addr) || self.pending_connections.contains(&peer_addr) {
            return Ok(());
        }

        self.pending_connections.insert(peer_addr);
        // TODO: Implement actual peer connection logic
        info!("Connecting to peer: {}", peer_addr);
        
        // Simulating successful connection
        self.add_peer(peer_addr)?;
        self.pending_connections.remove(&peer_addr);
        Ok(())
    }

    pub fn add_peer(&mut self, peer_addr: SocketAddr) -> IcnResult<()> {
        if self.peers.contains_key(&peer_addr) {
            return Err(IcnError::Network("Peer already connected".into()));
        }

        let peer = Peer {
            address: peer_addr,
            last_seen: std::time::Instant::now(),
        };
        self.peers.insert(peer_addr, peer);
        info!("Added new peer: {}", peer_addr);
        Ok(())
    }

    pub fn remove_peer(&mut self, peer_addr: &SocketAddr) -> IcnResult<()> {
        if self.peers.remove(peer_addr).is_none() {
            return Err(IcnError::Network("Peer not found".into()));
        }
        info!("Removed peer: {}", peer_addr);
        Ok(())
    }

    pub async fn send_packet(&self, packet: Packet) -> IcnResult<()> {
        self.packet_sender.send(packet).await.map_err(|e| IcnError::Network(format!("Failed to send packet: {}", e)))
    }

    pub async fn receive_packet(&mut self) -> IcnResult<Packet> {
        self.packet_receiver.recv().await.ok_or(IcnError::Network("Failed to receive packet".into()))
    }

    pub async fn broadcast(&self, packet_type: PacketType, content: Vec<u8>) -> IcnResult<()> {
        for peer_addr in self.peers.keys() {
            let packet = Packet {
                packet_type: packet_type.clone(),
                source: self.local_addr,
                destination: *peer_addr,
                content: content.clone(),
            };
            self.send_packet(packet).await?;
        }
        Ok(())
    }

    pub fn get_peers(&self) -> Vec<SocketAddr> {
        self.peers.keys().cloned().collect()
    }

    pub async fn handle_incoming_packets(&mut self) -> IcnResult<()> {
        while let Ok(packet) = self.receive_packet().await {
            match packet.packet_type {
                PacketType::Ping => self.handle_ping(packet).await?,
                PacketType::Pong => self.handle_pong(packet).await?,
                PacketType::PeerDiscovery => self.handle_peer_discovery(packet).await?,
                PacketType::Transaction => self.handle_transaction(packet).await?,
                PacketType::Block => self.handle_block(packet).await?,
                PacketType::Consensus => self.handle_consensus(packet).await?,
            }
        }
        Ok(())
    }

    async fn handle_ping(&self, packet: Packet) -> IcnResult<()> {
        let pong = Packet {
            packet_type: PacketType::Pong,
            source: self.local_addr,
            destination: packet.source,
            content: vec![],
        };
        self.send_packet(pong).await
    }

    async fn handle_pong(&mut self, packet: Packet) -> IcnResult<()> {
        if let Some(peer) = self.peers.get_mut(&packet.source) {
            peer.last_seen = std::time::Instant::now();
        }
        Ok(())
    }

    async fn handle_peer_discovery(&mut self, packet: Packet) -> IcnResult<()> {
        let peer_addresses: Vec<SocketAddr> = bincode::deserialize(&packet.content)
            .map_err(|e| IcnError::Network(format!("Failed to deserialize peer addresses: {}", e)))?;

        for addr in peer_addresses {
            if addr != self.local_addr && !self.peers.contains_key(&addr) {
                self.connect_to_peer(addr).await?;
            }
        }

        // Share our known peers with the sender
        let our_peers: Vec<SocketAddr> = self.peers.keys().cloned().collect();
        let response = Packet {
            packet_type: PacketType::PeerDiscovery,
            source: self.local_addr,
            destination: packet.source,
            content: bincode::serialize(&our_peers)
                .map_err(|e| IcnError::Network(format!("Failed to serialize peer addresses: {}", e)))?,
        };
        self.send_packet(response).await
    }

    async fn handle_transaction(&self, packet: Packet) -> IcnResult<()> {
        // TODO: Implement transaction handling logic
        // For now, we'll just log the received transaction
        info!("Received transaction from {}", packet.source);
        Ok(())
    }

    async fn handle_block(&self, packet: Packet) -> IcnResult<()> {
        // TODO: Implement block handling logic
        // For now, we'll just log the received block
        info!("Received block from {}", packet.source);
        Ok(())
    }

    async fn handle_consensus(&self, packet: Packet) -> IcnResult<()> {
        // TODO: Implement consensus message handling logic
        // For now, we'll just log the received consensus message
        info!("Received consensus message from {}", packet.source);
        Ok(())
    }

    pub async fn maintain_network(&mut self) -> IcnResult<()> {
        let mut interval = tokio::time::interval(std::time::Duration::from_secs(60));
        loop {
            interval.tick().await;
            self.remove_inactive_peers().await?;
            self.discover_new_peers().await?;
        }
    }

    async fn remove_inactive_peers(&mut self) -> IcnResult<()> {
        let now = std::time::Instant::now();
        let inactive_peers: Vec<SocketAddr> = self.peers
            .iter()
            .filter(|(_, peer)| now.duration_since(peer.last_seen) > std::time::Duration::from_secs(300))
            .map(|(addr, _)| *addr)
            .collect();

        for addr in inactive_peers {
            self.remove_peer(&addr)?;
        }
        Ok(())
    }

    async fn discover_new_peers(&mut self) -> IcnResult<()> {
        let peer_discovery_packet = Packet {
            packet_type: PacketType::PeerDiscovery,
            source: self.local_addr,
            destination: self.local_addr, // This will be replaced for each peer
            content: bincode::serialize(&self.get_peers())
                .map_err(|e| IcnError::Network(format!("Failed to serialize peer addresses: {}", e)))?,
        };

        for peer_addr in self.get_peers() {
            let mut packet = peer_discovery_packet.clone();
            packet.destination = peer_addr;
            self.send_packet(packet).await?;
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tokio::runtime::Runtime;

    #[test]
    fn test_network_operations() {
        let rt = Runtime::new().unwrap();
        rt.block_on(async {
            let mut network = Network::new("127.0.0.1:8000".parse().unwrap());
            
            // Test starting the network
            assert!(network.start().await.is_ok());

            // Test adding a peer
            let peer_addr: SocketAddr = "127.0.0.1:8001".parse().unwrap();
            assert!(network.connect_to_peer(peer_addr).await.is_ok());
            assert_eq!(network.get_peers().len(), 1);

            // Test removing a peer
            assert!(network.remove_peer(&peer_addr).is_ok());
            assert_eq!(network.get_peers().len(), 0);

            // Test sending a packet
            let packet = Packet {
                packet_type: PacketType::Ping,
                source: network.local_addr,
                destination: peer_addr,
                content: vec![],
            };
            assert!(network.send_packet(packet).await.is_ok());

            // Test stopping the network
            assert!(network.stop().await.is_ok());
        });
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_network/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/src/naming.rs =====
use icn_common::{IcnError, IcnResult};
use log::{info, error};

/// Represents a naming service in the ICN project.
pub struct NamingService;

impl NamingService {
    /// Creates a new instance of NamingService.
    pub fn new() -> Self {
        NamingService
    }

    /// Starts the naming service.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn start(&self) -> IcnResult<()> {
        info!("Naming service started");
        // Simulated naming service start process
        Ok(())
    }

    /// Stops the naming service.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn stop(&self) -> IcnResult<()> {
        info!("Naming service stopped");
        // Simulated naming service stop process
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_naming_service_start_and_stop() {
        let naming_service = NamingService::new();
        assert!(naming_service.start().is_ok());
        assert!(naming_service.stop().is_ok());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_network/src/naming.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/src/network.rs =====
use crate::{discovery::NodeDiscovery, protocol::NetworkProtocol, routing::Router, security::NetworkSecurity};
use icn_common::{IcnError, IcnResult};
use std::sync::{Arc, RwLock};

/// Represents a network in the ICN project.
pub struct Network {
    discovery: Arc<RwLock<NodeDiscovery>>,
    protocol: Arc<RwLock<NetworkProtocol>>,
    router: Arc<RwLock<Router>>,
    security: Arc<RwLock<NetworkSecurity>>,
}

impl Network {
    /// Creates a new network instance.
    ///
    /// # Arguments
    ///
    /// * `discovery` - Arc to the node discovery module.
    /// * `protocol` - Arc to the network protocol module.
    /// * `router` - Arc to the routing module.
    /// * `security` - Arc to the network security module.
    ///
    /// # Returns
    ///
    /// * `Network` - A new instance of Network.
    pub fn new(
        discovery: Arc<RwLock<NodeDiscovery>>,
        protocol: Arc<RwLock<NetworkProtocol>>,
        router: Arc<RwLock<Router>>,
        security: Arc<RwLock<NetworkSecurity>>,
    ) -> Self {
        Network {
            discovery,
            protocol,
            router,
            security,
        }
    }

    /// Starts the network.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn start(&self) -> IcnResult<()> {
        let discovery = self.discovery.read().unwrap();
        discovery.start()?;

        let protocol = self.protocol.read().unwrap();
        protocol.start()?;

        let router = self.router.read().unwrap();
        router.start()?;

        let security = self.security.read().unwrap();
        security.start()?;

        Ok(())
    }

    /// Stops the network.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn stop(&self) -> IcnResult<()> {
        let discovery = self.discovery.read().unwrap();
        discovery.stop()?;

        let protocol = self.protocol.read().unwrap();
        protocol.stop()?;

        let router = self.router.read().unwrap();
        router.stop()?;

        let security = self.security.read().unwrap();
        security.stop()?;

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::discovery::MockNodeDiscovery;
    use crate::protocol::MockNetworkProtocol;
    use crate::routing::MockRouter;
    use crate::security::MockNetworkSecurity;
    use std::sync::Arc;

    #[test]
    fn test_network_start_and_stop() {
        let discovery = Arc::new(RwLock::new(MockNodeDiscovery::new()));
        let protocol = Arc::new(RwLock::new(MockNetworkProtocol::new()));
        let router = Arc::new(RwLock::new(MockRouter::new()));
        let security = Arc::new(RwLock::new(MockNetworkSecurity::new()));

        let network = Network::new(discovery, protocol, router, security);

        assert!(network.start().is_ok());
        assert!(network.stop().is_ok());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_network/src/network.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/src/node.rs =====
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub enum NodeType {
    PersonalDevice,
    CooperativeServer,
    GovernmentServer,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Node {
    pub id: String,
    pub node_type: NodeType,
    pub address: String,
}

impl Node {
    pub fn new(id: &str, node_type: NodeType, address: &str) -> Self {
        Node {
            id: id.to_string(),
            node_type,
            address: address.to_string(),
        }
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_network/src/node.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/src/packet.rs =====
use icn_common::{IcnError, IcnResult};
use serde::{Serialize, Deserialize};

/// Represents a network packet in the ICN project.
#[derive(Serialize, Deserialize, Debug)]
pub struct Packet {
    pub source: String,
    pub destination: String,
    pub payload: Vec<u8>,
}

impl Packet {
    /// Creates a new packet.
    ///
    /// # Arguments
    ///
    /// * `source` - The source address.
    /// * `destination` - The destination address.
    /// * `payload` - The packet payload.
    ///
    /// # Returns
    ///
    /// * `Packet` - A new instance of Packet.
    pub fn new(source: String, destination: String, payload: Vec<u8>) -> Self {
        Packet {
            source,
            destination,
            payload,
        }
    }

    /// Validates the packet.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the packet is invalid.
    pub fn validate(&self) -> IcnResult<()> {
        if self.source.is_empty() || self.destination.is_empty() {
            return Err(IcnError::Network("Invalid packet: source or destination is empty".into()));
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_packet_creation_and_validation() {
        let packet = Packet::new("Source".to_string(), "Destination".to_string(), vec![1, 2, 3]);
        assert!(packet.validate().is_ok());

        let invalid_packet = Packet::new("".to_string(), "Destination".to_string(), vec![1, 2, 3]);
        assert!(invalid_packet.validate().is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_network/src/packet.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/src/protocol.rs =====
use icn_common::{IcnError, IcnResult};
use log::{info, error};

/// Represents a network protocol in the ICN project.
pub struct NetworkProtocol;

impl NetworkProtocol {
    /// Creates a new instance of NetworkProtocol.
    pub fn new() -> Self {
        NetworkProtocol
    }

    /// Starts the network protocol.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn start(&self) -> IcnResult<()> {
        info!("Network protocol started");
        // Simulated protocol start process
        Ok(())
    }

    /// Stops the network protocol.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn stop(&self) -> IcnResult<()> {
        info!("Network protocol stopped");
        // Simulated protocol stop process
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_protocol_start_and_stop() {
        let protocol = NetworkProtocol::new();
        assert!(protocol.start().is_ok());
        assert!(protocol.stop().is_ok());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_network/src/protocol.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/src/routing.rs =====
use icn_common::{IcnError, IcnResult};
use log::{info, error};

/// Represents a router in the ICN project.
pub struct Router;

impl Router {
    /// Creates a new instance of Router.
    pub fn new() -> Self {
        Router
    }

    /// Starts the router.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn start(&self) -> IcnResult<()> {
        info!("Router started");
        // Simulated router start process
        Ok(())
    }

    /// Stops the router.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn stop(&self) -> IcnResult<()> {
        info!("Router stopped");
        // Simulated router stop process
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_router_start_and_stop() {
        let router = Router::new();
        assert!(router.start().is_ok());
        assert!(router.stop().is_ok());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_network/src/routing.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_network/src/security.rs =====
use icn_common::{IcnError, IcnResult};
use log::{info, error};

/// Represents network security in the ICN project.
pub struct NetworkSecurity;

impl NetworkSecurity {
    /// Creates a new instance of NetworkSecurity.
    pub fn new() -> Self {
        NetworkSecurity
    }

    /// Starts the network security module.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn start(&self) -> IcnResult<()> {
        info!("Network security started");
        // Simulated security start process
        Ok(())
    }

    /// Stops the network security module.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn stop(&self) -> IcnResult<()> {
        info!("Network security stopped");
        // Simulated security stop process
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_security_start_and_stop() {
        let security = NetworkSecurity::new();
        assert!(security.start().is_ok());
        assert!(security.stop().is_ok());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_network/src/security.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_node_management/Cargo.toml =====
[package]
name = "icn_node_management"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_core = { path = "../icn_core" }
icn_network = { path = "../icn_network" }
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
log = "0.4"
thiserror = "1.0"

[dev-dependencies]
tokio = { version = "1.0", features = ["full"] }
===== END OF /home/matt/InterCooperative-Network/crates/icn_node_management/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/content_store.rs =====
use icn_common::{IcnError, IcnResult};
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use log::{info, error};

/// Represents a content store in the ICN project.
pub struct ContentStore {
    store: Arc<RwLock<HashMap<String, Vec<u8>>>>,
}

impl ContentStore {
    /// Creates a new instance of ContentStore.
    pub fn new() -> Self {
        ContentStore {
            store: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// Stores content in the content store.
    ///
    /// # Arguments
    ///
    /// * `content_id` - The ID of the content.
    /// * `data` - The content data.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn store(&self, content_id: String, data: Vec<u8>) -> IcnResult<()> {
        let mut store = self.store.write().unwrap();
        store.insert(content_id.clone(), data);
        info!("Content stored with ID: {}", content_id);
        Ok(())
    }

    /// Retrieves content from the content store.
    ///
    /// # Arguments
    ///
    /// * `content_id` - The ID of the content to be retrieved.
    ///
    /// # Returns
    ///
    /// * `IcnResult<Vec<u8>>` - The retrieved content data.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn retrieve(&self, content_id: &str) -> IcnResult<Vec<u8>> {
        let store = self.store.read().unwrap();
        store.get(content_id).cloned().ok_or_else(|| IcnError::Storage("Content not found".into()))
    }

    /// Removes content from the content store.
    ///
    /// # Arguments
    ///
    /// * `content_id` - The ID of the content to be removed.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn remove(&self, content_id: &str) -> IcnResult<()> {
        let mut store = self.store.write().unwrap();
        store.remove(content_id);
        info!("Content removed with ID: {}", content_id);
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_store_and_retrieve_content() {
        let content_store = ContentStore::new();
        let content_id = "content_1".to_string();
        let data = vec![1, 2, 3];
        assert!(content_store.store(content_id.clone(), data.clone()).is_ok());
        let retrieved_data = content_store.retrieve(&content_id).unwrap();
        assert_eq!(retrieved_data, data);
    }

    #[test]
    fn test_retrieve_non_existent_content() {
        let content_store = ContentStore::new();
        assert!(content_store.retrieve("non_existent_content").is_err());
    }

    #[test]
    fn test_remove_content() {
        let content_store = ContentStore::new();
        let content_id = "content_1".to_string();
        let data = vec![1, 2, 3];
        content_store.store(content_id.clone(), data).unwrap();
        assert!(content_store.remove(&content_id).is_ok());
        assert!(content_store.retrieve(&content_id).is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/content_store.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/fib.rs =====
use icn_common::{IcnError, IcnResult};
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use log::{info, error};

/// Represents a Forwarding Information Base (FIB) in the ICN project.
pub struct FIB {
    table: Arc<RwLock<HashMap<String, String>>>,
}

impl FIB {
    /// Creates a new instance of FIB.
    pub fn new() -> Self {
        FIB {
            table: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// Adds an entry to the FIB.
    ///
    /// # Arguments
    ///
    /// * `prefix` - The prefix of the entry.
    /// * `next_hop` - The next hop for the entry.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn add_entry(&self, prefix: String, next_hop: String) -> IcnResult<()> {
        let mut table = self.table.write().unwrap();
        table.insert(prefix.clone(), next_hop);
        info!("FIB entry added: {} -> {}", prefix, next_hop);
        Ok(())
    }

    /// Retrieves the next hop for a given prefix.
    ///
    /// # Arguments
    ///
    /// * `prefix` - The prefix to retrieve the next hop for.
    ///
    /// # Returns
    ///
    /// * `IcnResult<String>` - The next hop.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn get_next_hop(&self, prefix: &str) -> IcnResult<String> {
        let table = self.table.read().unwrap();
        table.get(prefix).cloned().ok_or_else(|| IcnError::Network("Next hop not found".into()))
    }

    /// Removes an entry from the FIB.
    ///
    /// # Arguments
    ///
    /// * `prefix` - The prefix of the entry to be removed.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn remove_entry(&self, prefix: &str) -> IcnResult<()> {
        let mut table = self.table.write().unwrap();
        table.remove(prefix);
        info!("FIB entry removed: {}", prefix);
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add_and_get_next_hop() {
        let fib = FIB::new();
        let prefix = "prefix_1".to_string();
        let next_hop = "next_hop_1".to_string();
        assert!(fib.add_entry(prefix.clone(), next_hop.clone()).is_ok());
        let retrieved_next_hop = fib.get_next_hop(&prefix).unwrap();
        assert_eq!(retrieved_next_hop, next_hop);
    }

    #[test]
    fn test_get_non_existent_next_hop() {
        let fib = FIB::new();
        assert!(fib.get_next_hop("non_existent_prefix").is_err());
    }

    #[test]
    fn test_remove_entry() {
        let fib = FIB::new();
        let prefix = "prefix_1".to_string();
        let next_hop = "next_hop_1".to_string();
        fib.add_entry(prefix.clone(), next_hop).unwrap();
        assert!(fib.remove_entry(&prefix).is_ok());
        assert!(fib.get_next_hop(&prefix).is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/fib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/icn_node.rs =====
use crate::{content_store::ContentStore, fib::FIB, pit::PIT};
use icn_common::{IcnError, IcnResult};
use log::{info, error};
use std::sync::{Arc, RwLock};

/// Represents an ICN node.
pub struct IcnNode {
    content_store: Arc<ContentStore>,
    fib: Arc<FIB>,
    pit: Arc<PIT>,
}

impl IcnNode {
    /// Creates a new instance of IcnNode.
    ///
    /// # Arguments
    ///
    /// * `content_store` - Arc to the content store.
    /// * `fib` - Arc to the FIB.
    /// * `pit` - Arc to the PIT.
    ///
    /// # Returns
    ///
    /// * `IcnNode` - A new instance of IcnNode.
    pub fn new(content_store: Arc<ContentStore>, fib: Arc<FIB>, pit: Arc<PIT>) -> Self {
        IcnNode {
            content_store,
            fib,
            pit,
        }
    }

    /// Processes an interest packet.
    ///
    /// # Arguments
    ///
    /// * `interest` - The interest packet to be processed.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn process_interest(&self, interest: &str) -> IcnResult<()> {
        // Check content store for the data
        if let Ok(data) = self.content_store.retrieve(interest) {
            // Data found, send data packet
            info!("Data found for interest: {}", interest);
            self.send_data_packet(interest, data)?;
        } else {
            // Data not found, forward interest packet
            info!("Data not found for interest: {}, forwarding", interest);
            let next_hop = self.fib.get_next_hop(interest)?;
            self.forward_interest_packet(interest, &next_hop)?;
        }
        Ok(())
    }

    /// Sends a data packet.
    ///
    /// # Arguments
    ///
    /// * `interest` - The interest associated with the data.
    /// * `data` - The data to be sent.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    fn send_data_packet(&self, interest: &str, data: Vec<u8>) -> IcnResult<()> {
        info!("Sending data packet for interest: {}", interest);
        // Simulate sending data packet
        Ok(())
    }

    /// Forwards an interest packet.
    ///
    /// # Arguments
    ///
    /// * `interest` - The interest packet to be forwarded.
    /// * `next_hop` - The next hop to forward the interest packet to.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    fn forward_interest_packet(&self, interest: &str, next_hop: &str) -> IcnResult<()> {
        info!("Forwarding interest packet: {} to next hop: {}", interest, next_hop);
        // Simulate forwarding interest packet
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::content_store::MockContentStore;
    use crate::fib::MockFIB;
    use crate::pit::MockPIT;

    #[test]
    fn test_process_interest() {
        let content_store = Arc::new(MockContentStore::new());
        let fib = Arc::new(MockFIB::new());
        let pit = Arc::new(MockPIT::new());

        let node = IcnNode::new(content_store, fib, pit);

        assert!(node.process_interest("interest_1").is_ok());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/icn_node.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/lib.rs =====
/// The ICN node management module.
pub mod content_store;
pub mod fib;
pub mod icn_node;
pub mod node;
pub mod pit;
===== END OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/node.rs =====
// ===============================================
// Content Store, FIB, and PIT Implementation
// ===============================================
// This file defines the structures and methods for the Content Store, Forwarding Information Base (FIB),
// and Pending Interest Table (PIT) used in the ICN Node.
//
// Key concepts:
// - Content Store: A cache for storing data packets temporarily.
// - Forwarding Information Base (FIB): A table that stores routing information for named data.
// - Pending Interest Table (PIT): A table that keeps track of interests that have been forwarded but not yet satisfied.

use std::collections::HashMap;

/// A struct representing a packet in the ICN Node.
#[derive(Clone)]
pub struct Packet {
    pub packet_type: PacketType,
    pub name: String,
    pub content: Vec<u8>,
}

/// Enum representing the type of a packet, either Interest or Data.
#[derive(Clone)]
pub enum PacketType {
    Interest,
    Data,
}

/// A struct representing the Content Store.
pub struct ContentStore {
    store: HashMap<String, Vec<u8>>,
}

impl ContentStore {
    /// Creates a new Content Store.
    pub fn new() -> Self {
        ContentStore {
            store: HashMap::new(),
        }
    }

    /// Inserts data into the Content Store.
    /// # Arguments
    /// * `name` - The name of the data.
    /// * `content` - The content of the data.
    pub fn insert(&mut self, name: String, content: Vec<u8>) {
        self.store.insert(name, content);
    }

    /// Retrieves data from the Content Store.
    /// # Arguments
    /// * `name` - The name of the data.
    /// # Returns
    /// An optional reference to the content if it exists.
    pub fn get(&self, name: &str) -> Option<&Vec<u8>> {
        self.store.get(name)
    }

    /// Checks if the Content Store is empty.
    /// # Returns
    /// True if the Content Store is empty, otherwise false.
    pub fn is_empty(&self) -> bool {
        self.store.is_empty()
    }
}

/// A struct representing the Forwarding Information Base (FIB).
pub struct ForwardingInformationBase {
    table: HashMap<String, Vec<String>>,
}

impl ForwardingInformationBase {
    /// Creates a new FIB.
    pub fn new() -> Self {
        ForwardingInformationBase {
            table: HashMap::new(),
        }
    }

    /// Adds an entry to the FIB.
    /// # Arguments
    /// * `name` - The name of the data.
    /// * `interface` - The interface to forward the data.
    pub fn add_entry(&mut self, name: String, interface: String) {
        self.table.entry(name).or_insert(Vec::new()).push(interface);
    }

    /// Retrieves the interfaces for a given name from the FIB.
    /// # Arguments
    /// * `name` - The name of the data.
    /// # Returns
    /// An optional reference to a vector of interfaces if they exist.
    pub fn get_interfaces(&self, name: &str) -> Option<&Vec<String>> {
        self.table.get(name)
    }

    /// Checks if the FIB is empty.
    /// # Returns
    /// True if the FIB is empty, otherwise false.
    pub fn is_empty(&self) -> bool {
        self.table.is_empty()
    }
}

/// A struct representing the Pending Interest Table (PIT).
pub struct PendingInterestTable {
    table: HashMap<String, Vec<String>>,
}

impl PendingInterestTable {
    /// Creates a new PIT.
    pub fn new() -> Self {
        PendingInterestTable {
            table: HashMap::new(),
        }
    }

    /// Adds an interest to the PIT.
    /// # Arguments
    /// * `name` - The name of the interest.
    /// * `interface` - The interface from which the interest came.
    pub fn add_interest(&mut self, name: String, interface: String) {
        self.table.entry(name).or_insert(Vec::new()).push(interface);
    }

    /// Retrieves the incoming interfaces for a given name from the PIT.
    /// # Arguments
    /// * `name` - The name of the interest.
    /// # Returns
    /// An optional reference to a vector of interfaces if they exist.
    pub fn get_incoming_interfaces(&self, name: &str) -> Option<&Vec<String>> {
        self.table.get(name)
    }

    /// Checks if the PIT is empty.
    /// # Returns
    /// True if the PIT is empty, otherwise false.
    pub fn is_empty(&self) -> bool {
        self.table.is_empty()
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/node.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/pit.rs =====
use icn_common::{IcnError, IcnResult};
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use log::{info, error};

/// Represents a Pending Interest Table (PIT) in the ICN project.
pub struct PIT {
    table: Arc<RwLock<HashMap<String, Vec<String>>>>,
}

impl PIT {
    /// Creates a new instance of PIT.
    pub fn new() -> Self {
        PIT {
            table: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// Adds an interest to the PIT.
    ///
    /// # Arguments
    ///
    /// * `interest` - The interest to be added.
    /// * `requester` - The requester of the interest.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn add_interest(&self, interest: String, requester: String) -> IcnResult<()> {
        let mut table = self.table.write().unwrap();
        table.entry(interest.clone()).or_default().push(requester.clone());
        info!("PIT entry added: {} requested by {}", interest, requester);
        Ok(())
    }

    /// Retrieves the requesters for a given interest.
    ///
    /// # Arguments
    ///
    /// * `interest` - The interest to retrieve the requesters for.
    ///
    /// # Returns
    ///
    /// * `IcnResult<Vec<String>>` - The list of requesters.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn get_requesters(&self, interest: &str) -> IcnResult<Vec<String>> {
        let table = self.table.read().unwrap();
        table.get(interest).cloned().ok_or_else(|| IcnError::Network("Interest not found".into()))
    }

    /// Removes an interest from the PIT.
    ///
    /// # Arguments
    ///
    /// * `interest` - The interest to be removed.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn remove_interest(&self, interest: &str) -> IcnResult<()> {
        let mut table = self.table.write().unwrap();
        table.remove(interest);
        info!("PIT entry removed: {}", interest);
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add_and_get_requesters() {
        let pit = PIT::new();
        let interest = "interest_1".to_string();
        let requester = "requester_1".to_string();
        assert!(pit.add_interest(interest.clone(), requester.clone()).is_ok());
        let requesters = pit.get_requesters(&interest).unwrap();
        assert_eq!(requesters, vec![requester]);
    }

    #[test]
    fn test_get_non_existent_requesters() {
        let pit = PIT::new();
        assert!(pit.get_requesters("non_existent_interest").is_err());
    }

    #[test]
    fn test_remove_interest() {
        let pit = PIT::new();
        let interest = "interest_1".to_string();
        let requester = "requester_1".to_string();
        pit.add_interest(interest.clone(), requester).unwrap();
        assert!(pit.remove_interest(&interest).is_ok());
        assert!(pit.get_requesters(&interest).is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_node_management/src/pit.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_reputation/Cargo.toml =====
[package]
name = "icn_reputation"
version = "0.1.0"
edition = "2021"

[dependencies]
===== END OF /home/matt/InterCooperative-Network/crates/icn_reputation/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_reputation/src/lib.rs =====
// File: crates/icn_reputation/src/lib.rs

use std::collections::HashMap;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReputationScore {
    score: f64,
    last_updated: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReputationEvent {
    entity_id: String,
    event_type: ReputationEventType,
    value: f64,
    timestamp: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ReputationEventType {
    Contribution,
    Participation,
    Feedback,
    Violation,
}

pub struct ReputationSystem {
    scores: HashMap<String, ReputationScore>,
    events: Vec<ReputationEvent>,
    decay_rate: f64,
    min_score: f64,
    max_score: f64,
}

impl ReputationSystem {
    pub fn new(decay_rate: f64, min_score: f64, max_score: f64) -> Self {
        ReputationSystem {
            scores: HashMap::new(),
            events: Vec::new(),
            decay_rate,
            min_score,
            max_score,
        }
    }

    pub fn add_event(&mut self, event: ReputationEvent) {
        self.events.push(event.clone());
        self.update_score(&event.entity_id, event);
    }

    pub fn get_score(&self, entity_id: &str) -> Option<f64> {
        self.scores.get(entity_id).map(|score| score.score)
    }

    fn update_score(&mut self, entity_id: &str, event: ReputationEvent) {
        let score = self.scores.entry(entity_id.to_string()).or_insert(ReputationScore {
            score: 0.0,
            last_updated: Utc::now(),
        });

        // Apply time decay
        let time_diff = (Utc::now() - score.last_updated).num_days() as f64;
        score.score *= (1.0 - self.decay_rate).powf(time_diff);

        // Update score based on event
        match event.event_type {
            ReputationEventType::Contribution | ReputationEventType::Participation => {
                score.score += event.value;
            }
            ReputationEventType::Feedback => {
                score.score += event.value * 0.5; // Feedback has less impact
            }
            ReputationEventType::Violation => {
                score.score -= event.value;
            }
        }

        // Ensure score is within bounds
        score.score = score.score.clamp(self.min_score, self.max_score);
        score.last_updated = Utc::now();
    }

    pub fn get_top_entities(&self, limit: usize) -> Vec<(String, f64)> {
        let mut entities: Vec<(String, f64)> = self.scores
            .iter()
            .map(|(id, score)| (id.clone(), score.score))
            .collect();
        entities.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());
        entities.truncate(limit);
        entities
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_reputation_system() {
        let mut system = ReputationSystem::new(0.01, 0.0, 100.0);

        // Add some events
        system.add_event(ReputationEvent {
            entity_id: "Alice".to_string(),
            event_type: ReputationEventType::Contribution,
            value: 10.0,
            timestamp: Utc::now(),
        });

        system.add_event(ReputationEvent {
            entity_id: "Bob".to_string(),
            event_type: ReputationEventType::Participation,
            value: 5.0,
            timestamp: Utc::now(),
        });

        // Check scores
        assert!(system.get_score("Alice").unwrap() > system.get_score("Bob").unwrap());

        // Add a violation for Alice
        system.add_event(ReputationEvent {
            entity_id: "Alice".to_string(),
            event_type: ReputationEventType::Violation,
            value: 3.0,
            timestamp: Utc::now(),
        });

        // Check top entities
        let top = system.get_top_entities(2);
        assert_eq!(top.len(), 2);
        assert_eq!(top[0].0, "Alice");
        assert_eq!(top[1].0, "Bob");
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_reputation/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_sharding/Cargo.toml =====
[package]
name = "icn_sharding"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
icn_blockchain = { path = "../icn_blockchain" }
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
log = "0.4"
thiserror = "1.0"
chrono = { version = "0.4", features = ["serde"] }
rand = "0.8"
sha2 = "0.9"

[dev-dependencies]
tokio-test = "0.4"===== END OF /home/matt/InterCooperative-Network/crates/icn_sharding/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_sharding/src/cross_shard_communication.rs =====
use crate::blockchain::Transaction;
use crate::sharding::ShardingManager;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{Mutex, mpsc};
use uuid::Uuid;
use icn_common::{Error, Result};

#[derive(Clone, Debug)]
pub struct CrossShardTransaction {
    pub transaction: Transaction,
    pub from_shard: u64,
    pub to_shard: u64,
    pub status: CrossShardTransactionStatus,
}

#[derive(Clone, Debug, PartialEq)]
pub enum CrossShardTransactionStatus {
    Initiated,
    LockAcquired,
    Committed,
    Failed(String),
}

pub struct CrossShardCommunicator {
    sharding_manager: Arc<Mutex<ShardingManager>>,
    pending_transactions: Arc<Mutex<HashMap<String, CrossShardTransaction>>>,
    tx_channels: HashMap<u64, mpsc::Sender<CrossShardTransaction>>,
}

impl CrossShardCommunicator {
    pub fn new(sharding_manager: Arc<Mutex<ShardingManager>>) -> Self {
        let pending_transactions = Arc::new(Mutex::new(HashMap::new()));
        let mut tx_channels = HashMap::new();
        let shard_count = sharding_manager.lock().unwrap().get_shard_count();
        
        for i in 0..shard_count {
            let (tx, mut rx) = mpsc::channel(100);
            tx_channels.insert(i, tx);
            let sm = Arc::clone(&sharding_manager);
            let pt = Arc::clone(&pending_transactions);
            
            tokio::spawn(async move {
                while let Some(transaction) = rx.recv().await {
                    if let Err(e) = Self::process_transaction(sm.clone(), pt.clone(), transaction).await {
                        log::error!("Error processing cross-shard transaction: {}", e);
                    }
                }
            });
        }

        CrossShardCommunicator {
            sharding_manager,
            pending_transactions,
            tx_channels,
        }
    }

    pub async fn initiate_cross_shard_transaction(&self, transaction: Transaction) -> Result<String> {
        let sharding_manager = self.sharding_manager.lock().await;
        let from_shard = sharding_manager.get_shard_for_address(&transaction.from);
        let to_shard = sharding_manager.get_shard_for_address(&transaction.to);

        if from_shard == to_shard {
            return Err(Error::ShardingError("Not a cross-shard transaction".to_string()));
        }

        let cross_shard_tx = CrossShardTransaction {
            transaction: transaction.clone(),
            from_shard,
            to_shard,
            status: CrossShardTransactionStatus::Initiated,
        };

        let tx_id = Uuid::new_v4().to_string();
        self.pending_transactions.lock().await.insert(tx_id.clone(), cross_shard_tx.clone());

        if let Some(tx) = self.tx_channels.get(&from_shard) {
            tx.send(cross_shard_tx).await.map_err(|e| Error::CommunicationError(e.to_string()))?;
        } else {
            return Err(Error::ShardingError(format!("Channel for shard {} not found", from_shard)));
        }

        Ok(tx_id)
    }

    async fn process_transaction(
        sharding_manager: Arc<Mutex<ShardingManager>>,
        pending_transactions: Arc<Mutex<HashMap<String, CrossShardTransaction>>>,
        mut transaction: CrossShardTransaction
    ) -> Result<()> {
        // Phase 1: Lock funds in the source shard
        {
            let mut sm = sharding_manager.lock().await;
            sm.lock_funds_in_shard(
                transaction.from_shard,
                &transaction.transaction.from,
                &transaction.transaction.currency_type,
                transaction.transaction.amount
            )?;
        }
        transaction.status = CrossShardTransactionStatus::LockAcquired;

        // Phase 2: Transfer funds to the destination shard
        {
            let mut sm = sharding_manager.lock().await;
            sm.transfer_between_shards(transaction.from_shard, transaction.to_shard, &transaction.transaction)?;
        }

        // Phase 3: Commit the transaction
        {
            let mut sm = sharding_manager.lock().await;
            sm.commit_cross_shard_transaction(&transaction.transaction, transaction.from_shard, transaction.to_shard)?;
        }

        transaction.status = CrossShardTransactionStatus::Committed;
        pending_transactions.lock().await.insert(Uuid::new_v4().to_string(), transaction);
        Ok(())
    }

    pub async fn get_transaction_status(&self, tx_id: &str) -> Option<CrossShardTransactionStatus> {
        self.pending_transactions.lock().await.get(tx_id).map(|tx| tx.status.clone())
    }

    pub async fn wait_for_transaction(&self, tx_id: &str, timeout: std::time::Duration) -> Result<CrossShardTransactionStatus> {
        let start_time = std::time::Instant::now();
        while start_time.elapsed() < timeout {
            if let Some(status) = self.get_transaction_status(tx_id).await {
                match status {
                    CrossShardTransactionStatus::Committed => return Ok(status),
                    CrossShardTransactionStatus::Failed(reason) => return Err(Error::TransactionFailed(reason)),
                    _ => tokio::time::sleep(std::time::Duration::from_millis(100)).await,
                }
            }
            tokio::time::sleep(std::time::Duration::from_millis(100)).await;
        }
        Err(Error::Timeout("Transaction timeout".to_string()))
    }

    pub async fn cleanup_completed_transactions(&self) {
        let mut pending_transactions = self.pending_transactions.lock().await;
        pending_transactions.retain(|_, tx| {
            match tx.status {
                CrossShardTransactionStatus::Committed => false,
                CrossShardTransactionStatus::Failed(_) => false,
                _ => true,
            }
        });
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_common::CurrencyType;
    use ed25519_dalek::Keypair;
    use rand::rngs::OsRng;

    #[tokio::test]
    async fn test_cross_shard_transaction() {
        let sharding_manager = Arc::new(Mutex::new(ShardingManager::new(2, 10)));
        let communicator = CrossShardCommunicator::new(sharding_manager.clone());

        {
            let mut sm = sharding_manager.lock().await;
            sm.add_address_to_shard("Alice".to_string(), 0);
            sm.add_address_to_shard("Bob".to_string(), 1);
            sm.initialize_balance("Alice".to_string(), CurrencyType::BasicNeeds, 1000.0).unwrap();
        }

        let mut csprng = OsRng{};
        let keypair: Keypair = Keypair::generate(&mut csprng);

        let mut transaction = Transaction::new(
            "Alice".to_string(),
            "Bob".to_string(),
            200.0,
            CurrencyType::BasicNeeds,
            1000,
        );
        transaction.sign(&keypair).unwrap();

        let tx_id = communicator.initiate_cross_shard_transaction(transaction).await.unwrap();

        // Wait for the transaction to be processed
        let status = communicator.wait_for_transaction(&tx_id, std::time::Duration::from_secs(5)).await.unwrap();
        assert_eq!(status, CrossShardTransactionStatus::Committed);

        let sm = sharding_manager.lock().await;
        let alice_balance = sm.get_balance("Alice".to_string(), CurrencyType::BasicNeeds).unwrap();
        let bob_balance = sm.get_balance("Bob".to_string(), CurrencyType::BasicNeeds).unwrap();
        
        assert_eq!(alice_balance, 800.0);
        assert_eq!(bob_balance, 200.0);
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_sharding/src/cross_shard_communication.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_sharding/src/cross_shard_sync.rs =====
use icn_common::{Result, Error};
use icn_blockchain::Block;
use std::collections::HashMap;
use tokio::sync::RwLock;
use std::sync::Arc;

pub struct CrossShardSyncManager {
    shard_data: Arc<RwLock<HashMap<u64, Vec<Block>>>>,
}

impl CrossShardSyncManager {
    pub fn new() -> Self {
        CrossShardSyncManager {
            shard_data: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    pub async fn synchronize(&self, shard_id: u64, blocks: Vec<Block>) -> Result<()> {
        let mut shard_data = self.shard_data.write().await;
        shard_data.insert(shard_id, blocks);
        Ok(())
    }

    pub async fn get_shard_data(&self, shard_id: u64) -> Result<Vec<Block>> {
        let shard_data = self.shard_data.read().await;
        shard_data.get(&shard_id)
            .cloned()
            .ok_or_else(|| Error::ShardingError(format!("No data for shard {}", shard_id)))
    }

    pub async fn validate_cross_shard_state(&self) -> Result<bool> {
        // Implement cross-shard state validation logic here
        // This is a placeholder implementation
        Ok(true)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_blockchain::Transaction;

    #[tokio::test]
    async fn test_cross_shard_sync() {
        let sync_manager = CrossShardSyncManager::new();
        
        let block = Block {
            index: 1,
            timestamp: chrono::Utc::now().timestamp(),
            transactions: vec![Transaction::new(
                "Alice".to_string(),
                "Bob".to_string(),
                100.0,
                icn_common::CurrencyType::BasicNeeds,
                0,
            )],
            previous_hash: "previous_hash".to_string(),
            hash: "current_hash".to_string(),
        };

        sync_manager.synchronize(1, vec![block.clone()]).await.unwrap();
        
        let retrieved_blocks = sync_manager.get_shard_data(1).await.unwrap();
        assert_eq!(retrieved_blocks.len(), 1);
        assert_eq!(retrieved_blocks[0].hash, block.hash);

        assert!(sync_manager.validate_cross_shard_state().await.unwrap());
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_sharding/src/cross_shard_sync.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_sharding/src/cross_shard_transaction_manager.rs =====
use icn_common::{IcnResult, IcnError, Block, Transaction, CurrencyType};
use std::collections::HashMap;
use sha2::{Sha256, Digest};

pub struct Shard {
    pub id: u64,
    pub blockchain: Vec<Block>,
    pub balances: HashMap<String, HashMap<CurrencyType, f64>>,
    pub pending_transactions: Vec<Transaction>,
}

pub struct ShardingManager {
    shards: HashMap<u64, Shard>,
    shard_count: u64,
    address_to_shard: HashMap<String, u64>,
}

impl ShardingManager {
    pub fn new(shard_count: u64) -> Self {
        let mut shards = HashMap::new();
        for i in 0..shard_count {
            shards.insert(i, Shard {
                id: i,
                blockchain: vec![Block::genesis()],
                balances: HashMap::new(),
                pending_transactions: Vec::new(),
            });
        }
        
        ShardingManager {
            shards,
            shard_count,
            address_to_shard: HashMap::new(),
        }
    }

    pub fn get_shard_count(&self) -> u64 {
        self.shard_count
    }

    pub fn process_transaction(&mut self, transaction: &Transaction) -> IcnResult<()> {
        let shard_id = self.get_shard_for_address(&transaction.from);
        {
            let shard = self.shards.get_mut(&shard_id).ok_or_else(|| IcnError::Sharding("Shard not found".to_string()))?;
            if !self.verify_transaction(shard, transaction) {
                return Err(IcnError::Sharding("Invalid transaction".to_string()));
            }
            shard.pending_transactions.push(transaction.clone());
        }
        let shard = self.shards.get_mut(&shard_id).ok_or_else(|| IcnError::Sharding("Shard not found".to_string()))?;
        self.update_balances(shard, transaction)
    }

    fn update_balances(&mut self, shard: &mut Shard, transaction: &Transaction) -> IcnResult<()> {
        let sender_balances = shard.balances.entry(transaction.from.clone()).or_insert_with(HashMap::new);
        let sender_balance = sender_balances.entry(transaction.currency_type.clone()).or_insert(0.0);
        
        if *sender_balance < transaction.amount {
            return Err(IcnError::Sharding("Insufficient balance".to_string()));
        }
        
        *sender_balance -= transaction.amount;

        let recipient_balances = shard.balances.entry(transaction.to.clone()).or_insert_with(HashMap::new);
        let recipient_balance = recipient_balances.entry(transaction.currency_type.clone()).or_insert(0.0);
        *recipient_balance += transaction.amount;

        Ok(())
    }

    pub fn create_block(&mut self, shard_id: u64) -> IcnResult<Block> {
        let new_block;
        {
            let shard = self.shards.get_mut(&shard_id).ok_or_else(|| IcnError::Sharding("Shard not found".to_string()))?;
            let previous_block = shard.blockchain.last().ok_or_else(|| IcnError::Sharding("No previous block found".to_string()))?;
            
            new_block = Block {
                index: shard.blockchain.len() as u64,
                timestamp: chrono::Utc::now().timestamp(),
                transactions: shard.pending_transactions.clone(),
                previous_hash: previous_block.hash.clone(),
                hash: String::new(), // Will be set later
            };

            shard.pending_transactions.clear();
        }
        let new_block = self.calculate_block_hash(new_block);
        let shard = self.shards.get_mut(&shard_id).ok_or_else(|| IcnError::Sharding("Shard not found".to_string()))?;
        shard.blockchain.push(new_block.clone());
        Ok(new_block)
    }

    pub fn get_shard_for_address(&self, address: &str) -> u64 {
        *self.address_to_shard.get(address).unwrap_or(&(self.hash_address(address) % self.shard_count))
    }

    pub fn add_address_to_shard(&mut self, address: String, shard_id: u64) -> IcnResult<()> {
        if shard_id >= self.shard_count {
            return Err(IcnError::Sharding("Invalid shard ID".to_string()));
        }
        self.address_to_shard.insert(address, shard_id);
        Ok(())
    }

    pub fn get_balance(&self, address: &str, currency_type: &CurrencyType) -> IcnResult<f64> {
        let shard_id = self.get_shard_for_address(address);
        let shard = self.shards.get(&shard_id).ok_or_else(|| IcnError::Sharding("Shard not found".to_string()))?;
        
        Ok(shard.balances
            .get(address)
            .and_then(|balances| balances.get(currency_type))
            .cloned()
            .unwrap_or(0.0))
    }

    fn verify_transaction(&self, shard: &Shard, transaction: &Transaction) -> bool {
        if let Some(sender_balances) = shard.balances.get(&transaction.from) {
            if let Some(balance) = sender_balances.get(&transaction.currency_type) {
                return *balance >= transaction.amount;
            }
        }
        false
    }

    fn hash_address(&self, address: &str) -> u64 {
        let mut hasher = Sha256::new();
        hasher.update(address.as_bytes());
        let result = hasher.finalize();
        let hash_bytes: [u8; 8] = result[..8].try_into().unwrap_or([0; 8]);
        u64::from_le_bytes(hash_bytes)
    }

    fn calculate_block_hash(&self, mut block: Block) -> Block {
        let mut hasher = Sha256::new();
        hasher.update(block.index.to_string().as_bytes());
        hasher.update(block.timestamp.to_string().as_bytes());
        for transaction in &block.transactions {
            hasher.update(transaction.from.as_bytes());
            hasher.update(transaction.to.as_bytes());
            hasher.update(transaction.amount.to_string().as_bytes());
            hasher.update(format!("{:?}", transaction.currency_type).as_bytes());
        }
        hasher.update(block.previous_hash.as_bytes());
        
        let hash = format!("{:x}", hasher.finalize());
        block.hash = hash;
        block
    }

    pub fn transfer_between_shards(&mut self, from_shard_id: u64, to_shard_id: u64, transaction: &Transaction) -> IcnResult<()> {
        {
            // Deduct from the source shard
            let from_shard = self.shards.get_mut(&from_shard_id).ok_or_else(|| IcnError::Sharding("Source shard not found".to_string()))?;
            self.update_balances(from_shard, transaction)?;
        }

        // Add to the destination shard
        let mut reverse_transaction = transaction.clone();
        reverse_transaction.from = transaction.to.clone();
        reverse_transaction.to = transaction.from.clone();
        {
            let to_shard = self.shards.get_mut(&to_shard_id).ok_or_else(|| IcnError::Sharding("Destination shard not found".to_string()))?;
            self.update_balances(to_shard, &reverse_transaction)?;
        }

        Ok(())
    }

    pub fn get_shard_state(&self, shard_id: u64) -> IcnResult<&Shard> {
        self.shards.get(&shard_id).ok_or_else(|| IcnError::Sharding("Shard not found".to_string()))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sharding_manager() {
        let mut manager = ShardingManager::new(4);
        assert_eq!(manager.get_shard_count(), 4);

        let transaction = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 100.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: 0,
            signature: None,
        };

        manager.add_address_to_shard("Alice".to_string(), 0).unwrap();
        manager.add_address_to_shard("Bob".to_string(), 1).unwrap();

        // Initialize Alice's balance
        let alice_shard = manager.shards.get_mut(&0).unwrap();
        alice_shard.balances.entry("Alice".to_string()).or_insert_with(HashMap::new).insert(CurrencyType::BasicNeeds, 200.0);

        assert!(manager.process_transaction(&transaction).is_ok());

        assert_eq!(manager.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap(), 100.0);
        assert_eq!(manager.get_balance("Bob", &CurrencyType::BasicNeeds).unwrap(), 100.0);

        // Test block creation
        let block = manager.create_block(0).unwrap();
        assert_eq!(block.index, 1);
        assert_eq!(block.transactions.len(), 1);

        // Test cross-shard transaction
        let cross_shard_tx = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 50.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: 1,
            signature: None,
        };

        assert!(manager.transfer_between_shards(0, 1, &cross_shard_tx).is_ok());
        assert_eq!(manager.get_balance("Alice", &CurrencyType::BasicNeeds).unwrap(), 50.0);
        assert_eq!(manager.get_balance("Bob", &CurrencyType::BasicNeeds).unwrap(), 150.0);

        // Test getting shard state
        let shard_state = manager.get_shard_state(0).unwrap();
        assert_eq!(shard_state.id, 0);
        assert_eq!(shard_state.blockchain.len(), 2); // Genesis block + 1 new block

        // Test invalid shard access
        assert!(manager.get_shard_state(10).is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_sharding/src/cross_shard_transaction_manager.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_sharding/src/lib.rs =====
// File: crates/icn_vm/src/coop_vm.rs

use std::collections::HashMap;
use icn_common::{IcnResult, IcnError};

#[derive(Clone, Debug, PartialEq)]
pub enum Value {
    Int(i64),
    Float(f64),
    Bool(bool),
    String(String),
    List(Vec<Value>),
    Map(HashMap<String, Value>),
}

#[derive(Clone, Debug)]
pub enum Opcode {
    Push(Value),
    Pop,
    Add,
    Sub,
    Mul,
    Div,
    Mod,
    Eq,
    Neq,
    Lt,
    Lte,
    Gt,
    Gte,
    And,
    Or,
    Not,
    Store(String),
    Load(String),
    Call(String),
    Return,
    JumpIf(usize),
    Jump(usize),
    CreateList,
    AppendList,
    GetListItem,
    SetListItem,
    CreateMap,
    SetMapItem,
    GetMapItem,
    Vote(String),
    AllocateResource(String),
    UpdateReputation(String),
    CreateProposal,
    GetProposalStatus,
    Emit(String),
}

pub struct CoopVM {
    stack: Vec<Value>,
    memory: HashMap<String, Value>,
    program: Vec<Opcode>,
    pc: usize,
    call_stack: Vec<usize>,
    functions: HashMap<String, usize>,
}

impl CoopVM {
    pub fn new(program: Vec<Opcode>) -> Self {
        CoopVM {
            stack: Vec::new(),
            memory: HashMap::new(),
            program,
            pc: 0,
            call_stack: Vec::new(),
            functions: HashMap::new(),
        }
    }

    pub fn run(&mut self) -> IcnResult<()> {
        while self.pc < self.program.len() {
            self.execute_instruction()?;
            self.pc += 1;
        }
        Ok(())
    }

    fn execute_instruction(&mut self) -> IcnResult<()> {
        let instruction = self.program[self.pc].clone();
        match instruction {
            Opcode::Push(value) => self.stack.push(value),
            Opcode::Pop => { self.stack.pop().ok_or(IcnError::VM("Stack underflow".into()))? ; }
            Opcode::Add => self.binary_op(|a, b| a + b)?,
            Opcode::Sub => self.binary_op(|a, b| a - b)?,
            Opcode::Mul => self.binary_op(|a, b| a * b)?,
            Opcode::Div => self.binary_op(|a, b| a / b)?,
            Opcode::Mod => self.binary_op(|a, b| a % b)?,
            Opcode::Eq => self.compare_op(|a, b| a == b)?,
            Opcode::Neq => self.compare_op(|a, b| a != b)?,
            Opcode::Lt => self.compare_op(|a, b| a < b)?,
            Opcode::Lte => self.compare_op(|a, b| a <= b)?,
            Opcode::Gt => self.compare_op(|a, b| a > b)?,
            Opcode::Gte => self.compare_op(|a, b| a >= b)?,
            Opcode::And => self.logic_op(|a, b| a && b)?,
            Opcode::Or => self.logic_op(|a, b| a || b)?,
            Opcode::Not => {
                let a = self.pop_bool()?;
                self.stack.push(Value::Bool(!a));
            }
            Opcode::Store(name) => {
                let value = self.stack.pop().ok_or(IcnError::VM("Stack underflow".into()))?;
                self.memory.insert(name, value);
            }
            Opcode::Load(name) => {
                let value = self.memory.get(&name).ok_or(IcnError::VM("Variable not found".into()))?.clone();
                self.stack.push(value);
            }
            Opcode::Call(func_name) => {
                let func_pc = self.functions.get(&func_name).ok_or(IcnError::VM("Function not found".into()))?;
                self.call_stack.push(self.pc);
                self.pc = *func_pc;
            }
            Opcode::Return => {
                self.pc = self.call_stack.pop().ok_or(IcnError::VM("Return without call".into()))?;
            }
            Opcode::JumpIf(target) => {
                let condition = self.pop_bool()?;
                if condition {
                    self.pc = target;
                }
            }
            Opcode::Jump(target) => {
                self.pc = target;
            }
            Opcode::CreateList => self.stack.push(Value::List(Vec::new())),
            Opcode::AppendList => {
                let value = self.stack.pop().ok_or(IcnError::VM("Stack underflow".into()))?;
                if let Some(Value::List(list)) = self.stack.last_mut() {
                    list.push(value);
                } else {
                    return Err(IcnError::VM("Expected list on top of stack".into()));
                }
            }
            Opcode::GetListItem => {
                let index = self.pop_int()?;
                if let Some(Value::List(list)) = self.stack.pop() {
                    let item = list.get(index as usize).ok_or(IcnError::VM("List index out of bounds".into()))?.clone();
                    self.stack.push(item);
                } else {
                    return Err(IcnError::VM("Expected list on top of stack".into()));
                }
            }
            Opcode::SetListItem => {
                let value = self.stack.pop().ok_or(IcnError::VM("Stack underflow".into()))?;
                let index = self.pop_int()?;
                if let Some(Value::List(list)) = self.stack.last_mut() {
                    if (index as usize) < list.len() {
                        list[index as usize] = value;
                    } else {
                        return Err(IcnError::VM("List index out of bounds".into()));
                    }
                } else {
                    return Err(IcnError::VM("Expected list on top of stack".into()));
                }
            }
            Opcode::CreateMap => self.stack.push(Value::Map(HashMap::new())),
            Opcode::SetMapItem => {
                let value = self.stack.pop().ok_or(IcnError::VM("Stack underflow".into()))?;
                let key = self.pop_string()?;
                if let Some(Value::Map(map)) = self.stack.last_mut() {
                    map.insert(key, value);
                } else {
                    return Err(IcnError::VM("Expected map on top of stack".into()));
                }
            }
            Opcode::GetMapItem => {
                let key = self.pop_string()?;
                if let Some(Value::Map(map)) = self.stack.pop() {
                    let value = map.get(&key).ok_or(IcnError::VM("Key not found in map".into()))?.clone();
                    self.stack.push(value);
                } else {
                    return Err(IcnError::VM("Expected map on top of stack".into()));
                }
            }
            Opcode::Vote(proposal_id) => {
                let vote = self.pop_bool()?;
                // In a real implementation, this would interact with the governance system
                println!("Voting {} on proposal {}", if vote { "Yes" } else { "No" }, proposal_id);
            }
            Opcode::AllocateResource(resource_id) => {
                let amount = self.pop_int()?;
                // In a real implementation, this would interact with a resource management system
                println!("Allocating {} units of resource {}", amount, resource_id);
            }
            Opcode::UpdateReputation(address) => {
                let change = self.pop_int()?;
                // In a real implementation, this would interact with the reputation system
                println!("Updating reputation of {} by {}", address, change);
            }
            Opcode::CreateProposal => {
                let description = self.pop_string()?;
                // In a real implementation, this would interact with the governance system
                println!("Creating proposal: {}", description);
                self.stack.push(Value::String("new_proposal_id".to_string()));
            }
            Opcode::GetProposalStatus => {
                let proposal_id = self.pop_string()?;
                // In a real implementation, this would interact with the governance system
                println!("Getting status of proposal: {}", proposal_id);
                self.stack.push(Value::String("Active".to_string()));
            }
            Opcode::Emit(event_name) => {
                let event_data = self.stack.pop().ok_or(IcnError::VM("Stack underflow".into()))?;
                // In a real implementation, this would emit an event to the blockchain
                println!("Emitting event {}: {:?}", event_name, event_data);
            }
        }
        Ok(())
    }

    fn binary_op<F>(&mut self, op: F) -> IcnResult<()>
    where
        F: Fn(f64, f64) -> f64,
    {
        let b = self.pop_number()?;
        let a = self.pop_number()?;
        self.stack.push(Value::Float(op(a, b)));
        Ok(())
    }

    fn compare_op<F>(&mut self, op: F) -> IcnResult<()>
    where
        F: Fn(&Value, &Value) -> bool,
    {
        let b = self.stack.pop().ok_or(IcnError::VM("Stack underflow".into()))?;
        let a = self.stack.pop().ok_or(IcnError::VM("Stack underflow".into()))?;
        self.stack.push(Value::Bool(op(&a, &b)));
        Ok(())
    }

    fn logic_op<F>(&mut self, op: F) -> IcnResult<()>
    where
        F: Fn(bool, bool) -> bool,
    {
        let b = self.pop_bool()?;
        let a = self.pop_bool()?;
        self.stack.push(Value::Bool(op(a, b)));
        Ok(())
    }

    fn pop_number(&mut self) -> IcnResult<f64> {
        match self.stack.pop().ok_or(IcnError::VM("Stack underflow".into()))? {
            Value::Int(i) => Ok(i as f64),
            Value::Float(f) => Ok(f),
            _ => Err(IcnError::VM("Expected number".into())),
        }
    }

    fn pop_int(&mut self) -> IcnResult<i64> {
        match self.stack.pop().ok_or(IcnError::VM("Stack underflow".into()))? {
            Value::Int(i) => Ok(i),
            _ => Err(IcnError::VM("Expected integer".into())),
        }
    }

    fn pop_bool(&mut self) -> IcnResult<bool> {
        match self.stack.pop().ok_or(IcnError::VM("Stack underflow".into()))? {
            Value::Bool(b) => Ok(b),
            _ => Err(IcnError::VM("Expected boolean".into())),
        }
    }

    fn pop_string(&mut self) -> IcnResult<String> {
        match self.stack.pop().ok_or(IcnError::VM("Stack underflow".into()))? {
            Value::String(s) => Ok(s),
            _ => Err(IcnError::VM("Expected string".into())),
        }
    }

    pub fn register_function(&mut self, name: String, pc: usize) {
        self.functions.insert(name, pc);
    }

    pub fn get_stack(&self) -> &Vec<Value> {
        &self.stack
    }

    pub fn get_memory(&self) -> &HashMap<String, Value> {
        &self.memory
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_operations() {
        let program = vec![
            Opcode::Push(Value::Int(5)),
            Opcode::Push(Value::Int(3)),
            Opcode::Add,
            Opcode::Push(Value::Int(2)),
            Opcode::Mul,
        ];

        let mut vm = CoopVM::new(program);
        vm.run().unwrap();

        assert_eq!(vm.stack, vec![Value::Float(16.0)]);
    }

    #[test]
    fn test_control_flow() {
        let program = vec![
            Opcode::Push(Value::Int(10)),
            Opcode::Push(Value::Int(5)),
            Opcode::Lt,
            Opcode::JumpIf(6),
            Opcode::Push(Value::String("Less".to_string())),
            Opcode::Jump(7),
            Opcode::Push(Value::String("Greater or Equal".to_string())),
        ];

        let mut vm = CoopVM::new(program);
        vm.run().unwrap();

        assert_eq!(vm.stack, vec![Value::String("Greater or Equal".to_string())]);
    }

    #[test]
    fn test_function_call() {
        let program = vec![
            Opcode::Push(Value::Int(5)),
            Opcode::Call("square".to_string()),
            Opcode::Push(Value::Int(3)),
            Opcode::Add,
            Opcode::Return,
            // square function
            Opcode::Mul,
            Opcode::Return,
        ];

        let mut vm = CoopVM::new(program);
        vm.register_function("square".to_string(), 5);
        vm.run().unwrap();

        assert_eq!(vm.stack, vec![Value::Float(28.0)]);
    }

    // File: crates/icn_vm/src/coop_vm.rs

    #[test]
    fn test_list_operations() {
        let program = vec![
            Opcode::CreateList,
            Opcode::Push(Value::Int(1)),
            Opcode::AppendList,
            Opcode::Push(Value::Int(2)),
            Opcode::AppendList,
            Opcode::Push(Value::Int(3)),
            Opcode::AppendList,
            Opcode::Push(Value::Int(1)),
            Opcode::GetListItem,
            Opcode::Push(Value::Int(10)),
            Opcode::Push(Value::Int(0)),
            Opcode::SetListItem,
        ];

        let mut vm = CoopVM::new(program);
        vm.run().unwrap();

        assert_eq!(vm.stack, vec![
            Value::List(vec![Value::Int(10), Value::Int(2), Value::Int(3)]),
            Value::Int(2)
        ]);
    }

    #[test]
    fn test_map_operations() {
        let program = vec![
            Opcode::CreateMap,
            Opcode::Push(Value::String("key1".to_string())),
            Opcode::Push(Value::Int(42)),
            Opcode::SetMapItem,
            Opcode::Push(Value::String("key2".to_string())),
            Opcode::Push(Value::String("value".to_string())),
            Opcode::SetMapItem,
            Opcode::Push(Value::String("key1".to_string())),
            Opcode::GetMapItem,
        ];

        let mut vm = CoopVM::new(program);
        vm.run().unwrap();

        let mut expected_map = HashMap::new();
        expected_map.insert("key1".to_string(), Value::Int(42));
        expected_map.insert("key2".to_string(), Value::String("value".to_string()));

        assert_eq!(vm.stack, vec![
            Value::Map(expected_map),
            Value::Int(42)
        ]);
    }

    #[test]
    fn test_cooperative_operations() {
        let program = vec![
            Opcode::Push(Value::String("Proposal 1".to_string())),
            Opcode::CreateProposal,
            Opcode::Push(Value::Bool(true)),
            Opcode::Vote("proposal_1".to_string()),
            Opcode::Push(Value::Int(100)),
            Opcode::AllocateResource("computing_power".to_string()),
            Opcode::Push(Value::Int(5)),
            Opcode::UpdateReputation("user1".to_string()),
            Opcode::Push(Value::String("proposal_1".to_string())),
            Opcode::GetProposalStatus,
        ];

        let mut vm = CoopVM::new(program);
        vm.run().unwrap();

        assert_eq!(vm.stack, vec![
            Value::String("new_proposal_id".to_string()),
            Value::String("Active".to_string())
        ]);
    }

    #[test]
    fn test_error_handling() {
        let program = vec![
            Opcode::Push(Value::Int(5)),
            Opcode::Push(Value::String("not a number".to_string())),
            Opcode::Add,
        ];

        let mut vm = CoopVM::new(program);
        let result = vm.run();

        assert!(result.is_err());
        assert_eq!(result.unwrap_err().to_string(), "VM error: Expected number");
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_sharding/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_smart_contracts/Cargo.toml =====
# File: /home/matt/InterCooperative-Network/crates/icn_smart_contracts/Cargo.toml

[package]
name = "icn_smart_contracts"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
icn_vm = { path = "../icn_vm" }
icn_language = { path = "../icn_language" }  # Add this line
serde = { workspace = true }
thiserror = { workspace = true }
log = { workspace = true }
pest = "2.1"
pest_derive = "2.1"===== END OF /home/matt/InterCooperative-Network/crates/icn_smart_contracts/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_smart_contracts/src/lib.rs =====
// crates/icn_smart_contracts/src/lib.rs

use pest::Parser;
use pest_derive::Parser;
use icn_common::{IcnResult, IcnError, CurrencyType};
use icn_vm::{CoopVM, Opcode, Value};
use std::collections::HashMap;
use std::fmt;

// Define the parser for our smart contract language
#[derive(Parser)]
#[grammar = "contract.pest"]
struct ContractParser;

// Enum to represent different types of smart contracts
#[derive(Debug, Clone)]
pub enum SmartContractType {
    AssetTransfer,
    VotingSystem,
    ReputationManagement,
    ResourceAllocation,
    CustomLogic,
}

// Struct to represent a compiled smart contract
#[derive(Debug)]
pub struct CompiledContract {
    contract_type: SmartContractType,
    bytecode: Vec<Opcode>,
    abi: ContractABI,
}

// Struct to represent the ABI (Application Binary Interface) of a smart contract
#[derive(Debug)]
pub struct ContractABI {
    functions: Vec<ContractFunction>,
    events: Vec<ContractEvent>,
}

// Struct to represent a function in the smart contract's ABI
#[derive(Debug)]
pub struct ContractFunction {
    name: String,
    inputs: Vec<ContractParameter>,
    outputs: Vec<ContractParameter>,
}

// Struct to represent an event in the smart contract's ABI
#[derive(Debug)]
pub struct ContractEvent {
    name: String,
    parameters: Vec<ContractParameter>,
}

// Struct to represent a parameter in a function or event
#[derive(Debug)]
pub struct ContractParameter {
    name: String,
    param_type: ContractValueType,
}

// Enum to represent the possible value types in a smart contract
#[derive(Debug, Clone)]
pub enum ContractValueType {
    Integer,
    Float,
    Boolean,
    String,
    Address,
    List(Box<ContractValueType>),
    Map(Box<ContractValueType>, Box<ContractValueType>),
}

impl fmt::Display for ContractValueType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ContractValueType::Integer => write!(f, "Integer"),
            ContractValueType::Float => write!(f, "Float"),
            ContractValueType::Boolean => write!(f, "Boolean"),
            ContractValueType::String => write!(f, "String"),
            ContractValueType::Address => write!(f, "Address"),
            ContractValueType::List(inner) => write!(f, "List<{}>", inner),
            ContractValueType::Map(key, value) => write!(f, "Map<{}, {}>", key, value),
        }
    }
}

// The main compiler for our natural language smart contracts
pub struct NaturalLanguageCompiler;

impl NaturalLanguageCompiler {
    // Compile a natural language contract into bytecode
    pub fn compile(input: &str) -> IcnResult<CompiledContract> {
        let pairs = ContractParser::parse(Rule::contract, input)
            .map_err(|e| IcnError::SmartContract(format!("Parsing error: {}", e)))?;

        let mut bytecode = Vec::new();
        let mut abi = ContractABI {
            functions: Vec::new(),
            events: Vec::new(),
        };
        let mut contract_type = SmartContractType::CustomLogic;

        for pair in pairs {
            match pair.as_rule() {
                Rule::contract_type => {
                    contract_type = Self::parse_contract_type(pair.into_inner().next().unwrap().as_str())?;
                }
                Rule::function_definition => {
                    let (func_bytecode, func_abi) = Self::compile_function(pair)?;
                    bytecode.extend(func_bytecode);
                    abi.functions.push(func_abi);
                }
                Rule::statement => {
                    bytecode.extend(Self::compile_statement(pair)?);
                }
                Rule::event_definition => {
                    abi.events.push(Self::compile_event(pair)?);
                }
                _ => {}
            }
        }

        Ok(CompiledContract {
            contract_type,
            bytecode,
            abi,
        })
    }

    // Parse the contract type from the input
    fn parse_contract_type(type_str: &str) -> IcnResult<SmartContractType> {
        match type_str {
            "AssetTransfer" => Ok(SmartContractType::AssetTransfer),
            "VotingSystem" => Ok(SmartContractType::VotingSystem),
            "ReputationManagement" => Ok(SmartContractType::ReputationManagement),
            "ResourceAllocation" => Ok(SmartContractType::ResourceAllocation),
            "CustomLogic" => Ok(SmartContractType::CustomLogic),
            _ => Err(IcnError::SmartContract(format!("Unknown contract type: {}", type_str))),
        }
    }

    // Compile a function definition
    fn compile_function(pair: pest::iterators::Pair<Rule>) -> IcnResult<(Vec<Opcode>, ContractFunction)> {
        let mut inner = pair.into_inner();
        let name = inner.next().unwrap().as_str().to_string();
        let params = inner.next().unwrap();
        let body = inner.next().unwrap();

        let mut inputs = Vec::new();
        let mut param_bytecode = Vec::new();
        for param in params.into_inner() {
            let mut param_inner = param.into_inner();
            let param_name = param_inner.next().unwrap().as_str().to_string();
            let param_type = Self::parse_type(param_inner.next().unwrap().as_str())?;
            inputs.push(ContractParameter {
                name: param_name.clone(),
                param_type: param_type.clone(),
            });
            param_bytecode.push(Opcode::Store(param_name));
        }

        let mut body_bytecode = Self::compile_statement(body)?;
        let mut bytecode = param_bytecode;
        bytecode.extend(body_bytecode);
        bytecode.push(Opcode::Return);

        let func_abi = ContractFunction {
            name,
            inputs,
            outputs: vec![],  // For simplicity, we're not handling return types yet
        };

        Ok((bytecode, func_abi))
    }

    // Compile a single statement
    fn compile_statement(pair: pest::iterators::Pair<Rule>) -> IcnResult<Vec<Opcode>> {
        let inner = pair.into_inner().next().unwrap();
        match inner.as_rule() {
            Rule::assignment => Self::compile_assignment(inner),
            Rule::if_statement => Self::compile_if_statement(inner),
            Rule::while_loop => Self::compile_while_loop(inner),
            Rule::function_call => Self::compile_function_call(inner),
            Rule::return_statement => Self::compile_return_statement(inner),
            _ => Err(IcnError::SmartContract("Unknown statement type".into())),
        }
    }

    // Compile an assignment statement
    fn compile_assignment(pair: pest::iterators::Pair<Rule>) -> IcnResult<Vec<Opcode>> {
        let mut inner = pair.into_inner();
        let variable = inner.next().unwrap().as_str();
        let value = inner.next().unwrap();

        let mut opcodes = Self::compile_expression(value)?;
        opcodes.push(Opcode::Store(variable.to_string()));
        Ok(opcodes)
    }

    // Compile an if statement
    fn compile_if_statement(pair: pest::iterators::Pair<Rule>) -> IcnResult<Vec<Opcode>> {
        let mut inner = pair.into_inner();
        let condition = inner.next().unwrap();
        let true_branch = inner.next().unwrap();
        let false_branch = inner.next();

        let mut opcodes = Self::compile_expression(condition)?;
        let true_opcodes = Self::compile_statement(true_branch)?;
        let false_opcodes = false_branch.map(Self::compile_statement).transpose()?;

        opcodes.push(Opcode::JumpIf(true_opcodes.len() as usize + 1));
        opcodes.extend(true_opcodes);
        if let Some(false_opcodes) = false_opcodes {
            opcodes.push(Opcode::Jump(false_opcodes.len() as usize));
            opcodes.extend(false_opcodes);
        }

        Ok(opcodes)
    }

    // Compile a while loop
    fn compile_while_loop(pair: pest::iterators::Pair<Rule>) -> IcnResult<Vec<Opcode>> {
        let mut inner = pair.into_inner();
        let condition = inner.next().unwrap();
        let body = inner.next().unwrap();

        let condition_opcodes = Self::compile_expression(condition)?;
        let body_opcodes = Self::compile_statement(body)?;

        let mut opcodes = Vec::new();
        opcodes.extend(condition_opcodes.clone());
        opcodes.push(Opcode::JumpIf(body_opcodes.len() as usize + 2));
        opcodes.extend(body_opcodes);
        opcodes.extend(condition_opcodes);
        opcodes.push(Opcode::JumpIf(usize::MAX - (opcodes.len() - 1)));

        Ok(opcodes)
    }

    // Compile a function call
    fn compile_function_call(pair: pest::iterators::Pair<Rule>) -> IcnResult<Vec<Opcode>> {
        let mut inner = pair.into_inner();
        let function_name = inner.next().unwrap().as_str();
        let arguments = inner.next().unwrap().into_inner();

        let mut opcodes = Vec::new();
        for arg in arguments {
            opcodes.extend(Self::compile_expression(arg)?);
        }
        opcodes.push(Opcode::Call(function_name.to_string()));
        Ok(opcodes)
    }

    // Compile a return statement
    fn compile_return_statement(pair: pest::iterators::Pair<Rule>) -> IcnResult<Vec<Opcode>> {
        let mut inner = pair.into_inner();
        let expression = inner.next().unwrap();

        let mut opcodes = Self::compile_expression(expression)?;
        opcodes.push(Opcode::Return);
        Ok(opcodes)
    }

    // Compile an expression
    fn compile_expression(pair: pest::iterators::Pair<Rule>) -> IcnResult<Vec<Opcode>> {
        match pair.as_rule() {
            Rule::number => Ok(vec![Opcode::Push(Value::Int(pair.as_str().parse().unwrap()))]),
            Rule::string => Ok(vec![Opcode::Push(Value::String(pair.into_inner().next().unwrap().as_str().to_string()))]),
            Rule::boolean => Ok(vec![Opcode::Push(Value::Bool(pair.as_str().parse().unwrap()))]),
            Rule::variable => Ok(vec![Opcode::Load(pair.as_str().to_string())]),
            Rule::expression => {
                let mut inner = pair.into_inner();
                let left = inner.next().unwrap();
                let operator = inner.next();
                let right = inner.next();

                let mut opcodes = Self::compile_expression(left)?;
                if let (Some(op), Some(right)) = (operator, right) {
                    opcodes.extend(Self::compile_expression(right)?);
                    opcodes.push(match op.as_str() {
                        "+" => Opcode::Add,
                        "-" => Opcode::Sub,
                        "*" => Opcode::Mul,
                        "/" => Opcode::Div,
                        "==" => Opcode::Eq,
                        "!=" => Opcode::Neq,
                        "<" => Opcode::Lt,
                        "<=" => Opcode::Lte,
                        ">" => Opcode::Gt,
                        ">=" => Opcode::Gte,
                        "and" => Opcode::And,
                        "or" => Opcode::Or,
                        _ => return Err(IcnError::SmartContract(format!("Unknown operator: {}", op.as_str()))),
                    });
                }
                Ok(opcodes)
            }
            _ => Err(IcnError::SmartContract("Unknown expression type".into())),
        }
    }

    // Compile an event definition
    fn compile_event(pair: pest::iterators::Pair<Rule>) -> IcnResult<ContractEvent> {
        let mut inner = pair.into_inner();
        let name = inner.next().unwrap().as_str().to_string();
        let params = inner.next().unwrap();

        let mut parameters = Vec::new();
        for param in params.into_inner() {
            let mut param_inner = param.into_inner();
            let param_name = param_inner.next().unwrap().as_str().to_string();
            let param_type = Self::parse_type(param_inner.next().unwrap().as_str())?;
            parameters.push(ContractParameter {
                name: param_name,
                param_type,
            });
        }

        Ok(ContractEvent { name, parameters })
    }

    // Parse a type string into a ContractValueType
    fn parse_type(type_str: &str) -> IcnResult<ContractValueType> {
        match type_str {
            "int" => Ok(ContractValueType::Integer),
            "float" => Ok(ContractValueType::Float),
            "bool" => Ok(ContractValueType::Boolean),
            "string" => Ok(ContractValueType::String),
            "address" => Ok(ContractValueType::Address),
            _ if type_str.starts_with("list<") => {
                let inner_type = &type_str[5..type_str.len()-1];
                Ok(ContractValueType::List(Box::new(Self::parse_type(inner_type)?)))
            }
            _ if type_str.starts_with("map<") => {
                let inner_types: Vec<&str> = type_str[4..type_str.len()-1].split(',').collect();
                if inner_types.len() != 2 {
                    return Err(IcnError::SmartContract("Invalid map type format".into()));
                }
                Ok(ContractValueType::Map(
                    Box::new(Self::parse_type(inner_types[0].trim())?),
                    Box::new(Self::parse_type(inner_types[1].trim())?)))
                }
                _ => Err(IcnError::SmartContract(format!("Unknown type: {}", type_str))),
            }
        }
    }
    
    /// Struct to represent the execution context of a smart contract
    pub struct ContractContext {
        pub balances: HashMap<String, HashMap<CurrencyType, f64>>,
        pub storage: HashMap<String, Value>,
        pub block_height: u64,
        pub timestamp: u64,
        pub caller: String,
    }
    
    /// Smart contract executor
    pub struct SmartContractExecutor {
        vm: CoopVM,
    }
    
    impl SmartContractExecutor {
        pub fn new() -> Self {
            SmartContractExecutor {
                vm: CoopVM::new(Vec::new()),
            }
        }
    
        /// Execute a compiled smart contract
        pub fn execute(&mut self, contract: &CompiledContract, context: &mut ContractContext, function: &str, args: Vec<Value>) -> IcnResult<Option<Value>> {
            self.vm.load_program(contract.bytecode.clone());
            self.vm.set_context(context);
    
            // Find the function in the ABI
            let function_abi = contract.abi.functions.iter()
                .find(|f| f.name == function)
                .ok_or_else(|| IcnError::SmartContract(format!("Function {} not found", function)))?;
    
            // Check argument count
            if args.len() != function_abi.inputs.len() {
                return Err(IcnError::SmartContract("Incorrect number of arguments".into()));
            }
    
            // Push arguments onto the stack
            for arg in args {
                self.vm.push(arg);
            }
    
            // Call the function
            self.vm.call(function)?;
    
            // Run the VM
            self.vm.run()?;
    
            // Return the top value from the stack, if any
            Ok(self.vm.pop())
        }
    }
    
    #[cfg(test)]
    mod tests {
        use super::*;
    
        #[test]
        fn test_compile_simple_contract() {
            let contract_source = r#"
            contract_type: AssetTransfer
    
            function transfer(from: address, to: address, amount: int) {
                if balanceOf(from) >= amount {
                    balanceOf[from] = balanceOf[from] - amount;
                    balanceOf[to] = balanceOf[to] + amount;
                    emit Transfer(from, to, amount);
                }
            }
    
            event Transfer(from: address, to: address, amount: int)
            "#;
    
            let compiled_contract = NaturalLanguageCompiler::compile(contract_source).unwrap();
    
            assert_eq!(compiled_contract.contract_type, SmartContractType::AssetTransfer);
            assert!(!compiled_contract.bytecode.is_empty());
            assert_eq!(compiled_contract.abi.functions.len(), 1);
            assert_eq!(compiled_contract.abi.events.len(), 1);
    
            let transfer_function = &compiled_contract.abi.functions[0];
            assert_eq!(transfer_function.name, "transfer");
            assert_eq!(transfer_function.inputs.len(), 3);
    
            let transfer_event = &compiled_contract.abi.events[0];
            assert_eq!(transfer_event.name, "Transfer");
            assert_eq!(transfer_event.parameters.len(), 3);
        }
    
        #[test]
        fn test_execute_simple_contract() {
            let contract_source = r#"
            contract_type: AssetTransfer
    
            function transfer(from: address, to: address, amount: int) {
                if balanceOf(from) >= amount {
                    balanceOf[from] = balanceOf[from] - amount;
                    balanceOf[to] = balanceOf[to] + amount;
                    emit Transfer(from, to, amount);
                }
            }
    
            event Transfer(from: address, to: address, amount: int)
            "#;
    
            let compiled_contract = NaturalLanguageCompiler::compile(contract_source).unwrap();
            let mut executor = SmartContractExecutor::new();
    
            let mut context = ContractContext {
                balances: HashMap::new(),
                storage: HashMap::new(),
                block_height: 1,
                timestamp: 1623456789,
                caller: "system".to_string(),
            };
    
            // Initialize balances
            let mut from_balance = HashMap::new();
            from_balance.insert(CurrencyType::BasicNeeds, 100.0);
            context.balances.insert("Alice".to_string(), from_balance);
    
            let mut to_balance = HashMap::new();
            to_balance.insert(CurrencyType::BasicNeeds, 50.0);
            context.balances.insert("Bob".to_string(), to_balance);
    
            // Execute transfer
            let result = executor.execute(
                &compiled_contract,
                &mut context,
                "transfer",
                vec![
                    Value::String("Alice".to_string()),
                    Value::String("Bob".to_string()),
                    Value::Int(30),
                ],
            );
    
            assert!(result.is_ok());
    
            // Check balances after transfer
            assert_eq!(context.balances["Alice"][&CurrencyType::BasicNeeds], 70.0);
            assert_eq!(context.balances["Bob"][&CurrencyType::BasicNeeds], 80.0);
        }
    }
    
    // Helper trait for CoopVM to interact with ContractContext
    trait VMContext {
        fn get_balance(&self, address: &str, currency: &CurrencyType) -> f64;
        fn set_balance(&mut self, address: &str, currency: &CurrencyType, amount: f64);
        fn get_storage(&self, key: &str) -> Option<&Value>;
        fn set_storage(&mut self, key: String, value: Value);
        fn emit_event(&mut self, name: &str, params: Vec<Value>);
    }
    
    impl VMContext for ContractContext {
        fn get_balance(&self, address: &str, currency: &CurrencyType) -> f64 {
            self.balances.get(address).and_then(|balances| balances.get(currency)).cloned().unwrap_or(0.0)
        }
    
        fn set_balance(&mut self, address: &str, currency: &CurrencyType, amount: f64) {
            self.balances.entry(address.to_string()).or_insert_with(HashMap::new).insert(currency.clone(), amount);
        }
    
        fn get_storage(&self, key: &str) -> Option<&Value> {
            self.storage.get(key)
        }
    
        fn set_storage(&mut self, key: String, value: Value) {
            self.storage.insert(key, value);
        }
    
        fn emit_event(&mut self, name: &str, params: Vec<Value>) {
            println!("Event emitted: {} {:?}", name, params);
            // In a real implementation, this would interact with the blockchain to record the event
        }
    }
    
    // Extend CoopVM to work with ContractContext
    impl CoopVM {
        pub fn set_context(&mut self, context: &ContractContext) {
            // Implementation depends on how CoopVM is designed to interact with external state
        }
    
        pub fn push(&mut self, value: Value) {
            // Implementation to push a value onto the VM's stack
        }
    
        pub fn pop(&mut self) -> Option<Value> {
            // Implementation to pop a value from the VM's stack
        }
    
        pub fn call(&mut self, function: &str) -> IcnResult<()> {
            // Implementation to call a function in the VM
            Ok(())
        }
    }===== END OF /home/matt/InterCooperative-Network/crates/icn_smart_contracts/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_storage/Cargo.toml =====
[package]
name = "icn_storage"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
log = "0.4"
thiserror = "1.0"
sha2 = "0.9"

[dev-dependencies]
tokio-test = "0.4"===== END OF /home/matt/InterCooperative-Network/crates/icn_storage/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_storage/src/lib.rs =====
/// The ICN storage module.
pub mod storage_manager;
pub mod storage_node;
===== END OF /home/matt/InterCooperative-Network/crates/icn_storage/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_storage/src/storage_manager.rs =====
use crate::storage_node::StorageNode;
use icn_common::{IcnError, IcnResult};
use std::sync::{Arc, RwLock};
use log::{info, error};

/// Manages storage nodes and handles data storage operations.
pub struct StorageManager {
    nodes: Arc<RwLock<Vec<StorageNode>>>,
}

impl StorageManager {
    /// Creates a new instance of StorageManager.
    pub fn new() -> Self {
        StorageManager {
            nodes: Arc::new(RwLock::new(Vec::new())),
        }
    }

    /// Adds a storage node to the manager.
    ///
    /// # Arguments
    ///
    /// * `node` - The storage node to be added.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn add_node(&self, node: StorageNode) -> IcnResult<()> {
        let mut nodes = self.nodes.write().unwrap();
        nodes.push(node);
        info!("Storage node added");
        Ok(())
    }

    /// Removes a storage node from the manager.
    ///
    /// # Arguments
    ///
    /// * `node_id` - The ID of the storage node to be removed.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn remove_node(&self, node_id: &str) -> IcnResult<()> {
        let mut nodes = self.nodes.write().unwrap();
        nodes.retain(|node| node.id != node_id);
        info!("Storage node removed");
        Ok(())
    }

    /// Stores data across available storage nodes.
    ///
    /// # Arguments
    ///
    /// * `data` - The data to be stored.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn store_data(&self, data: Vec<u8>) -> IcnResult<()> {
        let nodes = self.nodes.read().unwrap();
        if nodes.is_empty() {
            return Err(IcnError::Storage("No available storage nodes".into()));
        }
        // Simple round-robin distribution of data
        let node = &nodes[0];
        node.store(data)?;
        info!("Data stored");
        Ok(())
    }

    /// Retrieves data from storage nodes.
    ///
    /// # Arguments
    ///
    /// * `data_id` - The ID of the data to be retrieved.
    ///
    /// # Returns
    ///
    /// * `IcnResult<Vec<u8>>` - The retrieved data.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn retrieve_data(&self, data_id: &str) -> IcnResult<Vec<u8>> {
        let nodes = self.nodes.read().unwrap();
        for node in nodes.iter() {
            if let Ok(data) = node.retrieve(data_id) {
                return Ok(data);
            }
        }
        Err(IcnError::Storage("Data not found".into()))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::storage_node::MockStorageNode;

    #[test]
    fn test_add_and_remove_node() {
        let manager = StorageManager::new();
        let node = MockStorageNode::new("Node1".to_string());
        assert!(manager.add_node(node).is_ok());
        assert!(manager.remove_node("Node1").is_ok());
    }

    #[test]
    fn test_store_and_retrieve_data() {
        let manager = StorageManager::new();
        let node = MockStorageNode::new("Node1".to_string());
        manager.add_node(node).unwrap();

        let data = vec![1, 2, 3];
        assert!(manager.store_data(data.clone()).is_ok());
        let retrieved_data = manager.retrieve_data("data_id").unwrap();
        assert_eq!(retrieved_data, data);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_storage/src/storage_manager.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_storage/src/storage_node.rs =====
use icn_common::{IcnError, IcnResult};
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use log::{info, error};

/// Represents a storage node in the ICN project.
pub struct StorageNode {
    pub id: String,
    data_store: Arc<RwLock<HashMap<String, Vec<u8>>>>,
}

impl StorageNode {
    /// Creates a new instance of StorageNode.
    ///
    /// # Arguments
    ///
    /// * `id` - The ID of the storage node.
    ///
    /// # Returns
    ///
    /// * `StorageNode` - A new instance of StorageNode.
    pub fn new(id: String) -> Self {
        StorageNode {
            id,
            data_store: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// Stores data in the storage node.
    ///
    /// # Arguments
    ///
    /// * `data` - The data to be stored.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn store(&self, data: Vec<u8>) -> IcnResult<()> {
        let mut data_store = self.data_store.write().unwrap();
        let data_id = format!("data_{}", data_store.len() + 1);
        data_store.insert(data_id.clone(), data);
        info!("Data stored with ID: {}", data_id);
        Ok(())
    }

    /// Retrieves data from the storage node.
    ///
    /// # Arguments
    ///
    /// * `data_id` - The ID of the data to be retrieved.
    ///
    /// # Returns
    ///
    /// * `IcnResult<Vec<u8>>` - The retrieved data.
    ///
    /// # Errors
    ///
    /// Returns `IcnResult` if the operation fails.
    pub fn retrieve(&self, data_id: &str) -> IcnResult<Vec<u8>> {
        let data_store = self.data_store.read().unwrap();
        data_store.get(data_id).cloned().ok_or_else(|| IcnError::Storage("Data not found".into()))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_store_and_retrieve_data() {
        let node = StorageNode::new("Node1".to_string());
        let data = vec![1, 2, 3];
        assert!(node.store(data.clone()).is_ok());
        let retrieved_data = node.retrieve("data_1").unwrap();
        assert_eq!(retrieved_data, data);
    }

    #[test]
    fn test_retrieve_non_existent_data() {
        let node = StorageNode::new("Node1".to_string());
        assert!(node.retrieve("non_existent_data").is_err());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_storage/src/storage_node.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_testnet/Cargo.toml =====
[package]
name = "icn_testnet"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
icn_blockchain = { path = "../icn_blockchain" }
icn_consensus = { path = "../icn_consensus" }
icn_currency = { path = "../icn_currency" }
icn_governance = { path = "../icn_governance" }
icn_identity = { path = "../icn_identity" }
icn_network = { path = "../icn_network" }
icn_sharding = { path = "../icn_sharding" }
icn_storage = { path = "../icn_storage" }
icn_vm = { path = "../icn_vm" }
icn_core = { path = "../icn_core" }
icn_api = { path = "../icn_api" }
tokio = { version = "1.0", features = ["full"] }
log = "0.4"
env_logger = "0.9"
rand = "0.8"===== END OF /home/matt/InterCooperative-Network/crates/icn_testnet/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_testnet/src/main.rs =====
use icn_core::{IcnNode, Config};
use icn_types::{Transaction, Proposal, ProposalType, ProposalCategory, CurrencyType, ProposalStatus};
use std::io::{self, Write};
use chrono::{Duration, Utc};
use log::{info, warn, error};
use uuid::Uuid;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    env_logger::init();

    let config = Config {
        shard_count: 4,
        consensus_threshold: 0.66,
        consensus_quorum: 0.51,
        network_port: 8080,
    };

    info!("Starting InterCooperative Network testnet...");
    let node = IcnNode::new(config)?;
    node.start()?;

    info!("Node started successfully. Type 'help' for available commands.");

    loop {
        print!("> ");
        io::stdout().flush().unwrap();

        let mut input = String::new();
        io::stdin().read_line(&mut input).unwrap();
        let input = input.trim();

        match input {
            "help" => print_help(),
            "exit" => break,
            "transaction" => process_transaction(&node)?,
            "proposal" => create_proposal(&node)?,
            "balance" => check_balance(&node)?,
            "identity" => create_identity(&node)?,
            "allocate" => allocate_resource(&node)?,
            "network" => get_network_stats(&node)?,
            _ => println!("Unknown command. Type 'help' for available commands."),
        }
    }

    info!("Stopping node...");
    node.stop()?;
    info!("Node stopped. Goodbye!");

    Ok(())
}

fn print_help() {
    println!("Available commands:");
    println!("  help        - Show this help message");
    println!("  transaction - Create a new transaction");
    println!("  proposal    - Create a new proposal");
    println!("  balance     - Check account balance");
    println!("  identity    - Create a new identity");
    println!("  allocate    - Allocate a resource");
    println!("  network     - Get network statistics");
    println!("  exit        - Exit the application");
}

fn process_transaction(node: &IcnNode) -> Result<(), Box<dyn std::error::Error>> {
    info!("Processing a new transaction");
    
    print!("From: ");
    io::stdout().flush()?;
    let mut from = String::new();
    io::stdin().read_line(&mut from)?;
    
    print!("To: ");
    io::stdout().flush()?;
    let mut to = String::new();
    io::stdin().read_line(&mut to)?;
    
    print!("Amount: ");
    io::stdout().flush()?;
    let mut amount_str = String::new();
    io::stdin().read_line(&mut amount_str)?;
    let amount: f64 = amount_str.trim().parse()?;

    let transaction = Transaction {
        from: from.trim().to_string(),
        to: to.trim().to_string(),
        amount,
        currency_type: CurrencyType::BasicNeeds,
        timestamp: Utc::now().timestamp(),
        signature: None,
    };

    node.process_transaction(transaction)?;
    info!("Transaction processed successfully");
    Ok(())
}

fn create_proposal(node: &IcnNode) -> Result<(), Box<dyn std::error::Error>> {
    info!("Creating a new proposal");
    
    print!("Title: ");
    io::stdout().flush()?;
    let mut title = String::new();
    io::stdin().read_line(&mut title)?;
    
    print!("Description: ");
    io::stdout().flush()?;
    let mut description = String::new();
    io::stdin().read_line(&mut description)?;
    
    print!("Proposer: ");
    io::stdout().flush()?;
    let mut proposer = String::new();
    io::stdin().read_line(&mut proposer)?;

    let proposal = Proposal {
        id: Uuid::new_v4().to_string(),
        title: title.trim().to_string(),
        description: description.trim().to_string(),
        proposer: proposer.trim().to_string(),
        created_at: Utc::now(),
        voting_ends_at: Utc::now() + Duration::days(7),
        status: ProposalStatus::Active,
        proposal_type: ProposalType::Constitutional,
        category: ProposalCategory::Economic,
        required_quorum: 0.66,
        execution_timestamp: None,
    };

    let proposal_id = node.create_proposal(proposal)?;
    info!("Proposal created successfully with ID: {}", proposal_id);
    Ok(())
}

fn check_balance(node: &IcnNode) -> Result<(), Box<dyn std::error::Error>> {
    info!("Checking balance");
    
    print!("Address: ");
    io::stdout().flush()?;
    let mut address = String::new();
    io::stdin().read_line(&mut address)?;
    
    let balance = node.get_balance(address.trim(), &CurrencyType::BasicNeeds)?;
    println!("Balance: {}", balance);
    Ok(())
}

fn create_identity(node: &IcnNode) -> Result<(), Box<dyn std::error::Error>> {
    info!("Creating a new identity");
    
    print!("Name: ");
    io::stdout().flush()?;
    let mut name = String::new();
    io::stdin().read_line(&mut name)?;

    print!("Email: ");
    io::stdout().flush()?;
    let mut email = String::new();
    io::stdin().read_line(&mut email)?;

    let mut attributes = std::collections::HashMap::new();
    attributes.insert("name".to_string(), name.trim().to_string());
    attributes.insert("email".to_string(), email.trim().to_string());

    let identity = node.create_identity(attributes)?;
    info!("Identity created successfully with ID: {}", identity.id);
    Ok(())
}

fn allocate_resource(node: &IcnNode) -> Result<(), Box<dyn std::error::Error>> {
    info!("Allocating a resource");
    
    print!("Resource ID: ");
    io::stdout().flush()?;
    let mut resource_id = String::new();
    io::stdin().read_line(&mut resource_id)?;

    print!("Amount: ");
    io::stdout().flush()?;
    let mut amount_str = String::new();
    io::stdin().read_line(&mut amount_str)?;
    let amount: u64 = amount_str.trim().parse()?;

    node.allocate_resource(resource_id.trim(), amount)?;
    info!("Resource allocated successfully");
    Ok(())
}

fn get_network_stats(node: &IcnNode) -> Result<(), Box<dyn std::error::Error>> {
    info!("Getting network statistics");
    
    let stats = node.get_network_stats()?;
    println!("Connected peers: {}", stats.connected_peers);
    println!("Total transactions: {}", stats.total_transactions);
    println!("Network uptime: {} seconds", stats.uptime.as_secs());
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_node_creation_and_basic_operations() {
        let config = Config {
            shard_count: 4,
            consensus_threshold: 0.66,
            consensus_quorum: 0.51,
            network_port: 8080,
        };

        let node = IcnNode::new(config).unwrap();
        assert!(node.start().is_ok());

        // Test create identity
        let mut attributes = std::collections::HashMap::new();
        attributes.insert("name".to_string(), "Alice".to_string());
        attributes.insert("email".to_string(), "alice@example.com".to_string());
        let identity = node.create_identity(attributes).unwrap();
        assert_eq!(identity.attributes.get("name"), Some(&"Alice".to_string()));

        // Test process transaction
        let transaction = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 50.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: Utc::now().timestamp(),
            signature: None,
        };
        assert!(node.process_transaction(transaction).is_ok());

        // Test create proposal
        let proposal = Proposal {
            id: Uuid::new_v4().to_string(),
            title: "Test Proposal".to_string(),
            description: "This is a test proposal".to_string(),
            proposer: "Alice".to_string(),
            created_at: Utc::now(),
            voting_ends_at: Utc::now() + Duration::days(7),
            status: ProposalStatus::Active,
            proposal_type: ProposalType::Constitutional,
            category: ProposalCategory::Economic,
            required_quorum: 0.66,
            execution_timestamp: None,
        };
        assert!(node.create_proposal(proposal).is_ok());

        // Test get network stats
        let stats = node.get_network_stats().unwrap();
        assert!(stats.connected_peers >= 0);

        assert!(node.stop().is_ok());
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_testnet/src/main.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_utils/Cargo.toml =====
# File: icn_utils/Cargo.toml

[package]
name = "icn_utils"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
sha2 = "0.9"
ed25519-dalek = "1.0"
rand = "0.7"
thiserror = "1.0"
serde_json = "1.0"
bincode = "1.3"
hex = "0.4"
icn_common = { path = "../icn_common" }

[dev-dependencies]
serde_json = "1.0"
===== END OF /home/matt/InterCooperative-Network/crates/icn_utils/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_utils/src/error.rs =====
use thiserror::Error;

#[derive(Error, Debug)]
pub enum IcnError {
    #[error("Blockchain error: {0}")]
    Blockchain(String),

    #[error("Consensus error: {0}")]
    Consensus(String),

    #[error("Currency error: {0}")]
    Currency(String),

    #[error("Governance error: {0}")]
    Governance(String),

    #[error("Identity error: {0}")]
    Identity(String),

    #[error("Network error: {0}")]
    Network(String),

    #[error("Node management error: {0}")]
    NodeManagement(String),

    #[error("Sharding error: {0}")]
    Sharding(String),

    #[error("Storage error: {0}")]
    Storage(String),

    #[error("VM error: {0}")]
    Vm(String),

    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),

    #[error("Serialization error: {0}")]
    Serialization(#[from] serde_json::Error),

    #[error("Database error: {0}")]
    Database(String),

    #[error("Configuration error: {0}")]
    Config(String),

    #[error("Unknown error: {0}")]
    Unknown(String),
}

pub type IcnResult<T> = std::result::Result<T, IcnError>;
===== END OF /home/matt/InterCooperative-Network/crates/icn_utils/src/error.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_utils/src/lib.rs =====
// File: icn_utils/src/lib.rs

// Import necessary modules and crates
use sha2::{Digest, Sha256};
use chrono::{DateTime, Duration, Utc};
use hex::FromHexError;

// Function to encode data to a hexadecimal string
pub fn hex_encode(data: &[u8]) -> String {
    hex::encode(data)
}

// Function to decode a hexadecimal string to data
pub fn hex_decode(s: &str) -> Result<Vec<u8>, FromHexError> {
    hex::decode(s)
}

// Function to hash data using SHA-256
pub fn hash_data(data: &[u8]) -> Vec<u8> {
    let mut hasher = Sha256::new();
    hasher.update(data);
    hasher.finalize().to_vec()
}

// Function to calculate the Merkle root from a list of hashes
pub fn calculate_merkle_root(hashes: &[Vec<u8>]) -> Vec<u8> {
    if hashes.is_empty() {
        return vec![];
    }
    if hashes.len() == 1 {
        return hashes[0].clone();
    }
    let mut next_level = Vec::new();
    for chunk in hashes.chunks(2) {
        let mut hasher = Sha256::new();
        hasher.update(&chunk[0]);
        if chunk.len() > 1 {
            hasher.update(&chunk[1]);
        } else {
            hasher.update(&chunk[0]);
        }
        next_level.push(hasher.finalize().to_vec());
    }
    calculate_merkle_root(&next_level)
}

// Time-related utilities
pub mod time {
    use super::*;

    // Function to get the current UTC time
    pub fn now() -> DateTime<Utc> {
        Utc::now()
    }

    // Function to check if a given timestamp is expired based on a duration
    pub fn is_expired(timestamp: DateTime<Utc>, duration: Duration) -> bool {
        now() > timestamp + duration
    }
}

// Cryptographic utilities
pub mod crypto {
    use ed25519_dalek::{Keypair, PublicKey, SecretKey, Signature, Signer, Verifier};
    use rand::rngs::OsRng;

    // Function to generate a new key pair (public and private keys)
    pub fn generate_keypair() -> Keypair {
        let mut csprng = OsRng {};
        Keypair::generate(&mut csprng)
    }

    // Function to sign a message with a given secret key
    pub fn sign(secret_key: &SecretKey, message: &[u8]) -> Signature {
        let keypair = Keypair {
            public: PublicKey::from(secret_key),
            secret: *secret_key,
        };
        keypair.sign(message)
    }

    // Function to verify a signature with a given public key and message
    pub fn verify(public_key: &PublicKey, message: &[u8], signature: &Signature) -> bool {
        public_key.verify(message, signature).is_ok()
    }
}

// Unit tests for the utility functions
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_hex_encode_decode() {
        let data = vec![0x12, 0x34, 0x56, 0x78];
        let encoded = hex_encode(&data);
        assert_eq!(encoded, "12345678");
        let decoded = hex_decode(&encoded).unwrap();
        assert_eq!(decoded, data);
    }

    #[test]
    fn test_hash_data() {
        let data = b"test data";
        let hash = hash_data(data);
        assert_eq!(hash.len(), 32);
    }

    #[test]
    fn test_calculate_merkle_root() {
        let hashes = vec![
            vec![1; 32],
            vec![2; 32],
            vec![3; 32],
            vec![4; 32],
        ];
        let root = calculate_merkle_root(&hashes);
        assert_eq!(root.len(), 32);

        // Test with odd number of hashes
        let odd_hashes = vec![
            vec![1; 32],
            vec![2; 32],
            vec![3; 32],
        ];
        let odd_root = calculate_merkle_root(&odd_hashes);
        assert_eq!(odd_root.len(), 32);
    }

    #[test]
    fn test_time_utils() {
        let now = time::now();
        let duration = Duration::seconds(10);
        assert!(!time::is_expired(now, duration));
        assert!(time::is_expired(now - Duration::seconds(20), duration));
    }

    #[test]
    fn test_crypto_utils() {
        let keypair = crypto::generate_keypair();
        let message = b"test message";
        let signature = crypto::sign(&keypair.secret, message);
        assert!(crypto::verify(&keypair.public, message, &signature));
        
        // Test with incorrect message
        let wrong_message = b"wrong message";
        assert!(!crypto::verify(&keypair.public, wrong_message, &signature));
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_utils/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_utils/src/types/block.rs =====
// icn_utils/src/types/block.rs

use serde::{Serialize, Deserialize};
use sha2::{Sha256, Digest};
use crate::types::transaction::Transaction;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Block {
    pub index: u64,
    pub previous_hash: String,
    pub timestamp: u64,
    pub transactions: Vec<Transaction>,
    pub hash: String,
}

impl Block {
    pub fn new(index: u64, transactions: Vec<Transaction>, previous_hash: String) -> Self {
        let timestamp = chrono::Utc::now().timestamp() as u64;
        let mut block = Block {
            index,
            previous_hash,
            timestamp,
            transactions,
            hash: String::new(),
        };
        block.hash = block.calculate_hash();
        block
    }

    pub fn calculate_hash(&self) -> String {
        let input = format!(
            "{}{}{}{:?}",
            self.index, self.previous_hash, self.timestamp, self.transactions
        );
        let mut hasher = Sha256::new();
        hasher.update(input.as_bytes());
        format!("{:x}", hasher.finalize())
    }

    pub fn genesis() -> Self {
        Block::new(0, vec![], String::from("0"))
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_utils/src/types/block.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_utils/src/types/mod.rs =====
pub mod block;
pub mod transaction;

pub use self::block::Block;
pub use self::transaction::Transaction;

use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Error {
    pub message: String,
}

pub type Result<T> = std::result::Result<T, Error>;

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, Hash)]
pub enum CurrencyType {
    BasicNeeds,
    Education,
    Environmental,
    Community,
    Volunteer,
    Storage,
    Processing,
    Energy,
    Luxury,
    Service,
    Custom(String),
    AssetToken(String),
    Bond(String),
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Currency {
    pub currency_type: CurrencyType,
    pub total_supply: f64,
    pub creation_date: DateTime<Utc>,
    pub last_issuance: DateTime<Utc>,
    pub issuance_rate: f64,
}

impl Currency {
    pub fn new(currency_type: CurrencyType, initial_supply: f64, issuance_rate: f64) -> Self {
        let now = Utc::now();
        Currency {
            currency_type,
            total_supply: initial_supply,
            creation_date: now,
            last_issuance: now,
            issuance_rate,
        }
    }

    pub fn mint(&mut self, amount: f64) -> Result<()> {
        self.total_supply += amount;
        self.last_issuance = Utc::now();
        Ok(())
    }

    pub fn burn(&mut self, amount: f64) -> Result<()> {
        if amount > self.total_supply {
            return Err(Error {
                message: "Insufficient supply to burn".to_string(),
            });
        }
        self.total_supply -= amount;
        Ok(())
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CurrencySystem {
    pub currencies: HashMap<CurrencyType, Currency>,
}

impl CurrencySystem {
    pub fn new() -> Self {
        CurrencySystem {
            currencies: HashMap::new(),
        }
    }

    pub fn add_currency(&mut self, currency_type: CurrencyType, initial_supply: f64, issuance_rate: f64) {
        let currency = Currency::new(currency_type.clone(), initial_supply, issuance_rate);
        self.currencies.insert(currency_type, currency);
    }

    pub fn get_currency(&self, currency_type: &CurrencyType) -> Option<&Currency> {
        self.currencies.get(currency_type)
    }

    pub fn get_currency_mut(&mut self, currency_type: &CurrencyType) -> Option<&mut Currency> {
        self.currencies.get_mut(currency_type)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_currency_mint_burn() {
        let mut currency = Currency::new(CurrencyType::BasicNeeds, 1000.0, 0.01);
        assert!(currency.mint(100.0).is_ok());
        assert_eq!(currency.total_supply, 1100.0);
        assert!(currency.burn(200.0).is_ok());
        assert_eq!(currency.total_supply, 900.0);
        assert!(currency.burn(1000.0).is_err());
    }

    #[test]
    fn test_currency_system() {
        let mut system = CurrencySystem::new();
        system.add_currency(CurrencyType::BasicNeeds, 1000.0, 0.01);
        system.add_currency(CurrencyType::Education, 500.0, 0.005);

        assert!(system.get_currency(&CurrencyType::BasicNeeds).is_some());
        assert!(system.get_currency(&CurrencyType::Education).is_some());
        assert!(system.get_currency(&CurrencyType::Environmental).is_none());
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_utils/src/types/mod.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_utils/src/types/transaction.rs =====
use serde::{Deserialize, Serialize};
use ed25519_dalek::{Keypair, PublicKey, Signature, Signer, Verifier};
use crate::types::CurrencyType; // Import CurrencyType from crate
use bincode;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Transaction {
    pub from: String,
    pub to: String,
    pub amount: f64,
    pub gas_limit: u64,
    pub currency_type: CurrencyType, // Add this field
    pub signature: Option<Vec<u8>>,
    pub public_key: Option<Vec<u8>>,
}

impl Transaction {
    pub fn new(from: String, to: String, amount: f64, gas_limit: u64, currency_type: CurrencyType) -> Self {
        Transaction {
            from,
            to,
            amount,
            gas_limit,
            currency_type, // Initialize the field
            signature: None,
            public_key: None,
        }
    }

    pub fn sign(&mut self, keypair: &Keypair) -> Result<(), String> {
        let message = self.to_bytes();
        let signature = keypair.sign(&message);
        self.signature = Some(signature.to_bytes().to_vec());
        self.public_key = Some(keypair.public.to_bytes().to_vec());
        Ok(())
    }

    pub fn verify(&self) -> Result<bool, String> {
        let public_key_bytes = self.public_key.as_ref().ok_or("No public key present")?;
        let signature_bytes = self.signature.as_ref().ok_or("No signature present")?;

        let public_key = PublicKey::from_bytes(public_key_bytes).map_err(|e| e.to_string())?;
        let signature = Signature::from_bytes(signature_bytes).map_err(|e| e.to_string())?;

        let message = self.to_bytes();
        Ok(public_key.verify(&message, &signature).is_ok())
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut bytes = Vec::new();
        bytes.extend_from_slice(self.from.as_bytes());
        bytes.extend_from_slice(self.to.as_bytes());
        bytes.extend_from_slice(&self.amount.to_le_bytes());
        bytes.extend_from_slice(&self.gas_limit.to_le_bytes());
        // Serialize currency_type and append to bytes
        let currency_type_bytes = bincode::serialize(&self.currency_type).unwrap();
        bytes.extend_from_slice(&currency_type_bytes);
        bytes
    }

    pub fn to_string(&self) -> String {
        format!("{}{}{}{}", self.from, self.to, self.amount, self.gas_limit)
    }

    pub fn is_signed(&self) -> bool {
        self.signature.is_some() && self.public_key.is_some()
    }

    pub fn get_fee(&self) -> f64 {
        self.gas_limit as f64 * 0.0001
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_utils/src/types/transaction.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_utils/src/utils.rs =====
// icn_utils/src/utils.rs

// Placeholder for utility functions
pub fn some_utility_function() {
    // Utility function implementation
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_utils/src/utils.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_vm/Cargo.toml =====
# File: /home/matt/InterCooperative-Network/crates/icn_vm/Cargo.toml

[package]
name = "icn_vm"
version = "0.1.0"
edition = "2021"

[dependencies]
icn_common = { path = "../icn_common" }
icn_language = { path = "../icn_language" }  # Add this line
serde = { workspace = true }
tokio = { workspace = true }
log = { workspace = true }
thiserror = { workspace = true }
chrono = { workspace = true }

[dev-dependencies]
tokio-test = "0.4"===== END OF /home/matt/InterCooperative-Network/crates/icn_vm/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_vm/src/compiler.rs =====
use crate::vm::opcode::{Opcode, Value};
use std::error::Error;

// Define the tokens that the lexer will generate from source code
#[derive(Debug, PartialEq, Clone)]
enum Token {
    Identifier(String),
    Integer(i64),
    Float(f64),
    String(String),
    True,
    False,
    If,
    Else,
    While,
    Function,
    Return,
    Vote,
    AllocateResource,
    UpdateReputation,
    CreateProposal,
    GetProposalStatus,
    Emit,
    LParen,
    RParen,
    LBrace,
    RBrace,
    Semicolon,
    Comma,
    Equals,
    Plus,
    Minus,
    Multiply,
    Divide,
    Modulo,
    DoubleEquals,
    NotEquals,
    GreaterThan,
    LessThan,
    GreaterThanEquals,
    LessThanEquals,
    And,
    Or,
    Not,
}

// Lexer for converting source code into tokens
struct Lexer {
    input: Vec<char>,
    position: usize,
}

impl Lexer {
    // Create a new lexer with the given input string
    fn new(input: &str) -> Self {
        Lexer {
            input: input.chars().collect(),
            position: 0,
        }
    }

    // Get the next token from the input
    fn next_token(&mut self) -> Option<Token> {
        self.skip_whitespace();

        if self.position >= self.input.len() {
            return None;
        }

        match self.input[self.position] {
            '(' => {
                self.position += 1;
                Some(Token::LParen)
            }
            ')' => {
                self.position += 1;
                Some(Token::RParen)
            }
            '{' => {
                self.position += 1;
                Some(Token::LBrace)
            }
            '}' => {
                self.position += 1;
                Some(Token::RBrace)
            }
            ';' => {
                self.position += 1;
                Some(Token::Semicolon)
            }
            ',' => {
                self.position += 1;
                Some(Token::Comma)
            }
            '+' => {
                self.position += 1;
                Some(Token::Plus)
            }
            '-' => {
                self.position += 1;
                Some(Token::Minus)
            }
            '*' => {
                self.position += 1;
                Some(Token::Multiply)
            }
            '/' => {
                self.position += 1;
                Some(Token::Divide)
            }
            '%' => {
                self.position += 1;
                Some(Token::Modulo)
            }
            '=' => {
                if self.peek_next() == Some('=') {
                    self.position += 2;
                    Some(Token::DoubleEquals)
                } else {
                    self.position += 1;
                    Some(Token::Equals)
                }
            }
            '!' => {
                if self.peek_next() == Some('=') {
                    self.position += 2;
                    Some(Token::NotEquals)
                } else {
                    self.position += 1;
                    Some(Token::Not)
                }
            }
            '>' => {
                if self.peek_next() == Some('=') {
                    self.position += 2;
                    Some(Token::GreaterThanEquals)
                } else {
                    self.position += 1;
                    Some(Token::GreaterThan)
                }
            }
            '<' => {
                if self.peek_next() == Some('=') {
                    self.position += 2;
                    Some(Token::LessThanEquals)
                } else {
                    self.position += 1;
                    Some(Token::LessThan)
                }
            }
            '&' => {
                if self.peek_next() == Some('&') {
                    self.position += 2;
                    Some(Token::And)
                } else {
                    None // Invalid token
                }
            }
            '|' => {
                if self.peek_next() == Some('|') {
                    self.position += 2;
                    Some(Token::Or)
                } else {
                    None // Invalid token
                }
            }
            '"' => Some(self.read_string()),
            c if c.is_alphabetic() => Some(self.read_identifier()),
            c if c.is_digit(10) => Some(self.read_number()),
            _ => None, // Invalid token
        }
    }

    // Skip whitespace characters in the input
    fn skip_whitespace(&mut self) {
        while self.position < self.input.len() && self.input[self.position].is_whitespace() {
            self.position += 1;
        }
    }

    // Peek at the next character without advancing the position
    fn peek_next(&self) -> Option<char> {
        if self.position + 1 < self.input.len() {
            Some(self.input[self.position + 1])
        } else {
            None
        }
    }

    // Read a string token from the input
    fn read_string(&mut self) -> Token {
        self.position += 1; // Skip opening quote
        let start = self.position;
        while self.position < self.input.len() && self.input[self.position] != '"' {
            self.position += 1;
        }
        let value: String = self.input[start..self.position].iter().collect();
        self.position += 1; // Skip closing quote
        Token::String(value)
    }

    // Read an identifier token from the input
    fn read_identifier(&mut self) -> Token {
        let start = self.position;
        while self.position < self.input.len() && (self.input[self.position].is_alphanumeric() || self.input[self.position] == '_') {
            self.position += 1;
        }
        let value: String = self.input[start..self.position].iter().collect();
        match value.as_str() {
            "true" => Token::True,
            "false" => Token::False,
            "if" => Token::If,
            "else" => Token::Else,
            "while" => Token::While,
            "function" => Token::Function,
            "return" => Token::Return,
            "vote" => Token::Vote,
            "allocate_resource" => Token::AllocateResource,
            "update_reputation" => Token::UpdateReputation,
            "create_proposal" => Token::CreateProposal,
            "get_proposal_status" => Token::GetProposalStatus,
            "emit" => Token::Emit,
            _ => Token::Identifier(value),
        }
    }

    // Read a number token from the input
    fn read_number(&mut self) -> Token {
        let start = self.position;
        let mut is_float = false;
        while self.position < self.input.len() && (self.input[self.position].is_digit(10) || self.input[self.position] == '.') {
            if self.input[self.position] == '.' {
                is_float = true;
            }
            self.position += 1;
        }
        let value: String = self.input[start..self.position].iter().collect();
        if is_float {
            Token::Float(value.parse().unwrap())
        } else {
            Token::Integer(value.parse().unwrap())
        }
    }
}

// Parser for converting tokens into opcodes
struct Parser {
    tokens: Vec<Token>,
    position: usize,
}

impl Parser {
    // Create a new parser with the given tokens
    fn new(tokens: Vec<Token>) -> Self {
        Parser {
            tokens,
            position: 0,
        }
    }

    // Parse the tokens into a vector of opcodes
    fn parse(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        let mut opcodes = Vec::new();
        while self.position < self.tokens.len() {
            opcodes.append(&mut self.parse_statement()?);
        }
        Ok(opcodes)
    }

    // Parse a single statement into opcodes
    fn parse_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        match self.current_token() {
            Some(Token::If) => self.parse_if_statement(),
            Some(Token::While) => self.parse_while_statement(),
            Some(Token::Function) => self.parse_function_definition(),
            Some(Token::Return) => self.parse_return_statement(),
            Some(Token::Identifier(_)) => self.parse_assignment_or_function_call(),
            Some(Token::Vote) => self.parse_vote_statement(),
            Some(Token::AllocateResource) => self.parse_allocate_resource_statement(),
            Some(Token::UpdateReputation) => self.parse_update_reputation_statement(),
            Some(Token::CreateProposal) => self.parse_create_proposal_statement(),
            Some(Token::GetProposalStatus) => self.parse_get_proposal_status_statement(),
            Some(Token::Emit) => self.parse_emit_statement(),
            _ => Err("Unexpected token in statement".into()),
        }
    }

    // Parse an if statement into opcodes
    fn parse_if_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        // Implementation for parsing if statements
        Err("If statement parsing not implemented yet".into())
    }

    // Parse a while loop into opcodes
    fn parse_while_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        // Implementation for parsing while loops
        Err("While statement parsing not implemented yet".into())
    }

    // Parse a function definition into opcodes
    fn parse_function_definition(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        // Implementation for parsing function definitions
        Err("Function definition parsing not implemented yet".into())
    }

    // Parse a return statement into opcodes
    fn parse_return_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        self.consume_token(Token::Return)?;
        let mut opcodes = self.parse_expression()?;
        opcodes.push(Opcode::Return);
        self.consume_token(Token::Semicolon)?;
        Ok(opcodes)
    }

    // Parse an assignment or function call into opcodes
    fn parse_assignment_or_function_call(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        let identifier = self.consume_identifier()?;
        match self.current_token() {
            Some(Token::Equals) => self.parse_assignment(identifier),
            Some(Token::LParen) => self.parse_function_call(identifier),
            _ => Err("Expected '=' or '(' after identifier".into()),
        }
    }

    // Parse an assignment statement into opcodes
    fn parse_assignment(&mut self, identifier: String) -> Result<Vec<Opcode>, Box<dyn Error>> {
        self.consume_token(Token::Equals)?;
        let mut opcodes = self.parse_expression()?;
        opcodes.push(Opcode::Store(identifier));
        self.consume_token(Token::Semicolon)?;
        Ok(opcodes)
    }

    // Parse a function call into opcodes
    fn parse_function_call(&mut self, identifier: String) -> Result<Vec<Opcode>, Box<dyn Error>> {
        self.consume_token(Token::LParen)?;
        let mut opcodes = Vec::new();
        while !matches!(self.current_token(), Some(Token::RParen)) {
            opcodes.append(&mut self.parse_expression()?);
            if matches!(self.current_token(), Some(Token::Comma)) {
                self.consume_token(Token::Comma)?;
            }
        }
        self.consume_token(Token::RParen)?;
        opcodes.push(Opcode::Call(identifier));
        self.consume_token(Token::Semicolon)?;
        Ok(opcodes)
    }

    // Parse a vote statement into opcodes
    fn parse_vote_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        self.consume_token(Token::Vote)?;
        self.consume_token(Token::LParen)?;
        let proposal_id = self.consume_string()?;
        self.consume_token(Token::Comma)?;
        let mut opcodes = self.parse_expression()?; // This should push a boolean onto the stack
        self.consume_token(Token::RParen)?;
        opcodes.push(Opcode::Vote(proposal_id));
        self.consume_token(Token::Semicolon)?;
        Ok(opcodes)
    }

    // Parse an allocate resource statement into opcodes
    fn parse_allocate_resource_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        self.consume_token(Token::AllocateResource)?;
        self.consume_token(Token::LParen)?;
        let resource_id = self.consume_string()?;
        self.consume_token(Token::Comma)?;
        let mut opcodes = self.parse_expression()?; // This should push an integer onto the stack
        self.consume_token(Token::RParen)?;
        opcodes.push(Opcode::AllocateResource(resource_id));
        self.consume_token(Token::Semicolon)?;
        Ok(opcodes)
    }

    // Parse an update reputation statement into opcodes
    fn parse_update_reputation_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        self.consume_token(Token::UpdateReputation)?;
        self.consume_token(Token::LParen)?;
        let address = self.consume_string()?;
        self.consume_token(Token::Comma)?;
        let mut opcodes = self.parse_expression()?; // This should push an integer onto the stack
        self.consume_token(Token::RParen)?;
        opcodes.push(Opcode::UpdateReputation(address));
        self.consume_token(Token::Semicolon)?;
        Ok(opcodes)
    }

    // Parse a create proposal statement into opcodes
    fn parse_create_proposal_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        self.consume_token(Token::CreateProposal)?;
        self.consume_token(Token::LParen)?;
        let mut opcodes = self.parse_expression()?; // This should push a string onto the stack
        self.consume_token(Token::RParen)?;
        opcodes.push(Opcode::CreateProposal);
        self.consume_token(Token::Semicolon)?;
        Ok(opcodes)
    }

    // Parse a get proposal status statement into opcodes
    fn parse_get_proposal_status_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        self.consume_token(Token::GetProposalStatus)?;
        self.consume_token(Token::LParen)?;
        let mut opcodes = self.parse_expression()?; // This should push a string onto the stack
        self.consume_token(Token::RParen)?;
        opcodes.push(Opcode::GetProposalStatus);
        self.consume_token(Token::Semicolon)?;
        Ok(opcodes)
    }

    // Parse an emit statement into opcodes
    fn parse_emit_statement(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        self.consume_token(Token::Emit)?;
        self.consume_token(Token::LParen)?;
        let event_name = self.consume_string()?;
        self.consume_token(Token::Comma)?;
        let mut opcodes = self.parse_expression()?; // This should push the event data onto the stack
        self.consume_token(Token::RParen)?;
        opcodes.push(Opcode::Emit(event_name));
        self.consume_token(Token::Semicolon)?;
        Ok(opcodes)
    }

    // Parse an expression into opcodes
    fn parse_expression(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        let mut opcodes = self.parse_term()?;

        while let Some(token) = self.current_token() {
            match token {
                Token::Plus => {
                    self.position += 1;
                    opcodes.append(&mut self.parse_term()?);
                    opcodes.push(Opcode::Add);
                }
                Token::Minus => {
                    self.position += 1;
                    opcodes.append(&mut self.parse_term()?);
                    opcodes.push(Opcode::Sub);
                }
                _ => break,
            }
        }

        Ok(opcodes)
    }

    fn parse_term(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        let mut opcodes = self.parse_factor()?;

        while let Some(token) = self.current_token() {
            match token {
                Token::Multiply => {
                    self.position += 1;
                    opcodes.append(&mut self.parse_factor()?);
                    opcodes.push(Opcode::Mul);
                }
                Token::Divide => {
                    self.position += 1;
                    opcodes.append(&mut self.parse_factor()?);
                    opcodes.push(Opcode::Div);
                }
                _ => break,
            }
        }

        Ok(opcodes)
    }

    fn parse_factor(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        let token = self.current_token().cloned();
        match token {
            Some(Token::Integer(value)) => {
                self.position += 1;
                Ok(vec![Opcode::Push(Value::Int(value))])
            }
            Some(Token::Float(value)) => {
                self.position += 1;
                Ok(vec![Opcode::Push(Value::Float(value))])
            }
            Some(Token::String(value)) => {
                self.position += 1;
                Ok(vec![Opcode::Push(Value::String(value))])
            }
            Some(Token::True) => {
                self.position += 1;
                Ok(vec![Opcode::Push(Value::Bool(true))])
            }
            Some(Token::False) => {
                self.position += 1;
                Ok(vec![Opcode::Push(Value::Bool(false))])
            }
            Some(Token::Identifier(name)) => {
                self.position += 1;
                Ok(vec![Opcode::Load(name)])
            }
            Some(Token::LParen) => {
                self.position += 1;
                let expr = self.parse_expression()?;
                self.consume_token(Token::RParen)?;
                Ok(expr)
            }
            _ => Err("Unexpected token in expression".into()),
        }
    }

    // Consume the next token if it matches the expected token
    fn consume_token(&mut self, expected: Token) -> Result<(), Box<dyn Error>> {
        if self.current_token() == Some(&expected) {
            self.position += 1;
            Ok(())
        } else {
            Err(format!("Unexpected token: expected {:?}, found {:?}", expected, self.current_token()).into())
        }
    }

    // Consume an identifier token
    fn consume_identifier(&mut self) -> Result<String, Box<dyn Error>> {
        if let Some(Token::Identifier(name)) = self.current_token().cloned() {
            self.position += 1;
            Ok(name)
        } else {
            Err(format!("Expected identifier, found {:?}", self.current_token()).into())
        }
    }

    // Consume a string token
    fn consume_string(&mut self) -> Result<String, Box<dyn Error>> {
        if let Some(Token::String(value)) = self.current_token().cloned() {
            self.position += 1;
            Ok(value)
        } else {
            Err(format!("Expected string, found {:?}", self.current_token()).into())
        }
    }

    // Get the current token
    fn current_token(&self) -> Option<&Token> {
        self.tokens.get(self.position)
    }
}

// Compiler for converting source code into opcodes
pub struct CSCLCompiler {
    lexer: Lexer,
}

impl CSCLCompiler {
    // Create a new compiler with the given input source code
    pub fn new(input: &str) -> Self {
        CSCLCompiler {
            lexer: Lexer::new(input),
        }
    }

    // Compile the source code into a vector of opcodes
    pub fn compile(&mut self) -> Result<Vec<Opcode>, Box<dyn Error>> {
        let tokens = self.lexer.tokens();
        let mut parser = Parser::new(tokens);
        parser.parse()
    }
}

impl Lexer {
    // Get all tokens from the input
    fn tokens(&mut self) -> Vec<Token> {
        let mut tokens = Vec::new();
        while let Some(token) = self.next_token() {
            tokens.push(token);
        }
        tokens
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_lexer() {
        let input = "function test(x, y) { return x + y; }";
        let mut lexer = Lexer::new(input);
        let tokens = lexer.tokens();

        assert_eq!(tokens, vec![
            Token::Function,
            Token::Identifier("test".to_string()),
            Token::LParen,
            Token::Identifier("x".to_string()),
            Token::Comma,
            Token::Identifier("y".to_string()),
            Token::RParen,
            Token::LBrace,
            Token::Return,
            Token::Identifier("x".to_string()),
            Token::Plus,
            Token::Identifier("y".to_string()),
            Token::Semicolon,
            Token::RBrace,
        ]);
    }

    #[test]
    fn test_compiler() {
        let input = "x = 5 + 3 * 2; y = (10 - 4) / 2;";
        let mut compiler = CSCLCompiler::new(input);
        let opcodes = compiler.compile().unwrap();

        assert_eq!(opcodes, vec![
            Opcode::Push(Value::Int(5)),
            Opcode::Push(Value::Int(3)),
            Opcode::Push(Value::Int(2)),
            Opcode::Mul,
            Opcode::Add,
            Opcode::Store("x".to_string()),
            Opcode::Push(Value::Int(10)),
            Opcode::Push(Value::Int(4)),
            Opcode::Sub,
            Opcode::Push(Value::Int(2)),
            Opcode::Div,
            Opcode::Store("y".to_string()),
        ]);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_vm/src/compiler.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_vm/src/coop_vm.rs =====
use super::opcode::{Opcode, Value};
use std::collections::HashMap;

pub struct CoopVM {
    stack: Vec<Value>,
    memory: HashMap<String, Value>,
    program: Vec<Opcode>,
    pc: usize,
}

impl CoopVM {
    pub fn new(program: Vec<Opcode>) -> Self {
        CoopVM {
            stack: Vec::new(),
            memory: HashMap::new(),
            program,
            pc: 0,
        }
    }

    pub fn load_program(&mut self, program: Vec<Opcode>) {
        self.program = program;
        self.pc = 0;
    }

    pub fn run(&mut self) -> Result<(), String> {
        while self.pc < self.program.len() {
            self.execute_instruction()?;
            self.pc += 1;
        }
        Ok(())
    }

    fn execute_instruction(&mut self) -> Result<(), String> {
        let opcode = self.program[self.pc].clone();
        match opcode {
            Opcode::Push(value) => self.stack.push(value),
            Opcode::Pop => {
                self.stack.pop().ok_or("Stack underflow")?;
            }
            Opcode::Add => self.binary_op(|a, b| a + b)?,
            Opcode::Sub => self.binary_op(|a, b| a - b)?,
            Opcode::Mul => self.binary_op(|a, b| a * b)?,
            Opcode::Div => self.binary_op(|a, b| a / b)?,
            Opcode::Eq => self.compare_op(|a, b| a == b)?,
            Opcode::Lt => self.compare_op(|a, b| a < b)?,
            Opcode::Gt => self.compare_op(|a, b| a > b)?,
            Opcode::And => self.logic_op(|a, b| a && b)?,
            Opcode::Or => self.logic_op(|a, b| a || b)?,
            Opcode::Not => {
                let a = self.pop_bool()?;
                self.stack.push(Value::Bool(!a));
            }
            Opcode::Return => return Ok(()), // For now, just return
            Opcode::Store(name) => {
                let value = self.stack.pop().ok_or("Stack underflow")?;
                self.memory.insert(name, value);
            }
            Opcode::Load(name) => {
                let value = self.memory.get(&name).ok_or("Variable not found")?.clone();
                self.stack.push(value);
            }
            Opcode::Call(_) => return Err("Function calls not implemented yet".to_string()),
            Opcode::Vote(proposal_id) => {
                let vote = self.pop_bool()?;
                println!("Voting {} on proposal {}", if vote { "Yes" } else { "No" }, proposal_id);
            }
            Opcode::AllocateResource(resource_id) => {
                let amount = self.pop_int()?;
                println!("Allocating {} units of resource {}", amount, resource_id);
            }
            Opcode::UpdateReputation(address) => {
                let change = self.pop_int()?;
                println!("Updating reputation of {} by {}", address, change);
            }
            Opcode::CreateProposal => {
                let description = self.pop_string()?;
                println!("Creating proposal: {}", description);
                self.stack.push(Value::String("new_proposal_id".to_string()));
            }
            Opcode::GetProposalStatus => {
                let proposal_id = self.pop_string()?;
                println!("Getting status of proposal: {}", proposal_id);
                self.stack.push(Value::String("Active".to_string()));
            }
            Opcode::Emit(event_name) => {
                let event_data = self.stack.pop().ok_or("Stack underflow")?;
                println!("Emitting event {}: {:?}", event_name, event_data);
            }
        }
        Ok(())
    }

    fn binary_op<F>(&mut self, op: F) -> Result<(), String>
    where
        F: Fn(i64, i64) -> i64,
    {
        let b = self.pop_int()?;
        let a = self.pop_int()?;
        self.stack.push(Value::Int(op(a, b)));
        Ok(())
    }

    fn compare_op<F>(&mut self, op: F) -> Result<(), String>
    where
        F: Fn(&Value, &Value) -> bool,
    {
        let b = self.stack.pop().ok_or("Stack underflow")?;
        let a = self.stack.pop().ok_or("Stack underflow")?;
        self.stack.push(Value::Bool(op(&a, &b)));
        Ok(())
    }

    fn logic_op<F>(&mut self, op: F) -> Result<(), String>
    where
        F: Fn(bool, bool) -> bool,
    {
        let b = self.pop_bool()?;
        let a = self.pop_bool()?;
        self.stack.push(Value::Bool(op(a, b)));
        Ok(())
    }

    fn pop_int(&mut self) -> Result<i64, String> {
        match self.stack.pop().ok_or("Stack underflow")? {
            Value::Int(i) => Ok(i),
            _ => Err("Expected integer value".to_string()),
        }
    }

    fn pop_bool(&mut self) -> Result<bool, String> {
        match self.stack.pop().ok_or("Stack underflow")? {
            Value::Bool(b) => Ok(b),
            _ => Err("Expected boolean value".to_string()),
        }
    }

    fn pop_string(&mut self) -> Result<String, String> {
        match self.stack.pop().ok_or("Stack underflow")? {
            Value::String(s) => Ok(s),
            _ => Err("Expected string value".to_string()),
        }
    }

    pub fn get_stack(&self) -> &Vec<Value> {
        &self.stack
    }

    pub fn get_memory(&self) -> &HashMap<String, Value> {
        &self.memory
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_vm/src/coop_vm.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_vm/src/lib.rs =====
use icn_common::{IcnResult, IcnError};
use std::collections::HashMap;

#[derive(Clone, Debug, PartialEq)]
pub enum Value {
    Int(i64),
    Float(f64),
    Bool(bool),
    String(String),
}

#[derive(Clone, Debug)]
pub enum Opcode {
    Push(Value),
    Pop,
    Add,
    Sub,
    Mul,
    Div,
    Eq,
    Neq,
    Lt,
    Lte,
    Gt,
    Gte,
    And,
    Or,
    Not,
    Store(String),
    Load(String),
    Call(String),
    JumpIf(usize),
    Jump(usize),
}

pub struct CoopVM {
    stack: Vec<Value>,
    memory: HashMap<String, Value>,
    program: Vec<Opcode>,
    pc: usize,
    context: Option<ContractContext>,
}

pub struct ContractContext {
    pub balances: HashMap<String, f64>,
    pub votes: HashMap<String, bool>,
    pub reputation: HashMap<String, i32>,
}

impl CoopVM {
    pub fn new(program: Vec<Opcode>) -> Self {
        CoopVM {
            stack: Vec::new(),
            memory: HashMap::new(),
            program,
            pc: 0,
            context: None,
        }
    }

    pub fn load_program(&mut self, program: Vec<Opcode>) {
        self.program = program;
        self.pc = 0;
    }

    pub fn set_context(&mut self, context: &ContractContext) {
        self.context = Some(ContractContext {
            balances: context.balances.clone(),
            votes: context.votes.clone(),
            reputation: context.reputation.clone(),
        });
    }

    pub fn run(&mut self) -> IcnResult<()> {
        while self.pc < self.program.len() {
            self.execute_instruction()?;
            self.pc += 1;
        }
        Ok(())
    }

    fn execute_instruction(&mut self) -> IcnResult<()> {
        let instruction = &self.program[self.pc];
        match instruction {
            Opcode::Push(value) => self.stack.push(value.clone()),
            Opcode::Pop => { self.stack.pop().ok_or(IcnError::VM("Stack underflow".into()))? ; }
            Opcode::Add => self.binary_op(|a, b| a + b)?,
            Opcode::Sub => self.binary_op(|a, b| a - b)?,
            Opcode::Mul => self.binary_op(|a, b| a * b)?,
            Opcode::Div => self.binary_op(|a, b| a / b)?,
            Opcode::Eq => self.compare_op(|a, b| a == b)?,
            Opcode::Neq => self.compare_op(|a, b| a != b)?,
            Opcode::Lt => self.compare_op(|a, b| a < b)?,
            Opcode::Lte => self.compare_op(|a, b| a <= b)?,
            Opcode::Gt => self.compare_op(|a, b| a > b)?,
            Opcode::Gte => self.compare_op(|a, b| a >= b)?,
            Opcode::And => self.logic_op(|a, b| a && b)?,
            Opcode::Or => self.logic_op(|a, b| a || b)?,
            Opcode::Not => {
                let a = self.pop_bool()?;
                self.stack.push(Value::Bool(!a));
            }
            Opcode::Store(name) => {
                let value = self.stack.pop().ok_or(IcnError::VM("Stack underflow".into()))?;
                self.memory.insert(name.clone(), value);
            }
            Opcode::Load(name) => {
                let value = self.memory.get(name).ok_or(IcnError::VM("Variable not found".into()))?.clone();
                self.stack.push(value);
            }
            Opcode::Call(function) => {
                let result = self.execute_built_in(function)?;
                if let Some(value) = result {
                    self.stack.push(value);
                }
            }
            Opcode::JumpIf(target) => {
                if self.pop_bool()? {
                    self.pc = *target - 1; // -1 because pc will be incremented after this instruction
                }
            }
            Opcode::Jump(target) => {
                self.pc = *target - 1; // -1 because pc will be incremented after this instruction
            }
        }
        Ok(())
    }

    fn binary_op<F>(&mut self, op: F) -> IcnResult<()>
    where
        F: Fn(f64, f64) -> f64,
    {
        let b = self.pop_number()?;
        let a = self.pop_number()?;
        self.stack.push(Value::Float(op(a, b)));
        Ok(())
    }

    fn compare_op<F>(&mut self, op: F) -> IcnResult<()>
    where
        F: Fn(f64, f64) -> bool,
    {
        let b = self.pop_number()?;
        let a = self.pop_number()?;
        self.stack.push(Value::Bool(op(a, b)));
        Ok(())
    }

    fn logic_op<F>(&mut self, op: F) -> IcnResult<()>
    where
        F: Fn(bool, bool) -> bool,
    {
        let b = self.pop_bool()?;
        let a = self.pop_bool()?;
        self.stack.push(Value::Bool(op(a, b)));
        Ok(())
    }

    fn pop_number(&mut self) -> IcnResult<f64> {
        match self.stack.pop().ok_or(IcnError::VM("Stack underflow".into()))? {
            Value::Int(i) => Ok(i as f64),
            Value::Float(f) => Ok(f),
            _ => Err(IcnError::VM("Expected number".into())),
        }
    }

    fn pop_bool(&mut self) -> IcnResult<bool> {
        match self.stack.pop().ok_or(IcnError::VM("Stack underflow".into()))? {
            Value::Bool(b) => Ok(b),
            _ => Err(IcnError::VM("Expected boolean".into())),
        }
    }

    fn pop_string(&mut self) -> IcnResult<String> {
        match self.stack.pop().ok_or(IcnError::VM("Stack underflow".into()))? {
            Value::String(s) => Ok(s),
            _ => Err(IcnError::VM("Expected string".into())),
        }
    }

    fn execute_built_in(&mut self, function: &str) -> IcnResult<Option<Value>> {
        match function {
            "transfer" => self.transfer(),
            "vote" => self.vote(),
            "get_balance" => self.get_balance(),
            "update_reputation" => self.update_reputation(),
            _ => Err(IcnError::VM(format!("Unknown built-in function: {}", function))),
        }
    }

    fn transfer(&mut self) -> IcnResult<Option<Value>> {
        let amount = self.pop_number()?;
        let to = self.pop_string()?;
        let from = self.pop_string()?;

        let context = self.context.as_mut().ok_or(IcnError::VM("No context set".into()))?;
        
        let from_balance = context.balances.entry(from.clone()).or_insert(0.0);
        if *from_balance < amount {
            return Err(IcnError::VM("Insufficient balance".into()));
        }
        *from_balance -= amount;

        let to_balance = context.balances.entry(to.clone()).or_insert(0.0);
        *to_balance += amount;

        Ok(None)
    }

    fn vote(&mut self) -> IcnResult<Option<Value>> {
        let vote = self.pop_bool()?;
        let proposal = self.pop_string()?;

        let context = self.context.as_mut().ok_or(IcnError::VM("No context set".into()))?;
        context.votes.insert(proposal, vote);

        Ok(None)
    }

    fn get_balance(&mut self) -> IcnResult<Option<Value>> {
        let address = self.pop_string()?;

        let context = self.context.as_ref().ok_or(IcnError::VM("No context set".into()))?;
        let balance = *context.balances.get(&address).unwrap_or(&0.0);

        Ok(Some(Value::Float(balance)))
    }

    fn update_reputation(&mut self) -> IcnResult<Option<Value>> {
        let change = self.pop_number()? as i32;
        let address = self.pop_string()?;

        let context = self.context.as_mut().ok_or(IcnError::VM("No context set".into()))?;
        let reputation = context.reputation.entry(address).or_insert(0);
        *reputation += change;

        Ok(None)
    }

    pub fn get_stack(&self) -> &Vec<Value> {
        &self.stack
    }

    pub fn get_memory(&self) -> &HashMap<String, Value> {
        &self.memory
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_operations() {
        let program = vec![
            Opcode::Push(Value::Int(5)),
            Opcode::Push(Value::Int(3)),
            Opcode::Add,
            Opcode::Push(Value::Int(2)),
            Opcode::Mul,
        ];

        let mut vm = CoopVM::new(program);
        vm.run().unwrap();

        assert_eq!(vm.stack, vec![Value::Float(16.0)]);
    }

    #[test]
    fn test_transfer() {
        let program = vec![
            Opcode::Push(Value::String("Alice".to_string())),
            Opcode::Push(Value::String("Bob".to_string())),
            Opcode::Push(Value::Float(50.0)),
            Opcode::Call("transfer".to_string()),
            Opcode::Push(Value::String("Alice".to_string())),
            Opcode::Call("get_balance".to_string()),
            Opcode::Push(Value::String("Bob".to_string())),
            Opcode::Call("get_balance".to_string()),
        ];

        let mut vm = CoopVM::new(program);
        let mut context = ContractContext {
            balances: HashMap::new(),
            votes: HashMap::new(),
            reputation: HashMap::new(),
        };
        context.balances.insert("Alice".to_string(), 100.0);
        context.balances.insert("Bob".to_string(), 0.0);
        vm.set_context(&context);

        vm.run().unwrap();

        assert_eq!(vm.stack, vec![Value::Float(50.0), Value::Float(50.0)]);
    }

    #[test]
    fn test_voting() {
        let program = vec![
            Opcode::Push(Value::String("proposal1".to_string())),
            Opcode::Push(Value::Bool(true)),
            Opcode::Call("vote".to_string()),
            Opcode::Push(Value::String("proposal2".to_string())),
            Opcode::Push(Value::Bool(false)),
            Opcode::Call("vote".to_string()),
        ];

        let mut vm = CoopVM::new(program);
        let context = ContractContext {
            balances: HashMap::new(),
            votes: HashMap::new(),
            reputation: HashMap::new(),
        };
        vm.set_context(&context);

        vm.run().unwrap();

        assert_eq!(vm.context.unwrap().votes.len(), 2);
        assert_eq!(vm.context.unwrap().votes.get("proposal1"), Some(&true));
        assert_eq!(vm.context.unwrap().votes.get("proposal2"), Some(&false));
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_vm/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_vm/src/opcode.rs =====
#[derive(Debug, Clone, PartialEq, PartialOrd)] // Add PartialOrd here
pub enum Value {
    Int(i64),
    Float(f64),
    Bool(bool),
    String(String),
}

#[derive(Debug, Clone, PartialEq)]
pub enum Opcode {
    Push(Value),
    Pop,
    Add,
    Sub,
    Mul,
    Div,
    Eq,
    Lt,
    Gt,
    And,
    Or,
    Not,
    Return,
    Store(String),
    Load(String),
    Call(String),
    Vote(String),
    AllocateResource(String),
    UpdateReputation(String),
    CreateProposal,
    GetProposalStatus,
    Emit(String),
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_vm/src/opcode.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_vm/src/smart_contract.rs =====
// File: icn_vm/src/smart_contract.rs

use icn_common::{IcnResult, IcnError, Transaction, CurrencyType};
use std::collections::HashMap;
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct SmartContract {
    pub id: String,
    pub code: String,
    pub state: HashMap<String, Value>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub enum Value {
    Int(i64),
    Float(f64),
    Bool(bool),
    String(String),
    List(Vec<Value>),
    Map(HashMap<String, Value>),
}

pub struct SmartContractExecutor {
    contracts: HashMap<String, SmartContract>,
}

impl SmartContractExecutor {
    pub fn new() -> Self {
        SmartContractExecutor {
            contracts: HashMap::new(),
        }
    }

    pub fn deploy_contract(&mut self, id: String, code: String) -> IcnResult<()> {
        if self.contracts.contains_key(&id) {
            return Err(IcnError::VM(format!("Contract with id {} already exists", id)));
        }

        let contract = SmartContract {
            id: id.clone(),
            code,
            state: HashMap::new(),
        };

        self.contracts.insert(id, contract);
        Ok(())
    }

    pub fn execute_contract(&mut self, id: &str, function: &str, args: Vec<Value>) -> IcnResult<Value> {
        let contract = self.contracts.get_mut(id)
            .ok_or_else(|| IcnError::VM(format!("Contract with id {} not found", id)))?;

        // In a real implementation, you would parse and execute the contract code here.
        // For this example, we'll simulate a simple token transfer function.
        match function {
            "transfer" => self.execute_transfer(contract, args),
            _ => Err(IcnError::VM(format!("Unknown function: {}", function))),
        }
    }

    fn execute_transfer(&mut self, contract: &mut SmartContract, args: Vec<Value>) -> IcnResult<Value> {
        if args.len() != 3 {
            return Err(IcnError::VM("transfer function requires 3 arguments: from, to, and amount".into()));
        }

        let from = match &args[0] {
            Value::String(s) => s,
            _ => return Err(IcnError::VM("'from' argument must be a string".into())),
        };

        let to = match &args[1] {
            Value::String(s) => s,
            _ => return Err(IcnError::VM("'to' argument must be a string".into())),
        };

        let amount = match &args[2] {
            Value::Int(n) => *n as f64,
            Value::Float(n) => *n,
            _ => return Err(IcnError::VM("'amount' argument must be a number".into())),
        };

        let balances = contract.state.entry("balances".to_string())
            .or_insert_with(|| Value::Map(HashMap::new()));

        if let Value::Map(ref mut balance_map) = balances {
            let from_balance = balance_map.entry(from.to_string())
                .or_insert(Value::Float(0.0));
            
            let to_balance = balance_map.entry(to.to_string())
                .or_insert(Value::Float(0.0));

            if let (Value::Float(from_amount), Value::Float(to_amount)) = (from_balance, to_balance) {
                if *from_amount < amount {
                    return Err(IcnError::VM("Insufficient balance for transfer".into()));
                }

                *from_amount -= amount;
                *to_amount += amount;

                Ok(Value::Bool(true))
            } else {
                Err(IcnError::VM("Invalid balance type".into()))
            }
        } else {
            Err(IcnError::VM("Invalid state structure".into()))
        }
    }

    pub fn get_contract_state(&self, id: &str) -> IcnResult<&HashMap<String, Value>> {
        self.contracts.get(id)
            .map(|contract| &contract.state)
            .ok_or_else(|| IcnError::VM(format!("Contract with id {} not found", id)))
    }

    pub fn update_contract_state(&mut self, id: &str, key: String, value: Value) -> IcnResult<()> {
        let contract = self.contracts.get_mut(id)
            .ok_or_else(|| IcnError::VM(format!("Contract with id {} not found", id)))?;

        contract.state.insert(key, value);
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_smart_contract_deployment_and_execution() {
        let mut executor = SmartContractExecutor::new();

        // Deploy a simple token contract
        let contract_id = "token_contract".to_string();
        let contract_code = r#"
            function transfer(from, to, amount) {
                // Transfer logic is implemented in the executor
            }
        "#.to_string();

        executor.deploy_contract(contract_id.clone(), contract_code).unwrap();

        // Initialize some balances
        executor.update_contract_state(&contract_id, "balances".to_string(), Value::Map(HashMap::new())).unwrap();
        let mut initial_balances = HashMap::new();
        initial_balances.insert("Alice".to_string(), Value::Float(100.0));
        initial_balances.insert("Bob".to_string(), Value::Float(50.0));
        executor.update_contract_state(&contract_id, "balances".to_string(), Value::Map(initial_balances)).unwrap();

        // Execute a transfer
        let result = executor.execute_contract(
            &contract_id,
            "transfer",
            vec![
                Value::String("Alice".to_string()),
                Value::String("Bob".to_string()),
                Value::Float(30.0),
            ],
        ).unwrap();

        assert_eq!(result, Value::Bool(true));

        // Check the updated balances
        let state = executor.get_contract_state(&contract_id).unwrap();
        if let Value::Map(balances) = &state["balances"] {
            assert_eq!(balances["Alice"], Value::Float(70.0));
            assert_eq!(balances["Bob"], Value::Float(80.0));
        } else {
            panic!("Invalid state structure");
        }

        // Test insufficient balance
        let result = executor.execute_contract(
            &contract_id,
            "transfer",
            vec![
                Value::String("Alice".to_string()),
                Value::String("Bob".to_string()),
                Value::Float(100.0),
            ],
        );

        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err().to_string(),
            IcnError::VM("Insufficient balance for transfer".into()).to_string()
        );
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_vm/src/smart_contract.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_vm/src/templates.rs =====
===== END OF /home/matt/InterCooperative-Network/crates/icn_vm/src/templates.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_vm/src/vm.rs =====
// File: src/vm.rs

use std::collections::HashMap;
use std::fmt;

#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub enum Value {
    Int(i64),
    Float(f64),
    Bool(bool),
    String(String),
    Address(String),
    List(Vec<Value>),
}

impl fmt::Display for Value {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Value::Int(i) => write!(f, "{}", i),
            Value::Float(fl) => write!(f, "{}", fl),
            Value::Bool(b) => write!(f, "{}", b),
            Value::String(s) => write!(f, "\"{}\"", s),
            Value::Address(a) => write!(f, "Address({})", a),
            Value::List(l) => write!(f, "{:?}", l),
        }
    }
}

#[derive(Debug, Clone)]
pub enum Opcode {
    Push(Value),
    Pop,
    Add,
    Sub,
    Mul,
    Div,
    Mod,
    Eq,
    Neq,
    Gt,
    Lt,
    Gte,
    Lte,
    And,
    Or,
    Not,
    Store(String),
    Load(String),
    JumpIf(usize),
    Jump(usize),
    Call(String),
    Return,
    CreateList,
    AppendList,
    GetListItem,
    SetListItem,
    Vote(String),
    AllocateResource(String),
    UpdateReputation(String),
    CreateProposal,
    GetProposalStatus,
    Emit(String),
}

pub struct CoopVM {
    stack: Vec<Value>,
    memory: HashMap<String, Value>,
    program: Vec<Opcode>,
    pc: usize,
    call_stack: Vec<usize>,
    functions: HashMap<String, usize>,
}

impl CoopVM {
    pub fn new(program: Vec<Opcode>) -> Self {
        CoopVM {
            stack: Vec::new(),
            memory: HashMap::new(),
            program,
            pc: 0,
            call_stack: Vec::new(),
            functions: HashMap::new(),
        }
    }

    pub fn run(&mut self) -> Result<(), String> {
        while self.pc < self.program.len() {
            self.execute_instruction()?;
            self.pc += 1;
        }
        Ok(())
    }

    fn execute_instruction(&mut self) -> Result<(), String> {
        let current_instruction = &self.program[self.pc].clone();
        match current_instruction {
            Opcode::Push(value) => self.stack.push(value.clone()),
            Opcode::Pop => {
                self.stack.pop().ok_or("Stack underflow")?;
            }
            Opcode::Add => self.binary_op(|a, b| a + b)?,
            Opcode::Sub => self.binary_op(|a, b| a - b)?,
            Opcode::Mul => self.binary_op(|a, b| a * b)?,
            Opcode::Div => self.binary_op(|a, b| a / b)?,
            Opcode::Mod => self.binary_op(|a, b| a % b)?,
            Opcode::Eq => self.compare_op(|a, b| a == b)?,
            Opcode::Neq => self.compare_op(|a, b| a != b)?,
            Opcode::Gt => self.compare_op(|a, b| a > b)?,
            Opcode::Lt => self.compare_op(|a, b| a < b)?,
            Opcode::Gte => self.compare_op(|a, b| a >= b)?,
            Opcode::Lte => self.compare_op(|a, b| a <= b)?,
            Opcode::And => self.logic_op(|a, b| a && b)?,
            Opcode::Or => self.logic_op(|a, b| a || b)?,
            Opcode::Not => {
                let a = self.pop_bool()?;
                self.stack.push(Value::Bool(!a));
            }
            Opcode::Store(name) => {
                let value = self.stack.pop().ok_or("Stack underflow")?;
                self.memory.insert(name.clone(), value);
            }
            Opcode::Load(name) => {
                let value = self.memory.get(name).ok_or("Variable not found")?.clone();
                self.stack.push(value);
            }
            Opcode::JumpIf(target) => {
                if self.pop_bool()? {
                    self.pc = *target - 1;
                }
            }
            Opcode::Jump(target) => {
                self.pc = *target - 1;
            }
            Opcode::Call(func_name) => {
                let func_pc = self.functions.get(func_name).ok_or("Function not found")?;
                self.call_stack.push(self.pc);
                self.pc = *func_pc - 1;
            }
            Opcode::Return => {
                self.pc = self.call_stack.pop().ok_or("Return without call")?;
            }
            Opcode::CreateList => {
                self.stack.push(Value::List(Vec::new()));
            }
            Opcode::AppendList => {
                let value = self.stack.pop().ok_or("Stack underflow")?;
                if let Some(Value::List(list)) = self.stack.last_mut() {
                    list.push(value);
                } else {
                    return Err("Expected list on top of stack".to_string());
                }
            }
            Opcode::GetListItem => {
                let index = self.pop_int()?;
                if let Some(Value::List(list)) = self.stack.pop() {
                    let item = list.get(index as usize).ok_or("List index out of bounds")?.clone();
                    self.stack.push(item);
                } else {
                    return Err("Expected list on top of stack".to_string());
                }
            }
            Opcode::SetListItem => {
                let value = self.stack.pop().ok_or("Stack underflow")?;
                let index = self.pop_int()?;
                if let Some(Value::List(list)) = self.stack.last_mut() {
                    if (index as usize) < list.len() {
                        list[index as usize] = value;
                    } else {
                        return Err("List index out of bounds".to_string());
                    }
                } else {
                    return Err("Expected list on top of stack".to_string());
                }
            }
            Opcode::Vote(proposal_id) => {
                let vote = self.pop_bool()?;
                println!("Voting {} on proposal {}", if vote { "Yes" } else { "No" }, proposal_id);
            }
            Opcode::AllocateResource(resource_id) => {
                let amount = self.pop_int()?;
                println!("Allocating {} units of resource {}", amount, resource_id);
            }
            Opcode::UpdateReputation(address) => {
                let change = self.pop_int()?;
                println!("Updating reputation of {} by {}", address, change);
            }
            Opcode::CreateProposal => {
                let description = self.pop_string()?;
                println!("Creating proposal: {}", description);
                self.stack.push(Value::String("new_proposal_id".to_string()));
            }
            Opcode::GetProposalStatus => {
                let proposal_id = self.pop_string()?;
                println!("Getting status of proposal: {}", proposal_id);
                self.stack.push(Value::String("Active".to_string()));
            }
            Opcode::Emit(event_name) => {
                let event_data = self.stack.pop().ok_or("Stack underflow")?;
                println!("Emitting event {}: {}", event_name, event_data);
            }
        }
        Ok(())
    }

    fn binary_op<F>(&mut self, op: F) -> Result<(), String>
    where
        F: Fn(i64, i64) -> i64,
    {
        let b = self.pop_int()?;
        let a = self.pop_int()?;
        self.stack.push(Value::Int(op(a, b)));
        Ok(())
    }

    fn compare_op<F>(&mut self, op: F) -> Result<(), String>
    where
        F: Fn(&Value, &Value) -> bool,
    {
        let b = self.stack.pop().ok_or("Stack underflow")?;
        let a = self.stack.pop().ok_or("Stack underflow")?;
        self.stack.push(Value::Bool(op(&a, &b)));
        Ok(())
    }

    fn logic_op<F>(&mut self, op: F) -> Result<(), String>
    where
        F: Fn(bool, bool) -> bool,
    {
        let b = self.pop_bool()?;
        let a = self.pop_bool()?;
        self.stack.push(Value::Bool(op(a, b)));
        Ok(())
    }

    fn pop_int(&mut self) -> Result<i64, String> {
        match self.stack.pop().ok_or("Stack underflow")? {
            Value::Int(i) => Ok(i),
            _ => Err("Expected integer value".to_string()),
        }
    }

    fn pop_bool(&mut self) -> Result<bool, String> {
        match self.stack.pop().ok_or("Stack underflow")? {
            Value::Bool(b) => Ok(b),
            _ => Err("Expected boolean value".to_string()),
        }
    }

    fn pop_string(&mut self) -> Result<String, String> {
        match self.stack.pop().ok_or("Stack underflow")? {
            Value::String(s) => Ok(s),
            _ => Err("Expected string value".to_string()),
        }
    }

    pub fn register_function(&mut self, name: String, pc: usize) {
        self.functions.insert(name, pc);
    }

    pub fn get_stack(&self) -> &Vec<Value> {
        &self.stack
    }

    pub fn get_memory(&self) -> &HashMap<String, Value> {
        &self.memory
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_operations() {
        let program = vec![
            Opcode::Push(Value::Int(5)),
            Opcode::Push(Value::Int(3)),
            Opcode::Add,
            Opcode::Push(Value::Int(2)),
            Opcode::Mul,
        ];

        let mut vm = CoopVM::new(program);
        vm.run().unwrap();

        assert_eq!(vm.stack, vec![Value::Int(16)]);
    }

    #[test]
    fn test_store_and_load() {
        let program = vec![
            Opcode::Push(Value::Int(42)),
            Opcode::Store("x".to_string()),
            Opcode::Push(Value::Int(10)),
            Opcode::Load("x".to_string()),
            Opcode::Add,
        ];

        let mut vm = CoopVM::new(program);
        vm.run().unwrap();

        assert_eq!(vm.stack, vec![Value::Int(52)]);
    }

    #[test]
    fn test_conditional_jump() {
        let program = vec![
            Opcode::Push(Value::Bool(true)),
            Opcode::JumpIf(3),
            Opcode::Push(Value::Int(1)),
            Opcode::Push(Value::Int(2)),
            Opcode::Add,
        ];

        let mut vm = CoopVM::new(program);
        vm.run().unwrap();

        assert_eq!(vm.stack, vec![Value::Int(2)]);
    }

    #[test]
    fn test_list_operations() {
        let program = vec![
            Opcode::CreateList,
            Opcode::Push(Value::Int(1)),
            Opcode::AppendList,
            Opcode::Push(Value::Int(2)),
            Opcode::AppendList,
            Opcode::Push(Value::Int(0)),
            Opcode::GetListItem,
        ];

        let mut vm = CoopVM::new(program);
        vm.run().unwrap();

        assert_eq!(vm.stack, vec![Value::List(vec![Value::Int(1), Value::Int(2)]), Value::Int(1)]);
    }

    #[test]
    fn test_cooperative_operations() {
        let program = vec![
            Opcode::Push(Value::String("Proposal 1".to_string())),
            Opcode::CreateProposal,
            Opcode::Push(Value::Bool(true)),
            Opcode::Vote("proposal_1".to_string()),
            Opcode::Push(Value::Int(100)),
            Opcode::AllocateResource("computing_power".to_string()),
            Opcode::Push(Value::Int(5)),
            Opcode::UpdateReputation("user1".to_string()),
            Opcode::Push(Value::String("proposal_1".to_string())),
            Opcode::GetProposalStatus,
        ];

        let mut vm = CoopVM::new(program);
        vm.run().unwrap();

        assert_eq!(vm.stack, vec![Value::String("new_proposal_id".to_string()), Value::String("Active".to_string())]);
    }
}
===== END OF /home/matt/InterCooperative-Network/crates/icn_vm/src/vm.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_zkp/Cargo.toml =====
[package]
name = "icn_zkp"
version = "0.1.0"
edition = "2021"

[dependencies]
bellman = "0.11.1"
serde = { version = "1.0", features = ["derive"] }
chrono = "0.4"
ed25519-dalek = "1.0"
rand = "0.8"
bitvec = { path = "../../vendor/bitvec" }
funty = { path = "../../vendor/funty" }
===== END OF /home/matt/InterCooperative-Network/crates/icn_zkp/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_zkp/src/circuits.rs =====
use bellman::{Circuit, ConstraintSystem, SynthesisError};
use bls12_381::Scalar;
use icn_common::Transaction;

pub struct TransactionCircuit {
    // Private inputs
    sender: Option<Scalar>,
    receiver: Option<Scalar>,
    amount: Option<Scalar>,
    currency_type: Option<Scalar>,

    // Public inputs
    sender_hash: Option<Scalar>,
    receiver_hash: Option<Scalar>,
    amount_hash: Option<Scalar>,
    currency_type_hash: Option<Scalar>,
}

impl TransactionCircuit {
    pub fn new(transaction: &Transaction) -> Self {
        // In a real implementation, you would convert transaction fields to Scalar
        // and compute hashes. This is a simplified version.
        TransactionCircuit {
            sender: Some(Scalar::from(1u64)),
            receiver: Some(Scalar::from(2u64)),
            amount: Some(Scalar::from(transaction.amount as u64)),
            currency_type: Some(Scalar::from(0u64)), // Simplified representation

            sender_hash: Some(Scalar::from(3u64)),
            receiver_hash: Some(Scalar::from(4u64)),
            amount_hash: Some(Scalar::from(5u64)),
            currency_type_hash: Some(Scalar::from(6u64)),
        }
    }

    pub fn empty() -> Self {
        TransactionCircuit {
            sender: None,
            receiver: None,
            amount: None,
            currency_type: None,
            sender_hash: None,
            receiver_hash: None,
            amount_hash: None,
            currency_type_hash: None,
        }
    }

    pub fn public_inputs(transaction: &Transaction) -> Vec<Scalar> {
        // In a real implementation, you would compute actual hashes
        vec![
            Scalar::from(3u64),
            Scalar::from(4u64),
            Scalar::from(5u64),
            Scalar::from(6u64),
        ]
    }
}

impl Circuit<Scalar> for TransactionCircuit {
    fn synthesize<CS: ConstraintSystem<Scalar>>(self, cs: &mut CS) -> Result<(), SynthesisError> {
        // Allocate private inputs
        let sender = cs.alloc(|| "sender", || self.sender.ok_or(SynthesisError::AssignmentMissing))?;
        let receiver = cs.alloc(|| "receiver", || self.receiver.ok_or(SynthesisError::AssignmentMissing))?;
        let amount = cs.alloc(|| "amount", || self.amount.ok_or(SynthesisError::AssignmentMissing))?;
        let currency_type = cs.alloc(|| "currency_type", || self.currency_type.ok_or(SynthesisError::AssignmentMissing))?;

        // Allocate public inputs
        let sender_hash = cs.alloc_input(|| "sender_hash", || self.sender_hash.ok_or(SynthesisError::AssignmentMissing))?;
        let receiver_hash = cs.alloc_input(|| "receiver_hash", || self.receiver_hash.ok_or(SynthesisError::AssignmentMissing))?;
        let amount_hash = cs.alloc_input(|| "amount_hash", || self.amount_hash.ok_or(SynthesisError::AssignmentMissing))?;
        let currency_type_hash = cs.alloc_input(|| "currency_type_hash", || self.currency_type_hash.ok_or(SynthesisError::AssignmentMissing))?;

        // Add constraints
        // In a real implementation, you would add proper constraints to prove the relationship
        // between private inputs and public inputs (hashes)
        cs.enforce(
            || "sender hash constraint",
            |lc| lc + sender,
            |lc| lc + CS::one(),
            |lc| lc + sender_hash
        );

        cs.enforce(
            || "receiver hash constraint",
            |lc| lc + receiver,
            |lc| lc + CS::one(),
            |lc| lc + receiver_hash
        );

        cs.enforce(
            || "amount hash constraint",
            |lc| lc + amount,
            |lc| lc + CS::one(),
            |lc| lc + amount_hash
        );

        cs.enforce(
            || "currency type hash constraint",
            |lc| lc + currency_type,
            |lc| lc + CS::one(),
            |lc| lc + currency_type_hash
        );

        Ok(())
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_zkp/src/circuits.rs =====

===== START OF /home/matt/InterCooperative-Network/crates/icn_zkp/src/lib.rs =====
// File: icn_zkp/src/lib.rs

use bellman::{Circuit, ConstraintSystem, SynthesisError};
use bls12_381::Bls12;
use icn_common::{IcnResult, IcnError, Transaction};
use rand::rngs::OsRng;

mod circuits;
pub use circuits::*;

pub struct ZKPManager {
    params: bellman::groth16::Parameters<Bls12>,
    pvk: bellman::groth16::PreparedVerifyingKey<Bls12>,
}

impl ZKPManager {
    /// Creates a new ZKPManager with generated parameters.
    pub fn new() -> IcnResult<Self> {
        let mut rng = OsRng;
        let params = bellman::groth16::generate_random_parameters::<Bls12, _, _>(
            TransactionCircuit::empty(),
            &mut rng
        ).map_err(|e| IcnError::ZKP(format!("Failed to generate ZKP parameters: {}", e)))?;

        let pvk = bellman::groth16::prepare_verifying_key(&params.vk);

        Ok(ZKPManager { params, pvk })
    }

    /// Creates a zero-knowledge proof for a given transaction.
    pub fn create_proof(&self, transaction: &Transaction) -> IcnResult<bellman::groth16::Proof<Bls12>> {
        let circuit = TransactionCircuit::new(transaction);
        let mut rng = OsRng;

        bellman::groth16::create_random_proof(circuit, &self.params, &mut rng)
            .map_err(|e| IcnError::ZKP(format!("Failed to create ZKP proof: {}", e)))
    }

    /// Verifies a zero-knowledge proof for a given transaction.
    pub fn verify_proof(
        &self,
        proof: &bellman::groth16::Proof<Bls12>,
        transaction: &Transaction,
    ) -> IcnResult<bool> {
        let inputs = TransactionCircuit::public_inputs(transaction);

        bellman::groth16::verify_proof(&self.pvk, proof, &inputs)
            .map_err(|e| IcnError::ZKP(format!("Failed to verify ZKP proof: {}", e)))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_common::CurrencyType;

    #[test]
    fn test_zkp_create_and_verify() {
        let manager = ZKPManager::new().expect("Failed to create ZKPManager");

        let transaction = Transaction {
            from: "Alice".to_string(),
            to: "Bob".to_string(),
            amount: 100.0,
            currency_type: CurrencyType::BasicNeeds,
            timestamp: 1234567890,
            signature: None,
        };

        let proof = manager.create_proof(&transaction).expect("Failed to create proof");
        let is_valid = manager.verify_proof(&proof, &transaction).expect("Failed to verify proof");

        assert!(is_valid, "Proof verification failed");
    }
}===== END OF /home/matt/InterCooperative-Network/crates/icn_zkp/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/benches/eq.rs =====
#![feature(test)]

extern crate test;

use bitvec::prelude::*;
use test::Bencher;

#[bench]
fn bitwise_eq(bench: &mut Bencher) {
	let a = bitarr![0; 500];
	let b = bitarr![0; 500];

	bench.iter(|| {
		a.iter()
			.by_val()
			.zip(b.iter().by_val())
			.all(|(a, b)| a == b)
	});
}

#[bench]
fn lsb0_accel_eq(bench: &mut Bencher) {
	let a = bitarr![0; 500];
	let b = bitarr![0; 500];

	bench.iter(|| a == b);
}

#[bench]
fn msb0_accel_eq(bench: &mut Bencher) {
	let a = bitarr![Msb0, usize; 0; 500];
	let b = bitarr![Msb0, usize; 0; 500];

	bench.iter(|| a == b);
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/benches/eq.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/benches/macros.rs =====
/*! Macro construction benchmarks.

This is taken from [issue #28], which noted that the `bitvec![bit; rep]`
expansion was horribly inefficient.

This benchmark crate should be used for all macro performance recording, and
compare the macros against `vec!`. While `vec!` will always be faster, because
`bitvec!` does more work than `vec!`, they should at least be close.

Original performance was 10,000x slower. Performance after the fix for #28 was
within 20ns.

[issue #28]: https://github.com/myrrlyn/bitvec/issues/28
!*/

#![feature(test)]

extern crate test;

use bitvec::prelude::*;
use test::Bencher;

#[bench]
fn bits_seq_u8(b: &mut Bencher) {
	b.iter(|| {
		bitarr![LocalBits, u8;
			0, 1, 0, 1, 0, 0, 1, 1,
			0, 1, 1, 0, 0, 0, 0, 1,
			0, 1, 1, 0, 1, 1, 0, 0,
			0, 1, 1, 1, 0, 1, 0, 1,
			0, 1, 1, 1, 0, 1, 0, 0,
			0, 1, 1, 0, 1, 1, 1, 1,
			0, 1, 1, 0, 1, 1, 1, 0,
			0, 0, 1, 0, 1, 1, 0, 0,
			0, 0, 1, 0, 0, 0, 0, 0,
			0, 1, 1, 0, 1, 1, 0, 1,
			0, 1, 1, 0, 1, 1, 1, 1,
			0, 1, 1, 0, 1, 1, 1, 0,
			0, 1, 1, 0, 0, 1, 0, 0,
			0, 1, 1, 0, 1, 1, 1, 1,
			0, 0, 1, 0, 0, 0, 0, 1,
		]
	});
}

#[bench]
fn bits_seq_u16(b: &mut Bencher) {
	b.iter(|| {
		bitarr![LocalBits, u16;
			0, 1, 0, 1, 0, 0, 1, 1,
			0, 1, 1, 0, 0, 0, 0, 1,
			0, 1, 1, 0, 1, 1, 0, 0,
			0, 1, 1, 1, 0, 1, 0, 1,
			0, 1, 1, 1, 0, 1, 0, 0,
			0, 1, 1, 0, 1, 1, 1, 1,
			0, 1, 1, 0, 1, 1, 1, 0,
			0, 0, 1, 0, 1, 1, 0, 0,
			0, 0, 1, 0, 0, 0, 0, 0,
			0, 1, 1, 0, 1, 1, 0, 1,
			0, 1, 1, 0, 1, 1, 1, 1,
			0, 1, 1, 0, 1, 1, 1, 0,
			0, 1, 1, 0, 0, 1, 0, 0,
			0, 1, 1, 0, 1, 1, 1, 1,
			0, 0, 1, 0, 0, 0, 0, 1,
		]
	});
}

#[bench]
fn bits_seq_u32(b: &mut Bencher) {
	b.iter(|| {
		bitarr![LocalBits, u32;
			0, 1, 0, 1, 0, 0, 1, 1,
			0, 1, 1, 0, 0, 0, 0, 1,
			0, 1, 1, 0, 1, 1, 0, 0,
			0, 1, 1, 1, 0, 1, 0, 1,
			0, 1, 1, 1, 0, 1, 0, 0,
			0, 1, 1, 0, 1, 1, 1, 1,
			0, 1, 1, 0, 1, 1, 1, 0,
			0, 0, 1, 0, 1, 1, 0, 0,
			0, 0, 1, 0, 0, 0, 0, 0,
			0, 1, 1, 0, 1, 1, 0, 1,
			0, 1, 1, 0, 1, 1, 1, 1,
			0, 1, 1, 0, 1, 1, 1, 0,
			0, 1, 1, 0, 0, 1, 0, 0,
			0, 1, 1, 0, 1, 1, 1, 1,
			0, 0, 1, 0, 0, 0, 0, 1,
		]
	});
}

#[bench]
#[cfg(target_pointer_width = "64")]
fn bits_seq_u64(b: &mut Bencher) {
	b.iter(|| {
		bitarr![LocalBits, u64;
			0, 1, 0, 1, 0, 0, 1, 1,
			0, 1, 1, 0, 0, 0, 0, 1,
			0, 1, 1, 0, 1, 1, 0, 0,
			0, 1, 1, 1, 0, 1, 0, 1,
			0, 1, 1, 1, 0, 1, 0, 0,
			0, 1, 1, 0, 1, 1, 1, 1,
			0, 1, 1, 0, 1, 1, 1, 0,
			0, 0, 1, 0, 1, 1, 0, 0,
			0, 0, 1, 0, 0, 0, 0, 0,
			0, 1, 1, 0, 1, 1, 0, 1,
			0, 1, 1, 0, 1, 1, 1, 1,
			0, 1, 1, 0, 1, 1, 1, 0,
			0, 1, 1, 0, 0, 1, 0, 0,
			0, 1, 1, 0, 1, 1, 1, 1,
			0, 0, 1, 0, 0, 0, 0, 1,
		]
	});
}

// The repetition macros run at compile time, so should bench at zero.

#[bench]
fn bits_rep_u8(b: &mut Bencher) {
	b.iter(|| bitarr![LocalBits, u8; 0; 120]);
	b.iter(|| bitarr![LocalBits, u8; 1; 120]);
}

#[bench]
fn bits_rep_u16(b: &mut Bencher) {
	b.iter(|| bitarr![LocalBits, u16; 0; 120]);
	b.iter(|| bitarr![LocalBits, u16; 1; 120]);
}

#[bench]
fn bits_rep_u32(b: &mut Bencher) {
	b.iter(|| bitarr![LocalBits, u32; 0; 120]);
	b.iter(|| bitarr![LocalBits, u32; 1; 120]);
}

#[bench]
#[cfg(target_pointer_width = "64")]
fn bits_rep_u64(b: &mut Bencher) {
	b.iter(|| bitarr![LocalBits, u64; 0; 120]);
	b.iter(|| bitarr![LocalBits, u64; 1; 120]);
}

#[bench]
fn bitvec_rep(b: &mut Bencher) {
	b.iter(|| bitvec![0; 16 * 16 * 9]);
	b.iter(|| bitvec![1; 16 * 16 * 9]);
}

#[bench]
fn vec_rep(b: &mut Bencher) {
	b.iter(|| vec![0u8; 16 * 16 * 9 / 8]);
	b.iter(|| vec![-1i8; 16 * 16 * 9 / 8]);
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/benches/macros.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/benches/memcpy.rs =====
/*! Benchmarks for `BitSlice::copy_from_slice`.

The `copy_from_slice` implementation attempts to detect slice conditions that
allow element-wise `memcpy` behavior, rather than the conservative bit-by-bit
iteration, as element load/stores are faster than reading and writing each bit
in an element individually.
!*/

#![feature(maybe_uninit_uninit_array, maybe_uninit_slice)]

use std::mem::MaybeUninit;

use bitvec::{
	mem::elts,
	prelude::*,
};
use criterion::{
	criterion_group,
	criterion_main,
	BenchmarkId,
	Criterion,
	SamplingMode,
	Throughput,
};
use funty::IsNumber;
use tap::tap::Tap;

//  One kibibyte
const KIBIBYTE: usize = 1024;
//  Some number of kibibytes
const FACTOR: usize = 1 * KIBIBYTE;

//  Scalars applied to FACTOR to get a range of action
const SCALARS: &[usize] = &[1, 2, 4, 8, 16, 24, 32, 40, 52, 64];
//  The maximum number of bits in a memory region.
const MAX_BITS: usize = 64 * FACTOR * 8;

fn make_slots<T, const LEN: usize>()
-> ([MaybeUninit<T>; LEN], [MaybeUninit<T>; LEN])
where T: BitStore {
	(
		MaybeUninit::<T>::uninit_array::<LEN>(),
		MaybeUninit::<T>::uninit_array::<LEN>(),
	)
}

fn view_slots<'a, 'b, T>(
	src: &'a [MaybeUninit<T>],
	dst: &'b mut [MaybeUninit<T>],
) -> (&'a [T], &'b mut [T])
where
	T: BitStore,
{
	unsafe {
		(
			MaybeUninit::slice_assume_init_ref(src),
			MaybeUninit::slice_assume_init_mut(dst),
		)
	}
}

pub fn benchmarks(crit: &mut Criterion) {
	fn steps()
	-> impl Iterator<Item = (impl Fn(&'static str) -> BenchmarkId, usize, Throughput)>
	{
		SCALARS.iter().map(|&n| {
			(
				move |name| BenchmarkId::new(name, n),
				n * FACTOR * <u8 as IsNumber>::BITS as usize,
				Throughput::Bytes((n * FACTOR) as u64),
			)
		})
	}

	let (src_words, mut dst_words) =
		make_slots::<usize, { elts::<usize>(MAX_BITS) }>();
	let (src_bytes, mut dst_bytes) =
		make_slots::<u8, { elts::<u8>(MAX_BITS) }>();

	let (src_words, dst_words) = view_slots(&src_words, &mut dst_words);
	let (src_bytes, dst_bytes) = view_slots(&src_bytes, &mut dst_bytes);

	macro_rules! mkgrp {
		($crit:ident, $name:literal) => {
			(&mut *$crit).benchmark_group($name).tap_mut(|grp| {
				grp.sampling_mode(SamplingMode::Flat).sample_size(2000);
			})
		};
	}

	let mut group = mkgrp!(crit, "Element-wise");
	for (id, bits, thrpt) in steps() {
		group.throughput(thrpt);
		let words = bits / <usize as IsNumber>::BITS as usize;
		let bytes = bits / <u8 as IsNumber>::BITS as usize;

		let (src_words, dst_words) =
			(&src_words[.. words], &mut dst_words[.. words]);
		let (src_bytes, dst_bytes) =
			(&src_bytes[.. bytes], &mut dst_bytes[.. bytes]);

		//  Use the builtin memcpy to run the slices in bulk. This ought to be a
		//  lower bound on execution time.

		group.bench_function(id("words_plain"), |b| {
			let (src, dst) = (src_words, &mut *dst_words);
			b.iter(|| dst.copy_from_slice(src))
		});
		group.bench_function(id("bytes_plain"), |b| {
			let (src, dst) = (src_bytes, &mut *dst_bytes);
			b.iter(|| dst.copy_from_slice(src))
		});

		group.bench_function(id("words_manual"), |b| {
			let (src, dst) = (src_words, &mut *dst_words);
			b.iter(|| {
				for (from, to) in src.iter().zip(dst.iter_mut()) {
					*to = *from;
				}
			})
		});
		group.bench_function(id("bytes_manual"), |b| {
			let (src, dst) = (src_bytes, &mut *dst_bytes);
			b.iter(|| {
				for (from, to) in src.iter().zip(dst.iter_mut()) {
					*to = *from;
				}
			})
		});
	}
	group.finish();

	let mut group = mkgrp!(crit, "Bit-wise accelerated");
	for (id, bits, thrpt) in steps() {
		group.throughput(thrpt);
		let words = bits / <usize as IsNumber>::BITS as usize;
		let bytes = bits / <u8 as IsNumber>::BITS as usize;

		let (src_words, dst_words) =
			(&src_words[.. words], &mut dst_words[.. words]);
		let (src_bytes, dst_bytes) =
			(&src_bytes[.. bytes], &mut dst_bytes[.. bytes]);

		//  Ideal bitwise memcpy: no edges, same typarams, fully aligned.

		group.bench_function(id("bits_words_plain"), |b| {
			let (src, dst) = (
				src_words.view_bits::<Lsb0>(),
				dst_words.view_bits_mut::<Lsb0>(),
			);
			b.iter(|| dst.copy_from_bitslice(src));
		});
		group.bench_function(id("bits_bytes_plain"), |b| {
			let (src, dst) = (
				src_bytes.view_bits::<Lsb0>(),
				dst_bytes.view_bits_mut::<Lsb0>(),
			);
			b.iter(|| dst.copy_from_bitslice(src));
		});

		//  Same typarams, fully aligned, with fuzzed edges.

		group.bench_function(id("bits_words_edges"), |b| {
			let src = src_words.view_bits::<Lsb0>();
			let len = src.len();
			let (src, dst) = (
				&src[10 .. len - 10],
				&mut dst_words.view_bits_mut::<Lsb0>()[10 .. len - 10],
			);
			b.iter(|| dst.copy_from_bitslice(src));
		});
		group.bench_function(id("bits_bytes_edges"), |b| {
			let src = src_bytes.view_bits::<Lsb0>();
			let len = src.len();
			let (src, dst) = (
				&src[10 .. len - 10],
				&mut dst_bytes.view_bits_mut::<Lsb0>()[10 .. len - 10],
			);
			b.iter(|| dst.copy_from_bitslice(src));
		});

		//  Same typarams, misaligned.

		group.bench_function(id("bits_words_misalign"), |b| {
			let src = &src_words.view_bits::<Lsb0>()[10 ..];
			let dst = &mut dst_words.view_bits_mut::<Lsb0>()[.. src.len()];
			b.iter(|| dst.copy_from_bitslice(src));
		});
		group.bench_function(id("bits_bytes_misalign"), |b| {
			let src = &src_bytes.view_bits::<Lsb0>()[10 ..];
			let dst = &mut dst_bytes.view_bits_mut::<Lsb0>()[.. src.len()];
			b.iter(|| dst.copy_from_bitslice(src));
		});
	}
	group.finish();

	let mut group = mkgrp!(crit, "Bit-wise crawl");
	for (id, bits, thrpt) in steps() {
		group.throughput(thrpt);
		let words = bits / <usize as IsNumber>::BITS as usize;
		let bytes = bits / <u8 as IsNumber>::BITS as usize;

		let (src_words, dst_words) =
			(&src_words[.. words], &mut dst_words[.. words]);
		let (src_bytes, dst_bytes) =
			(&src_bytes[.. bytes], &mut dst_bytes[.. bytes]);

		//  Mismatched type parameters

		group.bench_function(id("bits_words_mismatched"), |b| {
			let (src, dst) = (
				src_words.view_bits::<Msb0>(),
				dst_words.view_bits_mut::<Lsb0>(),
			);
			b.iter(|| dst.clone_from_bitslice(src));
		});
		group.bench_function(id("bits_bytes_mismatched"), |b| {
			let (src, dst) = (
				src_bytes.view_bits::<Msb0>(),
				dst_bytes.view_bits_mut::<Lsb0>(),
			);
			b.iter(|| dst.clone_from_bitslice(src));
		});

		//  Crawl each bit individually. This ought to be an upper bound on
		//  execution time.

		group.bench_function(id("bitwise_words"), |b| {
			let (src, dst) = (
				src_words.view_bits::<Lsb0>(),
				dst_words.view_bits_mut::<Lsb0>(),
			);
			b.iter(|| unsafe {
				for (from, to) in
					src.as_bitptr_range().zip(dst.as_mut_bitptr_range())
				{
					to.write(from.read());
				}
			})
		});
		group.bench_function(id("bitwise_bytes"), |b| {
			let (src, dst) = (
				src_bytes.view_bits::<Lsb0>(),
				dst_bytes.view_bits_mut::<Lsb0>(),
			);
			b.iter(|| unsafe {
				for (from, to) in
					src.as_bitptr_range().zip(dst.as_mut_bitptr_range())
				{
					to.write(from.read());
				}
			})
		});

		group.bench_function(id("bitwise_words_mismatch"), |b| {
			let (src, dst) = (
				src_words.view_bits::<Lsb0>(),
				dst_words.view_bits_mut::<Msb0>(),
			);
			b.iter(|| unsafe {
				for (from, to) in
					src.as_bitptr_range().zip(dst.as_mut_bitptr_range())
				{
					to.write(from.read());
				}
			})
		});
		group.bench_function(id("bitwise_bytes_mismatch"), |b| {
			let (src, dst) = (
				src_bytes.view_bits::<Msb0>(),
				dst_bytes.view_bits_mut::<Lsb0>(),
			);
			b.iter(|| unsafe {
				for (from, to) in
					src.as_bitptr_range().zip(dst.as_mut_bitptr_range())
				{
					to.write(from.read());
				}
			})
		});
	}
}

criterion_group!(benches, benchmarks);
criterion_main!(benches);
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/benches/memcpy.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/benches/mut_access.rs =====
#![feature(test)]

extern crate test;

use bitvec::prelude::*;
use test::Bencher;

#[bench]
fn iter_mut(b: &mut Bencher) {
	let mut bits = bitarr![0; 500];
	b.iter(|| bits.iter_mut().for_each(|mut b| *b = !*b));
}

#[bench]
fn native_for_each(b: &mut Bencher) {
	let mut bits = bitarr![0; 500];
	b.iter(|| bits.for_each(|_, b| !b));
}

#[bench]
fn copy_within(b: &mut Bencher) {
	let mut a = bitarr![1, 1, 1, 1, 0, 0, 0, 0];
	b.iter(|| a.copy_within(.. 4, 2));
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/benches/mut_access.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/benches/slice.rs =====
#![feature(test)]

extern crate test;

use bitvec::prelude::*;
use test::{
	bench::black_box,
	Bencher,
};

/* `BitSlice::empty` is not benched, because the compiler const-folds it. It
is not a `const fn`, but it has exactly one function call, which is `const`, and
creates a value object from that function. As such, the compiler can prove that
the return value is a `const` value, and insert the value at all
`BitSlice::empty` call sites. It takes 0ns.
*/

#[bench]
fn element(b: &mut Bencher) {
	b.iter(|| BitSlice::<Msb0, u8>::from_element(&!0));
	b.iter(|| BitSlice::<Lsb0, u8>::from_element(&!0));
	b.iter(|| BitSlice::<Msb0, u16>::from_element(&!0));
	b.iter(|| BitSlice::<Lsb0, u16>::from_element(&!0));
	b.iter(|| BitSlice::<Msb0, u32>::from_element(&!0));
	b.iter(|| BitSlice::<Lsb0, u32>::from_element(&!0));

	#[cfg(target_pointer_width = "64")]
	{
		b.iter(|| BitSlice::<Msb0, u64>::from_element(&!0));
		b.iter(|| BitSlice::<Lsb0, u64>::from_element(&!0));
	}
}

#[bench]
fn slice(b: &mut Bencher) {
	b.iter(|| BitSlice::<Msb0, u8>::from_slice(&[0, 1, !0 - 1, !0][..]));
	b.iter(|| BitSlice::<Lsb0, u8>::from_slice(&[0, 1, !0 - 1, !0][..]));
	b.iter(|| BitSlice::<Msb0, u16>::from_slice(&[0, 1, !0 - 1, !0][..]));
	b.iter(|| BitSlice::<Lsb0, u16>::from_slice(&[0, 1, !0 - 1, !0][..]));
	b.iter(|| BitSlice::<Msb0, u32>::from_slice(&[0, 1, !0 - 1, !0][..]));
	b.iter(|| BitSlice::<Lsb0, u32>::from_slice(&[0, 1, !0 - 1, !0][..]));

	#[cfg(target_pointer_width = "64")]
	{
		b.iter(|| BitSlice::<Msb0, u64>::from_slice(&[0, 1, !0 - 1, !0][..]));
		b.iter(|| BitSlice::<Lsb0, u64>::from_slice(&[0, 1, !0 - 1, !0][..]));
	}
}

#[bench]
fn len(b: &mut Bencher) {
	let bsb08 = [0u8; 16].view_bits::<Msb0>();
	let bsl08 = [0u8; 16].view_bits::<Lsb0>();
	b.iter(|| bsb08.len());
	b.iter(|| bsl08.len());

	let bsb16 = [0u16; 8].view_bits::<Msb0>();
	let bsl16 = [0u16; 8].view_bits::<Lsb0>();
	b.iter(|| bsb16.len());
	b.iter(|| bsl16.len());

	let bsb32 = [0u32; 4].view_bits::<Msb0>();
	let bsl32 = [0u32; 4].view_bits::<Lsb0>();
	b.iter(|| bsb32.len());
	b.iter(|| bsl32.len());

	#[cfg(target_pointer_width = "64")]
	{
		let bsb64 = [0u64; 2].view_bits::<Msb0>();
		let bsl64 = [0u64; 2].view_bits::<Lsb0>();
		b.iter(|| bsb64.len());
		b.iter(|| bsl64.len());
	}
}

//  This index value is not only "nice", it also ensures that the hard path is
//  hit in `BitIdx::offset`.
#[bench]
fn index(b: &mut Bencher) {
	let bsb08 = [0u8; 16].view_bits::<Msb0>();
	let bsl08 = [0u8; 16].view_bits::<Lsb0>();
	b.iter(|| assert!(!black_box(bsb08)[black_box(69)]));
	b.iter(|| assert!(!black_box(bsl08)[black_box(69)]));

	let bsb16 = [0u16; 8].view_bits::<Msb0>();
	let bsl16 = [0u16; 8].view_bits::<Lsb0>();
	b.iter(|| assert!(!black_box(bsb16)[black_box(69)]));
	b.iter(|| assert!(!black_box(bsl16)[black_box(69)]));

	let bsb32 = [0u32; 4].view_bits::<Msb0>();
	let bsl32 = [0u32; 4].view_bits::<Lsb0>();
	b.iter(|| assert!(!black_box(bsb32)[black_box(69)]));
	b.iter(|| assert!(!black_box(bsl32)[black_box(69)]));

	#[cfg(target_pointer_width = "64")]
	{
		let bsb64 = [0u64; 2].view_bits::<Msb0>();
		let bsl64 = [0u64; 2].view_bits::<Lsb0>();
		b.iter(|| assert!(!black_box(bsb64)[black_box(69)]));
		b.iter(|| assert!(!black_box(bsl64)[black_box(69)]));
	}
}

/* This routine has more work to do: index, create a reference struct, and drop
it. The compiler *should* be able to properly arrange immediate drops, though.
*/
#[bench]
fn get_mut(b: &mut Bencher) {
	let mut src = [0u8; 16];
	let bsb08 = src.view_bits_mut::<Msb0>();
	b.iter(|| *bsb08.get_mut(69).unwrap() = true);
	let mut src = [0u8; 16];
	let bsl08 = src.view_bits_mut::<Lsb0>();
	b.iter(|| *bsl08.get_mut(69).unwrap() = true);

	let mut src = [0u16; 8];
	let bsb16 = src.view_bits_mut::<Msb0>();
	b.iter(|| *bsb16.get_mut(69).unwrap() = true);
	let mut src = [0u16; 8];
	let bsl16 = src.view_bits_mut::<Lsb0>();
	b.iter(|| *bsl16.get_mut(69).unwrap() = true);

	let mut src = [0u32; 4];
	let bsb32 = src.view_bits_mut::<Msb0>();
	b.iter(|| *bsb32.get_mut(69).unwrap() = true);
	let mut src = [0u32; 4];
	let bsl32 = src.view_bits_mut::<Lsb0>();
	b.iter(|| *bsl32.get_mut(69).unwrap() = true);

	#[cfg(target_pointer_width = "64")]
	{
		let mut src = [0u64; 2];
		let bsb64 = src.view_bits_mut::<Msb0>();
		b.iter(|| *bsb64.get_mut(69).unwrap() = true);
		let mut src = [0u64; 2];
		let bsl64 = src.view_bits_mut::<Lsb0>();
		b.iter(|| *bsl64.get_mut(69).unwrap() = true);
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/benches/slice.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/book.toml =====
################################################################################
#                              Book Configuration                              #
#                                                                              #
# This file configures the `mdbook` executable used to compile `book/` into a  #
# project manual.                                                              #
################################################################################

[book]
title = "A User’s Guide to the `bitvec` Project"
authors = [
	"myrrlyn <self@myrrlyn.dev>",
]
description = "A more thorough manual of the `bitvec` project"
src = "book"

[build]
build-dir = "target/book"

[output.html]
mathjax-support = true

[output.html.playpen]
line-numbers = true
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/book.toml =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/Cargo.toml =====
################################################################################
#                               Project Manifest                               #
#                                                                              #
# This file describes the `bitvec` Rust project to the Rust build tool, Cargo. #
################################################################################

[package]
name = "bitvec"
version = "0.22.0"
authors = [
	"myrrlyn <self@myrrlyn.dev>",
]
categories = [
	"data-structures",
	"embedded",
	"no-std",
	"rust-patterns",
]
description = "A crate for manipulating memory, bit by bit"
documentation = "https://docs.rs/bitvec"
edition = "2018"
homepage = "https://myrrlyn.net/crates/bitvec"
include = [
	"Cargo.toml",
	"LICENSE.txt",
	"README.md",
	"src/**/*.rs",
	"benches/*.rs",
]
keywords = [
	"bitfields",
	"bits",
	"bitstream",
	"bitvec",
	"bitvector",
]
license = "MIT"
readme = "README.md"
repository = "https://github.com/myrrlyn/bitvec"

[features]
alloc = [
	"wyz/alloc",
]
atomic = []
default = [
	"atomic",
	"std",
]
std = [
	"alloc",
]

[dependencies]
radium = "0.6"
tap = "1"

[dependencies.funty]
version = "~1.2"
default-features = false

[dependencies.serde]
default-features = false
optional = true
version = "1"

[dependencies.wyz]
version = "0.4"
default-features = false

# Crates required when running the test suite.
[dev-dependencies]
bincode = "1.3"
criterion = "0.3"
serde = "1"
serde_json = "1"
serde_test = "1"
static_assertions = "1"

[[bench]]
name = "memcpy"
harness = false

# Indicates the features that docs.rs should enable when building documentation.
[package.metadata.docs.rs]
features = [
	"atomic",
	"serde",
	"std",
]

[badges.codecov]
repository = "myrrlyn/bitvec"
branch = "develop"
service = "github"

[badges.is-it-maintained-issue-resolution]
repository = "myrrlyn/bitvec"

[badges.is-it-maintained-open-issues]
repository = "myrrlyn/bitvec"

[badges.maintenance]
status = "actively-developed"
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/clippy.toml =====
########################################################################
#                         Clippy Configuration                         #
#                                                                      #
# This file controls the `cargo clippy` linter for the lints where it  #
# accepts external input. Relatively few lints do; most require        #
# attributes set directly in the source code.                          #
########################################################################

msrv = "1.51.0"
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/clippy.toml =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/examples/aliasing.rs =====
/*! Memory region aliasing.

This test demonstrates how `bitvec` handles creation of slices that do not alias
individual *bits* in memory, but do alias the *elements* that contain those
bits. Because the hardware executing the `bitvec` instructions operates at the
element level, `bitvec` is forbidden from introducing conditions that cause
element-wide modifications to interfere with each other.

# How It Works

The `&mut BitSlice` reference is capable of analyzing its address value to
determine if it is possible for another reference handle to view the elements it
touches. It is undefined behavior to even *read* a memory element that is being
simultaneously written, *even if the bits subject to change will be erased*.

Fortunately, the Rust `&`/`&mut` reference exclusion rules already forbid the
possibility of a read reference viewing as unaliased the same element that a
write reference is modifying.

`BitSlice` only has a small number of methods that are capable of introducing an
alias, and they are all ultimately descended from `.split_at_mut()` and
`.split_at_mut_unchecked()`. Methods such as `.get_mut()` are *not* aliasing,
because Rust’s lifetime rules prevent the reference to the rest of the slice
from being used while the narrower reference handle is alive!

The methods that introduce parallel, disjoint, handles to memory that may alias
are all marked in the type system as producing handles to aliased memory. These
handles will either use atomic `lock` instructions to synchronize access across
threads, or use `Cell` access and remove their ability to cross thread
boundaries. Both mechanisms prevent race conditions from occurring.

# What This Test Does

This test demonstrates the effects in the type system of performing aliasing
work, and how users may remove the over-conservative alias taint on a slice. The
alias marker is added for *all* elements in a slice domain, after all, but only
the elements on the edges are actually aliased! This test demonstrates using
`.split_at_mut()` to taint slice handles, and `.bit_domain_mut()` to narrow the
taint to only the affected addresses.
!*/

#[cfg(all(feature = "atomic", feature = "std"))]
use std::{
	thread,
	time::Duration,
};

#[cfg(all(feature = "atomic", feature = "std"))]
use bitvec::{
	access::{
		BitSafe,
		BitSafeU8,
	},
	prelude::*,
};

#[cfg(all(feature = "atomic", feature = "std"))]
fn snooze() {
	thread::sleep(Duration::from_millis(10));
}

#[cfg(all(feature = "atomic", feature = "std"))]
fn main() {
	let data = BitBox::from_bitslice([0u8; 5].view_bits::<LocalBits>());
	let bits: &'static mut BitSlice<LocalBits, u8> = BitBox::leak(data);

	//  This slice is all zeros.
	assert!(bits.not_any());

	//  `bits` is an unaliased slice, and is currently `Send`. Let’s make a
	//  thread manipulate it, and send it back.
	let handle = thread::spawn(move || {
		bits.set_all(true);
		bits
	});
	let bits: &'static mut BitSlice<LocalBits, u8> = handle.join().unwrap();

	assert!(bits.all());

	//  Now, like the wise Solomon, we are going to cut this slice in half.
	let (left, right): (
		&'static mut BitSlice<LocalBits, BitSafeU8>,
		&'static mut BitSlice<LocalBits, BitSafeU8>,
	) = bits.split_at_mut(bits.len() / 2);

	/* If you look at the `.split_at_mut` docs, you’ll see that it returns a
	slice typed as `&mut BitSlice<O, T::Alias>`. If you follow that into the
	`BitStore` trait docs, you’ll see in the `u8` implementation that
	`type Alias = BitSafeU8;`. If you see `type Alias = BitSafeCellU8;`, then
	this example won’t compile! Turn on `feature = "atomic"` in your build
	settings.

	`BitSafeU8` is *still `Send`*, so we can still move these slices across
	threads!

	`&mut BitSlice` implements `Not`, and it does so by writing batched masks to
	the whole element. If we invert one side, then send them to threads and
	invert them both, we might hit a race condition in the middle!
	*/
	let left = !left;
	assert!(left.not_any());
	assert!(right.all());
	let (left, right) = (
		thread::spawn(move || {
			snooze();
			!left
		})
		.join()
		.unwrap(),
		thread::spawn(move || {
			snooze();
			!right
		})
		.join()
		.unwrap(),
	);

	//  Let’s check:
	assert!(left.all());
	assert!(right.not_any());

	/* The reason this worked is that these slices use `AtomicU8` for every
	mutation. But, `left` can only touch elements `[0 ..= 2]` and `right` can
	only touch elements `[2 ..= 4]`. They don’t *all* need atomic ops, only
	element `[2]`. How can we fix that? Introducing: `.bit_domain()` and
	`.bit_domain_mut()`. These methods are identical, except that `_mut` permits
	writing to the produced slices.
	*/
	let left = thread::spawn(move || {
		snooze();
		let (_head, _body, tail) = left.bit_domain_mut().region().unwrap();
		let _back = !tail;
		left
	})
	.join()
	.unwrap();
	let right = thread::spawn(move || {
		snooze();
		let (head, _body, _tail) = right.bit_domain_mut().region().unwrap();
		let _front = !head;
		right
	})
	.join()
	.unwrap();

	/* Now let’s look at the memory elements, with `.domain()`.

	`.domain()` and `.domain_mut()` produce descriptions of the memory elements
	underneath the slice. They carry the same aliasing types, but because they
	refer to elements, rather than bits, they must also carry the start and stop
	counters. As with the bit domains, the `body` field is unaliased.

	The values from a slice domain let you work with the underlying memory
	directly, rather than still going through the `BitSlice` wrapper view.
	*/
	let (head, body, tail) = left.domain().region().unwrap();
	assert!(head.is_none());
	assert_eq!(body, &[!0u8; 2]);
	let (tail_atom, _tail_idx) = tail.unwrap();
	assert_eq!(tail_atom.load(), 0b1111_0000u8);

	let (head, body, tail) = right.domain().region().unwrap();
	assert!(tail.is_none());
	assert_eq!(body, &[0u8; 2]);
	let (_head_idx, head_atom) = head.unwrap();
	assert_eq!(head_atom.load(), 0b1111_0000u8);
}

#[cfg(not(all(feature = "atomic", feature = "std")))]
fn main() {
	//  This example requires the presence of atomics and a standard library.
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/examples/aliasing.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/examples/ipv4.rs =====
/*! This example demonstrates building an IPv4 packet header using `BitField`.

The example program will run through the construction of the header at the speed
of your terminal's buffer. The program can be made interactive, pausing after
each modification so that the user can manually step to the next, by running it
with the argument "pause": `cargo run --example ipv4 -- pause`
!*/

#![allow(clippy::single_char_add_str)]

use std::{
	collections::BTreeSet,
	fmt::{
		self,
		Display,
		Formatter,
	},
	io,
	ops::Range,
};

use bitvec::prelude::*;
use wyz::fmt::FmtForward;

type Ipv4Header = BitArray<Msb0, [u8; 20]>;

/// Build up an IPv4 packet
fn build() -> Ipv4Header {
	let mut pkt: Ipv4Header = BitArray::zeroed();
	render("Starting with a blank packet", &pkt, 0 .. 0);

	//  Set IPv4
	pkt[.. 4].store(4u8);
	render("Set IP version to 4", &pkt, 0 .. 4);
	//  Set an IHL of 5 words
	pkt[4 .. 8].store(5u8);
	render(
		"Set header length to 5 32-bit words (20 bytes)",
		&pkt,
		4 .. 8,
	);
	//  Set the DSCP to "low drop, class 3" per Wikipedia
	pkt[8 .. 14].store(0b011010u8);
	render("Set DSCP number", &pkt, 8 .. 14);
	//  Set the ECN flag to "ECT(0)", per RFC 3168
	pkt[14 .. 16].store(0b10u8);
	render("Set ECN flag", &pkt, 14 .. 16);

	//  Set a total size of 20 bytes. The storage API will convert to
	//  big-endian.
	pkt[16 .. 32].store_be(20u16);
	render(
		"Set total packet length to 20 bytes (no payload)",
		&pkt,
		16 .. 32,
	);

	//  Set the identification fingerprint
	pkt[32 .. 48].store_be(0xACABu16);
	render("Set an identifying fingerprint", &pkt, 32 .. 48);

	//  Set the flags
	*pkt.get_mut(48).unwrap() = true;
	*pkt.get_mut(49).unwrap() = false;
	*pkt.get_mut(50).unwrap() = true;
	render("Set some flags", &pkt, 48 .. 51);

	//  Set the fragment offset to be 758, the age of the library in days
	pkt[51 .. 64].store_be(758u16);
	render("Set the fragment offset to 758", &pkt, 51 .. 64);

	//  Set the TTL to 27 (my age in years)
	pkt.as_mut_raw_slice()[8] = 27;
	render("Set the TTL", &pkt, 64 .. 72);
	//  Set the protocol number to 17 (UDP)
	pkt.as_mut_raw_slice()[9] = 17;
	render("Set the protocol number", &pkt, 72 .. 80);

	//  Fill in the IP addresses using ordinary byte accesses
	for (slot, byte) in pkt.as_mut_raw_slice()[12 .. 20]
		.iter_mut()
		.zip(&[127, 0, 0, 1, 192, 168, 1, 254])
	{
		*slot = *byte;
	}
	render("Fill the source IP addresses", &pkt, 96 .. 160);

	//  Last, set the checksum
	let csum = ipv4_csum(&pkt[..]);
	pkt[80 .. 96].store_be::<u16>(csum);
	render("Set the checksum", &pkt, 80 .. 96);

	pkt
}

fn parse(header: BitArray<Msb0, [u8; 20]>) {
	assert_eq!(ipv4_csum(&header[..]), 0);

	//  Check that the version field is `4`, by `load`ing it and by direct
	//  inspection
	assert_eq!(header[.. 4].load::<u8>(), 4);
	assert_eq!(header.as_raw_slice()[0] & 0xF0, 0x40);

	let ihl = header[4 .. 8].load::<u8>() as usize;
	assert!((5 .. 16).contains(&ihl));
	assert!(!header[49], "Unexpected fragmentation");
	assert!(header[50], "Unexpected fragmentation");

	eprintln!("Final packet: [");
	for byte in &header.into_inner() {
		eprintln!("    {:08b}", *byte);
	}
	eprintln!("]");
}

fn main() {
	eprintln!("Press <Enter> to move through the steps of the example");
	parse(build());
}

fn ipv4_csum(header: &BitSlice<Msb0, u8>) -> u16 {
	if !(160 .. 288).contains(&header.len()) {
		panic!("IPv4 headers must be between 160 and 288 bits");
	}
	let mut accum = 0u32;
	for pair in header.chunks(16) {
		accum += pair.load_be::<u16>() as u32;
	}
	while accum > 0xFFFFu32 {
		let high = accum & !0xFFFFu32;
		accum += high >> 16;
		accum -= high;
	}
	!(accum as u16)
}

fn render(title: &'static str, packet: &Ipv4Header, range: Range<usize>) {
	eprintln!("{}: {:#}", title, AnnotatedArray::new(packet, range));
	if std::env::args().last().unwrap() == "pause" {
		let _ = io::stdin().read_line(&mut String::new()).unwrap();
	}
}

struct AnnotatedArray<'a> {
	packet: &'a Ipv4Header,
	range: Range<usize>,
}

impl<'a> AnnotatedArray<'a> {
	fn new(packet: &'a Ipv4Header, range: Range<usize>) -> Self {
		Self { packet, range }
	}
}

impl<'a> Display for AnnotatedArray<'a> {
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		let mut out = fmt.debug_list();
		let marked_bits = self.range.clone().collect::<BTreeSet<_>>();
		let mut word_string = String::with_capacity(41);
		let mut mark_string = String::with_capacity(41);
		for (idx, word) in self.packet.as_bitslice().chunks(32).enumerate() {
			let start_bit = idx * 32;
			let bits = start_bit .. start_bit + 32;
			for (bit, idx) in word.iter().by_val().zip(bits) {
				word_string.push_str(if bit { "1" } else { "0" });
				mark_string.push_str(if marked_bits.contains(&idx) {
					"^"
				}
				else {
					" "
				});
				if idx % 8 == 7 && idx % 32 != 31 {
					word_string.push_str(" ");
					mark_string.push_str(" ");
				}
			}
			out.entry(&(&word_string).fmt_display());
			if !mark_string.trim().is_empty() {
				out.entry(&(&mark_string).fmt_display());
			}
			word_string.clear();
			mark_string.clear();
		}
		out.finish()
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/examples/ipv4.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/examples/sieve.rs =====
/*! Sieve of Eratosthenes

The `bit_vec` crate had this as an example, so I do too, I guess.

Run with

```sh
$ cargo run --release --example sieve -- [max] [count]
```

where max is an optional maximum number below which all primes will be found,
and count is an optional number whose square will be used to display the bottom
primes.

For example,

```sh
$ cargo run --release --example sieve -- 10000000 25
```

will find all primes less than ten million, and print the primes below 625 in a
square 25x25.
!*/

//  Impl notes: If this executable starts segfaulting, `BitSpan::len` might be
//  the culprit. Replace the bare + and - in that function with .saturating_ops
//  and see if that solves it.
//
//  Heisenbugs are weird.

#[cfg(feature = "std")]
use std::{
	cmp,
	env,
};

#[cfg(feature = "std")]
use bitvec::prelude::*;

#[cfg(feature = "std")]
fn main() {
	//  Capture the arguments iterator exactly once.
	let mut args = env::args();
	//  Attempt to parse the first argument as a search ceiling.
	let max: usize = args
		.nth(1)
		.and_then(|arg| arg.parse().ok())
		.unwrap_or(1_000_000);

	//  Allocate and immediately free a `Vec<bool>`, just to prove a point.
	let vec_bool_capa = vec![false; max].capacity();

	//  Prepare a vector for the search space.
	let mut primes = BitVec::<LocalBits, usize>::repeat(true, max);
	let len = primes.len();

	println!(
		"BitVec   [{}]: {} bytes of heap\nVec<bool>[{}]: {} bytes of heap",
		len,
		//  `.capacity()` always returns bits, and we want bytes
		primes.capacity() >> 3,
		len,
		vec_bool_capa,
	);

	//  0 and 1 are not primes
	primes.set(0, false);
	primes.set(1, false);

	println!("Calculating 1…");
	for num in 2 ..= ((len as f64).sqrt() as usize) {
		//  Adjust the frequency of log statements logarithmically.
		let log = (num as f64).log10();
		if log - log.floor() == 0.0 {
			println!("Calculating {}…", num);
		}
		//  If num is prime, mark all multiples as non-prime
		if primes[num] {
			//  Start at num * num, because num * (num - 1) was handled in the
			//  previous iteration: (num - 1) * (num - 1 + 1)
			'mul: for factor in num .. {
				let product = num * factor;
				if product >= len {
					break 'mul;
				}
				primes.set(product, false);
			}
		}
	}
	println!("Calculation complete!");
	//  Freeze the vector by permanently borrowing it as an immutable slice.
	let primes = primes.as_bitslice();

	let prime_ct = primes.count_ones();
	let prime_ratio = 100.0 * prime_ct as f64 / len as f64;

	if primes.not_any() {
		println!("There are no primes smaller than {}", len);
		std::process::exit(0);
	}
	else {
		println!(
			"There are {} primes less than {} ({}%)",
			prime_ct, len, prime_ratio
		);
	}

	let dim = args.next().and_then(|arg| arg.parse().ok()).unwrap_or(10);

	let limit = cmp::min(dim * dim, len);
	let displayed_primes = &primes[.. limit];
	//  Find the widest number that will be printed, and get its width.
	let cell_width = displayed_primes
		.iter()
		.by_val()
		//  search from the back
		.rev()
		.enumerate()
		//  stop at the first prime
		.find(|(_, bit)| *bit)
		//  ceil(log10) is the number of digits to print
		.map(|(idx, _)| ((limit - 1 - idx) as f64).log10().ceil() as usize)
		.expect("Failed to find a prime.");

	let prime_ct = displayed_primes.count_ones();
	let prime_ratio = 100.0 * prime_ct as f64 / limit as f64;
	println!(
		"There are {} primes less than {} ({}%) and they are:",
		prime_ct, limit, prime_ratio
	);
	'rows: for (row, bits) in displayed_primes.chunks(dim).take(dim).enumerate()
	{
		for (col, bit) in bits.iter().by_val().enumerate() {
			let idx = row * dim + col;
			if idx >= limit {
				println!();
				break 'rows;
			}
			if bit {
				print!("{:>1$} ", idx, cell_width);
			}
			else {
				print!("{:^1$} ", "-", cell_width);
			}
		}
		println!();
	}
}

#[cfg(not(feature = "std"))]
fn main() {
	//  This example requires the standard library.
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/examples/sieve.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/examples/tour.rs =====
/*! Demonstrates construction and use of bit vectors.

This example uses `bitvec!` to construct a `BitVec` from literals, then shows
a sample of the various operations that can be applied to it.

This example prints **a lot** of text to the console.
!*/

#[cfg(feature = "std")]
use std::iter::repeat;

#[cfg(feature = "std")]
use bitvec::prelude::{
	//  `bits!` macro
	bits,
	//  element-traversal trait (you shouldn’t explicitly need this)
	BitOrder,
	//  slice type, analagous to `[u1]`
	BitSlice,
	//  trait unifying the primitives (you shouldn’t explicitly need this)
	BitStore,
	//  vector type, analagous to `Vec<u1>`
	BitVec,
	//  directionality type markers
	Lsb0,
	Msb0,
};
#[cfg(feature = "std")]
use funty::IsNumber;

#[cfg(feature = "std")]
fn main() {
	//  Default types are `order::LocalBits` and `usize`
	let bits = bits![Msb0, u8;
		0, 0, 0, 0, 0, 0, 0, 1,
		0, 0, 0, 0, 0, 0, 1, 0,
		0, 0, 0, 0, 0, 1, 0, 0,
		0, 0, 0, 0, 1, 0, 0, 0,
		0, 0, 0, 1, 0, 0, 0, 0,
		0, 0, 1, 0, 0, 0, 0, 0,
		0, 1, 0, 0, 0, 0, 0, 0,
		1, 0, 0, 0, 0, 0, 0, 0,
		1, 0, 0, 0, 0, 0, 0, 0,
		0, 1, 0, 0, 0, 0, 0, 0,
		0, 0, 1, 0, 0, 0, 0, 0,
		0, 0, 0, 1, 0, 0, 0, 0,
		0, 0, 0, 0, 1, 0, 0, 0,
		0, 0, 0, 0, 0, 1, 0, 0,
		0, 0, 0, 0, 0, 0, 1, 0,
		0, 0, 0, 0, 0, 0, 0, 1,
		1, 0, 1, 0,
	];
	println!(
		"A Msb0 BitSlice has the same left-to-right order in memory as it does \
		 semantically"
	);
	render(&bits);

	//  BitVec can turn into iterators, and be built from iterators.
	let bv: BitVec<Lsb0, u8> = bits.iter().collect();
	println!(
		"An Lsb0 BitVec has the opposite layout in memory as it does \
		 semantically"
	);
	render(&bv);

	let bv: BitVec<Msb0, u16> = bv.into_iter().collect();
	println!("A BitVec can use storage other than u8");
	render(&bv);

	println!("BitVec can participate in Boolean arithmetic");
	let full = bv.clone() | repeat(true);
	render(&full);
	let empty = full & repeat(false);
	render(&empty);
	let flip = bv ^ repeat(true);
	render(&flip);
	let bv = !flip;
	render(&bv);

	println!(
		"\
Bit slice operations will never affect or observe memory outside the domain of
the slice descriptor. This can result in slow behavior when operations must work
bit-by-bit on partial outer elements, especially as the slice uses more of the
outer, but any whole elements in the slice will always use the full-element
operations. This makes `u8` faster than `u32` in cases where the partially-used
edge elements dominate, but `u32` faster than `u8` when wholly-used elements
are dominant."
	);

	//  Push and pop to the bitvec
	let mut bv = bv;
	for _ in 0 .. 12 {
		bv.push(false);
	}
	for _ in 0 .. 12 {
		bv.pop();
	}
	render(&bv);

	println!("End example");

	fn render<O, T>(bs: &BitSlice<O, T>)
	where
		O: BitOrder,
		T: BitStore,
	{
		println!(
			"Memory information: {} elements, {} bits",
			bs.as_raw_slice().len(),
			bs.len(),
		);
		println!("Print out the semantic contents");
		println!("{:#?}", bs);
		println!("Print out the memory contents");
		println!("{:?}", bs.domain());
		println!("Show the bits in memory");
		for elt in bs.domain() {
			println!("{:0w$b} ", elt, w = T::Mem::BITS as usize);
		}
		println!();
	}
}

#[cfg(not(feature = "std"))]
fn main() {
	//  This example requires the standard library.
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/examples/tour.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/rustfmt-nightly.toml =====
################################################################################
#                           Rust Style Configuration                           #
#                                                                              #
# This file controls the operation of `rustfmt` and `cargo fmt`. As the        #
# `rustfmt` tool is still unstable, this file is only usable by the nightly    #
# release of Rust at least as of the date this file was last touched.          #
#                                                                              #
# See <https://rust-lang.github.io/rustfmt/?version=v1.4.36>                   #
################################################################################

# Stable as of current nightly
edition = "2018"
fn_args_layout = "Tall"
force_explicit_abi = true
hard_tabs = true
match_arm_leading_pipes = "Never"
max_width = 81
merge_derives = true
newline_style = "Unix"
remove_nested_parens = true
reorder_imports = true
reorder_modules = true
tab_spaces = 4
use_field_init_shorthand = true
use_small_heuristics = "Default"
use_try_shorthand = true

# Still unstable
binop_separator = "Front"
blank_lines_lower_bound = 0
blank_lines_upper_bound = 1
brace_style = "SameLineWhere"
color = "Auto"
combine_control_expr = true
comment_width = 80
condense_wildcard_suffixes = true
control_brace_style = "ClosingNextLine"
disable_all_formatting = false
empty_item_single_line = false
enum_discrim_align_threshold = 40
error_on_line_overflow = false
error_on_unformatted = false
fn_single_line = false
force_multiline_blocks = false
format_code_in_doc_comments = false
format_macro_matchers = true
format_macro_bodies = true
format_strings = true
group_imports = "StdExternalCrate"
hide_parse_errors = false
ignore = []
imports_indent = "Block"
imports_granularity = "Crate"
imports_layout = "Vertical"
indent_style = "Block"
inline_attribute_width = 0
license_template_path = ""
match_arm_blocks = true
match_block_trailing_comma = true
normalize_comments = false
normalize_doc_attributes = true
overflow_delimited_expr = true
reorder_impl_items = true
report_fixme = "Never"
report_todo = "Never"
skip_children = false
space_after_colon = true
space_before_colon = false
spaces_around_ranges = true
struct_field_align_threshold = 0
struct_lit_single_line = true
trailing_comma = "Vertical"
trailing_semicolon = true
type_punctuation_density = "Wide"
unstable_features = true
version = "Two"
where_single_line = true
wrap_comments = true
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/rustfmt-nightly.toml =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/rustfmt.toml =====
################################################################################
#                           Rust Style Configuration                           #
#                                                                              #
# This file controls the operation of `rustfmt` and `cargo fmt`. As the        #
# `rustfmt` tool is still unstable, this file only contains the configurations #
# that are stable as of the pinned Rust version in `rust-toolchain`. The file  #
# `rustfmt-nightly.toml` contains the configurations that are available as of  #
# the nightly Rust release when that file was last touched.                    #
#                                                                              #
# See <https://rust-lang.github.io/rustfmt/?version=v1.4.20>                   #
################################################################################

edition = "2018"
fn_args_layout = "Tall"
force_explicit_abi = true
hard_tabs = true
max_width = 81
merge_derives = true
newline_style = "Unix"
remove_nested_parens = true
reorder_imports = true
reorder_modules = true
tab_spaces = 4
use_field_init_shorthand = true
use_small_heuristics = "Default"
use_try_shorthand = true
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/rustfmt.toml =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/access.rs =====
/*! Memory access guards.

[`bitvec`] allows a program to produce handles over memory that do not logically
alias their bits, but may alias in hardware. This module provides a unified
interface for memory accesses that can be specialized to handle aliased and
unaliased access events.

The [`BitAccess`] trait provides capabilities to access bits in memory elements
through shared references, and its implementations are responsible for
coördinating synchronization and contention as needed.

The [`BitSafe`] trait abstracts over wrappers to the [`Cell`] and [atomic] types
that forbid writing through their references, even when other references to the
same location may write.

[`BitAccess`]: crate::access::BitAccess
[`BitSafe`]: crate::access::BitSafe
[`Cell`]: core::cell::Cell
[`bitvec`]: crate
!*/

use core::sync::atomic;

use funty::IsInteger;
use radium::Radium;

use crate::{
	index::{
		BitIdx,
		BitMask,
	},
	mem::BitRegister,
	order::BitOrder,
};

/** Abstracts over the instructions used when accessing a memory location.

This trait provides functions to manipulate bits in a referent memory register
through the appropriate access instructions, so that use sites elsewhere in the
crate can select their required behavior without changing their interface.

This is automatically implemented for all types that permit shared/mutable
memory access to memory registers through the [`radium`] crate. Its use is
constrained in the [`store`] module.

This trait is only ever used by [`bitvec`] internals, and is never exposed
outside the crate. It must be marked as public so that it can be used as an
associated item in [`BitStore`], even though it is never made accessible.

[`BitStore`]: crate::store::BitStore
[`bitvec`]: crate
[`radium`]: radium
[`store`]: crate::store
**/
pub trait BitAccess: Radium
where <Self as Radium>::Item: BitRegister
{
	/// Clears any number of bits in a memory register to `0`.
	///
	/// The mask provided to this method must be constructed from indices that
	/// are valid in the caller’s context. As the mask is already computed by
	/// the caller, this does not take an ordering type parameter.
	///
	/// # Parameters
	///
	/// - `&self`
	/// - `mask`: A mask of any number of bits. This is a selection mask: all
	///   bits in the mask that are set to `1` will be modified in the element
	///   at `*self`.
	///
	/// # Effects
	///
	/// All bits in `*self` that are selected (set to `1` in the `mask`) will be
	/// cleared. All bits in `*self` that are not selected (cleared to `0` in
	/// the `mask`) are unchanged.
	///
	/// Do not invert the `mask` prior to calling this function in order to save
	/// the unselected bits and clear the selected bits. [`BitMask`] is a
	/// selection type, not a bitwise-operation argument.
	///
	/// [`BitMask`]: crate::index::BitMask
	fn clear_bits(&self, mask: BitMask<Self::Item>) {
		self.fetch_and(!mask.into_inner(), atomic::Ordering::Relaxed);
	}

	/// Sets any number of bits in a memory register to `1`.
	///
	/// The mask provided to this method must be constructed from indices that
	/// are valid in the caller’s context. As the mask is already computed by
	/// the caller, this does not take an ordering type parameter.
	///
	/// # Parameters
	///
	/// - `&self`
	/// - `mask`: A mask of any number of bits. This is a selection mask: all
	///   bits in the mask that are set to `1` will be modified in the element
	///   at `*self`.
	///
	/// # Effects
	///
	/// All bits in `*self` that are selected (set to `1` in the `mask`) will be
	/// cleared. All bits in `*self` that are not selected (cleared to `0` in
	/// the `mask`) are unchanged.
	fn set_bits(&self, mask: BitMask<Self::Item>) {
		self.fetch_or(mask.into_inner(), atomic::Ordering::Relaxed);
	}

	/// Inverts any number of bits in a memory register.
	///
	/// The mask provided to this method must be constructed from indices that
	/// are valid in the caller’s context. As the mask is already computed by
	/// the caller, this does not take an ordering type parameter.
	///
	/// # Parameters
	///
	/// - `&self`
	/// - `mask`: A mask of any number of bits. This is a selection mask: all
	///   bits in the mask that are set to `1` will be modified in the element
	///   at `*self`.
	///
	/// # Effects
	///
	/// All bits in `*self` that are selected (set to `1` in the `mask`) will be
	/// inverted. All bits in `*self` that are not selected (cleared to `0` in
	/// the `mask`) are unchanged.
	fn invert_bits(&self, mask: BitMask<Self::Item>) {
		self.fetch_xor(mask.into_inner(), atomic::Ordering::Relaxed);
	}

	/// Writes a value to one bit in a memory register.
	///
	/// # Type Parameters
	///
	/// - `O`: A bit ordering.
	///
	/// # Parameters
	///
	/// - `&self`
	/// - `index`: The semantic index of the bit in `*self` to write.
	/// - `value`: The bit value to write into `*self` at `index`.
	///
	/// # Returns
	///
	/// The bit previously stored in `*self` at `index`. As these operations are
	/// required to load the `*self` value from memory in order to work, the
	/// previous value can be retained to reduce spurious loads elsewhere in the
	/// crate.
	///
	/// # Effects
	///
	/// The memory register at address `self` has the bit corresponding to the
	/// `index` cursor under the `O` order written with the new `value`, and all
	/// other bits are unchanged.
	fn write_bit<O>(&self, index: BitIdx<Self::Item>, value: bool) -> bool
	where O: BitOrder {
		let select = index.select::<O>().into_inner();
		select
			& if value {
				self.fetch_or(select, atomic::Ordering::Relaxed)
			}
			else {
				self.fetch_and(!select, atomic::Ordering::Relaxed)
			} != <Self::Item>::ZERO
	}

	/// Gets the function that writes `value` into all bits under a mask.
	///
	/// # Parameters
	///
	/// - `value`: The bit that will be directly written by the returned
	///   function.
	///
	/// # Returns
	///
	/// A function which, when applied to a reference and a mask, will write
	/// `value` into memory. If `value` is `false`, then this produces
	/// [`clear_bits`]; if it is `true`, then this produces [`set_bits`].
	///
	/// [`clear_bits`]: Self::clear_bits
	/// [`set_bits`]: Self::set_bits
	fn get_writers(value: bool) -> for<'a> fn(&'a Self, BitMask<Self::Item>) {
		if value {
			Self::set_bits
		}
		else {
			Self::clear_bits
		}
	}
}

impl<A> BitAccess for A
where
	A: Radium,
	A::Item: BitRegister,
{
}

/** Restricts memory modification to only exclusive references.

The shared-mutability types do not permit locking their references to prevent
writing through them when inappropriate. Implementors of this trait are able to
view aliased memory and handle other references writing to it, even though they
themselves may be forbidden from doing so.
**/
pub trait BitSafe {
	/// The register type being guarded against shared mutation.
	///
	/// This is only present as an extra proof that the type graph all uses the
	/// same underlying integers.
	type Mem: BitRegister;

	/// The accessor type being prevented from mutating while shared.
	///
	/// This is exposed as an associated type so that `BitStore` can name it
	/// without having to re-select it based on crate configuration.
	type Rad: Radium<Item = Self::Mem>;

	/// Reads the value out of memory only if a shared reference to the location
	/// can be produced.
	fn load(&self) -> Self::Mem;

	/// Writes a value into memory only if an exclusive reference to the
	/// location can be produced.
	fn store(&mut self, value: Self::Mem);
}

macro_rules! safe {
	($($t:ident => $w:ident => $r:path),+ $(,)?) => { $(
		/// A wrapper over a shared-mutable type that forbids writing to the
		/// location through its own reference. Other references to the location
		/// may still write to it, and reads from this reference will be aware
		/// of this possibility.
		///
		/// This is necessary in order to enforce [`bitvec`]’s memory model,
		/// which disallows shared mutation to individual bits. [`BitSlice`]s
		/// may produce memory views that use this type in order to ensure that
		/// handles that lack write permission to an area may not write to it,
		/// even if other handles may.
		///
		/// Under the `"atomic"` feature, this uses [`radium`]’s best-effort
		/// atomic alias; when this feature is disabled, then it uses a [`Cell`]
		/// directly.
		///
		/// [`BitSlice`]: crate::slice::BitSlice
		/// [`Cell`]: core::cell::Cell
		/// [`radium`]: radium::types
		#[derive(Debug)]
		#[repr(transparent)]
		pub struct $w {
			inner: <Self as BitSafe>::Rad,
		}

		impl BitSafe for $w {
			type Mem = $t;

			#[cfg(feature = "atomic")]
			type Rad = $r;

			#[cfg(not(feature = "atomic"))]
			type Rad = core::cell::Cell<$t>;

			fn load(&self) -> $t {
				radium::Radium::load(
					&self.inner,
					core::sync::atomic::Ordering::Relaxed,
				)
			}

			fn store(&mut self, value: $t) {
				radium::Radium::store(
					&self.inner,
					value,
					core::sync::atomic::Ordering::Relaxed,
				)
			}
		}
	)+ };
}

safe! {
	u8 => BitSafeU8 => radium::types::RadiumU8,
	u16 => BitSafeU16 => radium::types::RadiumU16,
	u32 => BitSafeU32 => radium::types::RadiumU32,
}

#[cfg(target_pointer_width = "64")]
safe!(u64 => BitSafeU64 => radium::types::RadiumU64);

safe!(usize => BitSafeUsize => radium::types::RadiumUsize);

#[cfg(test)]
mod tests {
	use super::*;
	use crate::prelude::*;

	#[test]
	fn touch_memory() {
		let mut data = 0u8;
		let bits = data.view_bits_mut::<LocalBits>();
		let accessor = unsafe {
			&*(bits
				.as_bitspan()
				.address()
				.cast::<<u8 as BitStore>::Access>())
			.to_const()
		};
		let aliased = unsafe {
			&*(bits.as_bitspan().address().to_const()
				as *const <u8 as BitStore>::Alias)
		};

		BitAccess::set_bits(accessor, BitMask::ALL);
		assert_eq!(accessor.get(), !0);

		BitAccess::clear_bits(accessor, BitMask::ALL);
		assert_eq!(accessor.get(), 0);

		BitAccess::invert_bits(accessor, BitMask::ALL);
		assert_eq!(accessor.get(), !0);

		assert!(BitStore::get_bit::<Lsb0>(aliased, BitIdx::ZERO));
		assert_eq!(accessor.get(), !0);

		BitAccess::write_bit::<Lsb0>(accessor, BitIdx::new(1).unwrap(), false);
		assert_eq!(accessor.get(), !2);
	}

	#[test]
	#[cfg(not(miri))]
	fn sanity_check_prefetch() {
		use core::cell::Cell;
		assert_eq!(
			<Cell<u8> as BitAccess>::get_writers(false) as *const (),
			<Cell<u8> as BitAccess>::clear_bits as *const ()
		);

		assert_eq!(
			<Cell<u8> as BitAccess>::get_writers(true) as *const (),
			<Cell<u8> as BitAccess>::set_bits as *const ()
		);
	}

	#[test]
	fn safe_wrappers() {
		use super::BitSafe;

		let bits = bits![mut Msb0, u8; 0; 24];
		let (l, c): (&mut BitSlice<Msb0, BitSafeU8>, _) = bits.split_at_mut(4);
		let (c, _): (&mut BitSlice<Msb0, BitSafeU8>, _) = c.split_at_mut(16);

		//  Get a write-capable shared reference to the base address,
		let l_redge: &<BitSafeU8 as BitSafe>::Rad =
			l.domain_mut().region().unwrap().2.unwrap().0;
		//  and a write-incapable shared reference to the same base address.
		let c_ledge: &BitSafeU8 = c.domain().region().unwrap().0.unwrap().1;

		//  The split location means that the two subdomains share a location.
		assert_eq!(
			l_redge as *const _ as *const u8,
			c_ledge as *const _ as *const u8,
		);

		//  The center reference can only read,
		assert_eq!(c_ledge.load(), 0);
		//  while the left reference can write,
		l_redge.set_bits(BitMask::new(6));
		//  and be observed by the center.
		assert_eq!(c_ledge.load(), 6);
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/access.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/array/iter.rs =====
//! Array iteration.

use core::{
	fmt::{
		self,
		Debug,
		Formatter,
	},
	iter::FusedIterator,
	ops::Range,
};

use tap::pipe::Pipe;

use super::BitArray;
use crate::{
	order::BitOrder,
	ptr::{
		BitPtr,
		Const,
	},
	slice::BitSlice,
	view::BitViewSized,
};

/** A by-value [bit-array] iterator.

# Original

[`array::IntoIter`](core::array::IntoIter)

[bit-array]: crate::array::BitArray
[`BitView`]: crate::view::BitView
**/
#[derive(Clone)]
pub struct IntoIter<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	/// The array being iterated.
	array: BitArray<O, V>,

	/// The bits in `array` that have not yet been yielded.
	///
	/// Invariants:
	/// - `alive.start <= alive.end`
	/// - `alive.end <= V::BITS`
	alive: Range<usize>,
}

impl<O, V> IntoIter<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	/// Creates a new iterator over the given `array`.
	///
	/// # Original
	///
	/// [`IntoIter::new`](core::array::IntoIter::new)
	#[inline]
	pub(super) fn new(array: BitArray<O, V>) -> Self {
		Self {
			array,
			alive: 0 .. V::BITS,
		}
	}

	/// Returns an immutable slice of all bits that have not been yielded yet.
	///
	/// # Original
	///
	/// [`IntoIter::as_slice`](core::array::IntoIter::as_slice)
	#[inline]
	pub fn as_bitslice(&self) -> &BitSlice<O, V::Store> {
		unsafe { self.array.as_bitslice().get_unchecked(self.alive.clone()) }
	}

	#[doc(hidden)]
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	#[deprecated = "Use `as_bitslice` to view the underlying slice"]
	pub fn as_slice(&self) -> &BitSlice<O, V::Store> {
		self.as_bitslice()
	}

	/// Returns a mutable slice of all bits that have not been yielded yet.
	///
	/// # Original
	///
	/// [`IntoIter::as_mut_slice`](core::array::IntoIter::as_mut_slice)
	#[inline]
	pub fn as_mut_bitslice(&mut self) -> &mut BitSlice<O, V::Store> {
		unsafe {
			self.array
				.as_mut_bitslice()
				.get_unchecked_mut(self.alive.clone())
		}
	}

	#[doc(hidden)]
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	#[deprecated = "Use `as_mut_bitslice` to view the underlying slice"]
	pub fn as_mut_slice(&mut self) -> &mut BitSlice<O, V::Store> {
		self.as_mut_bitslice()
	}

	/// Extracts a bit from the array.
	#[inline]
	fn get(&self, index: usize) -> bool {
		unsafe {
			self.array
				.as_raw_slice()
				.pipe(BitPtr::<Const, O, V::Store>::from_slice)
				.add(index)
				.read()
		}
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, V> Debug for IntoIter<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		fmt.debug_tuple("IntoIter")
			.field(&self.as_bitslice())
			.finish()
	}
}

impl<O, V> Iterator for IntoIter<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	type Item = bool;

	#[inline]
	fn next(&mut self) -> Option<Self::Item> {
		self.alive.next().map(|idx| self.get(idx))
	}

	#[inline]
	fn nth(&mut self, n: usize) -> Option<Self::Item> {
		self.alive.nth(n).map(|idx| self.get(idx))
	}

	#[inline]
	fn size_hint(&self) -> (usize, Option<usize>) {
		let len = self.len();
		(len, Some(len))
	}

	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	fn count(self) -> usize {
		self.len()
	}

	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	fn last(mut self) -> Option<Self::Item> {
		self.next_back()
	}
}

impl<O, V> DoubleEndedIterator for IntoIter<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	#[inline]
	fn next_back(&mut self) -> Option<Self::Item> {
		self.alive.next_back().map(|idx| self.get(idx))
	}

	#[inline]
	fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
		self.alive.nth_back(n).map(|idx| self.get(idx))
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, V> ExactSizeIterator for IntoIter<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	#[inline(always)]
	fn len(&self) -> usize {
		self.alive.len()
	}
}

impl<O, V> FusedIterator for IntoIter<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/array/iter.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/array/ops.rs =====
//! Port of the `[T; N]` operator implementations.

use core::ops::{
	BitAnd,
	BitAndAssign,
	BitOr,
	BitOrAssign,
	BitXor,
	BitXorAssign,
	Deref,
	DerefMut,
	Index,
	IndexMut,
	Not,
};

use super::BitArray;
use crate::{
	order::BitOrder,
	slice::BitSlice,
	store::BitStore,
	view::BitViewSized,
};

#[cfg(not(tarpaulin_include))]
impl<O, V, Rhs> BitAnd<Rhs> for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
	BitSlice<O, V::Store>: BitAndAssign<Rhs>,
{
	type Output = Self;

	#[inline]
	fn bitand(mut self, rhs: Rhs) -> Self::Output {
		self &= rhs;
		self
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, V, Rhs> BitAndAssign<Rhs> for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
	BitSlice<O, V::Store>: BitAndAssign<Rhs>,
{
	#[inline]
	fn bitand_assign(&mut self, rhs: Rhs) {
		*self.as_mut_bitslice() &= rhs;
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, V, Rhs> BitOr<Rhs> for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
	BitSlice<O, V::Store>: BitOrAssign<Rhs>,
{
	type Output = Self;

	#[inline]
	fn bitor(mut self, rhs: Rhs) -> Self::Output {
		self |= rhs;
		self
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, V, Rhs> BitOrAssign<Rhs> for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
	BitSlice<O, V::Store>: BitOrAssign<Rhs>,
{
	#[inline]
	fn bitor_assign(&mut self, rhs: Rhs) {
		*self.as_mut_bitslice() |= rhs;
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, V, Rhs> BitXor<Rhs> for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
	BitSlice<O, V::Store>: BitXorAssign<Rhs>,
{
	type Output = Self;

	#[inline]
	fn bitxor(mut self, rhs: Rhs) -> Self::Output {
		self ^= rhs;
		self
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, V, Rhs> BitXorAssign<Rhs> for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
	BitSlice<O, V::Store>: BitXorAssign<Rhs>,
{
	#[inline]
	fn bitxor_assign(&mut self, rhs: Rhs) {
		*self.as_mut_bitslice() ^= rhs;
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, V> Deref for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	type Target = BitSlice<O, V::Store>;

	#[inline(always)]
	fn deref(&self) -> &Self::Target {
		self.as_bitslice()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, V> DerefMut for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	#[inline(always)]
	fn deref_mut(&mut self) -> &mut Self::Target {
		self.as_mut_bitslice()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, V, Idx> Index<Idx> for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
	BitSlice<O, V::Store>: Index<Idx>,
{
	type Output = <BitSlice<O, V::Store> as Index<Idx>>::Output;

	#[inline]
	fn index(&self, index: Idx) -> &Self::Output {
		self.as_bitslice().index(index)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, V, Idx> IndexMut<Idx> for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
	BitSlice<O, V::Store>: IndexMut<Idx>,
{
	#[inline]
	fn index_mut(&mut self, index: Idx) -> &mut Self::Output {
		self.as_mut_bitslice().index_mut(index)
	}
}

impl<O, V> Not for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	type Output = Self;

	#[inline]
	fn not(mut self) -> Self::Output {
		for elem in self.as_mut_raw_slice() {
			elem.store_value(!elem.load_value());
		}
		self
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/array/ops.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/array/tests.rs =====
//! Unit tests for the `array` module.

#![cfg(test)]

use tap::conv::TryConv;

use crate::{
	prelude::*,
	view::BitViewSized,
};

#[test]
fn create_arrays() {
	macro_rules! make {
		($($elts:literal),+ $(,)?) => { $(
			let _ = BitArray::<LocalBits, [u8; $elts]>::zeroed();
			let _ = BitArray::<LocalBits, [u16; $elts]>::zeroed();
			let _ = BitArray::<LocalBits, [u32; $elts]>::zeroed();
			let _ = BitArray::<LocalBits, [usize; $elts]>::zeroed();

			#[cfg(target_pointer_width = "64")] {
			let _ = BitArray::<LocalBits, [u64; $elts]>::zeroed();
			}
		)+ };
	}

	make!(
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
		20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32
	);
}

#[test]
fn wrap_unwrap() {
	let data: [u8; 15] = *b"Saluton, mondo!";
	let bits = BitArray::<LocalBits, _>::new(data);
	assert_eq!(bits.into_inner(), data);
}

#[test]
fn views() {
	let mut arr = bitarr![Msb0, u8; 0; 20];

	let s: &mut [u8] = arr.as_mut_raw_slice();
	s[0] = !0u8;
	let s: &[u8] = arr.as_raw_slice();
	assert_eq!(s, &[!0, 0, 0]);

	let a: &mut [u8; 3] = arr.as_mut_buffer();
	*a = [!0u8; 3];
	let a: &[u8; 3] = arr.as_buffer();
	assert_eq!(*a, [!0u8; 3]);
}

#[test]
fn convert() {
	let arr: BitArray<Lsb0, _> = 2u8.into();
	assert!(arr.any());

	let bits = bits![Msb0, u8; 1; 128];
	let arr = bits.try_conv::<BitArray<Msb0, [u8; 16]>>().unwrap();
	assert!(arr.all());

	let bits = bits![Lsb0, u32; 0; 64];
	let arr = bits.try_conv::<&BitArray<Lsb0, [u32; 2]>>().unwrap();
	assert!(arr.not_any());

	let bits = bits![mut Msb0, u16; 0; 64];
	let arr = bits.try_conv::<&mut BitArray<Msb0, [u16; 4]>>().unwrap();
	assert!(arr.not_any());

	let bits = bits![mut LocalBits, usize; 0; 4];
	assert!((&*bits).try_conv::<&BitArray<LocalBits, usize>>().is_err());
	assert!(bits.try_conv::<&mut BitArray<LocalBits, usize>>().is_err());
}

#[test]
#[allow(deprecated)]
fn iter() {
	let mut iter = bitarr![0, 0, 0, 1, 1, 1, 0, 0, 0].into_iter();
	let width = <[usize; 1] as BitViewSized>::BITS;

	let slice = iter.as_slice();
	let iter_slice = iter.as_bitslice();
	assert_eq!(slice, iter_slice);
	assert_eq!(iter_slice.count_ones(), 3);
	assert_eq!(iter_slice.len(), width);

	iter.as_mut_bitslice().set(0, true);
	iter.as_mut_slice().set(1, true);
	assert_eq!(iter.as_bitslice().count_ones(), 5);

	assert!(iter.next().unwrap());
	//  get the last bit of the literal
	assert!(!iter.nth_back(width - 9).unwrap());
	//  advance to the first `0` bit after the `1`s in the literal
	assert!(!iter.nth_back(1).unwrap());
	assert!(!iter.nth(1).unwrap());
	assert_eq!(iter.as_bitslice(), bits![1; 3]);

	assert!(iter.next().unwrap());
	assert!(iter.clone().last().unwrap());
	assert_eq!(iter.size_hint(), (2, Some(2)));
	assert_eq!(iter.clone().count(), 2);

	//  Reference iterators

	assert!((&bitarr![0]).into_iter().all(|b| !*b));
	assert!((&bitarr![1]).into_iter().any(|b| *b));

	let mut arr = bitarr![0];
	assert!(arr.not_any());
	for mut bit in &mut arr {
		*bit = !*bit;
	}
	assert!(arr.all(), "{:?}", arr);
}

#[test]
fn ops() {
	let a = bitarr![0, 0, 1, 1];
	let b = bitarr![0, 1, 0, 1];

	let c = a & b;
	assert_eq!(c, bitarr![0, 0, 0, 1]);

	let d = a | b;
	assert_eq!(d, bitarr![0, 1, 1, 1]);

	let e = a ^ b;
	assert_eq!(e, bitarr![0, 1, 1, 0]);

	let mut f = !e;
	//  Array literals are zero-extended to fill their `V` type, and do not
	//  store a length counter.
	assert_eq!(f[.. 4], bitarr![1, 0, 0, 1][.. 4]);

	let _: &BitSlice = &*a;
	let _: &mut BitSlice = &mut *f;
}

#[test]
fn traits() {
	use core::{
		borrow::{
			Borrow,
			BorrowMut,
		},
		cmp::Ordering,
	};

	let mut a = bitarr![0, 1, 0, 1];
	let bitspan = a.as_bitslice().as_bitspan();

	let bits: &BitSlice = a.borrow();
	assert_eq!(bits.as_bitspan(), bitspan);
	let bits_mut: &mut BitSlice = a.borrow_mut();
	assert_eq!(bits_mut.as_bitspan(), bitspan);

	let bits: &BitSlice = a.as_ref();
	assert_eq!(bits.as_bitspan(), bitspan);
	let bits_mut: &mut BitSlice = a.as_mut();
	assert_eq!(bits_mut.as_bitspan(), bitspan);

	let a = bitarr![0, 1];
	let b = bitarr![0, 0];
	assert!(a > b);
	assert_eq!(a.cmp(&b), Ordering::Greater);

	let a: BitArray = BitArray::default();
	assert!(a.not_any());
}

#[test]
#[cfg(feature = "alloc")]
fn format() {
	#[cfg(not(feature = "std"))]
	use alloc::format;

	let a = bitarr![0; 20];

	assert_eq!(format!("{}", a), format!("{}", a.as_bitslice()));
	assert_eq!(format!("{:b}", a), format!("{:b}", a.as_bitslice()));
	assert_eq!(format!("{:o}", a), format!("{:o}", a.as_bitslice()));
	assert_eq!(format!("{:x}", a), format!("{:x}", a.as_bitslice()));
	assert_eq!(format!("{:X}", a), format!("{:X}", a.as_bitslice()));

	let text = format!("{:?}", bitarr![Msb0, u8; 0, 1, 0, 0]);
	assert!(
		text.starts_with("BitArray<bitvec::order::Msb0, u8> { addr: 0x"),
		"{}",
		text
	);
	assert!(
		text.ends_with(", head: 000, bits: 8 } [01000000]"),
		"{}",
		text
	);
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/array/tests.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/array/traits.rs =====
//! Non-operator trait implementations.

use core::{
	borrow::{
		Borrow,
		BorrowMut,
	},
	cmp,
	convert::TryFrom,
	fmt::{
		self,
		Binary,
		Debug,
		Display,
		Formatter,
		LowerHex,
		Octal,
		UpperHex,
	},
	hash::{
		Hash,
		Hasher,
	},
};

use super::{
	BitArray,
	IntoIter,
};
use crate::{
	index::BitIdx,
	order::BitOrder,
	slice::BitSlice,
	store::BitStore,
	view::BitViewSized,
};

#[cfg(not(tarpaulin_include))]
impl<O, V> Borrow<BitSlice<O, V::Store>> for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	#[inline(always)]
	fn borrow(&self) -> &BitSlice<O, V::Store> {
		self.as_bitslice()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, V> BorrowMut<BitSlice<O, V::Store>> for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	#[inline(always)]
	fn borrow_mut(&mut self) -> &mut BitSlice<O, V::Store> {
		self.as_mut_bitslice()
	}
}

impl<O, V> Clone for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	#[inline]
	fn clone(&self) -> Self {
		let mut out = Self::zeroed();
		for (dst, src) in
			out.as_mut_raw_slice().iter_mut().zip(self.as_raw_slice())
		{
			dst.store_value(src.load_value());
		}
		out
	}
}

impl<O, V> Eq for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
}

impl<O, V> Ord for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	#[inline]
	fn cmp(&self, other: &Self) -> cmp::Ordering {
		self.as_bitslice().cmp(other.as_bitslice())
	}
}

impl<O1, O2, V, T> PartialEq<BitArray<O2, V>> for BitSlice<O1, T>
where
	O1: BitOrder,
	O2: BitOrder,
	V: BitViewSized,
	T: BitStore,
{
	#[inline]
	fn eq(&self, other: &BitArray<O2, V>) -> bool {
		self == other.as_bitslice()
	}
}

impl<O, V, Rhs> PartialEq<Rhs> for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
	Rhs: ?Sized,
	BitSlice<O, V::Store>: PartialEq<Rhs>,
{
	#[inline]
	fn eq(&self, other: &Rhs) -> bool {
		self.as_bitslice() == other
	}
}

impl<O, V, T> PartialOrd<BitArray<O, V>> for BitSlice<O, T>
where
	O: BitOrder,
	V: BitViewSized,
	T: BitStore,
{
	#[inline]
	fn partial_cmp(&self, other: &BitArray<O, V>) -> Option<cmp::Ordering> {
		self.partial_cmp(other.as_bitslice())
	}
}

impl<O, V, Rhs> PartialOrd<Rhs> for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
	Rhs: ?Sized,
	BitSlice<O, V::Store>: PartialOrd<Rhs>,
{
	#[inline]
	fn partial_cmp(&self, other: &Rhs) -> Option<cmp::Ordering> {
		self.as_bitslice().partial_cmp(other)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, V> AsRef<BitSlice<O, V::Store>> for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	#[inline(always)]
	fn as_ref(&self) -> &BitSlice<O, V::Store> {
		self.as_bitslice()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, V> AsMut<BitSlice<O, V::Store>> for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	#[inline(always)]
	fn as_mut(&mut self) -> &mut BitSlice<O, V::Store> {
		self.as_mut_bitslice()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, V> From<V> for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	#[inline(always)]
	fn from(data: V) -> Self {
		Self::new(data)
	}
}

impl<'a, O, V> TryFrom<&'a BitSlice<O, V::Store>> for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	type Error = TryFromBitSliceError<'a, O, V::Store>;

	#[inline]
	fn try_from(src: &'a BitSlice<O, V::Store>) -> Result<Self, Self::Error> {
		if src.len() != V::BITS {
			return Self::Error::err(src);
		}
		let mut out = Self::zeroed();
		out.copy_from_bitslice(src);
		Ok(out)
	}
}

impl<'a, O, V> TryFrom<&'a BitSlice<O, V::Store>> for &'a BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	type Error = TryFromBitSliceError<'a, O, V::Store>;

	#[inline]
	fn try_from(src: &'a BitSlice<O, V::Store>) -> Result<Self, Self::Error> {
		let bitspan = src.as_bitspan();
		//  This pointer cast can only happen if the slice is exactly as long as
		//  the array, and is aligned to the front of the element.
		if src.len() != V::BITS || bitspan.head() != BitIdx::ZERO {
			return Self::Error::err(src);
		}
		Ok(unsafe { &*(bitspan.address().to_const() as *const BitArray<O, V>) })
	}
}

impl<'a, O, V> TryFrom<&'a mut BitSlice<O, V::Store>> for &'a mut BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	type Error = TryFromBitSliceError<'a, O, V::Store>;

	#[inline]
	fn try_from(
		src: &'a mut BitSlice<O, V::Store>,
	) -> Result<Self, Self::Error> {
		let bitspan = src.as_mut_bitspan();
		if src.len() != V::BITS || bitspan.head() != BitIdx::ZERO {
			return Self::Error::err(&*src);
		}
		Ok(unsafe { &mut *(bitspan.address().to_mut() as *mut BitArray<O, V>) })
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, V> Default for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	#[inline(always)]
	fn default() -> Self {
		Self::zeroed()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, V> Binary for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		Binary::fmt(self.as_bitslice(), fmt)
	}
}

impl<O, V> Debug for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		self.as_bitspan().render(fmt, "Array", None)?;
		fmt.write_str(" ")?;
		Display::fmt(self, fmt)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, V> Display for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		Display::fmt(self.as_bitslice(), fmt)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, V> LowerHex for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		LowerHex::fmt(self.as_bitslice(), fmt)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, V> Octal for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		Octal::fmt(self.as_bitslice(), fmt)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, V> UpperHex for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		UpperHex::fmt(self.as_bitslice(), fmt)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, V> Hash for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	#[inline]
	fn hash<H>(&self, hasher: &mut H)
	where H: Hasher {
		self.as_bitslice().hash(hasher)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, V> IntoIterator for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	type IntoIter = IntoIter<O, V>;
	type Item = bool;

	#[inline(always)]
	fn into_iter(self) -> Self::IntoIter {
		IntoIter::new(self)
	}
}

#[cfg(not(tarpaulin_include))]
impl<'a, O, V> IntoIterator for &'a BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	type IntoIter = <&'a BitSlice<O, V::Store> as IntoIterator>::IntoIter;
	type Item = <&'a BitSlice<O, V::Store> as IntoIterator>::Item;

	#[inline]
	fn into_iter(self) -> Self::IntoIter {
		self.as_bitslice().into_iter()
	}
}

#[cfg(not(tarpaulin_include))]
impl<'a, O, V> IntoIterator for &'a mut BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	type IntoIter = <&'a mut BitSlice<O, V::Store> as IntoIterator>::IntoIter;
	type Item = <&'a mut BitSlice<O, V::Store> as IntoIterator>::Item;

	#[inline]
	fn into_iter(self) -> Self::IntoIter {
		self.as_mut_bitslice().into_iter()
	}
}

impl<O, V> Copy for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized + Copy,
{
}

impl<O, V> Unpin for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
}

/** The error type returned when a conversion from a [`BitSlice`] to a
[`BitArray`] fails.

[`BitArray`]: crate::array::BitArray
[`BitSlice`]: crate::slice::BitSlice
**/
#[repr(transparent)]
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
pub struct TryFromBitSliceError<'a, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	inner: &'a BitSlice<O, T>,
}

#[cfg(not(tarpaulin_include))]
impl<'a, O, T> TryFromBitSliceError<'a, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn err<A>(inner: &'a BitSlice<O, T>) -> Result<A, Self> {
		Err(Self { inner })
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Debug for TryFromBitSliceError<'_, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		fmt.debug_struct("TryFromBitSliceError")
			.field("inner", &self.inner)
			.finish()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Display for TryFromBitSliceError<'_, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		fmt.write_fmt(format_args!(
			"could not convert bit-slice to bit-array: {:?}",
			self.inner,
		))
	}
}

#[cfg(feature = "std")]
impl<'a, O, T> std::error::Error for TryFromBitSliceError<'a, O, T>
where
	O: BitOrder,
	T: BitStore,
{
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/array/traits.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/array.rs =====
/*! A statically-allocated, fixed-size, buffer containing a [`BitSlice`] region.

You can read the language’s [array fundamental documentation][std] here.

This module defines the [`BitArray`] immediate type, and its associated support
code.

[`BitArray`] is equivalent to `[bool; N]`, in its operation and in its
relationship to the [`BitSlice`] type. It has little behavior or properties in
its own right, and serves solely as a type capable of being used in immediate
value position, and delegates to `BitSlice` for all actual work.

[`BitArray`]: crate::array::BitArray
[`BitSlice`]: crate::slice::BitSlice
[std]: https://doc.rust-lang.org/stable/std/primitive.array.html
!*/

use core::{
	marker::PhantomData,
	mem::MaybeUninit,
	slice,
};

use crate::{
	order::{
		BitOrder,
		Lsb0,
	},
	slice::BitSlice,
	view::BitViewSized,
};

mod iter;
mod ops;
mod traits;

pub use self::iter::IntoIter;

/* Note on C++ `std::bitset<N>` compatibility:

The ideal API for `BitArray` is as follows:

```rust
struct BitArray<O, T, const N: usize>
where
  O: BitOrder,
  T: BitStore,
  N < T::MAX_BITS,
{
  _ord: PhantomData<O>,
  data: [T; crate::mem::elts::<T>(N)],
}

impl<O, T, const N: usize> BitArray<O, T, N>
where
  O: BitOrder,
  T: BitStore,
{
  pub fn len(&self) -> usize { N }
}
```

This allows the structure to be parametric over the number of bits, rather than
a scalar or array type that satisfies the number of bits. Unfortunately, it is
inexpressible until the Rust compiler’s const-evaluation engine permits using
numeric type parameters in type-level expressions.
*/

/** An array of individual bits, able to be held by value on the stack.

This type is generic over all [`Sized`] implementors of the [`BitView`] trait.
Due to limitations in the Rust language’s const-generics implementation (it is
both unstable and incomplete), this must take an array type parameter directly,
rather than register type and bit-count integer parameters. This makes it less
convenient to use than C++’s [`std::bitset<N>`] array type. The [`bitarr!`]
macro is capable of constructing both values and specific types of `BitArray`,
and this macro should be preferred for most use.

The advantage of using this wrapper is that it implements [`Deref`]/[`Mut`] to
[`BitSlice`], as well as implementing all of `BitSlice`s traits by forwarding to
the `BitSlice` view of its contained data. This allows it to have `BitSlice`
behavior by itself, without requiring explicit [`.as_bitslice()`] calls in user
code.

# Limitations

This does not track start or end indices of its [`BitSlice`] view, and so that
view will always fully span the buffer. You cannot produce, for example, an
array of twelve bits.

# Type Parameters

- `O`: The ordering of bits within memory registers.
- `V`: Some buffer which can be used as the basis for a [`BitSlice`] view. This
  will usually be an array of `[T: BitRegister; N]`.

# Examples

This type is useful for marking that some value is always to be used as a
[`BitSlice`].
**/
///
/// ```rust
/// use bitvec::prelude::*;
///
/// struct HasBitfields {
///   header: u32,
///   // creates a type declaration.
///   fields: BitArr!(for 20, in Msb0, u8),
/// }
///
/// impl HasBitfields {
///   pub fn new() -> Self {
///     Self {
///       header: 0,
///       // creates a value object.
///       // the type paramaters must be repeated.
///       fields: bitarr![Msb0, u8; 0; 20],
///     }
///   }
///
///   /// Access a bit region directly
///   pub fn get_subfield(&self) -> &BitSlice<Msb0, u8> {
///     &self.fields[.. 4]
///   }
///
///   /// Read a 12-bit value out of a region
///   pub fn read_value(&self) -> u16 {
///     self.fields[4 .. 16].load()
///   }
///
///   /// Write a 12-bit value into a region
///   pub fn set_value(&mut self, value: u16) {
///     self.fields[4 .. 16].store(value);
///   }
/// }
/// ```
/**
# Eventual Obsolescence

When const-generics stabilize, this will be modified to have a signature more
like `BitArray<O, T, const N: usize>([T; elts::<T>(N)]);`, to mirror the
behavior of ordinary arrays `[T; N]` as they stand today.

[`BitSlice`]: crate::slice::BitSlice
[`BitView`]: crate::view::BitView
[`Deref`]: core::ops::Deref
[`Mut`]: core::ops::DerefMut
[`Sized`]: core::marker::Sized
[`bitarr!`]: macro@crate::bitarr
[`std::bitset<N>`]: https://en.cppreference.com/w/cpp/utility/bitset
[`.as_bitslice()`]: Self::as_bitslice
**/
#[repr(transparent)]
pub struct BitArray<O = Lsb0, V = [usize; 1]>
where
	O: BitOrder,
	V: BitViewSized,
{
	/// The ordering of bits within a storage element `V::Store`.
	_ord: PhantomData<O>,
	/// The wrapped data store.
	data: V,
}

impl<O, V> BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
{
	/// Constructs a new `BitArray` with its memory set to zero.
	#[inline]
	pub fn zeroed() -> Self {
		Self {
			_ord: PhantomData,
			data: unsafe { MaybeUninit::zeroed().assume_init() },
		}
	}

	/// Wraps a buffer in a `BitArray`.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let data = [0u8; 2];
	/// let bits: BitArray<Msb0, _> = BitArray::new(data);
	/// assert_eq!(bits.len(), 16);
	/// ```
	#[inline]
	pub fn new(data: V) -> Self {
		Self {
			_ord: PhantomData,
			data,
		}
	}

	/// Removes the `BitArray` wrapper, leaving the contained buffer.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bitarr = bitarr![Lsb0, usize; 0; 30];
	/// let native: [usize; 1] = bitarr.into_inner();
	/// ```
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn into_inner(self) -> V {
		self.data
	}

	/// Views the array as a [`BitSlice`].
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn as_bitslice(&self) -> &BitSlice<O, V::Store> {
		self.data.view_bits::<O>()
	}

	/// Views the array as a mutable [`BitSlice`].
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn as_mut_bitslice(&mut self) -> &mut BitSlice<O, V::Store> {
		self.data.view_bits_mut::<O>()
	}

	/// Views the array as a slice of its underlying memory registers.
	#[inline]
	pub fn as_raw_slice(&self) -> &[V::Store] {
		unsafe {
			slice::from_raw_parts(
				&self.data as *const V as *const V::Store,
				V::ELTS,
			)
		}
	}

	/// Views the array as a mutable slice of its underlying memory registers.
	#[inline]
	pub fn as_mut_raw_slice(&mut self) -> &mut [V::Store] {
		unsafe {
			slice::from_raw_parts_mut(
				&mut self.data as *mut V as *mut V::Store,
				V::ELTS,
			)
		}
	}

	#[doc(hidden)]
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	#[deprecated = "This is renamed to `as_raw_slice`"]
	pub fn as_slice(&self) -> &[V::Store] {
		self.as_raw_slice()
	}

	#[doc(hidden)]
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	#[deprecated = "This is renamed to `as_mut_raw_slice`"]
	pub fn as_mut_slice(&mut self) -> &mut [V::Store] {
		self.as_mut_raw_slice()
	}

	/// Views the interior buffer.
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn as_buffer(&self) -> &V {
		&self.data
	}

	/// Mutably views the interior buffer.
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn as_mut_buffer(&mut self) -> &mut V {
		&mut self.data
	}
}

#[cfg(test)]
mod tests;
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/array.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/boxed/api.rs =====
//! Port of the `Box<[T]>` inherent API.

use core::{
	marker::Unpin,
	mem,
	pin::Pin,
};

use tap::pipe::Pipe;

use super::BitBox;
use crate::{
	order::BitOrder,
	ptr::BitSpan,
	slice::BitSlice,
	store::BitStore,
	vec::BitVec,
};

impl<O, T> BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// Allocates memory on the heap and then copies `x` into it.
	///
	/// This doesn’t actually allocate if `x` is zero-length.
	///
	/// # Original
	///
	/// [`Box::new`](alloc::boxed::Box::new)
	///
	/// # API Differences
	///
	/// `Box::<[T]>::new` does not exist, because unsized types cannot be taken
	/// by value. Instead, this takes a slice reference, and boxes the referent
	/// slice.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let boxed = BitBox::new(bits![0; 5]);
	/// ```
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	#[deprecated = "Prefer `from_bitslice`"]
	pub fn new(x: &BitSlice<O, T>) -> Self {
		Self::from_bitslice(x)
	}

	/// Constructs a new `Pin<BitBox<O, T>>`.
	///
	/// [`BitSlice`] is always [`Unpin`], so this has no actual effect.
	///
	/// # Original
	///
	/// [`Box::pin`](alloc::boxed::Box::pin)
	///
	/// # API Differences
	///
	/// As with [`new`], this only exists on `Box` when `T` is not unsized. This
	/// takes a slice reference, and pins the referent slice.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	/// [`Unpin`]: core::marker::Unpin
	/// [`new`]: Self::new
	#[inline]
	#[cfg(not(tarpaulin_include))]
	pub fn pin(x: &BitSlice<O, T>) -> Pin<Self>
	where
		O: Unpin,
		T: Unpin,
	{
		x.pipe(Self::from_bitslice).pipe(Pin::new)
	}

	/// Constructs a bit-box from a raw bit-slice pointer.
	///
	/// After calling this function, the raw bit-slice pointer is owned by the
	/// resulting `BitBox`. Specifically, the `BitBox` destructor will free the
	/// memory allocation at the bit-slice pointer’s address. For this to be
	/// safe, the bit-slice pointer can only have been produced by a `BitBox`
	/// previously destroyed using [`into_raw`].
	///
	/// # Original
	///
	/// [`Box::from_raw`](alloc::boxed::Box::from_raw)
	///
	/// # Safety
	///
	/// This function is unsafe because improper use may lead to memory
	/// problems. For example, a double-free may occur if the function is called
	/// twice on the same raw bit-slice pointer.
	///
	/// # Examples
	///
	/// Recreate a `BitBox` which was previously converted to a raw bit-slice
	/// pointer using [`BitBox::into_raw`]:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let x = bitbox![0; 10];
	/// let ptr = BitBox::into_raw(x);
	/// let x = unsafe { BitBox::from_raw(ptr) };
	/// ```
	///
	/// [`BitBox::into_raw`]: Self::into_raw
	/// [`into_raw`]: Self::into_raw
	#[inline]
	pub unsafe fn from_raw(raw: *mut BitSlice<O, T>) -> Self {
		Self {
			bitspan: BitSpan::from_bitslice_ptr_mut(raw),
		}
	}

	/// Consumes the `BitBox`, returning a raw bit-slice pointer.
	///
	/// The bit-slice pointer will be properly encoded and non-null.
	///
	/// After calling this function, the caller is responsible for the memory
	/// previously managed by the `BitBox`. In particular, the caller should
	/// properly release the memory by converting the bit-slice pointer back
	/// into a `BitBox` with the [`from_raw`] function, allowing the `BitBox`
	/// destructor to perform the cleanup.
	///
	/// Note: this is an associated function, which means that you have to call
	/// it as `BitBox::into_raw(b)` instead of `b.into_raw()`. This is to match
	/// signatures with the standard library’s [`Box`] API; there will never be
	/// a name conflict with [`BitSlice`].
	///
	/// # Original
	///
	/// [`Box::into_raw`](alloc::boxed::Box::into_raw)
	///
	/// # Examples
	///
	/// Converting the raw bit-slice pointer back into a `BitBox` with
	/// [`BitBox::from_raw`] for automatic cleanup:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let x = bitbox![0; 50];
	/// let p = BitBox::into_raw(x);
	/// let x = unsafe { BitBox::from_raw(p) };
	/// ```
	///
	/// You may not deällocate pointers produced by this function through any
	/// other manner.
	///
	/// [`BitBox::from_raw`]: Self::from_raw
	/// [`BitSlice`]: crate::slice::BitSlice
	/// [`Box`]: alloc::boxed::Box
	/// [`from_raw`]: Self::from_raw
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn into_raw(this: Self) -> *mut BitSlice<O, T> {
		Self::leak(this)
	}

	/// Consumes and leaks the `BitBox`, returning a mutable reference, `&'a mut
	/// BitSlice<O, T>`. This is eligible to be promoted to the `'static`
	/// lifetime.
	///
	/// # Original
	///
	/// [`Box::leak`](alloc::boxed::Box::leak)
	///
	/// This function is mainly useful for data that lives for the remainder
	/// of the program’s life. Dropping the returned reference will cause a
	/// memory leak. If this is not acceptable, the reference should first be
	/// wrapped with the [`BitBox::from_raw`] function producing a `BitBox`.
	/// This `BitBox` can then be dropped which will properly deällocate the
	/// memory.
	///
	/// Note: this is an associated function, which means that you have to call
	/// it as `BitBox::leak(b)` instead of `b.leak()`. This is to match
	/// signatures with the standard library’s [`Box`] API; there will never be
	/// a name conflict with [`BitSlice`].
	///
	/// # Original
	///
	/// [`Box::leak`](alloc::boxed::Box::leak)
	///
	/// # Examples
	///
	/// Simple usage:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let b = bitbox![0; 50];
	/// let static_ref: &'static mut BitSlice = BitBox::leak(b);
	/// static_ref.set(0, true);
	/// assert!(static_ref[0]);
	/// # drop(unsafe { BitBox::from_raw(static_ref) });
	/// ```
	///
	/// [`BitBox::from_raw`]: Self::from_raw
	/// [`BitSlice`]: crate::slice::BitSlice
	/// [`Box`]: alloc::boxed::Box
	#[inline]
	pub fn leak<'a>(this: Self) -> &'a mut BitSlice<O, T>
	where T: 'a {
		let out = this.bitspan.to_bitslice_mut();
		mem::forget(this);
		out
	}

	#[doc(hidden)]
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	#[deprecated = "Prefer `into_bitvec`"]
	pub fn into_vec(self) -> BitVec<O, T> {
		self.into_bitvec()
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/boxed/api.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/boxed/iter.rs =====
//! By-value buffer iteration.

use core::{
	fmt::{
		self,
		Debug,
		Formatter,
	},
	iter::FusedIterator,
};

use super::BitBox;
use crate::{
	order::BitOrder,
	ptr::{
		BitPtrRange,
		Mut,
	},
	slice::BitSlice,
	store::BitStore,
};
/// This is not present on `Box<[T]>`, but is needed to fit into the general
/// operator implementations.
#[cfg(not(tarpaulin_include))]
impl<O, T> IntoIterator for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	type IntoIter = IntoIter<O, T>;
	type Item = bool;

	#[inline(always)]
	fn into_iter(self) -> Self::IntoIter {
		IntoIter::new(self)
	}
}

/** An iterator that moves out of a [`BitVec`].

This `struct` is created by the [`into_iter`] method on [`BitVec`] (provided by
the [`IntoIterator`] trait).

# Original

[`vec::IntoIter`](alloc::vec::IntoIter)

[`BitVec`]: crate::vec::BitVec
[`IntoIterator`]: core::iter::IntoIterator
[`into_iter`]: core::iter::IntoIterator::into_iter
**/
pub struct IntoIter<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// The buffer being iterated.
	_buf: BitBox<O, T>,
	/// A bit-pointer iterator over the buffer’s contents.
	iter: BitPtrRange<Mut, O, T>,
}

impl<O, T> IntoIter<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// Constructs an iterator over a [`BitBox`] or [`BitVec`].
	///
	/// [`BitBox`]: crate::vec::BitBox
	/// [`BitVec`]: crate::vec::BitVec
	fn new(mut this: BitBox<O, T>) -> Self {
		let iter = this.as_mut_bitptr_range();
		Self { _buf: this, iter }
	}

	/// Returns the remaining bits of this iterator as a [`BitSlice`].
	///
	/// # Original
	///
	/// [`vec::IntoIter::as_slice`](alloc::vec::IntoIter::as_slice)
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bv = bitvec![0, 1, 0, 1];
	/// let mut into_iter = bv.into_iter();
	///
	/// assert_eq!(into_iter.as_bitslice(), bits![0, 1, 0, 1]);
	/// let _ = into_iter.next().unwrap();
	/// assert_eq!(into_iter.as_bitslice(), bits![1, 0, 1]);
	/// ```
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	#[inline]
	pub fn as_bitslice(&self) -> &BitSlice<O, T> {
		self.iter.clone().into_bitspan().to_bitslice_ref()
	}

	#[doc(hidden)]
	#[inline(always)]
	#[cfg(not(tarpalin_include))]
	#[deprecated = "Use `as_bitslice` to view the underlying slice"]
	pub fn as_slice(&self) -> &BitSlice<O, T> {
		self.as_bitslice()
	}

	/// Returns the remaining bits of this iterator as a mutable [`BitSlice`].
	///
	/// # Original
	///
	/// [`vec::IntoIter::as_mut_slice`](alloc::vec::IntoIter::as_mut_slice)
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bv = bitvec![0, 1, 0, 1];
	/// let mut into_iter = bv.into_iter();
	///
	/// assert_eq!(into_iter.as_bitslice(), bits![0, 1, 0, 1]);
	/// into_iter.as_mut_bitslice().set(2, true);
	/// assert!(!into_iter.next().unwrap());
	/// assert!(into_iter.next().unwrap());
	/// assert!(into_iter.next().unwrap());
	/// ```
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	#[inline]
	pub fn as_mut_bitslice(&mut self) -> &mut BitSlice<O, T> {
		self.iter.clone().into_bitspan().to_bitslice_mut()
	}

	#[doc(hidden)]
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	#[deprecated = "Use `as_mut_bitslice` to view the underlying slice"]
	pub fn as_mut_slice(&mut self) -> &mut BitSlice<O, T> {
		self.as_mut_bitslice()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Debug for IntoIter<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		fmt.debug_tuple("IntoIter")
			.field(&self.as_bitslice())
			.finish()
	}
}

impl<O, T> Iterator for IntoIter<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	type Item = bool;

	#[inline]
	fn next(&mut self) -> Option<Self::Item> {
		self.iter.next().map(crate::ptr::range::read_raw)
	}

	#[inline(always)]
	fn size_hint(&self) -> (usize, Option<usize>) {
		self.iter.size_hint()
	}

	#[inline(always)]
	fn count(self) -> usize {
		self.len()
	}

	#[inline]
	fn nth(&mut self, n: usize) -> Option<Self::Item> {
		self.iter.nth(n).map(crate::ptr::range::read_raw)
	}

	#[inline(always)]
	fn last(mut self) -> Option<Self::Item> {
		self.next_back()
	}
}

impl<O, T> DoubleEndedIterator for IntoIter<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn next_back(&mut self) -> Option<Self::Item> {
		self.iter.next_back().map(crate::ptr::range::read_raw)
	}

	#[inline]
	fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
		self.iter.nth_back(n).map(crate::ptr::range::read_raw)
	}
}

impl<O, T> ExactSizeIterator for IntoIter<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn len(&self) -> usize {
		self.iter.len()
	}
}

impl<O, T> FusedIterator for IntoIter<O, T>
where
	O: BitOrder,
	T: BitStore,
{
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/boxed/iter.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/boxed/ops.rs =====
//! Port of the `Box<[T]>` operator implementations.

use core::{
	mem::ManuallyDrop,
	ops::{
		BitAnd,
		BitAndAssign,
		BitOr,
		BitOrAssign,
		BitXor,
		BitXorAssign,
		Deref,
		DerefMut,
		Index,
		IndexMut,
		Not,
	},
};

use super::BitBox;
use crate::{
	order::BitOrder,
	slice::BitSlice,
	store::BitStore,
};

#[cfg(not(tarpaulin_include))]
impl<O, T, Rhs> BitAnd<Rhs> for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
	BitSlice<O, T>: BitAndAssign<Rhs>,
{
	type Output = Self;

	#[inline]
	fn bitand(mut self, rhs: Rhs) -> Self::Output {
		self &= rhs;
		self
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T, Rhs> BitAndAssign<Rhs> for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
	BitSlice<O, T>: BitAndAssign<Rhs>,
{
	#[inline]
	fn bitand_assign(&mut self, rhs: Rhs) {
		*self.as_mut_bitslice() &= rhs;
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T, Rhs> BitOr<Rhs> for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
	BitSlice<O, T>: BitOrAssign<Rhs>,
{
	type Output = Self;

	#[inline]
	fn bitor(mut self, rhs: Rhs) -> Self::Output {
		self |= rhs;
		self
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T, Rhs> BitOrAssign<Rhs> for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
	BitSlice<O, T>: BitOrAssign<Rhs>,
{
	#[inline]
	fn bitor_assign(&mut self, rhs: Rhs) {
		*self.as_mut_bitslice() |= rhs;
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T, Rhs> BitXor<Rhs> for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
	BitSlice<O, T>: BitXorAssign<Rhs>,
{
	type Output = Self;

	#[inline]
	fn bitxor(mut self, rhs: Rhs) -> Self::Output {
		self ^= rhs;
		self
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T, Rhs> BitXorAssign<Rhs> for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
	BitSlice<O, T>: BitXorAssign<Rhs>,
{
	#[inline]
	fn bitxor_assign(&mut self, rhs: Rhs) {
		*self.as_mut_bitslice() ^= rhs;
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Deref for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	type Target = BitSlice<O, T>;

	#[inline(always)]
	fn deref(&self) -> &Self::Target {
		self.as_bitslice()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> DerefMut for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn deref_mut(&mut self) -> &mut Self::Target {
		self.as_mut_bitslice()
	}
}

impl<O, T> Drop for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn drop(&mut self) {
		//  Run the `Box` destructor to deällocate the buffer.
		self.with_box(|slot| unsafe { ManuallyDrop::drop(slot) });
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T, Idx> Index<Idx> for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
	BitSlice<O, T>: Index<Idx>,
{
	type Output = <BitSlice<O, T> as Index<Idx>>::Output;

	#[inline]
	fn index(&self, index: Idx) -> &Self::Output {
		self.as_bitslice().index(index)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T, Idx> IndexMut<Idx> for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
	BitSlice<O, T>: IndexMut<Idx>,
{
	#[inline]
	fn index_mut(&mut self, index: Idx) -> &mut Self::Output {
		self.as_mut_bitslice().index_mut(index)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Not for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	type Output = Self;

	#[inline]
	fn not(mut self) -> Self::Output {
		for elem in self.as_mut_slice().iter_mut() {
			elem.store_value(!elem.load_value());
		}
		self
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/boxed/ops.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/boxed/tests.rs =====
//! Unit tests for the `boxed` module.

#[cfg(not(feature = "std"))]
use alloc::{
	boxed::Box,
	format,
};
use core::convert::TryInto;

use crate::prelude::*;

#[test]
#[allow(deprecated)]
fn api() {
	let boxed: Box<[u8]> = Box::new([0; 4]);
	let bb = BitBox::<LocalBits, _>::from_boxed_slice(boxed);
	assert_eq!(bb, bits![0; 32]);
	let boxed = bb.into_boxed_slice();
	assert_eq!(boxed[..], [0u8; 4][..]);

	let pinned = BitBox::pin(bits![0, 1, 0, 1]);
	let unpinned = BitBox::new(bits![0, 1, 0, 1]);
	assert_eq!(pinned.as_ref().get_ref(), unpinned[..]);

	let boxed = bitbox![0; 10];
	let bitspan = boxed.as_bitspan();
	let reboxed = unsafe { BitBox::from_raw(BitBox::into_raw(boxed)) };
	#[allow(deprecated)]
	{
		let _: BitVec = reboxed.clone().into_vec();
	}
	let bv = reboxed.into_bitvec();
	let bb = bv.into_boxed_bitslice();
	assert_eq!(bb.as_bitspan(), bitspan);

	let mut bb = 0b1001_0110u8.view_bits::<Msb0>()[2 .. 6]
		.to_bitvec()
		.into_boxed_bitslice();
	bb.set_uninitialized(false);
	assert_eq!(bb.as_slice(), &[0b0001_0100]);
	bb.set_uninitialized(true);
	assert_eq!(bb.as_slice(), &[0b1101_0111]);
	assert_eq!(bb, bits![0, 1, 0, 1]);
}

#[test]
fn ops() {
	let a = bitbox![0, 0, 1, 1];
	let b = bitbox![0, 1, 0, 1];

	let c = a.clone() & b.clone();
	assert_eq!(c, bitbox![0, 0, 0, 1]);

	let d = a.clone() | b.clone();
	assert_eq!(d, bitbox![0, 1, 1, 1]);

	let e = a.clone() ^ b.clone();
	assert_eq!(e, bitbox![0, 1, 1, 0]);

	let mut f = !e;
	assert_eq!(f, bitbox![1, 0, 0, 1]);

	let _: &BitSlice = &*a;
	let _: &mut BitSlice = &mut *f;

	let mut g = a.clone();
	assert!(g[.. 2].not_any());
	g[.. 2].set_all(true);
	assert!(g[.. 2].all());
}

#[test]
fn convert() {
	let boxed: BitBox = bits![1; 64].into();
	assert!(boxed.all());

	let boxed: BitBox<Lsb0, u32> = bitvec![Lsb0, u32; 0; 64].into();
	assert!(boxed.not_any());
	let boxed: Box<[u32]> = boxed.into();
	assert_eq!(&boxed[..], &[0; 2]);

	let _: BitBox<Lsb0, u32> = boxed.try_into().unwrap();
}

#[test]
fn traits() {
	use core::{
		borrow::{
			Borrow,
			BorrowMut,
		},
		cmp::Ordering,
	};

	let mut b = bitbox![0, 1, 0, 0];
	let bitspan = b.as_bitslice().as_bitspan();

	let bits: &BitSlice = b.borrow();
	assert_eq!(bits.as_bitspan(), bitspan);
	let bits_mut: &mut BitSlice = b.borrow_mut();
	assert_eq!(bits_mut.as_bitspan(), bitspan);

	let bits: &BitSlice = b.as_ref();
	assert_eq!(bits.as_bitspan(), bitspan);
	let bits_mut: &mut BitSlice = b.as_mut();
	assert_eq!(bits_mut.as_bitspan(), bitspan);

	let b1 = bitbox![0, 1];
	let b2 = bitbox![0, 0];
	assert!(b1 > b2);
	assert_eq!(b1.cmp(&b2), Ordering::Greater);
	assert_ne!(b1.as_bitslice(), b2);

	let b1_ref: &BitSlice = &*b1;
	assert_eq!((&b1_ref).partial_cmp(&b2), Some(Ordering::Greater));
	assert!(b1_ref.eq(&b1));

	let b: BitBox = BitBox::default();
	assert!(b.is_empty());
}

#[test]
#[cfg(feature = "alloc")]
fn format() {
	let b = bitbox![0; 20];

	assert_eq!(format!("{}", b), format!("{}", b.as_bitslice()));
	assert_eq!(format!("{:b}", b), format!("{:b}", b.as_bitslice()));
	assert_eq!(format!("{:o}", b), format!("{:o}", b.as_bitslice()));
	assert_eq!(format!("{:x}", b), format!("{:x}", b.as_bitslice()));
	assert_eq!(format!("{:X}", b), format!("{:X}", b.as_bitslice()));

	let text = format!("{:?}", bitbox![Msb0, u8; 0, 1, 0, 0]);
	assert!(
		text.starts_with("BitBox<bitvec::order::Msb0, u8> { addr: 0x"),
		"{}",
		text
	);
	assert!(text.ends_with(", head: 000, bits: 4 } [0100]"), "{}", text);
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/boxed/tests.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/boxed/traits.rs =====
//! Non-operator trait implementations.

use alloc::boxed::Box;
use core::{
	borrow::{
		Borrow,
		BorrowMut,
	},
	cmp,
	convert::TryFrom,
	fmt::{
		self,
		Binary,
		Debug,
		Display,
		Formatter,
		LowerHex,
		Octal,
		Pointer,
		UpperHex,
	},
	hash::{
		Hash,
		Hasher,
	},
};

use tap::pipe::Pipe;

use super::BitBox;
use crate::{
	order::BitOrder,
	ptr::{
		BitSpan,
		Mut,
	},
	slice::BitSlice,
	store::BitStore,
	vec::BitVec,
};

#[cfg(not(tarpaulin_include))]
impl<O, T> Borrow<BitSlice<O, T>> for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn borrow(&self) -> &BitSlice<O, T> {
		self.as_bitslice()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> BorrowMut<BitSlice<O, T>> for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn borrow_mut(&mut self) -> &mut BitSlice<O, T> {
		self.as_mut_bitslice()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Clone for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn clone(&self) -> Self {
		self.as_bitslice().pipe(Self::from_bitslice)
	}
}

impl<O, T> Eq for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Ord for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn cmp(&self, other: &Self) -> cmp::Ordering {
		self.as_bitslice().cmp(other.as_bitslice())
	}
}

#[cfg(not(tarpaulin_include))]
impl<O1, O2, T1, T2> PartialEq<BitBox<O2, T2>> for BitSlice<O1, T1>
where
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn eq(&self, other: &BitBox<O2, T2>) -> bool {
		self == other.as_bitslice()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O1, O2, T1, T2> PartialEq<BitBox<O2, T2>> for &BitSlice<O1, T1>
where
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn eq(&self, other: &BitBox<O2, T2>) -> bool {
		*self == other.as_bitslice()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O1, O2, T1, T2> PartialEq<BitBox<O2, T2>> for &mut BitSlice<O1, T1>
where
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn eq(&self, other: &BitBox<O2, T2>) -> bool {
		**self == other.as_bitslice()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T, Rhs> PartialEq<Rhs> for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
	Rhs: ?Sized + PartialEq<BitSlice<O, T>>,
{
	#[inline]
	fn eq(&self, other: &Rhs) -> bool {
		other == self.as_bitslice()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O1, O2, T1, T2> PartialOrd<BitBox<O2, T2>> for BitSlice<O1, T1>
where
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn partial_cmp(&self, other: &BitBox<O2, T2>) -> Option<cmp::Ordering> {
		self.partial_cmp(other.as_bitslice())
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T, Rhs> PartialOrd<Rhs> for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
	Rhs: ?Sized + PartialOrd<BitSlice<O, T>>,
{
	#[inline]
	fn partial_cmp(&self, other: &Rhs) -> Option<cmp::Ordering> {
		other.partial_cmp(self.as_bitslice())
	}
}

#[cfg(not(tarpaulin_include))]
impl<'a, O1, O2, T1, T2> PartialOrd<BitBox<O2, T2>> for &'a BitSlice<O1, T1>
where
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn partial_cmp(&self, other: &BitBox<O2, T2>) -> Option<cmp::Ordering> {
		self.partial_cmp(other.as_bitslice())
	}
}

#[cfg(not(tarpaulin_include))]
impl<'a, O1, O2, T1, T2> PartialOrd<BitBox<O2, T2>> for &'a mut BitSlice<O1, T1>
where
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn partial_cmp(&self, other: &BitBox<O2, T2>) -> Option<cmp::Ordering> {
		self.partial_cmp(other.as_bitslice())
	}
}

#[cfg(not(tarpauln_include))]
impl<O, T> AsRef<BitSlice<O, T>> for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn as_ref(&self) -> &BitSlice<O, T> {
		self.as_bitslice()
	}
}

#[cfg(not(tarpauln_include))]
impl<O, T> AsMut<BitSlice<O, T>> for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn as_mut(&mut self) -> &mut BitSlice<O, T> {
		self.as_mut_bitslice()
	}
}

#[cfg(not(tarpaulin_include))]
impl<'a, O, T> From<&'a BitSlice<O, T>> for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn from(slice: &'a BitSlice<O, T>) -> Self {
		Self::from_bitslice(slice)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> From<BitVec<O, T>> for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn from(bv: BitVec<O, T>) -> Self {
		bv.into_boxed_bitslice()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> From<BitBox<O, T>> for Box<[T]>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn from(bb: BitBox<O, T>) -> Self {
		bb.into_boxed_slice()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> TryFrom<Box<[T]>> for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	type Error = Box<[T]>;

	#[inline(always)]
	fn try_from(boxed: Box<[T]>) -> Result<Self, Self::Error> {
		Self::try_from_boxed_slice(boxed)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Default for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn default() -> Self {
		Self {
			bitspan: BitSpan::<Mut, O, T>::EMPTY,
		}
	}
}

impl<O, T> Debug for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		Pointer::fmt(self, fmt)?;
		fmt.write_str(" ")?;
		Display::fmt(self, fmt)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Display for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		Display::fmt(self.as_bitslice(), fmt)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Binary for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		Binary::fmt(self.as_bitslice(), fmt)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> LowerHex for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		LowerHex::fmt(self.as_bitslice(), fmt)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Octal for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		Octal::fmt(self.as_bitslice(), fmt)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Pointer for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		self.as_bitspan().render(fmt, "Box", None)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> UpperHex for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		UpperHex::fmt(self.as_bitslice(), fmt)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Hash for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn hash<H>(&self, state: &mut H)
	where H: Hasher {
		self.as_bitslice().hash(state)
	}
}

unsafe impl<O, T> Send for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
}

unsafe impl<O, T> Sync for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
}

impl<O, T> Unpin for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/boxed/traits.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/boxed.rs =====
/*! A dynamically-allocated, fixed-size, buffer containing a [`BitSlice`]
region.

You can read the standard library’s [`alloc::boxed` module documentation][std]
here.

This module defines the [`BitBox`] buffer, and all of its associated support
code.

[`BitBox`] is equivalent to `Box<[bool]>`, in its operation and in its
relationship to the [`BitSlice`] and [`BitVec`] types. Most of the interesting
work to be done on a bit-sequence is implemented in `BitSlice`, to which
`BitBox` dereferences, and the box container itself only exists to maintain
wonership and provide some specializations that cannot safely be done on
`BitSlice` alone.

There is almost never a reason to use this type, as it is a mixture of
[`BitArray`]’s fixed width and [`BitVec`]’s heap allocation. You should only use
it when you have a bit-sequence whose width is either unknowable at compile-time
or inexpressable in `BitArray`, and are constructing the sequence in a `BitVec`
before freezing it.

[`BitArray`]: crate::array::BitArray
[`BitBox`]: crate::boxed::BitBox
[`BitSlice`]: crate::slice::BitSlice
[`BitVec`]: crate::vec::BitVec
[std]: alloc::boxed
!*/

#![cfg(feature = "alloc")]

use alloc::boxed::Box;
use core::{
	mem::ManuallyDrop,
	slice,
};

use funty::IsNumber;
use tap::pipe::Pipe;

use crate::{
	index::BitIdx,
	order::{
		BitOrder,
		Lsb0,
	},
	ptr::{
		BitPtr,
		BitSpan,
		Mut,
	},
	slice::BitSlice,
	store::BitStore,
	vec::BitVec,
};

mod api;
mod iter;
mod ops;
mod traits;

pub use iter::IntoIter;

/** A frozen heap-allocated buffer of individual bits.

This is essentially a [`BitVec`] that has frozen its allocation, and given up
the ability to change size. It is analagous to `Box<[bool]>`. You should prefer
[`BitArray`] over `BitBox` where possible, and may freely box it if you need the
indirection.

# Documentation

All APIs that mirror something in the standard library will have an `Original`
section linking to the corresponding item. All APIs that have a different
signature or behavior than the original will have an `API Differences` section
explaining what has changed, and how to adapt your existing code to the change.

These sections look like this:

# Original

[`Box<[T]>`](alloc::boxed::Box)

# API Differences

The buffer type `Box<[bool]>` has no type parameters. `BitBox<O, T>` has the
same two type parameters as `BitSlice<O, T>`. Otherwise, `BitBox` is able to
implement the full API surface of `Box<[bool]>`.

# Behavior

Because `BitBox` is a fully-owned buffer, it is able to operate on its memory
without concern for any other views that may alias. This enables it to
specialize some [`BitSlice`] behavior to be faster or more efficient.

# Type Parameters

This takes the same [`BitOrder`] and [`BitStore`] parameters as [`BitSlice`].
Unlike `BitSlice`, it is restricted to only accept the fundamental integers as
its `BitStore` arguments; `BitBox` buffers can never be aliased by other
`BitBox`es, and do not need to share memory access.

# Safety

`BitBox` is a wrapper over a `NonNull<BitSlice<O, T>>` pointer; this allows it
to remain exactly two words in size, and means that it is subject to the same
representational incompatibility restrictions as [`BitSlice`] references. You
must never attempt to type-cast between `Box<[bool]>` and `BitBox` in any way,
nor may you attempt to modify the memory value of a `BitBox` handle. Doing so
will cause allocator and memory errors in your program, likely inducing a panic.

Everything in the `BitBox` public API, even the `unsafe` parts, are guaranteed
to have no more unsafety or potential for incorrectness than their equivalent
items in the standard library. All `unsafe` APIs will have documentation
explicitly detailing what the API requires you to uphold in order for it to
function safely and correctly. All safe APIs will do so themselves.

# Macro Construction

Heap allocation can only occur at runtime, but the [`bitbox!`] macro will
construct an appropriate [`BitSlice`] buffer at compile-time, and at run-time,
only copy the buffer into a heap allocation.

[`BitArray`]: crate::array::BitArray
[`BitOrder`]: crate::order::BitOrder
[`BitSlice`]: crate::slice::BitSlice
[`BitStore`]: crate::store::BitStore
[`BitVec`]: crate::vec::BitVec
[`bitbox!`]: macro@crate::bitbox
**/
#[repr(transparent)]
pub struct BitBox<O = Lsb0, T = usize>
where
	O: BitOrder,
	T: BitStore,
{
	bitspan: BitSpan<Mut, O, T>,
}

/// General-purpose functions not present on `Box<[T]>`.
impl<O, T> BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// Copies a [`BitSlice`] region into a new `BitBox` allocation.
	///
	/// # Effects
	///
	/// This delegates to [`BitVec::from_bitslice`], then discards the excess
	/// capacity.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bits = bits![0, 1, 0, 1, 1, 0, 1, 1];
	/// let bb = BitBox::from_bitslice(&bits[2 ..]);
	/// assert_eq!(bb, bits[2 ..]);
	/// assert_eq!(bb.as_slice(), bits.as_raw_slice());
	/// ```
	///
	/// [`BitVec::from_bitslice`]: crate::vec::BitVec::from_bitslice
	#[inline]
	pub fn from_bitslice(slice: &BitSlice<O, T>) -> Self {
		BitVec::from_bitslice(slice).into_boxed_bitslice()
	}

	/// Converts a `Box<[T]>` into a `BitBox`<O, T>` without copying its buffer.
	///
	/// # Parameters
	///
	/// - `boxed`: A boxed slice to view as bits.
	///
	/// # Returns
	///
	/// A `BitBox` over the `boxed` buffer.
	///
	/// # Panics
	///
	/// This panics if `boxed` is too long to convert into a `BitBox`. See
	/// [`BitSlice::MAX_ELTS`].
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let boxed: Box<[u8]> = Box::new([0; 4]);
	/// let addr = boxed.as_ptr();
	/// let bb = BitBox::<LocalBits, _>::from_boxed_slice(boxed);
	/// assert_eq!(bb, bits![0; 32]);
	/// assert_eq!(addr, bb.as_slice().as_ptr());
	/// ```
	///
	/// [`BitSlice::MAX_ELTS`]: crate::slice::BitSlice::MAX_ELTS
	#[inline]
	pub fn from_boxed_slice(boxed: Box<[T]>) -> Self {
		Self::try_from_boxed_slice(boxed)
			.expect("Slice was too long to be converted into a `BitBox`")
	}

	/// Converts a `Box<[T]>` into a `BitBox<O, T>` without copying its buffer.
	///
	/// This method takes ownership of a memory buffer and enables it to be used
	/// as a bit-box. Because `Box<[T]>` can be longer than `BitBox`es, this is
	/// a fallible method, and the original box will be returned if it cannot be
	/// converted.
	///
	/// # Parameters
	///
	/// - `boxed`: Some boxed slice of memory, to be viewed as bits.
	///
	/// # Returns
	///
	/// If `boxed` is short enough to be viewed as a `BitBox`, then this returns
	/// a `BitBox` over the `boxed` buffer. If `boxed` is too long, then this
	/// returns `boxed` unmodified.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let boxed: Box<[u8]> = Box::new([0; 4]);
	/// let addr = boxed.as_ptr();
	/// let bb = BitBox::<LocalBits, _>::try_from_boxed_slice(boxed).unwrap();
	/// assert_eq!(bb[..], bits![0; 32]);
	/// assert_eq!(addr, bb.as_slice().as_ptr());
	/// ```
	#[inline]
	pub fn try_from_boxed_slice(boxed: Box<[T]>) -> Result<Self, Box<[T]>> {
		let mut boxed = ManuallyDrop::new(boxed);

		BitPtr::from_mut_slice(&mut boxed[..])
			.span(boxed.len() * T::Mem::BITS as usize)
			.map(|bitspan| Self { bitspan })
			.map_err(|_| ManuallyDrop::into_inner(boxed))
	}

	/// Converts the slice back into an ordinary slice of memory elements.
	///
	/// This does not affect the slice’s buffer, only the handle used to control
	/// it.
	///
	/// # Parameters
	///
	/// - `self`
	///
	/// # Returns
	///
	/// An ordinary boxed slice containing all of the bit-slice’s memory buffer.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bb = bitbox![0; 5];
	/// let addr = bb.as_slice().as_ptr();
	/// let boxed = bb.into_boxed_slice();
	/// assert_eq!(boxed[..], [0][..]);
	/// assert_eq!(addr, boxed.as_ptr());
	/// ```
	#[inline]
	pub fn into_boxed_slice(self) -> Box<[T]> {
		self.pipe(ManuallyDrop::new)
			.as_mut_slice()
			.pipe(|slice| unsafe { Box::from_raw(slice) })
	}

	/// Converts `self` into a vector without clones or allocation.
	///
	/// The resulting vector can be converted back into a box via [`BitVec<O,
	/// T>`]’s [`.into_boxed_bitslice()`] method.
	///
	/// # Original
	///
	/// [`slice::into_vec`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.into_vec)
	///
	/// # API Differences
	///
	/// Despite taking a `Box<[T]>` receiver, this function is written in an
	/// `impl<T> [T]` block.
	///
	/// Rust does not allow the text
	///
	/// ```rust,ignore
	/// impl<O, T> BitSlice<O, T> {
	///   fn into_bitvec(self: BitBox<O, T>);
	/// }
	/// ```
	///
	/// to be written, and `BitBox` exists specifically because
	/// `Box<BitSlice<>>` cannot be written either, so this function must be
	/// implemented directly on `BitBox` rather than on `BitSlice` with a boxed
	/// receiver.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bb = bitbox![0, 1, 0, 1];
	/// let bv = bb.into_bitvec();
	///
	/// assert_eq!(bv, bitvec![0, 1, 0, 1]);
	/// ```
	///
	/// [`BitVec<O, T>`]: crate::vec::BitVec
	/// [`.into_boxed_bitslice()`]: crate::vec::BitVec::into_boxed_bitslice
	pub fn into_bitvec(self) -> BitVec<O, T> {
		let mut bitspan = self.bitspan;
		let mut raw = self
			//  Disarm the `self` destructor
			.pipe(ManuallyDrop::new)
			//  Extract the `Box<[T]>` handle, invalidating `self`
			.with_box(|b| unsafe { ManuallyDrop::take(b) })
			//  The distribution guarantees this to be correct and in-place.
			.into_vec()
			//  Disarm the `Vec<T>` destructor *also*.
			.pipe(ManuallyDrop::new);
		/* The distribution claims that `[T]::into_vec(Box<[T]>) -> Vec<T>` does
		not alter the address of the heap allocation, and only modifies the
		buffer handle. Nevertheless, update the bit-pointer with the address of
		the vector as returned by this transformation Just In Case.

		Inspection of the distribution’s implementation shows that the
		conversion from `(buf, len)` to `(buf, cap, len)` is done by using the
		slice length as the buffer capacity. However, this is *not* a behavior
		guaranteed by the distribution, and so the pipeline above must remain in
		place in the event that this behavior ever changes. It should compile
		away to nothing, as it is almost entirely typesystem manipulation.
		*/
		unsafe {
			bitspan.set_address(raw.as_mut_ptr());
			BitVec::from_fields(bitspan, raw.capacity())
		}
	}

	/// Views the buffer’s contents as a `BitSlice`.
	///
	/// This is equivalent to `&bb[..]`.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bb = bitbox![0, 1, 1, 0];
	/// let bits = bb.as_bitslice();
	/// ```
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn as_bitslice(&self) -> &BitSlice<O, T> {
		self.bitspan.to_bitslice_ref()
	}

	/// Extracts a mutable bit-slice of the entire vector.
	///
	/// Equivalent to `&mut bv[..]`.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv = bitvec![0, 1, 0, 1];
	/// let bits = bv.as_mut_bitslice();
	/// bits.set(0, true);
	/// ```
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn as_mut_bitslice(&mut self) -> &mut BitSlice<O, T> {
		self.bitspan.to_bitslice_mut()
	}

	/// Extracts an element slice containing the entire box.
	///
	/// # Analogue
	///
	/// See [`.as_bitslice()`] for a `&BitBox -> &BitSlice` transform.
	///
	/// # Examples
	///
	/// ```rust
	/// # #[cfg(feature = "std")] {
	/// use bitvec::prelude::*;
	/// use std::io::{self, Write};
	/// let buffer = bitbox![Msb0, u8; 0, 1, 0, 1, 1, 0, 0, 0];
	/// io::sink().write(buffer.as_slice()).unwrap();
	/// # }
	/// ```
	///
	/// [`.as_bitslice()`]: Self::as_bitslice
	#[inline]
	pub fn as_slice(&self) -> &[T] {
		let (data, len) =
			(self.bitspan.address().to_const(), self.bitspan.elements());
		unsafe { slice::from_raw_parts(data, len) }
	}

	/// Extracts a mutable slice of the entire box.
	///
	/// # Analogue
	///
	/// See [`.as_mut_bitslice()`] for a `&mut BitBox -> &mut BitSlice`
	/// transform.
	///
	/// # Examples
	///
	/// ```rust
	/// # #[cfg(feature = "std")] {
	/// use bitvec::prelude::*;
	/// use std::io::{self, Read};
	/// let mut buffer = bitbox![Msb0, u8; 0; 24];
	/// io::repeat(0b101).read_exact(buffer.as_mut_slice()).unwrap();
	/// # }
	/// ```
	///
	/// [`.as_mut_bitslice()`]: Self::as_mut_bitslice
	#[inline]
	pub fn as_mut_slice(&mut self) -> &mut [T] {
		let (data, len) =
			(self.bitspan.address().to_mut(), self.bitspan.elements());
		unsafe { slice::from_raw_parts_mut(data, len) }
	}

	/// Sets the uninitialized bits of the vector to a fixed value.
	///
	/// This method modifies all bits in the allocated buffer that are outside
	/// the `self.as_bitslice()` view so that they have a consistent value. This
	/// can be used to zero the uninitialized memory so that when viewed as a
	/// raw memory slice, bits outside the live region have a predictable value.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bb = BitBox::new(&220u8.view_bits::<Lsb0>()[.. 4]);
	/// assert_eq!(bb.count_ones(), 2);
	/// assert_eq!(bb.as_slice(), &[220u8]);
	///
	/// bb.set_uninitialized(false);
	/// assert_eq!(bb.as_slice(), &[12u8]);
	///
	/// bb.set_uninitialized(true);
	/// assert_eq!(bb.as_slice(), &[!3u8]);
	/// ```
	pub fn set_uninitialized(&mut self, value: bool) {
		let mut bp = self.bitspan;
		let (_, head, bits) = bp.raw_parts();
		let head = head.into_inner() as usize;
		let tail = head + bits;
		let full = crate::mem::elts::<T::Mem>(tail) * T::Mem::BITS as usize;
		unsafe {
			bp.set_head(BitIdx::ZERO);
			bp.set_len(full);
			let bits = bp.to_bitslice_mut();
			bits.get_unchecked_mut(.. head).set_all(value);
			bits.get_unchecked_mut(tail ..).set_all(value);
		}
	}

	/// Permits a function to modify the `Box<[T]>` backing storage of a
	/// `BitBox<_, T>`.
	///
	/// This produces a temporary `Box<[T]>` structure governing the `BitBox`’s
	/// buffer and allows a function to view it mutably. After the
	/// callback returns, the `Box` is written back into `self` and forgotten.
	///
	/// # Type Parameters
	///
	/// - `F`: A function which operates on a mutable borrow of a `Box<[T]>`
	///   buffer controller.
	/// - `R`: The return type of the `F` function.
	///
	/// # Parameters
	///
	/// - `&mut self`
	/// - `func`: A function which receives a mutable borrow of a `Box<[T]>`
	///   controlling `self`’s buffer.
	///
	/// # Returns
	///
	/// The return value of `func`. `func` is forbidden from borrowing any part
	/// of the `Box<[T]>` temporary view.
	fn with_box<F, R>(&mut self, func: F) -> R
	where F: FnOnce(&mut ManuallyDrop<Box<[T]>>) -> R {
		self.as_mut_slice()
			.pipe(|raw| unsafe { Box::from_raw(raw) })
			.pipe(ManuallyDrop::new)
			.pipe_ref_mut(func)
	}
}

#[cfg(test)]
mod tests;
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/boxed.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/devel.rs =====
//! Internal support utilities.

use core::{
	any::TypeId,
	ops::{
		Bound,
		Range,
		RangeBounds,
	},
};

use crate::{
	order::BitOrder,
	store::BitStore,
};

/** Normalizes any range into a basic `Range`.

This unpacks any range type into an ordinary `Range`, returning the start and
exclusive end markers. If the start marker is not provided, it is assumed to be
zero; if the end marker is not provided, then it is assumed to be `end`.

The end marker, if provided, may be greater than `end`. This is not checked in
the function, and must be inspected by the caller.

# Type Parameters

- `R`: A range of some kind

# Parameters

- `bounds`: A range of some kind
- `end`: The value to use as the exclusive end, if the range does not have an
  end.

# Returns

`bounds` normalized to an ordinary `Range`, optionally clamped to `end`.
**/
#[inline]
pub fn normalize_range<R>(bounds: R, end: usize) -> Range<usize>
where R: RangeBounds<usize> {
	let min = match bounds.start_bound() {
		Bound::Included(&n) => n,
		Bound::Excluded(&n) => n + 1,
		Bound::Unbounded => 0,
	};
	let max = match bounds.end_bound() {
		Bound::Included(&n) => n + 1,
		Bound::Excluded(&n) => n,
		Bound::Unbounded => end,
	};
	min .. max
}

/** Asserts that a range satisfies bounds constraints.

This requires that the range start be not greater than the range end, and the
range end be not greater than the ending marker (if provided).

# Parameters

- `range`: The range to validate
- `end`: An optional maximal value that the range cannot exceed

# Panics

This panics if the range fails a requirement.
**/
#[inline]
pub fn assert_range(range: Range<usize>, end: impl Into<Option<usize>>) {
	if range.start > range.end {
		panic!(
			"Malformed range: `{} .. {}` must run from lower to higher",
			range.start, range.end
		);
	}
	if let Some(end) = end.into() {
		if range.end > end {
			panic!(
				"Range out of bounds: `{} .. {}` must not exceed `{}`",
				range.start, range.end, end
			);
		}
	}
}

/// Tests if two `BitOrder` type parameters match each other.
///
/// This evaluates to a compile-time constant, and is removed during codegen.
#[cfg_attr(not(tarpaulin_include), inline(always))]
pub fn match_order<O1, O2>() -> bool
where
	O1: BitOrder,
	O2: BitOrder,
{
	TypeId::of::<O1>() == TypeId::of::<O2>()
}

/// Tests if two `BitStore` type parameters match each other.
///
/// This evaluates to a compile-time constant, and is removed during codegen.
#[cfg_attr(not(tarpaulin_include), inline(always))]
pub fn match_store<T1, T2>() -> bool
where
	T1: BitStore,
	T2: BitStore,
{
	TypeId::of::<T1>() == TypeId::of::<T2>()
}

/// Tests if two `<O, T>` type parameter pairs match each other.
///
/// This evaluates to a compile-time constant, and is removed during codegen.
#[cfg_attr(not(tarpaulin_include), inline(always))]
pub fn match_types<O1, T1, O2, T2>() -> bool
where
	O1: BitOrder,
	T1: BitStore,
	O2: BitOrder,
	T2: BitStore,
{
	match_order::<O1, O2>() && match_store::<T1, T2>()
}

#[cfg(all(test, feature = "std"))]
mod tests {
	use std::panic::catch_unwind;

	use super::*;

	#[test]
	#[allow(clippy::reversed_empty_ranges)] // I know.
	fn check_range_asserts() {
		assert!(catch_unwind(|| assert_range(7 .. 2, None)).is_err());
		assert!(catch_unwind(|| assert_range(0 .. 8, 4)).is_err());
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/devel.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/domain.rs =====
/*! Representations of the [`BitSlice`] region memory model.

This module allows any [`BitSlice`] region to be decomposed into domains that
restricts [`T::Alias`] markers to only the edge elements that may require them.

Specifically, any given [`BitSlice`] region is one of:

- touches only interior indices of one element
- touches at least one edge index of any number of elements (including zero)

In the latter case, any elements *completely* spanned by the [`BitSlice`] handle
are known to not have any other write-capable handles to them, and in the case
of an `&mut BitSlice` handle specifically, no other views at all. As such, the
domain view of this memory is able to remove the aliasing marker type and permit
direct memory access to the underlying buffer for the duration of its existence.

[`BitSlice`]: crate::slice::BitSlice
[`T::Alias`]: crate::store::BitStore::Alias
!*/

use core::{
	fmt::{
		self,
		Binary,
		Debug,
		Formatter,
		LowerHex,
		Octal,
		UpperHex,
	},
	slice,
};

use funty::IsNumber;
use tap::{
	pipe::Pipe,
	tap::Tap,
};
use wyz::fmt::FmtForward;

use crate::{
	index::{
		BitIdx,
		BitTail,
	},
	order::BitOrder,
	slice::BitSlice,
	store::BitStore,
};

macro_rules! bit_domain {
	($t:ident $(=> $m:ident)? $(@ $a:ident)?) => {
		/// Granular representation of the memory region containing a
		/// [`BitSlice`].
		///
		/// [`BitSlice`] regions can be described in terms of edge and center
		/// partitions, where the edge partitions must retain the aliasing
		/// status of the source `BitSlice` handle, and the center partition is
		/// known to be completely unaliased by any other view. This property
		/// allows any `BitSlice` handle to be decomposed into smaller regions,
		/// and safely remove any aliasing markers from the center partition
		/// that no longer requires such safeguarding.
		///
		/// This enum acts like the `.split*` methods in that it only subdivides
		/// the source [`BitSlice`] into smaller `BitSlice`s, and makes
		/// appropriate modifications to the aliasing markers.
		///
		/// It does not add any aliasing markers: if the slice is marked as
		/// aliased, then the edge partitions will retain that marker, and if it
		/// is not, then the edge partitions do not need it.
		///
		/// This does not provide references to the underlying memory buffer. If
		/// you need such direct access, use the [`Domain`] or [`DomainMut`]
		/// enums.
		///
		/// # Lifetimes
		///
		/// - `'a`: The lifetime of the referent storage region.
		///
		/// # Type Parameters
		///
		/// - `O`: The ordering type of the source [`BitSlice`] handle.
		/// - `T`: The register type of the source [`BitSlice`] handle,
		///   including any aliasing markers.
		///
		/// # Aliasing Awareness
		///
		/// This enum does not grant access to memory outside the scope of the
		/// original [`BitSlice`] handle, and so does not need to modfiy any
		/// aliasing conditions.
		///
		/// [`BitSlice`]: crate::slice::BitSlice
		/// [`Domain`]: crate::domain::Domain
		/// [`DomainMut`]: crate::domain::DomainMut
		#[derive(Debug)]
		pub enum $t <'a, O, T>
		where
			O: BitOrder,
			T: BitStore,
		{
			/// Indicates that a [`BitSlice`] is contained entirely in the
			/// interior indices of a single memory register.
			///
			/// [`BitSlice`]: crate::slice::BitSlice
			Enclave {
				/// The start index of the [`BitSlice`].
				///
				/// This is not likely to be useful information, but is retained
				/// for structural similarity with the rest of the module.
				///
				/// [`BitSlice`]: crate::slice::BitSlice
				head: BitIdx<T::Mem>,
				/// The original [`BitSlice`] used to create this bit-domain
				/// view.
				///
				/// [`BitSlice`]: crate::slice::BitSlice
				body: &'a $($m)? BitSlice<O, T>,
				/// The end index of the [`BitSlice`].
				///
				/// This is not likely to be useful information, but is retained
				/// for structural similarity with the rest of the module.
				///
				/// [`BitSlice`]: crate::slice::BitSlice
				tail: BitTail<T::Mem>,
			},
			/// Indicates that a [`BitSlice`] region touches at least one edge
			/// index of any number of elements.
			///
			/// This contains two [`BitSlice`]s representing the
			/// partially-occupied edge elements, with their original aliasing
			/// marker, and one `BitSlice` representing the fully-occupied
			/// interior elements, marked as unaliased.
			///
			/// [`BitSlice`]: crate::slice::BitSlice
			Region {
				/// Any bits that partially-fill the base element of the slice
				/// region.
				///
				/// This does not modify its aliasing status, as it will already
				/// be appropriately marked before constructing this view.
				head: &'a $($m)? BitSlice<O, T>,
				/// Any bits inside elements that the source [`BitSlice`]
				/// completely covers.
				///
				/// This is marked as unaliased, because it is statically
				/// impossible for any other handle to have write access to the
				/// region it covers. As such, a [`BitSlice`] that was marked as
				/// entirely aliased, but contains interior unaliased elements,
				/// can safely remove its aliasing protections.
				///
				/// [`BitSlice`]: crate::slice::BitSlice
				body: &'a $($m)? BitSlice<O, T::Unalias>,
				/// Any bits that partially fill the last element of the slice
				/// region.
				///
				/// This does not modify its aliasing status, as it will already
				/// be appropriately marked before constructing this view.
				tail: &'a $($m)? BitSlice<O, T>,
			},
		}

		impl<'a, O, T> $t <'a, O, T>
		where
			O: BitOrder,
			T: BitStore,
		{
			/// Attempts to view the domain as an enclave variant.
			///
			/// # Parameters
			///
			/// - `self`
			///
			/// # Returns
			///
			/// If `self` is the [`Enclave`] variant, this returns `Some` of the
			/// enclave fields, as a tuple. Otherwise, it returns `None`.
			///
			/// [`Enclave`]: Self::Enclave
			#[inline]
			pub fn enclave(self) -> Option<(
				BitIdx<T::Mem>,
				&'a $($m)? BitSlice<O, T>,
				BitTail<T::Mem>,
			)> {
				if let Self::Enclave { head, body, tail } = self {
					Some((head, body, tail))
				}
				else {
					None
				}
			}

			/// Attempts to view the domain as a region variant.
			///
			/// # Parameters
			///
			/// - `self`
			///
			/// # Returns
			///
			/// If `self` is the [`Region`] variant, this returns `Some` of the
			/// region fields, as a tuple. Otherwise, it returns `None`.
			///
			/// [`Region`]: Self::Region
			#[inline]
			pub fn region(self) -> Option<(
				&'a $($m)? BitSlice<O, T>,
				&'a $($m)? BitSlice<O, T::Unalias>,
				&'a $($m)? BitSlice<O, T>,
			)> {
				if let Self::Region { head, body, tail } = self {
					Some((head, body, tail))
				}
				else {
					None
				}
			}

			/// Constructs a bit-domain view from a [`BitSlice`].
			///
			/// # Parameters
			///
			/// - `slice`: The source [`BitSlice`] for which the view is
			///   constructed.
			///
			/// # Returns
			///
			/// A bit-domain view over the source slice.
			///
			/// [`BitSlice`]: crate::slice::BitSlice
			#[inline]
			pub(crate) fn new(slice: &'a $($m)? BitSlice<O, T>) -> Self {
				let bitspan = slice.as_bitspan();
				let h = bitspan.head();
				let (e, t) = h.span(bitspan.len());
				let w = T::Mem::BITS as u8;

				match (h.into_inner(), e, t.into_inner()) {
					(_, 0, _) => Self::empty(),
					(0, _, t) if t == w => Self::spanning(slice),
					(_, _, t) if t == w => Self::partial_head(slice, h),
					(0, ..) => Self::partial_tail(slice, h, t),
					(_, 1, _) => Self::minor(slice, h, t),
					_ => Self::major(slice, h, t),
				}
			}

			#[cfg_attr(not(tarpaulin_include), inline(always))]
			fn empty() -> Self {
				Self::Region {
					head: Default::default(),
					body: Default::default(),
					tail: Default::default(),
				}
			}

			#[inline]
			fn major(
				slice: &'a $($m)? BitSlice<O, T>,
				head: BitIdx<T::Mem>,
				tail: BitTail<T::Mem>,
			) -> Self {
				let (head, rest) = bit_domain!(split $($m)?
					slice,
					(T::Mem::BITS as u8 - head.into_inner()) as usize,
				);
				let (body, tail) = bit_domain!(split $($m)?
					rest,
					rest.len() - (tail.into_inner() as usize),
				);
				Self::Region {
					head: bit_domain!(retype $($m)? head),
					body: bit_domain!(retype $($m)? body),
					tail: bit_domain!(retype $($m)? tail),
				}
			}

			#[inline]
			fn minor(
				slice: &'a $($m)? BitSlice<O, T>,
				head: BitIdx<T::Mem>,
				tail: BitTail<T::Mem>,
			) -> Self {
				Self::Enclave {
					head,
					body: slice,
					tail,
				}
			}

			#[inline]
			fn partial_head(
				slice: &'a $($m)? BitSlice<O, T>,
				head: BitIdx<T::Mem>,
			) -> Self {
				let (head, rest) = bit_domain!(split $($m)?
					slice,
					(T::Mem::BITS as u8 - head.into_inner()) as usize,
				);
				let (head, body) = (
					bit_domain!(retype $($m)? head),
					bit_domain!(retype $($m)? rest),
				);
				Self::Region {
					head,
					body,
					tail: Default::default(),
				}
			}

			#[inline]
			fn partial_tail(
				slice: &'a $($m)? BitSlice<O, T>,
				/* This discarded head argument makes all constructor functions
				have the same register layout for the call, allowing the `::new`
				function to establish the arguments ahead of time, then select a
				constructor function to jump into.
				*/
				_head: BitIdx<T::Mem>,
				tail: BitTail<T::Mem>,
			) -> Self {
				let (rest, tail) = bit_domain!(split $($m)?
					slice,
					slice.len() - (tail.into_inner() as usize),
				);
				let (body, tail) = (
					bit_domain!(retype $($m)? rest),
					bit_domain!(retype $($m)? tail),
				);
				Self::Region {
					head: Default::default(),
					body,
					tail,
				}
			}

			#[cfg_attr(not(tarpaulin_include), inline(always))]
			fn spanning(slice: &'a $($m)? BitSlice<O, T>) -> Self {
				Self::Region {
					head: Default::default(),
					body: bit_domain!(retype $($m)? slice),
					tail: Default::default(),
				}
			}
		}
	};

	(retype mut $slice:ident $(,)? ) => {
		unsafe { &mut *($slice as *mut BitSlice<O, _> as *mut BitSlice<O, _>) }
	};
	(retype $slice:ident $(,)? ) => {
		unsafe { &*($slice as *const BitSlice<O, _> as *const BitSlice<O, _>) }
	};

	(split mut $slice:ident, $at:expr $(,)? ) => {
		unsafe { $slice.split_at_unchecked_mut($at) }
	};
	(split $slice:ident, $at:expr $(,)? ) => {
		unsafe { $slice.split_at_unchecked($at) }
	};
}

bit_domain!(BitDomain);
bit_domain!(BitDomainMut => mut @ Alias);

#[cfg(not(tarpaulin_include))]
impl<O, T> Clone for BitDomain<'_, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn clone(&self) -> Self {
		*self
	}
}

impl<O, T> Copy for BitDomain<'_, O, T>
where
	O: BitOrder,
	T: BitStore,
{
}

macro_rules! domain {
	($t:ident $(=> $m:ident @ $a:ident)?) => {
		/// Granular representation of the memory region containing a
		/// [`BitSlice`].
		///
		/// [`BitSlice`] regions can be described in terms of edge and center
		/// partitions, where the edge partitions must retain the aliasing
		/// status of the source `BitSlice` handle, and the center partition is
		/// known to be completely unaliased by any other view. This property
		/// allows any `BitSlice` handle to be decomposed into smaller regions,
		/// and safely remove any aliasing markers from the center partition
		/// that no longer requires such safeguarding.
		///
		/// This enum splits the underlying element slice `[T]` into the
		/// maybe-aliased edge elements and known-unaliased center elements. If
		/// you do not need to work with the memory elements directly, and only
		/// need to firmly specify the access behavior of the [`BitSlice`]
		/// handle, use the [`BitDomain`] and [`BitDomainMut`] enums.
		///
		/// # Lifetimes
		///
		/// - `'a`: The lifetime of the referent storage region.
		///
		/// # Type Parameters
		///
		/// - `T`: The register type of the source [`BitSlice`] handle,
		///   including any aliasing markers.
		///
		/// # Mutability
		///
		/// The immutable view produces [`T::Alias`] references, which permit
		/// foreign writes to the referent location but disallow writes through
		/// itself. The mutable view produces [`T::Access`] references, because
		/// `&mut _` references can only ever be produced when no other aliasing
		/// handle exists. The write permissions must be weakened from
		/// `&mut T::Alias` to `&T::Access` in order to satisfy the Rust memory
		/// rules.
		///
		/// The edge references do not forbid modifying bits outside of the
		/// source [`BitSlice`] domain, and writes out of bounds will be
		/// correctly handled by any other handles capable of viewing those
		/// elements. Doing so is still *incorrect*, though defined, and you are
		/// responsible for writing only within bounds when using `DomainMut`.
		///
		/// [`BitDomain`]: crate::domain::BitDomain
		/// [`BitDomainMut`]: crate::domain::BitDomainMut
		/// [`BitSlice`]: crate::slice::BitSlice
		/// [`T::Access`]: crate::store::BitStore::Access
		/// [`T::Alias`]: crate::store::BitStore::Alias
		#[derive(Debug)]
		pub enum $t <'a, T>
		where
			T: BitStore,
		{
			/// Indicates that a [`BitSlice`] is contained entirely in the
			/// interior indices of a single memory element.
			///
			/// [`BitSlice`]: crate::slice::BitSlice
			Enclave {
				/// The start index of the [`BitSlice`].
				///
				/// [`BitSlice`]: crate::slice::BitSlice
				head: BitIdx<T::Mem>,
				/// An aliased view of the element containing the [`BitSlice`].
				///
				/// This is necessary even on immutable views, because other
				/// views to the referent element may be permitted to modify it.
				///
				/// [`BitSlice`]: crate::slice::BitSlice
				elem: &'a T $(::$a)?,
				/// The end index of the [`BitSlice`].
				///
				/// [`BitSlice`]: crate::slice::BitSlice
				tail: BitTail<T::Mem>,
			},
			/// Indicates that a [`BitSlice`] region touches at least one edge
			/// index of any number of elements.
			///
			/// This contains two optional references to the aliased edges, and
			/// one reference to the unaliased middle. Each can be queried and
			/// used individually.
			///
			/// [`BitSlice`]: crate::slice::BitSlice
			Region {
				/// If the [`BitSlice`] started in the interior of its first
				/// element, this contains the starting index and the base
				/// address.
				///
				/// [`BitSlice`]: crate::slice::BitSlice
				head: Option<(BitIdx<T::Mem>, &'a T $(::$a)?)>,
				/// All fully-spanned, unaliased, elements.
				///
				/// This is marked as bare memory without any access
				/// protections, because it is statically impossible for any
				/// other handle to have write access to the region it covers.
				/// As such, a [`BitSlice`] that was marked as entirely aliased,
				/// but contains interior unaliased elements, can safely remove
				/// its aliasing protections.
				body: &'a $($m)? [T::Unalias],
				/// If the `BitSlice` ended in the interior of its last element,
				/// this contains the ending index and the last address.
				tail: Option<(&'a T $(::$a)?, BitTail<T::Mem>)>,
			}
		}

		impl<'a, T> $t <'a, T>
		where
			T: BitStore,
		{
			/// Attempts to view the domain as an enclave variant.
			///
			/// # Parameters
			///
			/// - `self`
			///
			/// # Returns
			///
			/// If `self` is the [`Enclave`] variant, this returns `Some` of the
			/// enclave fields, as a tuple. Otherwise, it returns `None`.
			///
			/// [`Enclave`]: Self::Enclave
			#[inline]
			pub fn enclave(self) -> Option<(
				BitIdx<T::Mem>,
				&'a T $(::$a)?,
				BitTail<T::Mem>,
			)> {
				if let Self::Enclave { head, elem, tail } = self {
					Some((head, elem, tail))
				} else {
					None
				}
			}

			/// Attempts to view the domain as the region variant.
			///
			/// # Parameters
			///
			/// - `self`
			///
			/// # Returns
			///
			/// If `self` is the [`Region`] variant, this returns `Some` of the
			/// region fields, as a tuple. Otherwise, it returns `None`.
			///
			/// [`Region`]: Self::Region
			#[inline]
			pub fn region(self) -> Option<(
				Option<(BitIdx<T::Mem>, &'a T $(::$a)?)>,
				&'a $($m)? [T::Unalias],
				Option<(&'a T $(::$a)?, BitTail<T::Mem>)>,
			)> {
				if let Self::Region { head, body, tail } = self {
					Some((head,body,tail))
				}
				else {
					None
				}
			}

			#[inline]
			pub(crate) fn new<O>(slice: &'a $($m)? BitSlice<O, T>) -> Self
			where O: BitOrder {
				let bitspan = slice.as_bitspan();
				let head = bitspan.head();
				let elts = bitspan.elements();
				let tail = bitspan.tail();
				let bits = T::Mem::BITS as u8;
				let base = bitspan.address().to_const() as *const _;
				match (head.into_inner(), elts, tail.into_inner()) {
					(_, 0, _) => Self::empty(),
					(0, _, t) if t == bits => Self::spanning(base, elts),
					(_, _, t) if t == bits => Self::partial_head(base, elts, head),
					(0, ..) => Self::partial_tail(base, elts, tail),
					(_, 1, _) => Self::minor(base, head, tail),
					_ => Self::major(base, elts, head, tail),
				}
			}

			#[cfg_attr(not(tarpaulin_include), inline(always))]
			fn empty() -> Self {
				Self::Region {
					head: None,
					body: & $($m)? [],
					tail: None,
				}
			}

			#[inline]
			fn major(
				base: *const T $(::$a)?,
				elts: usize,
				head: BitIdx<T::Mem>,
				tail: BitTail<T::Mem>,
			) -> Self {
				let h = unsafe { &*base };
				let t = unsafe { &*base.add(elts - 1) };
				let body = domain!(slice $($m)? base.add(1), elts - 2);
				Self::Region {
					head: Some((head, h)),
					body,
					tail: Some((t, tail)),
				}
			}

			#[inline]
			fn minor(
				addr: *const T $(::$a)?,
				head: BitIdx<T::Mem>,
				tail: BitTail<T::Mem>,
			) -> Self {
				Self::Enclave {
					head,
					elem: unsafe { &*addr },
					tail,
				}
			}

			#[inline]
			fn partial_head(
				base: *const T $(::$a)?,
				elts: usize,
				head: BitIdx<T::Mem>,
			) -> Self {
				let h = unsafe { &*base };
				let body = domain!(slice $($m)? base.add(1), elts - 1);
				Self::Region {
					head: Some((head, h)),
					body,
					tail: None,
				}
			}

			#[inline]
			fn partial_tail(
				base: *const T $(::$a)?,
				elts: usize,
				tail: BitTail<T::Mem>,
			) -> Self {
				let t = unsafe { &*base.add(elts - 1) };
				let body = domain!(slice $($m)? base, elts - 1);
				Self::Region {
					head: None,
					body,
					tail: Some((t, tail)),
				}
			}

			#[cfg_attr(not(tarpaulin_include), inline(always))]
			fn spanning(base: *const T $(::$a)?, elts: usize) -> Self {
				Self::Region {
					head: None,
					body: domain!(slice $($m)? base, elts),
					tail: None,
				}
			}
		}
	};

	(slice mut $base:expr, $elts:expr) => {
		unsafe { slice::from_raw_parts_mut($base as *const _ as *mut _, $elts) }
	};
	(slice $base:expr, $elts:expr) => {
		unsafe { slice::from_raw_parts($base as *const _, $elts) }
	};
}

domain!(Domain);
domain!(DomainMut => mut @ Access);

#[cfg(not(tarpaulin_include))]
impl<T> Clone for Domain<'_, T>
where T: BitStore
{
	#[inline(always)]
	fn clone(&self) -> Self {
		*self
	}
}

impl<'a, T> Iterator for Domain<'a, T>
where T: BitStore
{
	type Item = T::Mem;

	fn next(&mut self) -> Option<Self::Item> {
		match self {
			Self::Enclave { elem, .. } => {
				elem.load_value().pipe(Some).tap(|_| *self = Self::empty())
			},
			Self::Region { head, body, tail } => {
				if let Some((_, elem)) = *head {
					return elem.load_value().pipe(Some).tap(|_| *head = None);
				}
				if let Some((elem, rest)) = body.split_first() {
					*body = rest;
					return elem.load_value().into();
				}
				if let Some((elem, _)) = *tail {
					return elem.load_value().pipe(Some).tap(|_| *tail = None);
				}
				None
			},
		}
	}
}

impl<'a, T> DoubleEndedIterator for Domain<'a, T>
where T: BitStore
{
	fn next_back(&mut self) -> Option<Self::Item> {
		match self {
			Self::Enclave { elem, .. } => {
				elem.load_value().pipe(Some).tap(|_| *self = Self::empty())
			},
			Self::Region { head, body, tail } => {
				if let Some((elem, _)) = *tail {
					return elem.load_value().pipe(Some).tap(|_| *tail = None);
				}
				if let Some((elem, rest)) = body.split_last() {
					*body = rest;
					return elem.load_value().into();
				}
				if let Some((_, elem)) = *head {
					return elem.load_value().pipe(Some).tap(|_| *head = None);
				}
				None
			},
		}
	}
}

impl<T> ExactSizeIterator for Domain<'_, T>
where T: BitStore
{
	#[inline]
	fn len(&self) -> usize {
		match self {
			Self::Enclave { .. } => 1,
			Self::Region { head, body, tail } => {
				head.is_some() as usize + body.len() + tail.is_some() as usize
			},
		}
	}
}

impl<T> core::iter::FusedIterator for Domain<'_, T> where T: BitStore
{
}

impl<T> Copy for Domain<'_, T> where T: BitStore
{
}

macro_rules! fmt {
	($($f:ty => $fwd:ident),+ $(,)?) => { $(
		impl<T> $f for Domain<'_, T>
		where T: BitStore
		{
			#[inline]
			fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
				fmt.debug_list()
					.entries(self.into_iter().map(FmtForward::$fwd))
					.finish()
			}
		}
	)+ };
}

fmt!(
	Binary => fmt_binary,
	LowerHex => fmt_lower_hex,
	Octal => fmt_octal,
	UpperHex => fmt_upper_hex,
);

#[cfg(test)]
mod tests {
	use crate::prelude::*;

	#[test]
	fn domain_iter() {
		let data = [1u32, 2, 3];
		let bits = &data.view_bits::<LocalBits>()[4 .. 92];

		for (iter, elem) in bits.domain().rev().zip([3, 2, 1].iter().copied()) {
			assert_eq!(iter, elem);
		}
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/domain.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/field/io.rs =====
/*! I/O trait implementations.

The standard library defines byte-based I/O protocols that form the basis of
exchanging memory buffers with I/O controllers. As [`BitSlice`] is designed to be
used with I/O buffers, it makes sense for it to implement these protocols.

This module is a subset of the `field` module because it relies on the
[`BitField`] trait’s ability to map [`BitSlice`] to a value-storage region. The
I/O protocols [`Read`] and [`Write`] are strictly byte-based, and cannot be
altered to be bit-based. As such, they are only implemented on types with a
`BitField` implementation.

Calling [`BitField`] methods in a loop imposes a non-trivial, and irremovable,
per-loop overhead cost. Use of [`bitvec`] data structures directly, rather than
their underlying buffers, will have a performance penalty relative to the
underlying buffer, but much less than a bit-by-bit traversal.

[`BitField`]: crate::field::BitField
[`BitSlice`]: crate::slice::BitSlice
[`Read`]: std::io::Read
[`Write`]: std::io::Write
[`bitvec`]: crate
!*/

#![cfg(feature = "std")]

use core::mem;
use std::io::{
	self,
	Read,
	Write,
};

use super::BitField;
use crate::{
	order::BitOrder,
	slice::BitSlice,
	store::BitStore,
	vec::BitVec,
};

/** Mirrors the implementation on `[u8]` (found [here]).

The implementation loads bytes out of the `&BitSlice` reference until exhaustion
of either the source [`BitSlice`] or destination `[u8]`. When `read` returns,
`self` will have been updated to no longer include the leading segment copied
out as bytes of `buf`.

The implementation uses [`BitField::load_be`].

[here]: https://doc.rust-lang.org/stable/std/primitive.slice.html#impl-Read
[`BitField::load_be`]: crate::field::BitField::load_be
[`BitSlice`]: crate::slice::BitSlice
**/
impl<'a, O, T> Read for &'a BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
	BitSlice<O, T>: BitField,
{
	#[inline]
	fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
		let mut idx = 0;
		for (byte, slot) in self.chunks_exact(8).zip(buf.iter_mut()) {
			*slot = byte.load_be();
			idx += 1;
		}
		*self = unsafe { self.get_unchecked(idx * 8 ..) };
		Ok(idx)
	}
}

/** Mirrors the implementation on `[u8]` (found [here]).

The implementation copies bytes into the `&mut BitSlice` reference until
exhaustion of either the source `[u8]` or destination [`BitSlice`]. When `write`
returns, `self` will have been updated to no longer include the leading segment
containing bytes copied in from `buf`.

The implementation uses [`BitField::store_be`].

[here]: https://doc.rust-lang.org/stable/std/primitive.slice.html#impl-Write
[`BitField::store_be`]: crate::field::BitField::store_be
[`BitSlice`]: crate::slice::BitSlice
**/
impl<'a, O, T> Write for &'a mut BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
	BitSlice<O, T>: BitField,
{
	#[inline]
	fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
		let mut idx = 0;
		for (slot, byte) in unsafe { self.chunks_exact_mut(8).remove_alias() }
			.zip(buf.iter().copied())
		{
			slot.store_be(byte);
			idx += 1;
		}
		*self = unsafe { mem::take(self).get_unchecked_mut(idx * 8 ..) };
		Ok(idx)
	}

	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	fn flush(&mut self) -> io::Result<()> {
		Ok(())
	}
}

/** Mirrors the implementation on `Vec<u8>` (found [here]).

The implementation copies bytes from `buf` into the tail end of `self`. The
performance characteristics of this operation are dependent on the type
parameters of the [`BitVec`], and the position of its tail.

[here]: https://doc.rust-lang.org/stable/std/vec/struct.Vec.html#impl-Write
[`BitVec`]: crate::vec::BitVec
**/
impl<O, T> Write for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
	BitSlice<O, T>: BitField,
{
	#[inline]
	fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
		let len = self.len();
		self.resize(len + buf.len() * 8, false);
		unsafe { self.get_unchecked_mut(len ..) }.write(buf)
	}

	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	fn flush(&mut self) -> io::Result<()> {
		Ok(())
	}
}

#[cfg(test)]
mod tests {
	use super::*;
	use crate::prelude::*;

	#[test]
	fn read_bits() {
		let data = [0x136Cu16, 0x8C63];
		let mut bits = &data.view_bits::<Msb0>()[4 ..];
		assert_eq!(bits.len(), 28);

		let mut transfer = [0u8; 4];
		let last_ptr = &mut transfer[3] as *mut _;
		let mut transfer_handle = &mut transfer[..];

		assert_eq!(io::copy(&mut bits, &mut transfer_handle).unwrap(), 3);

		//  Once a bitslice cannot produce a byte, it stops `Read`ing
		assert_eq!(bits, data.view_bits::<Msb0>()[28 ..]);
		//  So the destination slice does not fill up.
		assert_eq!(transfer_handle.as_mut_ptr() as *mut _, last_ptr);

		assert_eq!(transfer[.. 3], [0x36, 0xC8, 0xC6][..]);
	}

	#[test]
	fn write_bits() {
		let mut bv = bitvec![Msb0, usize; 0, 0, 0, 0];
		assert_eq!(
			3,
			io::copy(&mut &[0xC3u8, 0xF0, 0x69][..], &mut bv).unwrap()
		);

		assert_eq!(bv, bits![
			0, 0, 0, 0, // byte 0
			1, 1, 0, 0, 0, 0, 1, 1, // byte 1
			1, 1, 1, 1, 0, 0, 0, 0, // byte 2
			0, 1, 1, 0, 1, 0, 0, 1,
		]);
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/field/io.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/field/permutation_tests.rs =====
/*! Permutation testing.

This module runs battery tests on implementations of `BitField` to check that
they behave as expected.
!*/

use super::*;
#[cfg(not(miri))]
use crate::prelude::*;

/// Resizing always preserves the LSedge.
#[test]
fn check_resize() {
	assert_eq!(resize::<u8, u8>(0xA5u8), 0xA5u8);
	assert_eq!(resize::<u8, u16>(0xA5u8), 0xA5u16);
	assert_eq!(resize::<u8, u32>(0xA5u8), 0xA5u32);

	assert_eq!(resize::<u16, u8>(0x1234u16), 0x34u8);
	assert_eq!(resize::<u16, u16>(0x1234u16), 0x1234u16);
	assert_eq!(resize::<u16, u32>(0x1234u16), 0x1234u32);

	assert_eq!(resize::<u32, u8>(0x1234_5678u32), 0x78u8);
	assert_eq!(resize::<u32, u16>(0x1234_5678u32), 0x5678u16);
	assert_eq!(resize::<u32, u32>(0x1234_5678u32), 0x1234_5678u32);

	#[cfg(target_pointer_width = "64")]
	{
		assert_eq!(resize::<u8, u64>(0xA5u8), 0xA5u64);
		assert_eq!(resize::<u16, u64>(0x1234u16), 0x1234u64);
		assert_eq!(resize::<u32, u64>(0x1234_5678u32), 0x1234_5678u64);

		assert_eq!(resize::<u64, u8>(0x0123_4567_89AB_CDEFu64), 0xEFu8);
		assert_eq!(resize::<u64, u16>(0x0123_4567_89AB_CDEFu64), 0xCDEFu16);
		assert_eq!(resize::<u64, u32>(0x0123_4567_89AB_CDEFu64), 0x89AB_CDEFu32);
		assert_eq!(
			resize::<u64, u64>(0x0123_4567_89AB_CDEFu64),
			0x0123_4567_89AB_CDEFu64
		);
	}
}

#[test]
#[cfg(not(miri))]
fn l08() {
	let bits = bits![mut Lsb0, u8; 0; 32];

	for i in 0 .. 8 {
		for n in 0u8 ..= !0 {
			bits[i ..][.. 8].store_le::<u8>(n);
			assert_eq!(bits[i ..][.. 8].load_le::<u8>(), n);
		}
	}

	for i in 0 .. 16 {
		for n in 0u16 ..= !0 {
			bits[i ..][.. 16].store_le::<u16>(n);
			assert_eq!(bits[i ..][.. 16].load_le::<u16>(), n);
		}
	}
}

#[test]
#[cfg(not(miri))]
fn m08() {
	let bits = bits![mut Msb0, u8; 0; 32];

	for i in 0 .. 8 {
		for n in 0u8 ..= !0 {
			bits[i ..][.. 8].store_le::<u8>(n);
			assert_eq!(bits[i ..][.. 8].load_le::<u8>(), n);
		}
	}

	for i in 0 .. 16 {
		for n in 0u16 ..= !0 {
			bits[i ..][.. 16].store_le::<u16>(n);
			assert_eq!(bits[i ..][.. 16].load_le::<u16>(), n);
		}
	}
}

#[test]
#[cfg(not(miri))]
fn l16() {
	let bits = bits![mut Lsb0, u16; 0; 32];

	for i in 0 .. 8 {
		for n in 0u8 ..= !0 {
			bits[i ..][.. 8].store_le::<u8>(n);
			assert_eq!(bits[i ..][.. 8].load_le::<u8>(), n);
		}
	}

	for i in 0 .. 16 {
		for n in 0u16 ..= !0 {
			bits[i ..][.. 16].store_le::<u16>(n);
			assert_eq!(bits[i ..][.. 16].load_le::<u16>(), n);
		}
	}
}

#[test]
#[cfg(not(miri))]
fn m16() {
	let bits = bits![mut Msb0, u16; 0; 32];

	for i in 0 .. 8 {
		for n in 0u8 ..= !0 {
			bits[i ..][.. 8].store_le::<u8>(n);
			assert_eq!(bits[i ..][.. 8].load_le::<u8>(), n);
		}
	}

	for i in 0 .. 16 {
		for n in 0u16 ..= !0 {
			bits[i ..][.. 16].store_le::<u16>(n);
			assert_eq!(bits[i ..][.. 16].load_le::<u16>(), n);
		}
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/field/permutation_tests.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/field/tests.rs =====
//! Unit tests for the `field` module.

use super::*;
use crate::prelude::*;

#[test]
fn get_value() {
	let data = [5u32 << 3, 0x01234567, !5];
	let bits = data.view_bits::<Lsb0>();

	let (head, elem, tail) = bits[3 .. 6].domain().enclave().unwrap();
	let byte = get::<u32, u8>(elem, Lsb0::mask(head, tail), 3);
	assert_eq!(byte, 5u8);

	let (head, body, tail) = bits[32 .. 48].domain().region().unwrap();
	assert!(head.is_none());
	assert!(body.is_empty());
	let (elem, tail) = tail.unwrap();
	let short = get::<u32, u16>(elem, Lsb0::mask(None, tail), 0);
	assert_eq!(short, 0x4567u16);

	let (head, body, tail) = bits[48 .. 64].domain().region().unwrap();
	assert!(tail.is_none());
	assert!(body.is_empty());
	let (head, elem) = head.unwrap();
	let short = get::<u32, u16>(elem, Lsb0::mask(head, None), 16);
	assert_eq!(short, 0x0123u16);

	let (head, body, tail) = bits[64 .. 96].domain().region().unwrap();
	assert!(head.is_none());
	assert_eq!(body, &[!5]);
	assert!(tail.is_none());
}

#[test]
fn set_value() {
	let mut data = [0u32; 3];
	let bits = data.view_bits_mut::<Lsb0>();

	let (head, elem, tail) = bits[3 .. 6].domain_mut().enclave().unwrap();
	set::<u32, u16>(elem, 13u16, Lsb0::mask(head, tail), 3);

	let (head, body, tail) = bits[32 .. 48].domain_mut().region().unwrap();
	assert!(head.is_none());
	assert!(body.is_empty());
	let (elem, tail) = tail.unwrap();
	set::<u32, u16>(elem, 0x4567u16, Lsb0::mask(None, tail), 0);

	let (head, body, tail) = bits[48 .. 64].domain_mut().region().unwrap();
	assert!(tail.is_none());
	assert!(body.is_empty());
	let (head, elem) = head.unwrap();
	set::<u32, u16>(elem, 0x0123u16, Lsb0::mask(head, None), 16);

	assert_eq!(data[0], 5 << 3);
	assert_eq!(data[1], 0x01234567u32);
}

#[test]
fn byte_fields() {
	let mut data = [0u8; 3];

	data.view_bits_mut::<Msb0>()[4 .. 20].store_be(0xABCDu16);
	assert_eq!(data, [0x0A, 0xBC, 0xD0]);
	assert_eq!(data.view_bits::<Msb0>()[4 .. 20].load_be::<u16>(), 0xABCD);

	data.view_bits_mut::<Msb0>()[2 .. 6].store_be(9u8);
	assert_eq!(data, [0x26, 0xBC, 0xD0]);
	assert_eq!(data.view_bits::<Msb0>()[2 .. 6].load_be::<u8>(), 9);

	data = [0; 3];
	data.view_bits_mut::<Lsb0>()[4 .. 20].store_be(0xABCDu16);
	assert_eq!(data, [0xA0, 0xBC, 0x0D]);
	assert_eq!(data.view_bits::<Lsb0>()[4 .. 20].load_be::<u16>(), 0xABCD);

	data.view_bits_mut::<Lsb0>()[2 .. 6].store_be(9u8);
	//  0b1010_0000 | 0b00_1001_00
	assert_eq!(data, [0xA4, 0xBC, 0x0D]);
	assert_eq!(data.view_bits::<Lsb0>()[2 .. 6].load_be::<u8>(), 9);

	data = [0; 3];
	data.view_bits_mut::<Msb0>()[4 .. 20].store_le(0xABCDu16);
	assert_eq!(data, [0x0D, 0xBC, 0xA0]);
	assert_eq!(data.view_bits::<Msb0>()[4 .. 20].load_le::<u16>(), 0xABCD);

	data.view_bits_mut::<Msb0>()[.. 8].set_all(false);
	data.view_bits_mut::<Msb0>()[2 .. 6].store_le(5u8);
	assert_eq!(data[0], 20);
	assert_eq!(data.view_bits::<Msb0>()[2 .. 6].load_le::<u8>(), 5);

	data = [0; 3];
	data.view_bits_mut::<Lsb0>()[4 .. 20].store_le(0xABCDu16);
	assert_eq!(data, [0xD0, 0xBC, 0x0A]);
	assert_eq!(data.view_bits::<Lsb0>()[4 .. 20].load_le::<u16>(), 0xABCD);

	data.view_bits_mut::<Lsb0>()[.. 8].set_all(false);
	data.view_bits_mut::<Lsb0>()[2 .. 6].store_le(5u8);
	assert_eq!(data[0], 20);
	assert_eq!(data.view_bits::<Lsb0>()[2 .. 6].load_le::<u8>(), 5);
}

#[test]
fn narrow_byte_fields() {
	let mut data = [0u16; 2];

	data.view_bits_mut::<Msb0>()[16 .. 24].store_be(0x12u8);
	assert_eq!(data, [0x0000, 0x1200]);
	assert_eq!(data.view_bits::<Msb0>()[16 .. 24].load_be::<u8>(), 0x12);

	data.view_bits_mut::<Msb0>()[8 .. 16].store_be(0x34u8);
	assert_eq!(data, [0x0034, 0x1200]);
	assert_eq!(data.view_bits::<Msb0>()[8 .. 16].load_be::<u8>(), 0x34);

	data.view_bits_mut::<Msb0>()[0 .. 8].store_be(0x56u8);
	assert_eq!(data, [0x5634, 0x1200]);
	assert_eq!(data.view_bits::<Msb0>()[0 .. 8].load_be::<u8>(), 0x56);

	data = [0; 2];

	data.view_bits_mut::<Msb0>()[16 .. 24].store_le(0x12u8);
	assert_eq!(data, [0x0000, 0x1200]);
	assert_eq!(data.view_bits::<Msb0>()[16 .. 24].load_le::<u8>(), 0x12);

	data.view_bits_mut::<Msb0>()[8 .. 16].store_le(0x34u8);
	assert_eq!(data, [0x0034, 0x1200]);
	assert_eq!(data.view_bits::<Msb0>()[8 .. 16].load_le::<u8>(), 0x34);

	data.view_bits_mut::<Msb0>()[0 .. 8].store_le(0x56u8);
	assert_eq!(data, [0x5634, 0x1200]);
	assert_eq!(data.view_bits::<Msb0>()[0 .. 8].load_le::<u8>(), 0x56);

	data = [0; 2];

	data.view_bits_mut::<Lsb0>()[16 .. 24].store_be(0x12u8);
	assert_eq!(data, [0x0000, 0x0012]);
	assert_eq!(data.view_bits::<Lsb0>()[16 .. 24].load_be::<u8>(), 0x12);

	data.view_bits_mut::<Lsb0>()[8 .. 16].store_be(0x34u8);
	assert_eq!(data, [0x3400, 0x0012]);
	assert_eq!(data.view_bits::<Lsb0>()[8 .. 16].load_be::<u8>(), 0x34);

	data.view_bits_mut::<Lsb0>()[0 .. 8].store_be(0x56u8);
	assert_eq!(data, [0x3456, 0x0012]);
	assert_eq!(data.view_bits::<Lsb0>()[0 .. 8].load_be::<u8>(), 0x56);

	data = [0; 2];

	data.view_bits_mut::<Lsb0>()[16 .. 24].store_le(0x12u8);
	assert_eq!(data, [0x0000, 0x0012]);
	assert_eq!(data.view_bits::<Lsb0>()[16 .. 24].load_le::<u8>(), 0x12);

	data.view_bits_mut::<Lsb0>()[8 .. 16].store_le(0x34u8);
	assert_eq!(data, [0x3400, 0x0012]);
	assert_eq!(data.view_bits::<Lsb0>()[8 .. 16].load_le::<u8>(), 0x34);

	data.view_bits_mut::<Lsb0>()[0 .. 8].store_le(0x56u8);
	assert_eq!(data, [0x3456, 0x0012]);
	assert_eq!(data.view_bits::<Lsb0>()[0 .. 8].load_le::<u8>(), 0x56);
}

#[test]
fn wide_load() {
	let mut data = bitarr![Lsb0, u16; 0; 256];
	assert_eq!(data[16 .. 144].load::<u128>(), 0u128);
	data[16 .. 144].store(!0u128);
	assert_eq!(data[16 .. 144].load::<u128>(), !0u128);
}

#[test]
#[should_panic]
#[cfg(not(target_arch = "riscv64"))]
fn check_panic() {
	check::<u8>("fail", 10);
}

#[test]
#[cfg(feature = "alloc")]
fn wrappers() {
	let mut a = bitarr![Msb0, u8; 0; 8];
	let b = bits![1; 8];
	let mut c = bitbox![0; 8];
	let mut d = bitvec![0; 8];

	a.store_le::<u8>(b.load_le::<u8>());
	a.store_be::<u8>(b.load_be::<u8>());
	assert_eq!(a[.. 8], b);
	assert_eq!(a.load_le::<u8>(), !0);
	assert_eq!(a.load_be::<u8>(), !0);

	c.store_le::<u8>(b.load_le::<u8>());
	c.store_be::<u8>(b.load_be::<u8>());
	assert_eq!(c, b);
	assert_eq!(c.load_le::<u8>(), !0);
	assert_eq!(c.load_be::<u8>(), !0);

	d.store_le::<u8>(b.load_le::<u8>());
	d.store_be::<u8>(b.load_be::<u8>());
	assert_eq!(d, b);
	assert_eq!(d.load_le::<u8>(), !0);
	assert_eq!(d.load_be::<u8>(), !0);
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/field/tests.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/field.rs =====
/*! Batched load/store access to bitfields.

This module provides load/store access to bitfield regions that emulates the
ordinary memory bus. This functionality enables any [`BitSlice`] span to be used
as a memory region, and provides the basis of a library-level analogue to the
bitfield language feature found in C and C++. Additionally, orderings that have
contiguous positions can transfer more than one bit in an operation, allowing a
performance acceleration over sequential bit-by-bit traversal.

The [`BitField`] trait is open for implementation. Rust’s implementation rules
currently disallow a crate to implement a foreign trait on a foreign type, even
when parameterized over a local type. If you need such a `BitField`
implementation with a new `BitOrder` type, please file an issue.

# Batched Behavior

The first purpose of [`BitField`] is to provide access to [`BitSlice`] regions
as if they were an ordinary memory location. However, this can be done through
the `BitSlice` sequential API. The second purpose of this trait is to accelerate
such access by using the parallel memory bus to transfer more than one bit at a
time when the region permits it. As such, implementors should provide a transfer
behavior based on shift/mask operations wherever possible, for as wide a span in
a memory element as possible.

# Register Bit Order Preservation

As a default assumption, each element of the underlying memory region used to
store part of a value should not reörder the bit-pattern of that value. While
the [`BitOrder`] argument is used to determine which segments of the memory
register are live for the purposes of this transfer, it should not be used to
map each individual bit of the transferred value to a corresponding bit of the
storage element. As an example, the [`Lsb0`] and [`Msb0`] implementations both
store the value `12u8` in memory as a four-bit span with its two
more-significant bits set and its two less-significant bits cleared; the
difference is only in *which* bits of an element are used to store the span.

# Endianness

The `_le` and `_be` methods of [`BitField`] refer to the order in which
successive `T` elements of a storage region are assigned numeric significance
during a transfer. Within any particular `T` element, the ordering of its memory
is not governed by the `BitField` trait.

The provided [`BitOrder`] implementors [`Lsb0`] and [`Msb0`] use the local
machine’s byte ordering, and do not reörder bytes during transfer.

## `_le` Methods

When storing a value `M` into a sequence of memory elements `T`, [`store_le`]
breaks `M` into chunks from the least significant edge. The least significant
chunk is placed in the lowest-addressed element `T`, then the next more
significant chunk is placed in the successive address, until the most
significant chunk of the value `M` is placed in the highest address of a
location `T`.

When loading a value `M` out of a sequence of memory elements `T`, [`load_le`]
uses the same chunking behavior: the lowest-addressed `T` contains the least
significant chunk of the returned `M`, then each successive address contains a
more significant chunk, until the highest address contains the most significant.

The [`BitOrder`] implementation governs *where* in each `T` location a fragment
of `M` is stored.

Let us store 8 bits into memory, over an element boundary, using both [`Lsb0`]
and [`Msb0`] orderings:

```rust
use bitvec::prelude::*;

let val: u8 = 0b11010_011;
//              STUVW XYZ
let mut store = [0u8; 2];

store.view_bits_mut::<Lsb0>()
  [5 .. 13]
  .store_le(val);
assert_eq!(
  store,
  [0b011_00000, 0b000_11010],
//   XYZ               STUVW
# "[{:08b}, {:08b}]",
# store[0],
# store[1],
);
store = [0u8; 2];

store.view_bits_mut::<Msb0>()
  [5 .. 13]
  .store_le(val);
assert_eq!(
  store,
  [0b00000_011, 0b11010_000],
//         XYZ    STUVW
# "[{:08b}, {:08b}]",
# store[0],
# store[1],
);
```

In both cases, the lower three bits of `val` were placed into the element at the
lower memory address. The choice of [`Lsb0`] vs [`Msb0`] changed *which* three
bits in the element were considered to be indexed by `5 .. 8`, but [`store_le`]
always placed the least three bits of `val`, *in ordinary register order*, into
element `[0]`. Similarly, the higher five bits of `val` were placed into element
`[1]`; `Lsb0` and `Msb0` selected *which* five bits in the element were indexed
by `8 .. 13`, and the bits retained their register order.

## `_be` Methods

When storing a value `M` into a sequence of memory elements `T`, [`store_be`]
breaks `M` into chunks from the most significant edge. The most significant
chunk is placed in the lowest-addressed element `T`, then the next less
significant chunk is placed in the successive address, until the least
significant chunk of the value `M` is placed in the highest address of a
location `T`.

When loading a value `M` out of a sequence of memory elements `T`, [`load_be`]
uses the same chunking behavior: the lowest-addressed `T` contains the most
significant chunk of the returned `M`, then each successive address contains a
less significant chunk, until the highest address contains the least
significant.

The [`BitOrder`] implementation governs *where* in each `T` location a fragment
of `M` is stored.

Let us store 8 bits into memory, over an element boundary, using both [`Lsb0`]
and [`Msb0`] orderings:

```rust
use bitvec::prelude::*;

let val: u8 = 0b110_10011;
//              STU VWXYZ
let mut store = [0u8; 2];

store.view_bits_mut::<Lsb0>()
  [5 .. 13]
  .store_be(val);
assert_eq!(
  store,
  [0b110_00000, 0b000_10011],
//   STU              VWXYZ
# "[{:08b}, {:08b}]",
# store[0],
# store[1],
);
store = [0u8; 2];

store.view_bits_mut::<Msb0>()
  [5 .. 13]
  .store_be(val);
assert_eq!(
  store,
  [0b00000_110, 0b10011_000],
//         STU    VWXYZ
# "[{:08b}, {:08b}]",
# store[0],
# store[1],
);
```

In both cases, the higher three bits of `val` were placed into the element at
the lower memory address. The choice of [`Lsb0`] vs [`Msb0`] changed *which*
three bits in the element were considered to be indexed by `5 .. 8`, but
[`store_be`] always placed the greatest three bits of `val`, *in ordinary*
*register order*, into element `[0]`. Similarly, the lower five bits of `val`
were placed into element `[1]`; `Lsb0` and `Msb0` selected *which* five bits in
the element were indexed by `8 .. 13`, and the bits retained their register
order.

# `M` and `T` Relationships

`BitField` permits any type of (unsigned) integer `M` to be stored into or
loaded from a bit-slice region with any storage type `T`. While the examples
used `u8` for both, for brevity of writing out values, `BitField` will still
operate correctly for any other combination of types.

`Bitfield` implementations use the processor’s own concept of integer registers
to operate. As such, the byte-wise memory access patterns for types wider than
`u8` depends on your processor’s byte-endianness, as well as which `BitField`
method and which `BitOrder` implementation you are using.

`BitField` only operates within processor registers; traffic of `T` elements
between the memory bank and the processor register is controlled entirely by the
processor.

If you do not want to introduce the processor’s byte-endianness as a variable
that affects the in-memory representation of stored integers, stick to
`BitSlice<_, u8>` as the bit-field driver. `BitSlice<Msb0, u8>` will fill memory
in a way that matches a debugger or other memory inspections.

[`BitField`]: crate::field::BitField
[`BitOrder`]: crate::order::BitOrder
[`BitSlice`]: crate::slice::BitSlice
[`Lsb0`]: crate::order::Lsb0
[`Msb0`]: crate::order::Msb0
[`load_be`]: crate::field::BitField::load_be
[`load_le`]: crate::field::BitField::load_le
[`store_be`]: crate::field::BitField::store_be
[`store_le`]: crate::field::BitField::store_le
!*/

use core::{
	mem,
	ptr,
};

use funty::IsNumber;
use tap::pipe::Pipe;

use crate::{
	access::BitAccess,
	array::BitArray,
	domain::{
		Domain,
		DomainMut,
	},
	index::BitMask,
	mem::BitMemory,
	order::{
		BitOrder,
		Lsb0,
		Msb0,
	},
	slice::BitSlice,
	store::BitStore,
	view::BitViewSized,
};
#[cfg(feature = "alloc")]
use crate::{
	boxed::BitBox,
	vec::BitVec,
};

/** Performs C-style bitfield access through a [`BitSlice`].

This trait transfers data between a [`BitSlice`] region and a local integer. The
trait functions always place the live bits of the value against the least
significant bit edge of the local integer (the return value of the load methods,
and the argument value of the store methods).

Methods should be called as `bits[start .. end].load_or_store()`, where the
range subslice selects no more than the [`M::BITS`] element width.

# Target-Specific Behavior

When you are using this trait to manage memory that never leaves your machine,
you can use the [`load`] and [`store`] methods. However, if you are using this
trait to operate on a de/serialization buffer, where the exact bit pattern in
memory is important to your work and/or you need to be aware of the processor
byte endianness, you must not use these methods.

Instead, use [`load_le`], [`load_be`], [`store_le`], or[`store_be`] directly.

The un-suffixed methods choose their implementation based on the target
processor byte endianness; the suffixed methods have a consistent and fixed
behavior.

# Element- and Bit- Ordering Combinations

The `_le` and `_be` method suffices refer to the significance of successive
elements `T` in memory, while the `BitOrder` trait refers to the order that bits
within a single element `T` are traversed. The `BitField` methods and the
`BitOrder` implementors are ***not*** related.

When a load or store operation is contained in only one memory element, then the
`_le` and `_be` methods have the same behavior. They differ when the operation
must touch more than one element.

The module documentation contains a more detailed explanation, and examples, for
this behavior.

[`BitSlice`]: crate::slice::BitSlice
[`M::BITS`]: funty::IsNumber::BITS
[`load`]: Self::load
[`load_be`]: Self::load_be
[`load_le`]: Self::load_le
[`store`]: Self::store
[`store_be`]: Self::store_be
[`store_le`]: Self::store_le
**/
pub trait BitField {
	/// Loads the bits in the `self` region into a local value.
	///
	/// This can load into any of the unsigned integers which implement
	/// [`BitMemory`]. Any further transformation must be done by the user.
	///
	/// # Target-Specific Behavior
	///
	/// **THIS FUNCTION CHANGES BEHAVIOR FOR DIFFERENT TARGETS.**
	///
	/// The default implementation of this function calls [`load_le`] on
	/// little-endian byte-ordered CPUs, and [`load_be`] on big-endian
	/// byte-ordered CPUs.
	///
	/// If you are using this function from a region that crosses multiple
	/// elements in memory, be aware that it will behave differently on
	/// big-endian and little-endian target architectures.
	///
	/// # Parameters
	///
	/// - `&self`: A read reference to some bits in memory. This slice must be
	///   trimmed to have a width no more than the [`M::BITS`] width of the type
	///   being loaded. This can be accomplished with range indexing on a larger
	///   slice.
	///
	/// # Returns
	///
	/// A value `M` whose least [`self.len()`] significant bits are filled with
	/// the bits of `self`.
	///
	/// # Panics
	///
	/// This method is encouraged to panic if `self` is empty, or wider than a
	/// single element `M`.
	///
	/// [`BitMemory`]: crate::mem::BitMemory
	/// [`M::BITS`]: funty::IsNumber::BITS
	/// [`load_be`]: Self::load_be
	/// [`load_le`]: Self::load_le
	/// [`self.len()`]: crate::slice::BitSlice::len
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	fn load<M>(&self) -> M
	where M: BitMemory {
		#[cfg(target_endian = "little")]
		return self.load_le::<M>();

		#[cfg(target_endian = "big")]
		return self.load_be::<M>();
	}

	/// Stores a sequence of bits from the user into the domain of `self`.
	///
	/// This can store any of the unsigned integers which implement
	/// [`BitMemory`]. Any other types must first be transformed by the user.
	///
	/// # Target-Specific Behavior
	///
	/// **THIS FUNCTION CHANGES BEHAVIOR FOR DIFFERENT TARGETS.**
	///
	/// The default implementation of this function calls [`store_le`] on
	/// little-endian byte-ordered CPUs, and [`store_be`] on big-endian
	/// byte-ordered CPUs.
	///
	/// If you are using this function to store into a region that crosses
	/// multiple elements in memory, be aware that it will behave differently on
	/// big-endian and little-endian target architectures.
	///
	/// # Parameters
	///
	/// - `&mut self`: A write reference to some bits in memory. This slice must
	///   be trimmed to have a width no more than the [`M::BITS`] width of the
	///   type being stored. This can be accomplished with range indexing on a
	///   larger slice.
	/// - `value`: A value, whose [`self.len()`] least significant bits will be
	///   stored into `self`.
	///
	/// # Behavior
	///
	/// The [`self.len()`] least significant bits of `value` are written into
	/// the domain of `self`.
	///
	/// # Panics
	///
	/// This method is encouraged to panic if `self` is empty, or wider than a
	/// single element `M`.
	///
	/// [`BitMemory`]: crate::mem::BitMemory
	/// [`M::BITS`]: funty::IsNumber::BITS
	/// [`self.len()`]: crate::slice::BitSlice::len
	/// [`store_be`]: Self::store_be
	/// [`store_le`]: Self::store_le
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	fn store<M>(&mut self, value: M)
	where M: BitMemory {
		#[cfg(target_endian = "little")]
		self.store_le(value);

		#[cfg(target_endian = "big")]
		self.store_be(value);
	}

	/// Loads from `self`, using little-endian element `T` ordering.
	///
	/// This function interprets a multi-element slice as having its least
	/// significant chunk in the low memory address, and its most significant
	/// chunk in the high memory address. Each element `T` is still interpreted
	/// from individual bytes according to the local CPU ordering.
	///
	/// # Parameters
	///
	/// - `&self`: A read reference to some bits in memory. This slice must be
	///   trimmed to have a width no more than the [`M::BITS`] width of the type
	///   being loaded. This can be accomplished with range indexing on a larger
	///   slice.
	///
	/// # Returns
	///
	/// A value `M` whose least [`self.len()`] significant bits are filled with
	/// the bits of `self`. If `self` spans multiple elements `T`, then the
	/// lowest-address `T` is interpreted as containing the least significant
	/// bits of the return value `M`, and the highest-address `T` is interpreted
	/// as containing its most significant bits.
	///
	/// # Panics
	///
	/// This method is encouraged to panic if `self` is empty, or wider than a
	/// single element `M`.
	///
	/// # Examples
	///
	/// This example shows how a value is segmented across multiple storage
	/// elements:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut data = [0u8; 3];
	/// data.view_bits_mut::<Msb0>()
	///   [5 .. 17]
	///   .store_le(0b0000_1_1011_1000_110u16);
	/// //                 O PQRS TUVW XYZ
	///
	/// assert_eq!(data, [
	///   0b00000_110, 0b1011_1000, 0b1_0000000
	/// //        XYZ    PQRS TUVW    O
	/// ]);
	///
	/// let val = data.view_bits::<Msb0>()
	///   [5 .. 17]
	///   .load_le::<u16>();
	/// assert_eq!(
	///   val,
	///   0b0000_1_1011_1000_110,
	/// //       O PQRS TUVW XYZ
	/// );
	/// ```
	///
	/// And this example shows how the same memory region will be read by
	/// different `BitOrder` implementors:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// // Bit pos:   14                                     19  16
	/// // Lsb0:     ─┤                                       ├──┤
	/// let arr = [0b0100_0000_0000_0011u16, 0b0001_0000_0000_1110u16];
	/// // Msb0:                      ├─       ├──┤
	/// // Bit pos:                  14       16  19
	///
	/// assert_eq!(
	///   arr.view_bits::<Lsb0>()[14 .. 20].load_le::<u8>(),
	///   0b111001,
	/// );
	/// assert_eq!(
	///   arr.view_bits::<Msb0>()[14 .. 20].load_le::<u8>(),
	///   0b000111,
	/// );
	/// ```
	///
	/// [`M::BITS`]: funty::IsNumber::BITS
	/// [`self.len()`]: crate::slice::BitSlice::len
	fn load_le<M>(&self) -> M
	where M: BitMemory;

	/// Loads from `self`, using big-endian element `T` ordering.
	///
	/// This function interprets a multi-element slice as having its most
	/// significant chunk in the low memory address, and its least significant
	/// chunk in the high memory address. Each element `T` is still interpreted
	/// from individual bytes according to the local CPU ordering.
	///
	/// # Parameters
	///
	/// - `&self`: A read reference to some bits in memory. This slice must be
	///   trimmed to have a width no more than the [`M::BITS`] width of the type
	///   being loaded. This can be accomplished with range indexing on a larger
	///   slice.
	///
	/// # Returns
	///
	/// A value `M` whose least [`self.len()`] significant bits are filled with
	/// the bits of `self`. If `self` spans multiple elements `T`, then the
	/// lowest-address `T` is interpreted as containing the most significant
	/// bits of the return value `M`, and the highest-address `T` is interpreted
	/// as containing its least significant bits.
	///
	/// # Panics
	///
	/// This method is encouraged to panic if `self` is empty, or wider than a
	/// single element `M`.
	///
	/// # Examples
	///
	/// This example shows how a value is segmented across multiple storage
	/// elements:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut data = [0u8; 3];
	/// data.view_bits_mut::<Msb0>()
	///   [5 .. 17]
	///   .store_be(0b0000_110_1000_1011_1u16);
	/// //                 OPQ RSTU VWXY Z
	///
	/// assert_eq!(data, [
	///   0b00000_110, 0b1000_1011, 0b1_0000000
	/// //        OPQ    RSTU VWXY    Z
	/// ]);
	///
	/// let val = data.view_bits::<Msb0>()
	///   [5 .. 17]
	///   .load_be::<u16>();
	/// assert_eq!(
	///   val,
	///   0b0000_110_1000_1011_1,
	/// //       OPQ RSTU VWXY Z
	/// # "{:012b}",
	/// # val,
	/// );
	/// ```
	///
	/// And this example shows how the same memory region will be read by
	/// different `BitOrder` implementations:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	/// // Bit pos:   14                                     19  16
	/// // Lsb0:     ─┤                                       ├──┤
	/// let arr = [0b0100_0000_0000_0011u16, 0b0001_0000_0000_1110u16];
	/// // Msb0:                      ├─       ├──┤
	/// // Bit pos:                  14       16  19
	///
	/// assert_eq!(
	///   arr.view_bits::<Lsb0>()[14 .. 20].load_be::<u8>(),
	///   0b011110,
	/// );
	/// assert_eq!(
	///   arr.view_bits::<Msb0>()[14 .. 20].load_be::<u8>(),
	///   0b110001,
	/// );
	/// ```
	///
	/// [`M::BITS`]: funty::IsNumber::BITS
	/// [`self.len()`]: crate::slice::BitSlice::len
	fn load_be<M>(&self) -> M
	where M: BitMemory;

	/// Stores into `self`, using little-endian element ordering.
	///
	/// This function interprets a multi-element slice as having its least
	/// significant chunk in the low memory address, and its most significant
	/// chunk in the high memory address. Each element `T` is still interpreted
	/// from individual bytes according to the local CPU ordering.
	///
	/// # Parameters
	///
	/// - `&mut self`: A write reference to some bits in memory. This slice must
	///   be trimmed to have a width no more than the [`M::BITS`] width of the
	///   type being stored. This can be accomplished with range indexing on a
	///   larger slice.
	/// - `value`: A value, whose [`self.len()`] least significant bits will be
	///   stored into `self`.
	///
	/// # Behavior
	///
	/// The [`self.len()`] least significant bits of `value` are written into
	/// the domain of `self`. If `self` spans multiple elements `T`, then the
	/// lowest-address `T` is interpreted as containing the least significant
	/// bits of the `M` return value, and the highest-address `T` is interpreted
	/// as containing its most significant bits.
	///
	/// # Panics
	///
	/// This method is encouraged to panic if `self` is empty, or wider than a
	/// single element `M`.
	///
	/// # Examples
	///
	/// This example shows how a value is segmented across multiple storage
	/// elements:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut data = [0u8; 3];
	/// data.view_bits_mut::<Lsb0>()
	///   [5 .. 17]
	///   .store_le(0b0000_1_1011_1000_110u16);
	/// //                 O PQRS TUVW XYZ
	///
	/// assert_eq!(data, [
	///   0b110_00000, 0b1011_1000, 0b0000000_1
	/// //  XYZ          PQRS TUVW            O
	/// ]);
	///
	/// let val = data.view_bits::<Lsb0>()
	///   [5 .. 17]
	///   .load_le::<u16>();
	/// assert_eq!(
	///   val,
	///   0b0000_1_1011_1000_110u16,
	/// //       O PQRS TUVW XYZ
	/// );
	/// ```
	///
	/// And this example shows how the same memory region is written by
	/// different `BitOrder` implementations:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	/// let mut lsb0 = bitarr![Lsb0, u16; 0; 32];
	/// let mut msb0 = bitarr![Msb0, u16; 0; 32];
	///
	/// // Bit pos:        14                                     19  16
	/// // Lsb0:          ─┤                                       ├──┤
	/// let exp_lsb0 = [0b0100_0000_0000_0000u16, 0b0000_0000_0000_1110u16];
	/// let exp_msb0 = [0b0000_0000_0000_0011u16, 0b0001_0000_0000_0000u16];
	/// // Msb0:                           ├─       ├──┤
	/// // Bit pos:                       14       16  19
	///
	/// lsb0[14 ..= 19].store_le(0b111001u8);
	/// msb0[14 ..= 19].store_le(0b000111u8);
	/// assert_eq!(lsb0.as_raw_slice(), exp_lsb0);
	/// assert_eq!(msb0.as_raw_slice(), exp_msb0);
	/// ```
	///
	/// [`M::BITS`]: funty::IsNumber::BITS
	/// [`self.len()`]: crate::slice::BitSlice::len
	fn store_le<M>(&mut self, value: M)
	where M: BitMemory;

	/// Stores into `self`, using big-endian element ordering.
	///
	/// This function interprets a multi-element slice as having its most
	/// significant chunk in the low memory address, and its least significant
	/// chunk in the high memory address. Each element `T` is still interpreted
	/// from individual bytes according to the local CPU ordering.
	///
	/// # Parameters
	///
	/// - `&mut self`: A write reference to some bits in memory. This slice must
	///   be trimmed to have a width no more than the [`M::BITS`] width of the
	///   type being stored. This can be accomplished with range indexing on a
	///   larger slice.
	/// - `value`: A value, whose [`self.len()`] least significant bits will be
	///   stored into `self`.
	///
	/// # Behavior
	///
	/// The [`self.len()`] least significant bits of `value` are written into
	/// the domain of `self`. If `self` spans multiple elements `T`, then the
	/// lowest-address `T` is interpreted as containing the most significant
	/// bits of the `M` return value, and the highest-address `T` is interpreted
	/// as containing its least significant bits.
	///
	/// # Panics
	///
	/// This method is encouraged to panic if `self` is empty, or wider than a
	/// single element `M`.
	///
	/// # Examples
	///
	/// This example shows how a value is segmented across multiple storage
	/// elements:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut data = [0u8; 3];
	/// data.view_bits_mut::<Lsb0>()
	///   [5 .. 17]
	///   .store_be(0b0000_110_1000_1011_1u16);
	/// //                 OPQ RSTU VWXY Z
	///
	/// assert_eq!(data, [
	///   0b110_00000, 0b1000_1011, 0b0000000_1
	/// //  OPQ          RSTU VWXY            Z
	/// ]);
	///
	/// let val = data.view_bits::<Lsb0>()
	///   [5 .. 17]
	///   .load_be::<u16>();
	/// assert_eq!(
	///   val,
	///   0b0000_110_1000_1011_1u16,
	/// //       OPQ RSTU VWXY Z
	/// );
	/// ```
	///
	/// And this example shows how the same memory region is written by
	/// different `BitOrder` implementations:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	/// let mut lsb0 = bitarr![Lsb0, u16; 0; 32];
	/// let mut msb0 = bitarr![Msb0, u16; 0; 32];
	///
	/// // Bit pos:        14                                     19  16
	/// // Lsb0:          ─┤                                       ├──┤
	/// let exp_lsb0 = [0b0100_0000_0000_0000u16, 0b0000_0000_0000_1110u16];
	/// let exp_msb0 = [0b0000_0000_0000_0011u16, 0b0001_0000_0000_0000u16];
	/// // Msb0:                           ├─       ├──┤
	/// // Bit pos:                       14       16  19
	///
	/// lsb0[14 ..= 19].store_be(0b011110u8);
	/// msb0[14 ..= 19].store_be(0b110001u8);
	/// assert_eq!(lsb0.as_raw_slice(), exp_lsb0);
	/// assert_eq!(msb0.as_raw_slice(), exp_msb0);
	/// ```
	///
	/// [`M::BITS`]: funty::IsNumber::BITS
	/// [`self.len()`]: crate::slice::BitSlice::len
	fn store_be<M>(&mut self, value: M)
	where M: BitMemory;
}

impl<T> BitField for BitSlice<Lsb0, T>
where T: BitStore
{
	/// Loads from `self`, using little-endian element ordering if `self` spans
	/// more than one `T` element.
	///
	/// If [`self.domain()`] produces a [`Domain::Region`], then:
	///
	/// - its [`head`] element contains the least significant segment of the
	///   returned value, in the bits at the most significant edge of the
	///   element,
	/// - its [`body`] slice contains successively more-significant segments,
	///   and
	/// - its [`tail`] element contains the most significant segment of the
	///   returned value, in the bits at the least significant edge of the
	///   element.
	///
	/// If the domain is an [`Enclave`], then the referent element is merely
	/// loaded, shifted, and masked; no recombination of segments is necessary.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut data = [0u8; 3];
	/// data.view_bits_mut::<Lsb0>()[5 .. 21].store_le::<u16>(
	///   0b1_1011_0100_1100_011
	/// //  K LMNO PQRS TUVW XYZ
	/// );
	/// assert_eq!(data, [
	///   0b011_00000, 0b0100_1100, 0b000_1_1011
	/// //  XYZ          PQRS TUVW        K LMNO
	/// ]);
	/// let val = data.view_bits::<Lsb0>()[5 .. 21].load_le::<u16>();
	/// assert_eq!(
	///   val,
	///   0b1_1011_0100_1100_011,
	/// //  K LMNO PQRS TUVW XYZ
	/// );
	/// ```
	///
	/// [`Domain::Region`]: crate::domain::Domain::Region
	/// [`Enclave`]: crate::domain::Domain::Enclave
	/// [`body`]: crate::domain::Domain::Region::body
	/// [`head`]: crate::domain::Domain::Region::head
	/// [`self.domain()`]: crate::slice::BitSlice::domain
	/// [`tail`]: crate::domain::Domain::Region::tail
	fn load_le<M>(&self) -> M
	where M: BitMemory {
		check::<M>("load", self.len());

		match self.domain() {
			//  In Lsb0, a `head` index counts distance from LSedge, and a
			//  `tail` index counts element width minus distance from MSedge.
			Domain::Enclave { head, elem, tail } => {
				get::<T, M>(elem, Lsb0::mask(head, tail), head.into_inner())
			},
			Domain::Region { head, body, tail } => {
				let mut accum = M::ZERO;

				/* For multi-`T::Mem` domains, the most significant chunk is
				stored in the highest memory address, the tail. Each successive
				memory address lower has a chunk of decreasing significance,
				until the least significant chunk is stored in the lowest memory
				address, the head.
				*/

				if let Some((elem, tail)) = tail {
					accum = get::<T, M>(elem, Lsb0::mask(None, tail), 0);
				}

				for elem in body.iter().rev().map(BitStore::load_value) {
					/* Rust does not allow the use of shift instructions of
					exactly a type width to clear a value. This loop only enters
					when `M` is not narrower than `T::Mem`, and the shift is
					only needed when `M` occupies *more than one* `T::Mem` slot.
					When `M` is exactly as wide as `T::Mem`, this loop either
					does not run (head and tail only), or runs once (single
					element), and thus the shift is unnecessary.

					As a const-expression, this branch folds at compile-time to
					conditionally remove or retain the instruction.
					*/
					if M::BITS > <T::Mem as IsNumber>::BITS {
						accum <<= <T::Mem as IsNumber>::BITS;
					}
					accum |= resize::<T::Mem, M>(elem);
				}

				if let Some((head, elem)) = head {
					let shamt = head.into_inner();
					let rshamt = <T::Mem as IsNumber>::BITS as u8 - shamt;
					if M::BITS as u8 > rshamt {
						accum <<= rshamt;
					}
					else {
						accum = M::ZERO;
					}
					accum |= get::<T, M>(elem, Lsb0::mask(head, None), shamt);
				}

				accum
			},
		}
	}

	/// Loads from `self`, using big-endian element ordering if `self` spans
	/// more than one `T` element.
	///
	/// If [`self.domain()`] produces a [`Domain::Region`], then:
	///
	/// - its [`head`] element contains the most significant segment of the
	///   returned value, in the bits at the most significant edge of the
	///   element,
	/// - its [`body`] slice contains successively less-significant segments,
	///   and
	/// - its [`tail`] element contains the least significant segment of the
	///   returned value, in the bits at the least significant edge of the
	///   element.
	///
	/// If the domain is an [`Enclave`], then the referent element is merely
	/// loaded, shifted, and masked; no recombination of segments is necessary.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut data = [0u8; 3];
	/// data.view_bits_mut::<Lsb0>()[5 .. 21].store_be::<u16>(
	///   0b011_1100_0100_1011_1,
	/// //  KLM NOPQ RSTU VWXY Z
	/// );
	/// assert_eq!(data, [
	///   0b011_00000, 0b1100_0100, 0b000_1011_1
	/// //  KLM          NOPQ RSTU        VWXY Z
	/// ]);
	/// let val = data.view_bits::<Lsb0>()[5 .. 21].load_be::<u16>();
	/// assert_eq!(
	///   val,
	///   0b011_1100_0100_1011_1,
	/// //  KLM NOPQ RSTU VWXY Z
	/// );
	/// ```
	///
	/// [`Domain::Region`]: crate::domain::Domain::Region
	/// [`Enclave`]: crate::domain::Domain::Enclave
	/// [`body`]: crate::domain::Domain::Region::body
	/// [`head`]: crate::domain::Domain::Region::head
	/// [`self.domain()`]: crate::slice::BitSlice::domain
	/// [`tail`]: crate::domain::Domain::Region::tail
	fn load_be<M>(&self) -> M
	where M: BitMemory {
		check::<M>("load", self.len());

		match self.domain() {
			Domain::Enclave { head, elem, tail } => {
				get::<T, M>(elem, Lsb0::mask(head, tail), head.into_inner())
			},
			Domain::Region { head, body, tail } => {
				let mut accum = M::ZERO;

				if let Some((head, elem)) = head {
					accum = get::<T, M>(
						elem,
						Lsb0::mask(head, None),
						head.into_inner(),
					);
				}

				for elem in body.iter().map(BitStore::load_value) {
					if M::BITS > <T::Mem as IsNumber>::BITS {
						accum <<= <T::Mem as IsNumber>::BITS;
					}
					accum |= resize::<T::Mem, M>(elem);
				}

				if let Some((elem, tail)) = tail {
					let shamt = tail.into_inner();
					if M::BITS as u8 > shamt {
						accum <<= shamt;
					}
					else {
						accum = M::ZERO;
					}
					accum |= get::<T, M>(elem, Lsb0::mask(None, tail), 0);
				}

				accum
			},
		}
	}

	/// Stores into `self`, using little-endian element ordering if `self` spans
	/// more than one `T` element.
	///
	/// If [`self.domain()`] produces a [`Domain::Region`], then:
	///
	/// - its [`head`] element receives the least significant segment of
	///   `value`, in the bits at the most significant edge of the element,
	/// - its [`body`] slice receives successively more-significant segments of
	///   `value`, and
	/// - its [`tail`] element receives the most significant segment of `value`,
	///   in the bits at the least significant edge of the element.
	///
	/// If the domain is an [`Enclave`], then `value` is shifted into place and
	/// written without any segmentation.
	///
	/// # Examples
	///
	/// See the documentation for `<BitSlice<Lsb0, u8> as BitField>::load_le`.
	///
	/// [`Domain::Region`]: crate::domain::Domain::Region
	/// [`Enclave`]: crate::domain::Domain::Enclave
	/// [`head`]: crate::domain::Domain::Region::head
	/// [`body`]: crate::domain::Domain::Region::body
	/// [`self.domain()`]: crate::slice::BitSlice::domain
	/// [`tail`]: crate::domain::Domain::Region::tail
	fn store_le<M>(&mut self, mut value: M)
	where M: BitMemory {
		check::<M>("store", self.len());

		match self.domain_mut() {
			DomainMut::Enclave { head, elem, tail } => {
				set::<T, M>(
					elem,
					value,
					Lsb0::mask(head, tail),
					head.into_inner(),
				);
			},
			DomainMut::Region { head, body, tail } => {
				if let Some((head, elem)) = head {
					let shamt = head.into_inner();
					set::<T, M>(elem, value, Lsb0::mask(head, None), shamt);
					let lshamt = <T::Mem as IsNumber>::BITS as u8 - shamt;
					if M::BITS as u8 > lshamt {
						value >>= lshamt;
					}
					else {
						value = M::ZERO;
					}
				}

				for elem in body.iter_mut() {
					elem.store_value(resize(value));
					if M::BITS > <T::Mem as IsNumber>::BITS {
						value >>= <T::Mem as IsNumber>::BITS;
					}
				}

				if let Some((elem, tail)) = tail {
					set::<T, M>(elem, value, Lsb0::mask(None, tail), 0);
				}
			},
		}
	}

	/// Stores into `self`, using big-endian element ordering if `self` spans
	/// more than one `T` element.
	///
	/// If [`self.domain()`] produces a [`Domain::Region`], then:
	///
	/// - its [`head`] element receives the most significant segment of `value`,
	///   in the bits at the most significant edge of the element,
	/// - its [`body`] slice receives successively less-significant segments of
	///   `value`, and
	/// - its [`tail`] element receives the least significant segment of
	///   `value`, in the bits at the least significant edge of the element.
	///
	/// If the domain is an [`Enclave`], then `value` is shifted into place and
	/// written without any segmentation.
	///
	/// # Examples
	///
	/// See the documentation for `<BitSlice<Lsb0, u8> as BitField>::load_be`.
	///
	/// [`Domain::Region`]: crate::domain::Domain::Region
	/// [`Enclave`]: crate::domain::Domain::Enclave
	/// [`head`]: crate::domain::Domain::Region::head
	/// [`body`]: crate::domain::Domain::Region::body
	/// [`self.domain()`]: crate::slice::BitSlice::domain
	/// [`tail`]: crate::domain::Domain::Region::tail
	fn store_be<M>(&mut self, mut value: M)
	where M: BitMemory {
		check::<M>("store", self.len());

		match self.domain_mut() {
			DomainMut::Enclave { head, elem, tail } => {
				set::<T, M>(
					elem,
					value,
					Lsb0::mask(head, tail),
					head.into_inner(),
				);
			},
			DomainMut::Region { head, body, tail } => {
				if let Some((elem, tail)) = tail {
					set::<T, M>(elem, value, Lsb0::mask(None, tail), 0);
					let shamt = tail.into_inner();
					if M::BITS as u8 > shamt {
						value >>= shamt;
					}
					else {
						value = M::ZERO;
					}
				}

				for elem in body.iter_mut().rev() {
					elem.store_value(resize(value));
					if M::BITS > <T::Mem as IsNumber>::BITS {
						value >>= <T::Mem as IsNumber>::BITS;
					}
				}

				if let Some((head, elem)) = head {
					set::<T, M>(
						elem,
						value,
						Lsb0::mask(head, None),
						head.into_inner(),
					);
				}
			},
		}
	}
}

impl<T> BitField for BitSlice<Msb0, T>
where T: BitStore
{
	/// Loads from `self`, using little-endian element ordering if `self` spans
	/// more than one `T` element.
	///
	/// If [`self.domain()`] produces a [`Domain::Region`], then:
	///
	/// - its [`head`] element contains the least significant segment of the
	///   returned value, in the bits at the least significant edge of the
	///   element,
	/// - its [`body`] slice contains successively more-significant segments,
	///   and
	/// - its [`tail`] element contains the most significant segment of the
	///   returned value, in the bits at the most significant edge of the
	///   element.
	///
	/// If the domain is an [`Enclave`], then the referent element is merely
	/// loaded, shifted, and masked; no recombination of segments is necessary.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut data = [0u8; 3];
	/// data.view_bits_mut::<Msb0>()[5 .. 21].store_le::<u16>(
	///   0b1_1011_0100_1100_110
	/// //  K LMNO PQRS TUVW XYZ
	/// );
	/// assert_eq!(data, [
	///   0b00000_110, 0b0100_1100, 0b1_1011_000
	/// //        XYZ    PQRS TUVW    K LMNO
	/// ]);
	/// let val = data.view_bits::<Msb0>()[5 .. 21].load_le::<u16>();
	/// assert_eq!(
	///   val,
	///   0b1_1011_0100_1100_110,
	/// //  K LMNO PQRS TUVW XYZ
	/// );
	/// ```
	///
	/// [`Domain::Region`]: crate::domain::Domain::Region
	/// [`Enclave`]: crate::domain::Domain::Enclave
	/// [`body`]: crate::domain::Domain::Region::body
	/// [`head`]: crate::domain::Domain::Region::head
	/// [`self.domain()`]: crate::slice::BitSlice::domain
	/// [`tail`]: crate::domain::Domain::Region::tail
	fn load_le<M>(&self) -> M
	where M: BitMemory {
		check::<M>("load", self.len());

		match self.domain() {
			Domain::Enclave { head, elem, tail } => get::<T, M>(
				elem,
				Msb0::mask(head, tail),
				<T::Mem as IsNumber>::BITS as u8 - tail.into_inner(),
			),
			Domain::Region { head, body, tail } => {
				let mut accum = M::ZERO;

				if let Some((elem, tail)) = tail {
					accum = get::<T, M>(
						elem,
						Msb0::mask(None, tail),
						<T::Mem as IsNumber>::BITS as u8 - tail.into_inner(),
					);
				}

				for elem in body.iter().rev().map(BitStore::load_value) {
					if M::BITS > <T::Mem as IsNumber>::BITS {
						accum <<= <T::Mem as IsNumber>::BITS;
					}
					accum |= resize::<T::Mem, M>(elem);
				}

				if let Some((head, elem)) = head {
					let shamt =
						<T::Mem as IsNumber>::BITS as u8 - head.into_inner();
					if M::BITS as u8 > shamt {
						accum <<= shamt;
					}
					else {
						accum = M::ZERO;
					}
					accum |= get::<T, M>(elem, Msb0::mask(head, None), 0);
				}

				accum
			},
		}
	}

	/// Loads from `self`, using big-endian element ordering if `self` spans
	/// more than one element `T`.
	///
	/// If [`self.domain()`] produces a [`Domain::Region`], then:
	///
	/// - its [`head`] element contains the most significant segment of the
	///   returned value, in the bits at the least significant edge of the
	///   element,
	/// - its [`body`] slice contains successively less-significant segments,
	///   and
	/// - its [`tail`] element contains the least significant segment of the
	///   returned value, in the bits at the most significant edge of the
	///   element.
	///
	/// If the domain is an [`Enclave`], then the referent element is merely
	/// loaded, shifted, and masked; no recombination of segments is necessary.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut data = [0u8; 3];
	/// data.view_bits_mut::<Msb0>()[5 .. 21].store_be::<u16>(
	///   0b110_1011_1100_0100_1
	/// //  KLM NOPQ RSTU VWXY Z
	/// );
	/// assert_eq!(data, [
	///   0b00000_110, 0b1011_1100, 0b0100_1_000
	/// //        KLM    NOPQ RSTU    VWXY Z
	/// ]);
	/// let val = data.view_bits::<Msb0>()[5 .. 21].load_be::<u16>();
	/// assert_eq!(
	///   val,
	///   0b110_1011_1100_0100_1,
	/// //  KLM NOPQ RSTU VWXY Z
	/// );
	/// ```
	///
	/// [`Domain::Region`]: crate::domain::Domain::Region
	/// [`Enclave`]: crate::domain::Domain::Enclave
	/// [`body`]: crate::domain::Domain::Region::body
	/// [`head`]: crate::domain::Domain::Region::head
	/// [`self.domain()`]: crate::slice::BitSlice::domain
	/// [`tail`]: crate::domain::Domain::Region::tail
	fn load_be<M>(&self) -> M
	where M: BitMemory {
		check::<M>("load", self.len());

		match self.domain() {
			Domain::Enclave { head, elem, tail } => get::<T, M>(
				elem,
				Msb0::mask(head, tail),
				<T::Mem as IsNumber>::BITS as u8 - tail.into_inner(),
			),
			Domain::Region { head, body, tail } => {
				let mut accum = M::ZERO;

				if let Some((head, elem)) = head {
					accum = get::<T, M>(elem, Msb0::mask(head, None), 0);
				}

				for elem in body.iter().map(BitStore::load_value) {
					if M::BITS > <T::Mem as IsNumber>::BITS {
						accum <<= <T::Mem as IsNumber>::BITS;
					}
					accum |= resize::<T::Mem, M>(elem);
				}

				if let Some((elem, tail)) = tail {
					let shamt = tail.into_inner();
					if M::BITS as u8 > shamt {
						accum <<= shamt;
					}
					else {
						accum = M::ZERO;
					}
					accum |= get::<T, M>(
						elem,
						Msb0::mask(None, tail),
						<T::Mem as IsNumber>::BITS as u8 - shamt,
					);
				}

				accum
			},
		}
	}

	/// Stores into `self`, using little-endian element ordering if `self` spans
	/// more than one `T` element.
	///
	/// If [`self.domain()`] produces a [`Domain::Region`], then:
	///
	/// - its [`head`] element receives the least significant segment of
	///   `value`, in the bits at the least significant edge of the element,
	/// - its [`body`] slice receives successively more-significant segments of
	///   `value`, and
	/// - its [`tail`] element receives the most significant segment of `value`,
	///   in the bits at the most significant edge of the element.
	///
	/// If the domain is an [`Enclave`], then `value` is shifted into place and
	/// written without any segmentation.
	///
	/// # Examples
	///
	/// See the documentation for `<BitSlice<Msb0, u8> as BitField>::load_le`.
	///
	/// [`Domain::Region`]: crate::domain::Domain::Region
	/// [`Enclave`]: crate::domain::Domain::Enclave
	/// [`head`]: crate::domain::Domain::Region::head
	/// [`body`]: crate::domain::Domain::Region::body
	/// [`self.domain()`]: crate::slice::BitSlice::domain
	/// [`tail`]: crate::domain::Domain::Region::tail
	fn store_le<M>(&mut self, mut value: M)
	where M: BitMemory {
		check::<M>("store", self.len());

		match self.domain_mut() {
			DomainMut::Enclave { head, elem, tail } => set::<T, M>(
				elem,
				value,
				Msb0::mask(head, tail),
				<T::Mem as IsNumber>::BITS as u8 - tail.into_inner(),
			),
			DomainMut::Region { head, body, tail } => {
				if let Some((head, elem)) = head {
					set::<T, M>(elem, value, Msb0::mask(head, None), 0);
					let shamt =
						<T::Mem as IsNumber>::BITS as u8 - head.into_inner();
					if M::BITS as u8 > shamt {
						value >>= shamt;
					}
					else {
						value = M::ZERO;
					}
				}

				for elem in body.iter_mut() {
					elem.store_value(resize(value));
					if M::BITS > <T::Mem as IsNumber>::BITS {
						value >>= <T::Mem as IsNumber>::BITS;
					}
				}

				if let Some((elem, tail)) = tail {
					set::<T, M>(
						elem,
						value,
						Msb0::mask(None, tail),
						<T::Mem as IsNumber>::BITS as u8 - tail.into_inner(),
					);
				}
			},
		}
	}

	/// Stores into `self`, using big-endian element ordering if `self` spans
	/// more than one `T` element.
	///
	/// If [`self.domain()`] produces a [`Domain::Region`], then:
	///
	/// - its [`head`] element receives the most significant segment of `value`,
	///   in the bits at the least significant edge of the element,
	/// - its [`body`] slice receives successively less-significant segments of
	///   `value`, and
	/// - its [`tail`] element receives the least significant segment of
	///   `value`, in the bits at the most significant edge of the element.
	///
	/// If the domain is an [`Enclave`], then `value` is shifted into place and
	/// written without any segmentation.
	///
	/// # Examples
	///
	/// See the documentation for `<BitSlice<Lsb0, u8> as BitField>::load_be`.
	///
	/// [`Domain::Region`]: crate::domain::Domain::Region
	/// [`Enclave`]: crate::domain::Domain::Enclave
	/// [`head`]: crate::domain::Domain::Region::head
	/// [`body`]: crate::domain::Domain::Region::body
	/// [`self.domain()`]: crate::slice::BitSlice::domain
	/// [`tail`]: crate::domain::Domain::Region::tail
	fn store_be<M>(&mut self, mut value: M)
	where M: BitMemory {
		check::<M>("store", self.len());

		match self.domain_mut() {
			DomainMut::Enclave { head, elem, tail } => set::<T, M>(
				elem,
				value,
				Msb0::mask(head, tail),
				<T::Mem as IsNumber>::BITS as u8 - tail.into_inner(),
			),
			DomainMut::Region { head, body, tail } => {
				if let Some((elem, tail)) = tail {
					set::<T, M>(
						elem,
						value,
						Msb0::mask(None, tail),
						<T::Mem as IsNumber>::BITS as u8 - tail.into_inner(),
					);
					if M::BITS as u8 > tail.into_inner() {
						value >>= tail.into_inner();
					}
					else {
						value = M::ZERO;
					}
				}

				for elem in body.iter_mut().rev() {
					elem.store_value(resize(value));
					if M::BITS > <T::Mem as IsNumber>::BITS {
						value >>= <T::Mem as IsNumber>::BITS;
					}
				}

				if let Some((head, elem)) = head {
					set::<T, M>(elem, value, Msb0::mask(head, None), 0);
				}
			},
		}
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, V> BitField for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized,
	BitSlice<O, V::Store>: BitField,
{
	#[inline(always)]
	fn load_le<M>(&self) -> M
	where M: BitMemory {
		self.as_bitslice().load_le()
	}

	#[inline(always)]
	fn load_be<M>(&self) -> M
	where M: BitMemory {
		self.as_bitslice().load_be()
	}

	#[inline(always)]
	fn store_le<M>(&mut self, value: M)
	where M: BitMemory {
		self.as_mut_bitslice().store_le(value)
	}

	#[inline(always)]
	fn store_be<M>(&mut self, value: M)
	where M: BitMemory {
		self.as_mut_bitslice().store_be(value)
	}
}

#[cfg(feature = "alloc")]
#[cfg(not(tarpaulin_include))]
impl<O, T> BitField for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
	BitSlice<O, T>: BitField,
{
	#[inline(always)]
	fn load_le<M>(&self) -> M
	where M: BitMemory {
		self.as_bitslice().load_le()
	}

	#[inline(always)]
	fn load_be<M>(&self) -> M
	where M: BitMemory {
		self.as_bitslice().load_be()
	}

	#[inline(always)]
	fn store_le<M>(&mut self, value: M)
	where M: BitMemory {
		self.as_mut_bitslice().store_le(value)
	}

	#[inline(always)]
	fn store_be<M>(&mut self, value: M)
	where M: BitMemory {
		self.as_mut_bitslice().store_be(value)
	}
}

#[cfg(feature = "alloc")]
#[cfg(not(tarpaulin_include))]
impl<O, T> BitField for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
	BitSlice<O, T>: BitField,
{
	#[inline(always)]
	fn load_le<M>(&self) -> M
	where M: BitMemory {
		self.as_bitslice().load_le()
	}

	#[inline(always)]
	fn load_be<M>(&self) -> M
	where M: BitMemory {
		self.as_bitslice().load_be()
	}

	#[inline(always)]
	fn store_le<M>(&mut self, value: M)
	where M: BitMemory {
		self.as_mut_bitslice().store_le(value)
	}

	#[inline(always)]
	fn store_be<M>(&mut self, value: M)
	where M: BitMemory {
		self.as_mut_bitslice().store_be(value)
	}
}

/// Asserts that a slice length is within a memory element width.
///
/// # Panics
///
/// This panics if len is 0, or wider than [`M::BITS`].
///
/// [`M::BITS`]: funty::IsNumber::BITS
#[inline]
fn check<M>(action: &'static str, len: usize)
where M: BitMemory {
	if !(1 ..= M::BITS as usize).contains(&len) {
		panic!(
			"Cannot {} {} bits from a {}-bit region",
			action,
			M::BITS,
			len,
		);
	}
}

/** Reads a value out of a section of a memory element.

This function is used to extract a portion of an `M` value from a portion of a
`T` value. The [`BitField`] implementations call it as they assemble a complete
`M`. It performs the following steps:

1. the referent value of the `elem` pointer is copied into local memory,
2. `mask`ed to discard the portions of `*elem` that are not live,
3. shifted to the LSedge of the [`T::Mem`] temporary,
4. then `resize`d into an `M` value.

This is the exact inverse of `set`.

# Type Parameters

- `T`: The [`BitStore`] type of a [`BitSlice`] that is the source of a read
  event.
- `M`: The local type of the data contained in that [`BitSlice`].

# Parameters

- `elem`: An aliased reference to a single element of a [`BitSlice`] storage.
  This is required to remain aliased, as other write-capable references to the
  location may exist.
- `mask`: A [`BitMask`] of the live region of the value at `*elem` to be used as
  the contents of the returned value.
- `shamt`: The distance of the least significant bit of the mask region from the
  least significant edge of the [`T::Mem`] fetched value.

# Returns

`resize((*elem & mask) >> shamt)`

[`BitField`]: crate::field::BitField
[`BitMask`]: crate::index::BitMask
[`BitSlice`]: crate::slice::BitSlice
[`BitStore`]: crate::store::BitStore
[`T::Mem`]: crate::store::BitStore::Mem
**/
//  The trait resolution system fails here, and only resolves to `<&usize>` as
//  the RHS operand.
#[inline]
#[allow(clippy::op_ref)]
fn get<T, M>(elem: &T, mask: BitMask<T::Mem>, shamt: u8) -> M
where
	T: BitStore,
	M: BitMemory,
{
	//  Read the value out of the `elem` reference
	elem.load_value()
		//  Mask it against the slot
		.pipe(|val| val & &mask.into_inner())
		//  Shift it down to the LSedge
		.pipe(|val| val >> &(shamt as usize))
		//  And resize to the expected output
		.pipe(resize::<T::Mem, M>)
}

/** Writes a value into a section of a memory element.

This function is used to emplace a portion of an `M` value into a portion of a
`T` value. The [`BitField`] implementations call it as they disassemble a
complete `M`. It performs the following steps:

1. the provided `value` is `resize`d from `M` to [`T::Mem`],
2. then shifted from the LSedge of the [`T::Mem`] temporary by `shamt`,
3. `mask`ed to discard the portions of `value` that are not live,
4. then written into the `mask`ed portion of `*elem`.

This is the exact inverse of `get`.

# Type Parameters

- `T`: The [`BitStore`] type of a [`BitSlice`] that is the sink of a write event.
- `M`: The local type of the data being written into that [`BitSlice`].

# Parameters

- `elem`: An aliased reference to a single element of a [`BitSlice`] storage.
- `value`: The value whose least-significant bits will be written into the
  subsection of `*elt` covered by `mask`.
- `mask`: A `BitMask` of the live region of the value at `*elem` to be used as
  a filter on the provided value.
- `shamt`: The distance of the least significant bit of the mask region from the
  least significant edge of the [`T::Mem`] destination value.

# Effects

`*elem &= !mask; *elem |= (resize(value) << shamt) & mask;`

[`BitField`]: crate::field::BitField
[`BitMask`]: crate::index::BitMask
[`BitSlice`]: crate::slice::BitSlice
[`BitStore`]: crate::store::BitStore
[`T::Mem`]: crate::store::BitStore::Mem
**/
#[inline]
#[allow(clippy::op_ref)]
fn set<T, M>(elem: &T::Access, value: M, mask: BitMask<T::Mem>, shamt: u8)
where
	T: BitStore,
	M: BitMemory,
{
	//  Convert the `mask` type to fit into the accessor.
	let mask = BitMask::new(mask.into_inner());
	let value = value
		//  Resize the value to the expected input
		.pipe(resize::<M, T::Mem>)
		//  Shift it up from the LSedge
		.pipe(|val| val << &(shamt as usize))
		//  And mask it to the slot
		.pipe(|val| mask & val);

	//  Erase the slot
	elem.clear_bits(mask);
	//  And write the shift/masked value into it
	elem.set_bits(value);
}

/** Resizes a value from one register width to another.

This zero-extends or truncates its source value in order to fit in the target
type.

# Type Parameters

- `T`: The initial register type of the value to resize.
- `U`: The final register type of the resized value.

# Parameters

- `value`: Any register value.

# Returns

`value`, either zero-extended if `U` is wider than `T` or truncated if `U` is
narrower than `T`.
**/
#[inline]
fn resize<T, U>(value: T) -> U
where
	T: BitMemory,
	U: BitMemory,
{
	let mut out = U::ZERO;
	let size_t = mem::size_of::<T>();
	let size_u = mem::size_of::<U>();

	unsafe {
		resize_inner::<T, U>(&value, &mut out, size_t, size_u);
	}

	out
}

/// Performs little-endian byte-order register resizing.
#[cfg_attr(not(tarpaulin_include), inline(always))]
#[cfg(target_endian = "little")]
unsafe fn resize_inner<T, U>(
	src: &T,
	dst: &mut U,
	size_t: usize,
	size_u: usize,
) {
	//  In LE, the least significant byte is the base address, so resizing is
	//  just a memcpy into a zeroed slot, taking only the smaller width.
	ptr::copy_nonoverlapping(
		src as *const T as *const u8,
		dst as *mut U as *mut u8,
		core::cmp::min(size_t, size_u),
	);
}

/// Performs big-endian byte-order register resizing.
#[cfg_attr(not(tarpaulin_include), inline(always))]
#[cfg(target_endian = "big")]
unsafe fn resize_inner<T, U>(
	src: &T,
	dst: &mut U,
	size_t: usize,
	size_u: usize,
) {
	let src = src as *const T as *const u8;
	let dst = dst as *mut U as *mut u8;

	//  In BE, shrinking a value requires moving the source base pointer up,
	if size_t > size_u {
		ptr::copy_nonoverlapping(src.add(size_t - size_u), dst, size_u);
	}
	//  While expanding a value requires moving the destination base pointer up.
	else {
		ptr::copy_nonoverlapping(src, dst.add(size_u - size_t), size_t);
	}
}

#[cfg(not(any(target_endian = "big", target_endian = "little")))]
compile_fail!(concat!(
	"This architecture is currently not supported. File an issue at ",
	env!(CARGO_PKG_REPOSITORY)
));

#[cfg(feature = "std")]
mod io;

#[cfg(test)]
mod tests;

// These tests are purely mathematical, and do not need to run more than once.
#[cfg(all(test, feature = "std", not(miri), not(tarpaulin)))]
mod permutation_tests;
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/field.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/index.rs =====
/*! Well-typed counters and register descriptors.

This module provides session types which encode a strict chain of modification
to map semantic indices within a [`BitSlice`] to the electrical register values
used to interact with the memory bus.

The main advantage of the types in this module is that they provide
register-dependent range requirements for counter values, making it impossible
to have an index out of bounds for a register. They also create a sequence of
type transformations that assure the library about the continued validity of
each value in its surrounding context.

By eliminating public constructors from arbitrary integers, [`bitvec`] can
guarantee that only it can produce seed values, and only trusted functions can
transform their numeric values or types, until the program reaches the property
that it requires. This chain of assurance means that memory operations can be
confident in the correctness of their actions and effects.

# Type Sequence

The library produces [`BitIdx`] values from region computation. These types
cannot be publicly constructed, and are only ever the result of pointer
analysis. As such, they rely on correctness of the memory regions provided to
library entry points, and those entry points can leverage the Rust type system
to ensure safety there.

[`BitIdx`] is transformed to [`BitPos`] through the [`BitOrder`] trait. The
[`order`] module provides verification functions that implementors can use to
demonstrate correctness. `BitPos` is the seed type that describes memory
operations, and is used to create selection masks [`BitSel`] and [`BitMask`].

[`BitIdx`]: crate::index::BitIdx
[`BitMask`]: crate::index::BitMask
[`BitOrder`]: crate::order::BitOrder
[`BitPos`]: crate::index::BitPos
[`BitSel`]: crate::index::BitSel
[`BitSlice`]: crate::slice::BitSlice
[`bitvec`]: crate
[`order`]: crate::order
!*/

use core::{
	any,
	convert::TryFrom,
	fmt::{
		self,
		Binary,
		Debug,
		Display,
		Formatter,
	},
	iter::{
		FusedIterator,
		Sum,
	},
	marker::PhantomData,
	ops::{
		BitAnd,
		BitOr,
		Not,
	},
};

use crate::{
	mem::BitRegister,
	order::BitOrder,
};

/** A semantic index counter within a register element `R`.

This type is a counter in the ring `0 .. R::BITS`, and serves to mark a semantic
index within some register element. It is a virtual index, and is the stored
value used in pointer encodings to track region start information.

It is translated to an electrical index through the [`BitOrder`] trait. This
virtual index is the only counter that can be used for address computation, and
once lowered to an electrical index through [`BitOrder::at`], the electrical
address can only be used for instruction selection.

# Type Parameters

- `R`: The register element that this index governs.

# Validity

Values of this type are **required** to be in the range `0 .. R::BITS`. Any
value not less than [`R::BITS`] makes the program invalid, and will likely cause
either a crash or incorrect memory access.

# Construction

This type can never be constructed outside of the [`bitvec`] crate. It is passed
in to [`BitOrder`] implementations, which may use it to construct electrical
position, selection, or mask values from it. All values of this type constructed
by [`bitvec`] are known to be correct in their region; no other construction
site can be trusted.

[`BitOrder`]: crate::order::BitOrder
[`BitOrder::at`]: crate::order::BitOrder::at
[`R::BITS`]: funty::IsNumber::BITS
[`bitvec`]: crate
**/
// #[rustc_layout_scalar_valid_range_end(R::BITS)]
#[repr(transparent)]
#[derive(Clone, Copy, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BitIdx<R>
where R: BitRegister
{
	/// Semantic index counter within a register, constrained to `0 .. R::BITS`.
	idx: u8,
	/// Marker for the register type.
	_ty: PhantomData<R>,
}

impl<R> BitIdx<R>
where R: BitRegister
{
	/// The inclusive maximum index within an element `R`.
	pub const LAST: Self = Self {
		idx: R::MASK,
		_ty: PhantomData,
	};
	/// The inclusive minimum index within an element `R`.
	pub const ZERO: Self = Self {
		idx: 0,
		_ty: PhantomData,
	};

	/// Wraps a counter value as a known-good index into an `R` register.
	///
	/// # Parameters
	///
	/// - `value`: The counter value to mark as an index. This must be not less
	///   than [`Self::ZERO`] and not more than [`Self::LAST`].
	///
	/// # Returns
	///
	/// This returns `value`, marked as either a valid or invalid index by
	/// whether or not it is within the valid range `0 .. R::BITS`.
	///
	/// [`Self::LAST`]: Self::LAST
	/// [`Self::ZERO`]: Self::ZERO
	#[inline]
	pub fn new(value: u8) -> Result<Self, BitIdxError<R>> {
		if value >= R::BITS as u8 {
			return Err(BitIdxError::new(value));
		}
		Ok(unsafe { Self::new_unchecked(value) })
	}

	/// Wraps a counter value as an assumed-good index into an `R` register.
	///
	/// # Parameters
	///
	/// - `value`: The counter value to mark as an index. This must be not less
	///   than [`Self::ZERO`] and not more than [`Self::LAST`].
	///
	/// # Returns
	///
	/// This returns `value`, marked as a valid index.
	///
	/// # Safety
	///
	/// If the `value` is outside the valid range, then the program is
	/// incorrect. Debug builds will panic; release builds do not inspect the
	/// `value`.
	///
	/// [`Self::LAST`]: Self::LAST
	/// [`Self::ZERO`]: Self::ZERO
	#[inline]
	pub unsafe fn new_unchecked(value: u8) -> Self {
		debug_assert!(
			value < R::BITS as u8,
			"Bit index {} cannot exceed type width {}",
			value,
			R::BITS,
		);
		Self {
			idx: value,
			_ty: PhantomData,
		}
	}

	/// Casts to a new index type.
	///
	/// This will always succeed if `self.into_inner()` is a valid index in the
	/// `S` register; it will return an error if the `self` index is too wide
	/// for `S`.
	#[inline]
	pub fn cast<S>(self) -> Result<BitIdx<S>, BitIdxError<S>>
	where S: BitRegister {
		BitIdx::new(self.into_inner())
	}

	/// Removes the index wrapper, leaving the internal counter.
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn into_inner(self) -> u8 {
		self.idx
	}

	/// Increments an index counter, wrapping at the back edge of the register.
	///
	/// # Parameters
	///
	/// - `self`: The index to increment.
	///
	/// # Returns
	///
	/// - `.0`: The next index after `self`.
	/// - `.1`: Indicates that the new index is in the next register.
	#[inline]
	pub fn next(self) -> (Self, bool) {
		let next = self.idx + 1;
		(
			unsafe { Self::new_unchecked(next & R::MASK) },
			next == R::BITS as u8,
		)
	}

	/// Decrements an index counter, wrapping at the front edge of the register.
	///
	/// # Parameters
	///
	/// - `self`: The index to decrement.
	///
	/// # Returns
	///
	/// - `.0`: The previous index before `self`.
	/// - `.1`: Indicates that the new index is in the previous register.
	#[inline]
	pub fn prev(self) -> (Self, bool) {
		let prev = self.idx.wrapping_sub(1);
		(
			unsafe { Self::new_unchecked(prev & R::MASK) },
			self.idx == 0,
		)
	}

	/// Computes the bit position corresponding to `self` under some ordering.
	///
	/// This forwards to [`O::at::<R>`], which is the only public, safe,
	/// constructor for a position counter.
	///
	/// [`O::at::<R>`]: crate::order::BitOrder::at
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn position<O>(self) -> BitPos<R>
	where O: BitOrder {
		O::at::<R>(self)
	}

	/// Computes the bit selector corresponding to `self` under an ordering.
	///
	/// This forwards to [`O::select::<R>`], which is the only public, safe,
	/// constructor for a bit selector.
	///
	/// [`O::select::<R>`]: crate::order::BitOrder::select
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn select<O>(self) -> BitSel<R>
	where O: BitOrder {
		O::select::<R>(self)
	}

	/// Computes the bit selector for `self` as an accessor mask.
	///
	/// This is a type-cast over [`Self::select`].
	///
	/// [`Self::select`]: Self::select
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn mask<O>(self) -> BitMask<R>
	where O: BitOrder {
		self.select::<O>().mask()
	}

	/// Iterates over all indices between an inclusive start and exclusive end
	/// point.
	///
	/// Because implementation details of the range type family, including the
	/// [`RangeBounds`] trait, are not yet stable, and heterogenous ranges are
	/// not supported, this must be an opaque iterator rather than a direct
	/// [`Range<BitIdx<R>>`].
	///
	/// # Parameters
	///
	/// - `from`: The inclusive low bound of the range. This will be the first
	///   index produced by the iterator.
	/// - `upto`: The exclusive high bound of the range. The iterator will halt
	///   before yielding an index of this value.
	///
	/// # Returns
	///
	/// An opaque iterator that is equivalent to the range `from .. upto`.
	///
	/// # Requirements
	///
	/// `from` must be no greater than `upto`.
	///
	/// [`RangeBounds`]: core::ops::RangeBounds
	/// [`Range<BitIdx<R>>`]: core::ops::Range
	#[inline]
	pub fn range(
		self,
		upto: BitTail<R>,
	) -> impl Iterator<Item = Self>
	+ DoubleEndedIterator
	+ ExactSizeIterator
	+ FusedIterator {
		let (from, upto) = (self.into_inner(), upto.into_inner());
		debug_assert!(from <= upto, "Ranges must run from low to high");
		(from .. upto).map(|val| unsafe { Self::new_unchecked(val) })
	}

	/// Iterates over all possible index values.
	#[inline]
	pub fn range_all() -> impl Iterator<Item = Self>
	+ DoubleEndedIterator
	+ ExactSizeIterator
	+ FusedIterator {
		BitIdx::ZERO.range(BitTail::LAST)
	}

	/// Computes the jump distance for some number of bits away from a starting
	/// index.
	///
	/// This computes the number of elements by which to adjust a base pointer,
	/// and then the bit index of the destination bit in the new referent
	/// register element.
	///
	/// # Parameters
	///
	/// - `self`: An index within some element, from which the offset is
	///   computed.
	/// - `by`: The distance by which to jump. Negative values move lower in the
	///   index and element-pointer space; positive values move higher.
	///
	/// # Returns
	///
	/// - `.0`: The number of elements `R` by which to adjust a base pointer.
	///   This value can be passed directly into [`ptr::offset`].
	/// - `.1`: The index of the destination bit within the destination element.
	///
	/// [`ptr::offset`]: https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.offset
	pub fn offset(self, by: isize) -> (isize, Self) {
		let val = self.into_inner();

		/* Signed-add `val` to the jump distance. This will almost certainly not
		overflow (as the crate imposes restrictions well below `isize::MAX`),
		but correctness never hurts. The resulting sum is a bit index (`far`)
		and an overflow marker. Overflow only occurs when a negative `far` is
		the result of a positive `by`, and so `far` must instead be interpreted
		as an unsigned integer.

		`far` is permitted to be negative when `ovf` does not trigger, as `by`
		may be a negative value.

		The number line has its 0 at the front edge of the implicit current
		address, with -1 in index R::MASK at one element address less than the
		implicit current address.
		*/
		let (far, ovf) = by.overflowing_add(val as isize);
		//  If the `isize` addition does not overflow, then the sum can be used
		//  directly.
		if !ovf {
			//  If `far` is in the origin element, then the jump moves zero
			//  elements and produces `far` as an absolute index directly.
			if (0 .. R::BITS as isize).contains(&far) {
				(0, unsafe { Self::new_unchecked(far as u8) })
			}
			/* Otherwise, downshift the bit distance to compute the number of
			elements moved in either direction, and mask to compute the absolute
			bit index in the destination element.
			*/
			else {
				(far >> R::INDX, unsafe {
					Self::new_unchecked(far as u8 & R::MASK)
				})
			}
		}
		else {
			/* Overflowing `isize` addition happens to produce ordinary `usize`
			addition. In point of fact, `isize` addition and `usize` addition
			are the same machine instruction to perform the sum; it is merely
			the signed interpretation of the sum that differs. The sum can be
			recast back to `usize` without issue.
			*/
			let far = far as usize;
			//  This is really only needed in order to prevent sign-extension of
			//  the downshift; once shifted, the value can be safely re-signed.
			((far >> R::INDX) as isize, unsafe {
				Self::new_unchecked(far as u8 & R::MASK)
			})
		}
	}

	/// Computes the span information for a region beginning at `self` for `len`
	/// bits.
	///
	/// The span information is the number of elements in the region that hold
	/// live bits, and the position of the tail marker after the live bits.
	///
	/// This forwards to [`BitTail::span`], as the computation is identical for
	/// the two types. Beginning a span at any `Idx` is equivalent to beginning
	/// it at the tail of a previous span.
	///
	/// # Parameters
	///
	/// - `self`: The start bit of the span.
	/// - `len`: The number of bits in the span.
	///
	/// # Returns
	///
	/// - `.0`: The number of elements, starting in the element that contains
	///   `self`, that contain live bits of the span.
	/// - `.1`: The tail counter of the span’s end point.
	///
	/// [`BitTail::span`]: crate::index::BitTail::span
	#[inline]
	pub fn span(self, len: usize) -> (usize, BitTail<R>) {
		unsafe { BitTail::<R>::new_unchecked(self.into_inner()) }.span(len)
	}
}

#[cfg(not(tarpaulin_include))]
impl<R> TryFrom<u8> for BitIdx<R>
where R: BitRegister
{
	type Error = BitIdxError<R>;

	#[inline(always)]
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		Self::new(value)
	}
}

#[cfg(not(tarpaulin_include))]
impl<R> Binary for BitIdx<R>
where R: BitRegister
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		write!(fmt, "{:0>1$b}", self.idx, R::INDX as usize)
	}
}

#[cfg(not(tarpaulin_include))]
impl<R> Debug for BitIdx<R>
where R: BitRegister
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		write!(fmt, "BitIdx<{}>({})", any::type_name::<R>(), self)
	}
}

#[cfg(not(tarpaulin_include))]
impl<R> Display for BitIdx<R>
where R: BitRegister
{
	#[inline(always)]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		Binary::fmt(&self, fmt)
	}
}

/// Marks an index that is invalid for a register type.
#[repr(transparent)]
#[derive(Clone, Copy, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BitIdxError<R>
where R: BitRegister
{
	/// The value that is invalid as a [`BitIdx<R>`].
	///
	/// [`BitIdx<R>`]: crate::index::BitIdx
	err: u8,
	/// Marker for the register type.
	_ty: PhantomData<R>,
}

impl<R> BitIdxError<R>
where R: BitRegister
{
	/// Marks a counter value as invalid to be an index for an `R` register.
	///
	/// # Parameters
	///
	/// - `value`: The counter value to mark as an error. This must be greater
	///   than [`BitIdx::<R>::LAST`].
	///
	/// # Returns
	///
	/// This returns `value`, marked as an invalid index for `R`.
	///
	/// # Panics
	///
	/// Debug builds panic when `value` is a valid index for `R`.
	#[inline]
	pub(crate) fn new(value: u8) -> Self {
		debug_assert!(
			value >= R::BITS as u8,
			"Bit index {} is valid for type width {}",
			value,
			R::BITS
		);
		Self {
			err: value,
			_ty: PhantomData,
		}
	}

	/// Removes the error wrapper, leaving the internal counter.
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn into_inner(self) -> u8 {
		self.err
	}
}

#[cfg(not(tarpaulin_include))]
impl<R> Debug for BitIdxError<R>
where R: BitRegister
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		write!(fmt, "BitIdxErr<{}>({})", any::type_name::<R>(), self.err)
	}
}

#[cfg(not(tarpaulin_include))]
impl<R> Display for BitIdxError<R>
where R: BitRegister
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		write!(
			fmt,
			"The value {} is too large to index into {} ({} bits)",
			self.err,
			any::type_name::<R>(),
			R::BITS
		)
	}
}

#[cfg(feature = "std")]
impl<R> std::error::Error for BitIdxError<R> where R: BitRegister
{
}

/** A semantic index counter within *or one bit past the end of* a register
element `R`.

This type is a counter in the ring `0 ..= R::BITS`, and serves to mark a
semantic index of a dead bit *after* a live region. As such, following in the
C++ and LLVM memory model of first-live/first-dead region descriptiors, it marks
an endpoint outside some bit-region, and may be used to compute the startpoint
of a bit-region immediately succeeding, but not overlapping, the source.

As a dead-bit index, this *cannot* be used for indexing into a register. It is
used only in abstract region computation.

This type is necessary in order to preserve the distinction between a dead
memory address that is *not* part of a buffer and a live memory address that is
within a region. [`BitIdx`] is insufficient to this task, and causes buffer
management errors when used in its stead.

# Type Parameters

- `R`: The register element that this end index governs.

# Validity

Values of this type are **required** to be in the range `0 ..= R::BITS`. Any
value greater than [`R::BITS`] makes the program invalid, and will likely cause
either a crash or incorrect memory access.

# Construction

This type can only be publicly constructed through [`BitIdx::span`].

[`BitIdx`]: crate::index::BitIdx
[`R::BITS`]: funty::IsNumber::BITS
**/
#[repr(transparent)]
#[derive(Clone, Copy, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BitTail<R>
where R: BitRegister
{
	/// Semantic tail counter within or after a register, contained to `0 ..=
	/// R::BITS`.
	end: u8,
	/// Marker for the register type.
	_ty: PhantomData<R>,
}

impl<R> BitTail<R>
where R: BitRegister
{
	/// The inclusive maximum tail within an element `R`.
	pub const LAST: Self = Self {
		end: R::BITS as u8,
		_ty: PhantomData,
	};
	/// The inclusive minimum tail within an element `R`.
	pub const ZERO: Self = Self {
		end: 0,
		_ty: PhantomData,
	};

	/// Wraps a counter value as a known-good tail of an `R` register.
	///
	/// # Parameters
	///
	/// - `value`: The counter value to mark as a tail. This must be not less
	///   than [`Self::ZERO`] and not more than [`Self::LAST`].
	///
	/// # Returns
	///
	/// This returns `Some(value)` when it is in the valid range `0 .. R::BITS`,
	/// and `None` when it is not.
	///
	/// [`Self::LAST`]: Self::LAST
	/// [`Self::ZERO`]: Self::ZERO
	#[inline]
	pub fn new(value: u8) -> Option<Self> {
		if value > R::BITS as u8 {
			return None;
		}
		Some(unsafe { Self::new_unchecked(value) })
	}

	/// Wraps a counter value as an assumed-good tail of an `R` register.
	///
	/// # Parameters
	///
	/// - `value`: The counter value to mark as a tail. This must be not less
	///   than [`Self::ZERO` and not more than [`Self::LAST`].
	///
	/// # Returns
	///
	/// This returns `value`, marked as a valid tail.
	///
	/// # Safety
	///
	/// If the `value` is outside the valid range, then the program is
	/// incorrect. Debug builds will panic; release builds do not inspect the
	/// `value`.
	///
	/// [`Self::LAST`]: Self::LAST
	/// [`Self::ZERO`]: Self::ZERO
	#[inline]
	pub(crate) unsafe fn new_unchecked(value: u8) -> Self {
		debug_assert!(
			value <= R::BITS as u8,
			"Bit tail {} cannot exceed type width {}",
			value,
			R::BITS,
		);
		Self {
			end: value,
			_ty: PhantomData,
		}
	}

	/// Removes the tail wrapper, leaving the internal counter.
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn into_inner(self) -> u8 {
		self.end
	}

	/// Iterates over all tail indices at and after an inclusive starting point.
	///
	/// Because implementation details of the range type family, including the
	/// [`RangeBounds`] trait, are not yet stable, and heterogenous ranges are
	/// not yet supported, this must be an opaque iterator rather than a direct
	/// [`Range<BitTail<R>>`].
	///
	/// # Parameters
	///
	/// - `from`: The inclusive low bound of the range. This will be the first
	///   tail produced by the iterator.
	///
	/// # Returns
	///
	/// An opaque iterator that is equivalent to the range `from ..=
	/// Self::LAST`.
	///
	/// [`RangeBounds`]: core::ops::RangeBounds
	/// [`Range<BitTail<R>>`]: core::ops::Range
	#[inline]
	pub fn range_from(
		from: BitIdx<R>,
	) -> impl Iterator<Item = Self>
	+ DoubleEndedIterator
	+ ExactSizeIterator
	+ FusedIterator {
		(from.idx ..= Self::LAST.end)
			.map(|tail| unsafe { BitTail::new_unchecked(tail) })
	}

	/// Computes the span information for a region beginning immediately after a
	/// preceding region.
	///
	/// The computed region of `len` bits has its start at the *live* bit that
	/// corresponds to the `self` dead tail. The return value is the number of
	/// memory elements containing live bits of the computed span and its tail
	/// marker.
	///
	/// # Parameters
	///
	/// - `self`: A dead bit immediately after some region.
	/// - `len`: The number of live bits in the span starting after `self`.
	///
	/// # Returns
	///
	/// - `.0`: The number of elements `R` that contain live bits in the
	///   computed region.
	/// - `.1`: The tail counter of the first dead bit after the new span.
	///
	/// # Behavior
	///
	/// If `len` is `0`, this returns `(0, self)`, as the span has no live bits.
	/// If `self` is [`BitTail::LAST`], then the new region starts at
	/// [`BitIdx::ZERO`] in the next element.
	///
	/// [`BitIdx::ZERO`]: crate::index::BitIdx::ZERO
	/// [`BitTail::LAST`]: crate::index::BitTail::LAST
	pub fn span(self, len: usize) -> (usize, Self) {
		if len == 0 {
			return (0, self);
		}

		let val = self.end;

		let head = val & R::MASK;
		let bits_in_head = (R::BITS as u8 - head) as usize;

		if len <= bits_in_head {
			return (1, unsafe { Self::new_unchecked(head + len as u8) });
		}

		let bits_after_head = len - bits_in_head;
		let elts = bits_after_head >> R::INDX;
		let tail = bits_after_head as u8 & R::MASK;

		let is_zero = (tail == 0) as u8;
		let edges = 2 - is_zero as usize;
		(elts + edges, unsafe {
			Self::new_unchecked((is_zero << R::INDX) | tail)
		})
	}
}

#[cfg(not(tarpaulin_include))]
impl<R> Binary for BitTail<R>
where R: BitRegister
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		write!(fmt, "{:0>1$b}", self.end, R::INDX as usize + 1)
	}
}

#[cfg(not(tarpaulin_include))]
impl<R> Debug for BitTail<R>
where R: BitRegister
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		write!(fmt, "BitTail<{}>({})", any::type_name::<R>(), self)
	}
}

#[cfg(not(tarpaulin_include))]
impl<R> Display for BitTail<R>
where R: BitRegister
{
	#[inline(always)]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		Binary::fmt(&self, fmt)
	}
}

/** An electrical position counter within a register element `R`.

This type is a counter in the ring `0 .. R::BITS`, and serves to mark an
electrical address of a real bit. It is the shift distance in the expression
`1 << n`. It is only produced by applying a [`BitOrder::at`] transformation to
some [`BitIdx`] produced by this library.

# Type Parameters

- `R`: The register element that this position governs.

# Validity

Values of this type are **required** to be in the range `0 .. R::BITS`. Any
value not less than [`R::BITS`] makes the program invalid, and will likely cause
a crash. In addition, [`BitOrder::at`] has a list of requirements that its
implementations must uphold in order to make construction of this type
semantically correct in a program.

# Construction

This type is publicly constructible. [`bitvec`] will only request its creation
by calling [`BitOrder::at`], and has no sites that can publicly accept untrusted
values.

[`BitIdx`]: crate::index::BitIdx
[`BitOrder::at`]: crate::order::BitOrder::at
[`R::BITS`]: funty::IsNumber::BITS
**/
// #[rustc_layout_scalar_valid_range_end(R::BITS)]
#[repr(transparent)]
#[derive(Clone, Copy, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BitPos<R>
where R: BitRegister
{
	/// Electrical position counter within a register, constrained to `0 ..
	/// R::BITS`.
	pos: u8,
	/// Marker for the register type.
	_ty: PhantomData<R>,
}

impl<R> BitPos<R>
where R: BitRegister
{
	/// Wraps a counter value as a known-good position within an `R` register.
	///
	/// # Parameters
	///
	/// - `value`: The counter value to mark as a position. This must be in the
	///   range `0 .. R::BITS`.
	///
	/// # Returns
	///
	/// This returns `Some(value)` when it is in the valid range `0 .. R::BITS`,
	/// and `None` when it is not.
	#[inline]
	pub fn new(value: u8) -> Option<Self> {
		if value >= R::BITS as u8 {
			return None;
		}
		Some(unsafe { Self::new_unchecked(value) })
	}

	/// Wraps a counter value as an assumed-good position within an `R`
	/// register.
	///
	/// # Parameters
	///
	/// - `value`: The counter value to mark as a position. This must be in the
	///   range `0 .. R::BITS`.
	///
	/// # Returns
	///
	/// This returns `value`, marked as a valid position.
	///
	/// # Safety
	///
	/// If the `value` is outside the valid range, then the program is
	/// incorrect. Debug builds will panic; release builds do not inspect the
	/// `value`.
	#[inline]
	pub unsafe fn new_unchecked(value: u8) -> Self {
		debug_assert!(
			value < R::BITS as u8,
			"Bit position {} cannot exceed type width {}",
			value,
			R::BITS,
		);
		Self {
			pos: value,
			_ty: PhantomData,
		}
	}

	/// Removes the position wrapper, leaving the internal counter.
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn into_inner(self) -> u8 {
		self.pos
	}

	/// Computes the bit selector corresponding to `self`.
	///
	/// This is always `1 << self.pos`.
	#[inline(always)]
	pub fn select(self) -> BitSel<R> {
		unsafe { BitSel::new_unchecked(R::ONE << self.pos) }
	}

	/// Computes the bit selector for `self` as an accessor mask.
	///
	/// This is a type-cast over [`Self::select`].
	///
	/// [`Self::select`]: Self::select
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn mask(self) -> BitMask<R> {
		self.select().mask()
	}

	/// Iterates over all possible position values.
	#[inline]
	pub(crate) fn range_all() -> impl Iterator<Item = Self>
	+ DoubleEndedIterator
	+ ExactSizeIterator
	+ FusedIterator {
		BitIdx::<R>::range_all()
			.map(|idx| unsafe { Self::new_unchecked(idx.into_inner()) })
	}
}

#[cfg(not(tarpaulin_include))]
impl<R> Binary for BitPos<R>
where R: BitRegister
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		write!(fmt, "{:0>1$b}", self.pos, R::INDX as usize)
	}
}

#[cfg(not(tarpaulin_include))]
impl<R> Debug for BitPos<R>
where R: BitRegister
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		write!(fmt, "BitPos<{}>({})", any::type_name::<R>(), self)
	}
}

#[cfg(not(tarpaulin_include))]
impl<R> Display for BitPos<R>
where R: BitRegister
{
	#[inline(always)]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		Binary::fmt(&self, fmt)
	}
}

/** A one-hot selection mask for a register element `R`.

This type selects exactly one bit in a register. It is used to apply test and
write operations into memory.

# Type Parameters

- `R`: The register element this selector governs.

# Validity

Values of this type are required to have exactly one bit set high, and all
others set low.

# Construction

This type is only constructed from the [`BitPos::select`] and
[`BitOrder::select`] functions. It is always equivalent to
`1 << BitPos::unwrap`.

The chain of custody, from known-good [`BitIdx`] values, through proven-good
[`BitOrder`] implementations, into [`BitPos`] and then `BitSel`, proves that
values of this type are always correct to apply to underlying memory.

[`BitIdx`]: crate::index::BitIdx
[`BitOrder`]: crate::order::BitOrder
[`BitOrder::select`]: crate::order::BitOrder::select
[`BitPos`]: crate::index::BitPos
[`BitPos::select`]: crate::index::BitPos::select
**/
// #[rustc_layout_scalar_valid_range_end(R::BITS)]
#[repr(transparent)]
#[derive(Clone, Copy, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BitSel<R>
where R: BitRegister
{
	/// The one-hot selector mask.
	sel: R,
}

impl<R> BitSel<R>
where R: BitRegister
{
	/// Wraps a counter value as a known-good selection of an `R` register.
	///
	/// # Parameters
	///
	/// - `value`: A one-hot selection mask of a bit in an `R` register.
	///
	/// # Returns
	///
	/// If `value` is a power of two (exactly one bit set high and all others
	/// set low), it returns `Some` of a `BitSel` wrapping the `value`.
	///
	/// [`BitOrder::at`]: crate:order::BitOrder::at
	/// [`BitOrder::select`]: crate::order::BitOrder::select
	/// [`BitPos`]: crate::index::BitPos
	#[inline]
	pub fn new(value: R) -> Option<Self> {
		if value.count_ones() != 1 {
			return None;
		}
		Some(unsafe { Self::new_unchecked(value) })
	}

	/// Wraps a counter value as an assumed-good selection of an `R` register.
	///
	/// # Parameters
	///
	/// - `value`: A one-hot selection mask of a bit in an `R` register.
	///
	/// # Returns
	///
	/// `value` wrapped in a `BitSel`.
	///
	/// # Safety
	///
	/// `value` **must** be a power of two: one bit set high and all others set
	/// low. In debug builds, invalid `value`s cause a panic; release builds do
	/// not check the input.
	///
	/// This function must only be called in a [`BitOrder::select`]
	/// implementation that is verified to be correct.
	///
	/// [`BitOrder::select`]: crate::order::BitOrder::select
	#[inline]
	pub unsafe fn new_unchecked(value: R) -> Self {
		debug_assert!(
			value.count_ones() == 1,
			"Selections are required to have exactly one set bit: {:0>1$b}",
			value,
			R::BITS as usize,
		);
		Self { sel: value }
	}

	/// Removes the selector wrapper, leaving the internal counter.
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn into_inner(self) -> R {
		self.sel
	}

	/// Computes a bit-mask for `self`. This is a type-cast.
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn mask(self) -> BitMask<R> {
		BitMask::new(self.sel)
	}

	/// Iterates over all possible selector values.
	#[inline]
	pub fn range_all() -> impl Iterator<Item = Self>
	+ DoubleEndedIterator
	+ ExactSizeIterator
	+ FusedIterator {
		BitPos::<R>::range_all().map(BitPos::select)
	}
}

#[cfg(not(tarpaulin_include))]
impl<R> Binary for BitSel<R>
where R: BitRegister
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		write!(fmt, "{:0>1$b}", self.sel, R::BITS as usize)
	}
}

#[cfg(not(tarpaulin_include))]
impl<R> Debug for BitSel<R>
where R: BitRegister
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		write!(fmt, "BitSel<{}>({})", any::type_name::<R>(), self)
	}
}

#[cfg(not(tarpaulin_include))]
impl<R> Display for BitSel<R>
where R: BitRegister
{
	#[inline(always)]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		Binary::fmt(&self, fmt)
	}
}

/** A multi-bit selection mask for a register `R`.

Unlike [`BitSel`], which enforces a strict one-hot mask encoding, this mask type
permits any number of bits to be set or unset. This is used to accumulate
selections for a batched operation on a register.

# Type Parameters

- `R`: The register element that this masks.

# Construction

This can only be constructed by combining [`BitSel`] selection mask produced
through the [`BitIdx`] and [`BitOrder`] chain of custody.

[`BitIdx`]: crate::index::BitIdx
[`BitOrder`]: crate::order::BitOrder
[`BitSel`]: crate::index::BitSel
**/
#[repr(transparent)]
#[derive(Clone, Copy, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BitMask<R>
where R: BitRegister
{
	/// A mask of any number of bits to select.
	mask: R,
}

impl<R> BitMask<R>
where R: BitRegister
{
	/// A full mask.
	pub const ALL: Self = Self { mask: R::ALL };
	/// An empty mask.
	pub const ZERO: Self = Self { mask: R::ZERO };

	/// Wraps any `R` value as a bit-mask.
	///
	/// This constructor is provided to explicitly declare that an operation is
	/// discarding the numeric value of an integer and instead using it only as
	/// a bit-mask.
	///
	/// # Parameters
	///
	/// - `value`: Some integer to use as a bit-mask.
	///
	/// # Returns
	///
	/// The `value` wrapped as a bit-mask, with its numeric context discarded.
	///
	/// Prefer accumulating [`BitSel`] values using the `Sum` implementation.
	///
	/// # Safety
	///
	/// The `value` must be computed from a set of valid bit positions in the
	/// caller’s context.
	///
	/// [`BitOrder::mask`]: crate::order::BitOrder::mask
	/// [`BitSel`]: crate::index::BitSel
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn new(value: R) -> Self {
		Self { mask: value }
	}

	/// Removes the mask wrapper, leaving the internal value.
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn into_inner(self) -> R {
		self.mask
	}

	/// Tests whether the mask contains a given selector bit.
	///
	/// # Parameters
	///
	/// - `&self`
	/// - `sel`: Some single selection bit to test in `self`.
	///
	/// # Returns
	///
	/// Whether `self` is set high at `sel`.
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn test(&self, sel: BitSel<R>) -> bool {
		self.mask & sel.sel != R::ZERO
	}

	/// Inserts a selector bit into an existing mask.
	///
	/// # Parameters
	///
	/// - `&mut self`
	/// - `sel`: A selector bit to set in `self`.
	///
	/// # Effects
	///
	/// The bit at `sel` is set high in `self`.
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn insert(&mut self, sel: BitSel<R>) {
		self.mask |= sel.sel;
	}

	/// Creates a new mask with a selector bit activated.
	///
	/// # Parameters
	///
	/// - `self`
	/// - `sel`: A selector bit to set in `self`
	///
	/// # Returns
	///
	/// A copy of `self`, with `sel` set high.
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn combine(self, sel: BitSel<R>) -> Self {
		Self {
			mask: self.mask | sel.sel,
		}
	}
}

#[cfg(not(tarpaulin_include))]
impl<R> Binary for BitMask<R>
where R: BitRegister
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		write!(fmt, "{:0>1$b}", self.mask, R::BITS as usize)
	}
}

#[cfg(not(tarpaulin_include))]
impl<R> Debug for BitMask<R>
where R: BitRegister
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		write!(fmt, "BitMask<{}>({})", any::type_name::<R>(), self)
	}
}

#[cfg(not(tarpaulin_include))]
impl<R> Display for BitMask<R>
where R: BitRegister
{
	#[inline(always)]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		Binary::fmt(&self, fmt)
	}
}

#[cfg(not(tarpaulin_include))]
impl<R> Sum<BitSel<R>> for BitMask<R>
where R: BitRegister
{
	#[inline]
	fn sum<I>(iter: I) -> Self
	where I: Iterator<Item = BitSel<R>> {
		iter.fold(Self::ZERO, Self::combine)
	}
}

#[cfg(not(tarpaulin_include))]
impl<R> BitAnd<R> for BitMask<R>
where R: BitRegister
{
	type Output = Self;

	#[inline]
	fn bitand(self, rhs: R) -> Self::Output {
		Self {
			mask: self.mask & rhs,
		}
	}
}

#[cfg(not(tarpaulin_include))]
impl<R> BitOr<R> for BitMask<R>
where R: BitRegister
{
	type Output = Self;

	#[inline]
	fn bitor(self, rhs: R) -> Self::Output {
		Self {
			mask: self.mask | rhs,
		}
	}
}

#[cfg(not(tarpaulin_include))]
impl<R> Not for BitMask<R>
where R: BitRegister
{
	type Output = Self;

	#[inline]
	fn not(self) -> Self::Output {
		Self { mask: !self.mask }
	}
}

#[cfg(test)]
mod tests {
	use tap::conv::TryConv;

	use super::*;
	use crate::order::Lsb0;

	#[test]
	fn index_ctors() {
		for n in 0 .. 8 {
			assert!(BitIdx::<u8>::new(n).is_ok());
			assert!(n.try_conv::<BitIdx<u8>>().is_ok());
		}
		assert!(BitIdx::<u8>::new(8).is_err());
		assert!(8u8.try_conv::<BitIdx<u8>>().is_err());
		for n in 0 .. 16 {
			assert!(BitIdx::<u16>::new(n).is_ok());
		}
		assert!(BitIdx::<u16>::new(16).is_err());
		for n in 0 .. 32 {
			assert!(BitIdx::<u32>::new(n).is_ok());
		}
		assert!(BitIdx::<u32>::new(32).is_err());

		#[cfg(target_pointer_width = "64")]
		{
			for n in 0 .. 64 {
				assert!(BitIdx::<u64>::new(n).is_ok());
			}
			assert!(BitIdx::<u64>::new(64).is_err());
		}

		if cfg!(target_pointer_width = "32") {
			for n in 0 .. 32 {
				assert!(BitIdx::<usize>::new(n).is_ok());
			}
			assert!(BitIdx::<usize>::new(32).is_err());
		}
		else if cfg!(target_pointer_width = "64") {
			for n in 0 .. 64 {
				assert!(BitIdx::<usize>::new(n).is_ok());
			}
			assert!(BitIdx::<usize>::new(64).is_err());
		}
	}

	#[test]
	fn tail_ctors() {
		for n in 0 ..= 8 {
			assert!(BitTail::<u8>::new(n).is_some());
		}
		assert!(BitTail::<u8>::new(9).is_none());
		for n in 0 ..= 16 {
			assert!(BitTail::<u16>::new(n).is_some());
		}
		assert!(BitTail::<u16>::new(17).is_none());
		for n in 0 ..= 32 {
			assert!(BitTail::<u32>::new(n).is_some());
		}
		assert!(BitTail::<u32>::new(33).is_none());

		#[cfg(target_pointer_width = "64")]
		{
			for n in 0 ..= 64 {
				assert!(BitTail::<u64>::new(n).is_some());
			}
			assert!(BitTail::<u64>::new(65).is_none());
		}

		if cfg!(target_pointer_width = "32") {
			for n in 0 ..= 32 {
				assert!(BitTail::<usize>::new(n).is_some());
			}
			assert!(BitTail::<usize>::new(33).is_none());
		}
		else if cfg!(target_pointer_width = "64") {
			for n in 0 ..= 64 {
				assert!(BitTail::<usize>::new(n).is_some());
			}
			assert!(BitTail::<usize>::new(65).is_none());
		}
	}

	#[test]
	fn position_ctors() {
		for n in 0 .. 8 {
			assert!(BitPos::<u8>::new(n).is_some());
		}
		assert!(BitPos::<u8>::new(8).is_none());
		for n in 0 .. 16 {
			assert!(BitPos::<u16>::new(n).is_some());
		}
		assert!(BitPos::<u16>::new(16).is_none());
		for n in 0 .. 32 {
			assert!(BitPos::<u32>::new(n).is_some());
		}
		assert!(BitPos::<u32>::new(32).is_none());

		#[cfg(target_pointer_width = "64")]
		{
			for n in 0 .. 64 {
				assert!(BitPos::<u64>::new(n).is_some());
			}
			assert!(BitPos::<u64>::new(64).is_none());
		}

		if cfg!(target_pointer_width = "32") {
			for n in 0 .. 32 {
				assert!(BitPos::<usize>::new(n).is_some());
			}
			assert!(BitPos::<usize>::new(32).is_none());
		}
		else if cfg!(target_pointer_width = "64") {
			for n in 0 .. 64 {
				assert!(BitPos::<usize>::new(n).is_some());
			}
			assert!(BitPos::<usize>::new(64).is_none());
		}
	}

	#[test]
	fn select_ctors() {
		for n in 0 .. 8 {
			assert!(BitSel::<u8>::new(1 << n).is_some());
		}
		assert!(BitSel::<u8>::new(3).is_none());
		for n in 0 .. 16 {
			assert!(BitSel::<u16>::new(1 << n).is_some());
		}
		assert!(BitSel::<u16>::new(3).is_none());
		for n in 0 .. 32 {
			assert!(BitSel::<u32>::new(1 << n).is_some());
		}
		assert!(BitSel::<u32>::new(3).is_none());

		#[cfg(target_pointer_width = "64")]
		{
			for n in 0 .. 64 {
				assert!(BitSel::<u64>::new(1 << n).is_some());
			}
			assert!(BitSel::<u64>::new(3).is_none());
		}

		if cfg!(target_pointer_width = "32") {
			for n in 0 .. 32 {
				assert!(BitSel::<usize>::new(1 << n).is_some());
			}
			assert!(BitSel::<usize>::new(3).is_none());
		}
		else if cfg!(target_pointer_width = "64") {
			for n in 0 .. 64 {
				assert!(BitSel::<usize>::new(1 << n).is_some());
			}
			assert!(BitSel::<usize>::new(3).is_none());
		}
	}

	#[test]
	fn ranges() {
		let mut range = BitIdx::<u16>::range_all();
		assert_eq!(range.next(), BitIdx::new(0).ok());
		assert_eq!(range.next_back(), BitIdx::new(15).ok());
		assert_eq!(range.count(), 14);

		let mut range = BitTail::<u8>::range_from(BitIdx::new(1).unwrap());
		assert_eq!(range.next(), BitTail::new(1));
		assert_eq!(range.next_back(), BitTail::new(8));
		assert_eq!(range.count(), 6);

		let mut range = BitPos::<u8>::range_all();
		assert_eq!(range.next(), BitPos::new(0));
		assert_eq!(range.next_back(), BitPos::new(7));
		assert_eq!(range.count(), 6);

		let mut range = BitSel::<u8>::range_all();
		assert_eq!(range.next(), BitSel::new(1));
		assert_eq!(range.next_back(), BitSel::new(128));
		assert_eq!(range.count(), 6);
	}

	#[test]
	fn index_cycle() {
		let six = BitIdx::<u8>::new(6).unwrap();
		let (seven, step) = six.next();
		assert_eq!(seven, BitIdx::new(7).unwrap());
		assert!(!step);
		let (zero, step) = seven.next();
		assert_eq!(zero, BitIdx::ZERO);
		assert!(step);
		let (seven, step) = zero.prev();
		assert_eq!(seven, BitIdx::new(7).unwrap());
		assert!(step);
		let (six, step) = seven.prev();
		assert_eq!(six, BitIdx::new(6).unwrap());
		assert!(!step);

		let fourteen = BitIdx::<u16>::new(14).unwrap();
		let (fifteen, step) = fourteen.next();
		assert_eq!(fifteen, BitIdx::new(15).unwrap());
		assert!(!step);
		let (zero, step) = fifteen.next();
		assert_eq!(zero, BitIdx::ZERO);
		assert!(step);
		let (fifteen, step) = zero.prev();
		assert_eq!(fifteen, BitIdx::new(15).unwrap());
		assert!(step);
		let (fourteen, step) = fifteen.prev();
		assert_eq!(fourteen, BitIdx::new(14).unwrap());
		assert!(!step);
	}

	#[test]
	fn jumps() {
		let (jump, head) = BitIdx::<u8>::new(1).unwrap().offset(2);
		assert_eq!(jump, 0);
		assert_eq!(head, BitIdx::new(3).unwrap());

		let (jump, head) = BitIdx::<u8>::LAST.offset(1);
		assert_eq!(jump, 1);
		assert_eq!(head, BitIdx::ZERO);

		let (jump, head) = BitIdx::<u16>::new(10).unwrap().offset(40);
		// 10 is in 0..16; 10+40 is in 48..64
		assert_eq!(jump, 3);
		assert_eq!(head, BitIdx::new(2).unwrap());

		let (jump, head) = BitIdx::<u8>::LAST.offset(isize::MAX);
		assert_eq!(jump, ((isize::MAX as usize + 1) >> 3) as isize);
		assert_eq!(head, BitIdx::LAST.prev().0);

		let (elts, tail) = BitIdx::<u8>::new(4).unwrap().span(0);
		assert_eq!(elts, 0);
		assert_eq!(tail, BitTail::new(4).unwrap());

		let (elts, tail) = BitIdx::<u8>::new(3).unwrap().span(3);
		assert_eq!(elts, 1);
		assert_eq!(tail, BitTail::new(6).unwrap());

		let (elts, tail) = BitIdx::<u16>::new(10).unwrap().span(40);
		assert_eq!(elts, 4);
		assert_eq!(tail, BitTail::new(2).unwrap());
	}

	#[test]
	fn mask_operators() {
		let mut mask = BitIdx::<u8>::new(2)
			.unwrap()
			.range(BitTail::new(5).unwrap())
			.map(BitIdx::select::<Lsb0>)
			.sum::<BitMask<u8>>();
		assert_eq!(mask, BitMask::new(28));
		assert_eq!(mask & 25, BitMask::new(24));
		assert_eq!(mask | 32, BitMask::new(60));
		assert_eq!(!mask, BitMask::new(!28));
		let yes = BitSel::<u8>::new(16).unwrap();
		let no = BitSel::<u8>::new(64).unwrap();
		assert!(mask.test(yes));
		assert!(!mask.test(no));
		mask.insert(no);
		assert!(mask.test(no));
	}

	#[test]
	#[cfg(feature = "alloc")]
	fn render() {
		#[cfg(not(feature = "std"))]
		use alloc::format;

		use crate::order::Msb0;

		assert_eq!(format!("{:?}", BitIdx::<u8>::LAST), "BitIdx<u8>(111)");
		assert_eq!(format!("{:?}", BitIdx::<u16>::LAST), "BitIdx<u16>(1111)");
		assert_eq!(format!("{:?}", BitIdx::<u32>::LAST), "BitIdx<u32>(11111)");

		assert_eq!(
			format!("{:?}", BitIdx::<u8>::new(8).unwrap_err()),
			"BitIdxErr<u8>(8)",
		);
		assert_eq!(
			format!("{:?}", BitIdx::<u16>::new(16).unwrap_err()),
			"BitIdxErr<u16>(16)",
		);
		assert_eq!(
			format!("{:?}", BitIdx::<u32>::new(32).unwrap_err()),
			"BitIdxErr<u32>(32)",
		);

		assert_eq!(format!("{:?}", BitTail::<u8>::LAST), "BitTail<u8>(1000)");
		assert_eq!(format!("{:?}", BitTail::<u16>::LAST), "BitTail<u16>(10000)");
		assert_eq!(
			format!("{:?}", BitTail::<u32>::LAST),
			"BitTail<u32>(100000)",
		);

		assert_eq!(
			format!("{:?}", BitIdx::<u8>::LAST.position::<Msb0>()),
			"BitPos<u8>(000)",
		);
		assert_eq!(
			format!("{:?}", BitIdx::<u16>::LAST.position::<Lsb0>()),
			"BitPos<u16>(1111)",
		);
		assert_eq!(
			format!("{:?}", BitIdx::<u32>::LAST.position::<Msb0>()),
			"BitPos<u32>(00000)",
		);

		assert_eq!(
			format!("{:?}", BitIdx::<u8>::LAST.select::<Msb0>()),
			"BitSel<u8>(00000001)",
		);
		assert_eq!(
			format!("{:?}", BitIdx::<u16>::LAST.select::<Lsb0>()),
			"BitSel<u16>(1000000000000000)",
		);
		assert_eq!(
			format!("{:?}", BitIdx::<u32>::LAST.select::<Msb0>()),
			"BitSel<u32>(00000000000000000000000000000001)",
		);

		assert_eq!(
			format!("{:?}", BitMask::<u8>::new(1 | 4 | 32)),
			"BitMask<u8>(00100101)",
		);
		assert_eq!(
			format!("{:?}", BitMask::<u16>::new(1 | 4 | 32)),
			"BitMask<u16>(0000000000100101)",
		);
		assert_eq!(
			format!("{:?}", BitMask::<u32>::new(1 | 4 | 32)),
			"BitMask<u32>(00000000000000000000000000100101)",
		);

		#[cfg(target_pointer_width = "64")]
		{
			assert_eq!(
				format!("{:?}", BitIdx::<u64>::LAST),
				"BitIdx<u64>(111111)",
			);
			assert_eq!(
				format!("{:?}", BitIdx::<u64>::new(64).unwrap_err()),
				"BitIdxErr<u64>(64)",
			);
			assert_eq!(
				format!("{:?}", BitTail::<u64>::LAST),
				"BitTail<u64>(1000000)",
			);
			assert_eq!(
				format!("{:?}", BitIdx::<u64>::LAST.position::<Lsb0>()),
				"BitPos<u64>(111111)",
			);
			assert_eq!(
				format!("{:?}",BitIdx::<u64>::LAST.select::<Lsb0>()),
				"BitSel<u64>(1000000000000000000000000000000000000000000000000000000000000000)",
			);
			assert_eq!(
				format!("{:?}", BitMask::<u64>::new(1 | 4 | 32)),
				"BitMask<u64>(0000000000000000000000000000000000000000000000000000000000100101)",
			);
		}
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/index.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/lib.rs =====
/*! # `bitvec` — Addressable Bits

`bitvec` provides the foundation tools needed to implement truly single-bit
`bool` collections and arbitrary bit-precision addressing. It builds compact
collections and performant [bitfield] regions with a high-level, expressive, API
that compiles down to the simple machine instructions you would expect.

# Examples

The [`examples/`] directory of the project repository contains some programs
that showcase different `bitvec` features and use cases. In addition, each data
structure’s API documentation contains more focused samples.

To begin using `bitvec`, you need only import its [prelude]. Once in scope,
`bitvec` can take over existing memory buffers or create entirely new values:

```rust
use bitvec::prelude::*;

let data = &[0u8, 1, 2, 3];
let data_bits = data.view_bits::<Msb0>();

let literal_bits = bits![Lsb0, u16; 1, 0, 1, 1];
assert_eq!(literal_bits.as_raw_slice()[0], 0b1101);

let array_bool = bitarr![1; 40];
# #[cfg(feature = "alloc")] {
let boxed_bool = bitbox![Lsb0, u32; 1; 50];
let vec_bool = bitvec![Msb0, usize; 1; 60];
# }
```

The two easiest entry points into `bitvec` are through the [`BitView`] trait,
which provides extension methods on ordinary memory to view it as a
[`BitSlice`], and the [macro] constructors, which convert token strings into
appropriate buffers at compile time. Each data structure also has its own
constructor functions that create new buffers or borrow existing values.

Once in use, `bitvec`’s types obey all the same patterns and APIs that you have
come to expect from their analogues in the [`core`], [`alloc`], and [`std`]
libraries.

# Usage

`bitvec` provides data structures that specialize the major sequence types in
the standard libraries:

- `[bool]` becomes [`BitSlice`]
- `[bool; N]` becomes [`BitArray`]
- `Box<[bool]>` becomes [`BitBox`]
- `Vec<bool>` becomes [`BitVec`]

You can start using the crate in an existing codebase by replacing types and
chasing compiler errors from there.

As an example,

```rust
# #[cfg(feature = "alloc")] {
let mut io_buf: Vec<u8> = Vec::new();
io_buf.extend(&[0x47, 0xA5]);

let stats: Vec<bool> = vec![
  true, false, true, true,
  false, false, true, false,
];
# }
```

would become

```rust
# #[cfg(feature = "alloc")] {
use bitvec::prelude::*;

let mut io_buf: BitVec<Msb0, u8> = BitVec::new();
io_buf.resize(16, false);
io_buf[.. 4].store(4u8);
io_buf[4 .. 8].store(7u8);
io_buf[8 .. 16].store(0xA5u8);

let stats: BitVec = bitvec![
  1, 0, 1, 1,
  0, 0, 1, 0,
];
# }
```

## Type Arguments

The `bitvec` data structures are all generic over two type parameters which
control how they view and manage the memory they use. These type parameters
allow users to precisely control the memory layout, value bit-patterns, and
generated instructions, but most users of the library will not need to be
generic over them. Instead, you probably either do not care about the details of
the underlying memory, or you have a specific and fixed layout requirement. In
either case, you will likely select a specific combination of type arguments and
use it consistently throughout your project.

You *can* write your project to be generic over these type arguments, and this
is certainly useful when writing code that is not coupled directly to memory,
increases complexity with little practical gain.

The default type arguments are chosen for optimal behavior in memory use and
instruction selection. The unadorned types [`BitArray`], [`BitSlice`],
[`BitBox`], and [`BitVec`] can all be used in type-annotation position (`let`
bindings, `struct` fields, and function arguments). Users who need to specify
their type arguments should prefer to do so in a `type` alias, and use that
alias throughout their project instead of the much longer fully-qualified
`bitvec` type names:

```rust
use bitvec::prelude::*;

pub type MySlice = BitSlice<Msb0, u8>;
pub type MyArray20 = BitArr!(for 20, in Msb0, u8);
# #[cfg(feature = "alloc")]
pub type MyVec = BitVec<Msb0, u8>;

fn make_buffer() -> MyVec {
  MyVec::new()
}
```

In general, you will probably work with [`BitSlice`] borrows and [`BitVec`]
owned buffers. The [`BitArray`] and [`BitBox`] types are provided for
completeness and have their uses, but the additional constraints and frozen size
render them less commonly useful.

## Additional Details

As a replacement for `bool` sequences, you should be able to replace old type
definition and value construction sites with their corresponding items from this
project, and the rest of your project should just work with the new types.

To use `bitvec` for structural [bitfields] or specialized I/O protocol buffers,
you should use [`BitArray`] or [`BitVec`] to manage your data buffers (for
compile-time statically-sized and run-time dynamically-sized, respectively), and
the [`BitField`] trait to manage transferring values into and out of them.

The [`BitSlice`] type contains most of the behavior that interacts with the
*contents* of a memory buffer. [`BitVec`] adds behavior that operates on
allocations, and specializes [`BitSlice`] behaviors that can take advantage of
owned buffers.

The [`domain`] module, whose types are accessed by the `.{bit_,}domain{,_mut}`
methods on [`BitSlice`], allows users to split their views of memory at aliasing
boundaries. This removes synchronization guards where `bitvec` can prove that
doing so is legal and correct.

There are many ways to construct a bit-level view of data. The [`BitArray`],
[`BitBox`], and [`BitVec`] types all own a buffer of memory and dereference it
to [`BitSlice`] in order to view it. In addition, you can borrow any piece of
ordinary Rust memory as a `BitSlice` view by using its borrowing constructor
functions or the [`BitView`] trait’s extension methods.

# Capabilities

`bitvec` stands out from other bit-sequence libraries, both in Rust and in other
languages, in a few significant ways.

Unlike other Rust libraries, `bitvec` stores its region information in
specially-encoded pointers *to* memory regions, rather than in the region
itself. By using its own pointer encoding scheme, `bitvec` can use references
(`&BitSlice<_, _>` and `&mut BitSlice<_, _>`) to manage memory accesses and fit
seamlessly into the Rust language rules and API signatures.

Unlike *any* other bit-sequence system, `bitvec` enables users to specify both
the register element type used to store data and also the ordering of bits
within each register element. This sidesteps the problems found in C
[bitfields], C++ [`std::bitset`] and [`std::vector<bool>`], Python’s
[`bitstring`], Erlang’s [`bitstream`], and other Rust libraries such as
[`bit-vec`].

By permitting the in-memory layout to be specified by the user, rather than
hard-coding it within the library, `bitvec` enables users to select the behavior
characteristics they want or need without significant effort on their part.

This works by supplying two type parameters: an `O` [`BitOrder`] ordering of
bits within a register element, and a `T` [`BitStore`] register element used for
storage and memory description. `T` is restricted to be only the raw unsigned
integers, and [`bitvec`-provided wrappers][`BitSafe`] over [atomic] and [`Cell`]
synchronization guards, that fit within processor registers on your target.

These parameters permit the `bitvec` type system to track memory access rules
and bit addressing, thus enabling a nearly seamless use of [`BitSlice`]s as if
they were ordinary Rust slices.

`bitvec` correctly handles memory aliasing by leveraging the type system to mark
regions that have become subject to shared mutability. This mark can, depending
on your build settings, either forbid moving such slices across threads, or
issue lock instructions to the memory bus when accessing memory. You will never
need to add your own guards to prevent race conditions, and [`BitSlice`]
provides interfaces to separate any bit-slice into its aliased and unaliased
subslices.

Where possible, `bitvec` uses its knowledge of bit ordering and memory
availability to accelerate memory operations from individual bit-by-bit walks to
batched operations within a register. This is an area of ongoing development,
and is an implementation detail rather than an aspect of public API.

`bitvec`’s performance even when working with individual bits is as close to
ideal as a general-purpose library can be, but the width of processor registers
means that no amount of performance improvement at the individual bit level can
compete with instructions operating on 32 or 64 bits at once. If you encounter
performance bottlenecks, you can escape `bitvec`’s views to operate on the
memory directly, or submit an issue for future work on specialized batch
parallelization.

# Project Structure

You should generally import the library [prelude], with

```rust
use bitvec::prelude::*;
```

The prelude contains the basic symbols you will need to make use of the crate:
the names of data structures, ordering parameters, useful traits, and
constructor macros. Almost all symbols begin with the prefix `Bit`; only the
orderings [`Lsb0`], [`Msb0`], and [`LocalBits`] do not. This will reduce the
likelihood of name collisions.

Each major component in the library is divided into its own module. This
includes each data structure and trait, as well as utility objects used for
implementation. The data structures that mirror the language distribution have
submodules for each part of their mirroring: `api` ports inherent methods,
`iter` contains iteration logic, `ops` overrides operator sigils, and `traits`
holds all other trait implementations. The data structure’s own module typically
only contains its own definition and its inherent methods that are not ports of
the standard libraries.

[atomic]: core::sync::atomic
[bitfield]: https://en.cppreference.com/w/c/language/bit_field
[bitfields]: https://en.cppreference.com/w/c/language/bit_field
[macro]: #macros
[prelude]: crate::prelude

[`BitArray`]: crate::array::BitArray
[`BitBox`]: crate::boxed::BitBox
[`BitField`]: crate::field::BitField
[`BitOrder`]: crate::order::BitOrder
[`BitSafe`]: crate::access::BitSafe
[`BitSlice`]: crate::slice::BitSlice
[`BitStore`]: crate::store::BitStore
[`BitVec`]: crate::vec::BitVec
[`BitView`]: crate::view::BitView
[`Cell`]: core::cell::Cell
[`LocalBits`]: crate::order::LocalBits
[`Lsb0`]: crate::order::Lsb0
[`Msb0`]: crate::order::Msb0

[`alloc`]: alloc
[`bitstream`]: https://erlang.org/doc/programming_examples/bit_syntax.html
[`bitstring`]: https://pypi.org/project/bitstring/
[`bit-vec`]: https://crates.io/crates/bit-vec
[`core`]: core
[`domain`]: crate::domain
[`examples/`]: https://github.com/myrrlyn/bitvec/tree/HEAD/examples
[`std`]: std
[`std::bitset`]: https://en.cppreference.com/w/cpp/utility/bitset
[`std::vector<bool>`]: https://en.cppreference.com/w/cpp/container/vector_bool
!*/

#![cfg_attr(not(feature = "std"), no_std)]
#![cfg_attr(debug_assertions, warn(missing_docs))]
#![cfg_attr(not(debug_assertions), deny(missing_docs))]
#![deny(unconditional_recursion)]
//  Clippy controls applicable in ordinary code.
#![allow(
	clippy::single_char_add_str, // Bypass UTF-8 encoding.
)]
//  Clippy controls only applicable in #[cfg(test)] testing modules.
#![cfg_attr(test, allow(
	clippy::many_single_char_names, // Tests do not need descriptive bind names.
	clippy::redundant_clone, // Does not matter in tests.
	clippy::unusual_byte_groupings, // Literals are for region patterns.
))]

#[cfg(feature = "alloc")]
extern crate alloc;

#[macro_use]
pub mod macros;

pub mod access;
pub mod array;
mod devel;
pub mod domain;
pub mod field;
pub mod index;
pub mod mem;
pub mod order;
pub mod prelude;
pub mod ptr;
pub mod slice;
pub mod store;
pub mod view;

#[cfg(feature = "alloc")]
pub mod boxed;

#[cfg(feature = "alloc")]
pub mod vec;

#[cfg(feature = "serde")]
mod serdes;
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/macros/internal.rs =====
/*! Internal implementation macros for the public exports.

The macros in this module are required to be exported from the crate, as the
public macros will call them from client contexts (`macro_rules!` expansion
bodies are not in source crate scope, as they are token expansion rather than
symbolic calls). However, they are not part of the public *API* of the crate,
and are not intended for use anywhere but in the expansion bodies of the
public-API constructor macros.
!*/

#![doc(hidden)]

#[doc(hidden)]
pub use core;

#[doc(hidden)]
pub use funty;

/** Encodes a sequence of bits into an array of `BitStore` types.

This is able to encode a bitstream into any of the fundamental integers, their
atomics, and their cells. It always produces an array of the requested type,
even if the array is one element long.
**/
#[doc(hidden)]
#[macro_export]
macro_rules! __encode_bits {
	//  Capture the `BitStore` storage arguments literally. The macro cannot
	//  accept unknown typenames, as it must use them to chunk the bitstream.

	($ord:tt, u8; $($val:expr),*) => {
		$crate::__encode_bits!($ord, u8 as u8; $($val),*)
	};
	($ord:tt, Cell<u8>; $($val:expr),*) => {
		$crate::__encode_bits!($ord, Cell<u8> as u8; $($val),*)
	};
	($ord:tt, AtomicU8; $($val:expr),*) => {
		$crate::__encode_bits!($ord, AtomicU8 as u8; $($val),*)
	};

	($ord:tt, u16; $($val:expr),*) => {
		$crate::__encode_bits!($ord, u16 as u16; $($val),*)
	};
	($ord:tt, Cell<u16>; $($val:expr),*) => {
		$crate::__encode_bits!($ord, Cell<u16> as u16; $($val),*)
	};
	($ord:tt, AtomicU16; $($val:expr),*) => {
		$crate::__encode_bits!($ord, AtomicU16 as u16; $($val),*)
	};

	($ord:tt, u32; $($val:expr),*) => {
		$crate::__encode_bits!($ord, u32 as u32; $($val),*)
	};
	($ord:tt, Cell<u32>; $($val:expr),*) => {
		$crate::__encode_bits!($ord, Cell<u32> as u32; $($val),*)
	};
	($ord:tt, AtomicU32; $($val:expr),*) => {
		$crate::__encode_bits!($ord, AtomicU32 as u32; $($val),*)
	};

	($ord:tt, u64; $($val:expr),*) => {
		$crate::__encode_bits!($ord, u64 as u64; $($val),*)
	};
	($ord:tt, Cell<u64>; $($val:expr),*) => {
		$crate::__encode_bits!($ord, Cell<u64> as u64; $($val),*)
	};
	($ord:tt, AtomicU64; $($val:expr),*) => {
		$crate::__encode_bits!($ord, AtomicU64 as u64; $($val),*)
	};

	($ord:tt, usize; $($val:expr),*) => {
		$crate::__encode_bits!($ord, usize as usize; $($val),*)
	};
	($ord:tt, Cell<usize>; $($val:expr),*) => {
		$crate::__encode_bits!($ord, Cell<usize> as usize; $($val),*)
	};
	($ord:tt, AtomicUsize; $($val:expr),*) => {
		$crate::__encode_bits!($ord, AtomicUsize as usize; $($val),*)
	};

	//  Capture `$typ as usize`, and forward them to the correct known-width
	//  integer for construction.
	($ord:tt, $typ:ty as usize; $($val:expr),*) => {{
		const LEN: usize = $crate::__count_elts!(usize; $($val),*);

		#[cfg(target_pointer_width = "32")]
		let out: [$typ; LEN] = $crate::__encode_bits!(
			$ord, $typ as u32 as usize; $($val),*
		);

		#[cfg(target_pointer_width = "64")]
		let out: [$typ; LEN] = $crate::__encode_bits!(
			$ord, $typ as u64 as usize; $($val),*
		);

		out
	}};

	/* All matchers above forward to this matcher, which then forwards to those
	below.

	This block extends the bitstream with 64 `0` literals, ensuring that *any*
	provided bitstream can fit into the chunking matchers for subdivision.
	*/
	($ord:tt, $typ:ty as $uint:ident $(as $usz:ident)?; $($val:expr),*) => {
		$crate::__encode_bits!(
			$ord, $typ as $uint $(as $usz)?, []; $($val,)*
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 32
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 48
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 64
		)
	};

	/* This block is the last invoked. It requires a sequence of chunked element
	candidates (the `$bit` tokens are actually an opaque sequence of bit
	expressions), followed by literal `0` tokens. Tokens provided by the caller
	are already opaque; only the zeros created in the previous arm are visible.

	As such, this enters only when the caller-provided bit tokens are exhausted.

	Once entered, this matcher converts each tuple of bit expressions into the
	requested storage type, and collects them into an array. This array is the
	return value of the originally-called macro.
	*/
	(
		$ord:tt,
		$typ:ty as $uint:ident $(as usize)?,
		[$( ( $($bit:tt),* ) )*]; $(0,)*
	) => {
		[$($crate::__make_elem!(
			$ord,
			$typ as $uint;
			$($bit),*
		)),*]
	};

	/* These matchers chunk a stream of bit expressions into storage elements.

	On each entry, one element’s worth of bit tokens are pulled from the front
	of the stream (possibly including the literal `0` tokens provided above) and
	appended to the accumulator array as a n-tuple of bit expressions. This
	process continues until no more caller-provided bitstream tokens remain, at
	which point recursion traps in the above matchers, terminating the chunking
	and proceeding to element construction.
	*/
	(
		$ord:tt, $typ:tt as u8, [$( $elem:tt )*];
		$a0:tt, $b0:tt, $c0:tt, $d0:tt, $e0:tt, $f0:tt, $g0:tt, $h0:tt,
		$($t:tt)*
	) => {
		$crate::__encode_bits!(
			$ord, $typ as u8, [$($elem)* (
				$a0, $b0, $c0, $d0, $e0, $f0, $g0, $h0
			)]; $($t)*
		)
	};

	(
		$ord:tt, $typ:tt as u16, [$( $elem:tt )*];
		$a0:tt, $b0:tt, $c0:tt, $d0:tt, $e0:tt, $f0:tt, $g0:tt, $h0:tt,
		$a1:tt, $b1:tt, $c1:tt, $d1:tt, $e1:tt, $f1:tt, $g1:tt, $h1:tt,
		$($t:tt)*
	) => {
		$crate::__encode_bits!(
			$ord, $typ as u16, [$($elem)* (
				$a0, $b0, $c0, $d0, $e0, $f0, $g0, $h0,
				$a1, $b1, $c1, $d1, $e1, $f1, $g1, $h1
			)]; $($t)*
		)
	};

	(
		$ord:tt, $typ:tt as u32 $(as $usz:ident)?, [$( $elem:tt )*];
		$a0:tt, $b0:tt, $c0:tt, $d0:tt, $e0:tt, $f0:tt, $g0:tt, $h0:tt,
		$a1:tt, $b1:tt, $c1:tt, $d1:tt, $e1:tt, $f1:tt, $g1:tt, $h1:tt,
		$a2:tt, $b2:tt, $c2:tt, $d2:tt, $e2:tt, $f2:tt, $g2:tt, $h2:tt,
		$a3:tt, $b3:tt, $c3:tt, $d3:tt, $e3:tt, $f3:tt, $g3:tt, $h3:tt,
		$($t:tt)*
	) => {
		$crate::__encode_bits!(
			$ord, $typ as u32 $(as $usz)?, [$($elem)* (
				$a0, $b0, $c0, $d0, $e0, $f0, $g0, $h0,
				$a1, $b1, $c1, $d1, $e1, $f1, $g1, $h1,
				$a2, $b2, $c2, $d2, $e2, $f2, $g2, $h2,
				$a3, $b3, $c3, $d3, $e3, $f3, $g3, $h3
			)]; $($t)*
		)
	};

	(
		$ord:tt, $typ:tt as u64 $(as $usz:ident)?, [$( $elem:tt )*];
		$a0:tt, $b0:tt, $c0:tt, $d0:tt, $e0:tt, $f0:tt, $g0:tt, $h0:tt,
		$a1:tt, $b1:tt, $c1:tt, $d1:tt, $e1:tt, $f1:tt, $g1:tt, $h1:tt,
		$a2:tt, $b2:tt, $c2:tt, $d2:tt, $e2:tt, $f2:tt, $g2:tt, $h2:tt,
		$a3:tt, $b3:tt, $c3:tt, $d3:tt, $e3:tt, $f3:tt, $g3:tt, $h3:tt,
		$a4:tt, $b4:tt, $c4:tt, $d4:tt, $e4:tt, $f4:tt, $g4:tt, $h4:tt,
		$a5:tt, $b5:tt, $c5:tt, $d5:tt, $e5:tt, $f5:tt, $g5:tt, $h5:tt,
		$a6:tt, $b6:tt, $c6:tt, $d6:tt, $e6:tt, $f6:tt, $g6:tt, $h6:tt,
		$a7:tt, $b7:tt, $c7:tt, $d7:tt, $e7:tt, $f7:tt, $g7:tt, $h7:tt,
		$($t:tt)*
	) => {
		$crate::__encode_bits!(
			$ord, $typ as u64 $(as $usz)?, [$($elem)* (
				$a0, $b0, $c0, $d0, $e0, $f0, $g0, $h0,
				$a1, $b1, $c1, $d1, $e1, $f1, $g1, $h1,
				$a2, $b2, $c2, $d2, $e2, $f2, $g2, $h2,
				$a3, $b3, $c3, $d3, $e3, $f3, $g3, $h3,
				$a4, $b4, $c4, $d4, $e4, $f4, $g4, $h4,
				$a5, $b5, $c5, $d5, $e5, $f5, $g5, $h5,
				$a6, $b6, $c6, $d6, $e6, $f6, $g6, $h6,
				$a7, $b7, $c7, $d7, $e7, $f7, $g7, $h7
			)]; $($t)*
		)
	};
}

/// Counts the number of repetitions inside a `$()*` sequence.
#[doc(hidden)]
#[macro_export]
macro_rules! __count {
	(@ $val:expr) => { 1 };
	($($val:expr),*) => {{
		/* Clippy warns that `.. EXPR + 1`, for any value of `EXPR`, should be
		replaced with `..= EXPR`. This means that `.. $crate::__count!` raises
		the lint, causing `bits![(val,)…]` to have an unfixable lint warning.
		By binding to a `const`, then returning the `const`, this syntax
		construction is avoided as macros only expand to
		`.. { const LEN = …; LEN }` rather than `.. 0 (+ 1)…`.
		*/
		const LEN: usize = 0usize $(+ $crate::__count!(@ $val))*;
		LEN
	}};
}

/// Counts the number of elements needed to store a number of bits.
#[doc(hidden)]
#[macro_export]
macro_rules! __count_elts {
	($t:ty; $($val:expr),*) => {{
		$crate::mem::elts::<$t>($crate::__count!($($val),*))
	}};
}

/** Constructs a `T: BitStore` element from a byte-chunked sequence of bits.

# Arguments

- one of `Lsb0`, `Msb0`, `LocalBits`, or some path to a `BitOrder` implementor:
  the ordering parameter to use. Token matching against the three named
  orderings allows immediate work; unknown tokens invoke their trait
  implementation.
- `$typ` as `$uint`: Any `BitStore` implementor and its `::Mem` type.
- A sequence of any number of `(`, eight expressions, then `)`. These cluster
  bits into bytes, bytes into `$uint`, and then `$uint` into `$typ`.

# Returns

Exactly one `$typ`, whose bit-pattern is set to the provided sequence according
to the provided ordering.

# Safety

This uses `mem::transmute` internally, and so must be invoked within a
caller-provided `unsafe` block. It does not use its own `unsafe` block in order
to avoid a compiler warning about nested blocks.
**/
#[doc(hidden)]
#[macro_export]
macro_rules! __make_elem {
	//  Token-matching ordering names can use specialized work.
	(Lsb0, $typ:ty as $uint:ident; $(
		$a:expr, $b:expr, $c:expr, $d:expr,
		$e:expr, $f:expr, $g:expr, $h:expr
	),*) => { unsafe {
		use $crate::macros::internal::core;
		const ELEM: $uint = $crate::__ty_from_bytes!(
			Lsb0, $uint, [$($crate::macros::internal::u8_from_le_bits(
				$a != 0, $b != 0, $c != 0, $d != 0,
				$e != 0, $f != 0, $g != 0, $h != 0,
			)),*]
		);
		core::mem::transmute::<$uint, $typ>(ELEM)
	} };
	(Msb0, $typ:ty as $uint:ident; $(
		$a:expr, $b:expr, $c:expr, $d:expr,
		$e:expr, $f:expr, $g:expr, $h:expr
	),*) => { unsafe {
		use $crate::macros::internal::core;
		const ELEM: $uint = $crate::__ty_from_bytes!(
			Msb0, $uint, [$($crate::macros::internal::u8_from_be_bits(
				$a != 0, $b != 0, $c != 0, $d != 0,
				$e != 0, $f != 0, $g != 0, $h != 0,
			)),*]
		);
		core::mem::transmute::<$uint, $typ>(ELEM)
	} };
	(LocalBits, $typ:ty as $uint:ident; $(
		$a:expr, $b:expr, $c:expr, $d:expr,
		$e:expr, $f:expr, $g:expr, $h:expr
	),*) => { unsafe {
		use $crate::macros::internal::core;
		const ELEM: $uint = $crate::__ty_from_bytes!(
			LocalBits, $uint, [$($crate::macros::internal::u8_from_ne_bits(
				$a != 0, $b != 0, $c != 0, $d != 0,
				$e != 0, $f != 0, $g != 0, $h != 0,
			)),*]
		);
		core::mem::transmute::<$uint, $typ>(ELEM)
	} };
	//  Otherwise, invoke `BitOrder` for each bit and accumulate.
	($ord:tt, $typ:ty as $uint:ident; $($bit:expr),* $(,)?) => { unsafe {
		use $crate::macros::internal::core;
		let mut tmp: $uint = 0;
		let _bits = $crate::slice::BitSlice::<$ord, $uint>::from_element_mut(
			&mut tmp
		);
		let mut _idx = 0;
		$( _bits.set(_idx, $bit != 0); _idx += 1; )*
		core::mem::transmute::<$uint, $typ>(tmp)
	} };
}

/** Extend a single bit to fill an element.

# Parameters

- `$val`: An integer expression to be tested as non-zero.
- `$typ`: Some opaque type expression.

# Returns

`$val != 0`, as `<$typ as BitStore>::Mem`.
**/
#[doc(hidden)]
#[macro_export]
macro_rules! __extend_bool {
	($val:expr, $typ:tt) => {{
		type Mem = <$typ as BitStore>::Mem;
		[
			<Mem as $crate::macros::internal::funty::IsInteger>::ZERO,
			<Mem as $crate::mem::BitRegister>::ALL,
		][($val != 0) as usize]
	}};
}

/// Constructs a fundamental integer from a list of bytes.
#[doc(hidden)]
#[macro_export]
macro_rules! __ty_from_bytes {
	(Msb0, u8, [$($byte:expr),*]) => {
		u8::from_be_bytes([$($byte),*])
	};
	(Lsb0, u8, [$($byte:expr),*]) => {
		u8::from_le_bytes([$($byte),*])
	};
	(LocalBits, u8, [$($byte:expr),*]) => {
		u8::from_ne_bytes([$($byte),*])
	};
	(Msb0, u16, [$($byte:expr),*]) => {
		u16::from_be_bytes([$($byte),*])
	};
	(Lsb0, u16, [$($byte:expr),*]) => {
		u16::from_le_bytes([$($byte),*])
	};
	(LocalBits, u16, [$($byte:expr),*]) => {
		u16::from_ne_bytes([$($byte),*])
	};
	(Msb0, u32, [$($byte:expr),*]) => {
		u32::from_be_bytes([$($byte),*])
	};
	(Lsb0, u32, [$($byte:expr),*]) => {
		u32::from_le_bytes([$($byte),*])
	};
	(LocalBits, u32, [$($byte:expr),*]) => {
		u32::from_ne_bytes([$($byte),*])
	};
	(Msb0, u64, [$($byte:expr),*]) => {
		u64::from_be_bytes([$($byte),*])
	};
	(Lsb0, u64, [$($byte:expr),*]) => {
		u64::from_le_bytes([$($byte),*])
	};
	(LocalBits, u64, [$($byte:expr),*]) => {
		u64::from_ne_bytes([$($byte),*])
	};
	(Msb0, usize, [$($byte:expr),*]) => {
		usize::from_be_bytes([$($byte),*])
	};
	(Lsb0, usize, [$($byte:expr),*]) => {
		usize::from_le_bytes([$($byte),*])
	};
	(LocalBits, usize, [$($byte:expr),*]) => {
		usize::from_ne_bytes([$($byte),*])
	};
}

/// Construct a `u8` from bits applied in Lsb0-order.
#[cfg_attr(not(tarpaulin_include), inline(always))]
#[allow(clippy::many_single_char_names, clippy::too_many_arguments)]
pub const fn u8_from_le_bits(
	a: bool,
	b: bool,
	c: bool,
	d: bool,
	e: bool,
	f: bool,
	g: bool,
	h: bool,
) -> u8 {
	(a as u8)
		| ((b as u8) << 1)
		| ((c as u8) << 2)
		| ((d as u8) << 3)
		| ((e as u8) << 4)
		| ((f as u8) << 5)
		| ((g as u8) << 6)
		| ((h as u8) << 7)
}

/// Construct a `u8` from bits applied in Msb0-order.
#[cfg_attr(not(tarpaulin_include), inline(always))]
#[allow(clippy::many_single_char_names, clippy::too_many_arguments)]
pub const fn u8_from_be_bits(
	a: bool,
	b: bool,
	c: bool,
	d: bool,
	e: bool,
	f: bool,
	g: bool,
	h: bool,
) -> u8 {
	(h as u8)
		| ((g as u8) << 1)
		| ((f as u8) << 2)
		| ((e as u8) << 3)
		| ((d as u8) << 4)
		| ((c as u8) << 5)
		| ((b as u8) << 6)
		| ((a as u8) << 7)
}

#[doc(hidden)]
#[cfg(target_endian = "big")]
pub use self::u8_from_be_bits as u8_from_ne_bits;
#[doc(hidden)]
#[cfg(target_endian = "little")]
pub use self::u8_from_le_bits as u8_from_ne_bits;

#[cfg(test)]
mod tests {
	use super::*;

	#[test]
	fn byte_assembly() {
		assert_eq!(
			u8_from_le_bits(false, false, true, true, false, true, false, true),
			0b1010_1100
		);

		assert_eq!(
			u8_from_be_bits(false, false, true, true, false, true, false, true),
			0b0011_0101
		);
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/macros/internal.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/macros/tests.rs =====
//! Unit tests for the `macros` module.

#![cfg(test)]

use core::cell::Cell;

use funty::IsNumber;

use crate::prelude::*;

#[test]
fn compile_bitarr_typedef() {
	#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]
	struct Slots {
		all: BitArr!(for 10, in Msb0, u8),
		typ: BitArr!(for 10, in u8),
		def: BitArr!(for 10),
	}

	static SLOTS: Slots = Slots {
		all: bitarr!(const Msb0, u8; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
		typ: bitarr!(const Lsb0, u8; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
		def: bitarr!(const           1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
	};

	let slots = Slots {
		all: bitarr!(Msb0, u8; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
		typ: bitarr!(Lsb0, u8; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
		def: bitarr!(1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
	};

	assert_eq!(SLOTS, slots);

	assert_eq!(slots.all.into_inner(), [!0u8, 192]);
	assert_eq!(slots.typ.into_inner(), [!0u8, 3]);
	let def: [usize; 1] = slots.def.into_inner();
	assert_eq!(def[0].count_ones(), 10);
}

#[test]
fn constexpr_macros() {
	const A: BitArr!(for 20, in Lsb0, Cell<u8>) =
		bitarr!(const Lsb0, Cell<u8>; 1; 20);
	let a = A;
	assert_eq!(a.len(), 24);
	assert!(a.all());

	const B: BitArr!(for 20) = bitarr!(const 1; 20);
	let b = B;
	assert_eq!(b.len(), <usize as IsNumber>::BITS as usize);
	assert!(b.all());

	const C: BitArr!(for 5, in Msb0, Cell<u16>) =
		bitarr!(const Msb0, Cell<u16>; 1, 0, 1, 1, 0);
	let c = C;
	assert_eq!(c[.. 5], bits![1, 0, 1, 1, 0]);

	const D: BitArr!(for 5, in Lsb0, u32) =
		bitarr!(const Lsb0, u32; 1, 0, 1, 1, 0);
	let d = D;
	assert_eq!(d[.. 5], bits![1, 0, 1, 1, 0]);

	let _: &'static mut BitSlice<Msb0, Cell<u16>> =
		bits!(static mut Msb0, Cell<u16>; 1; 20);
	let _: &'static mut BitSlice<Lsb0, u32> = bits!(static mut Lsb0, u32; 1; 20);
	let _: &'static mut BitSlice = bits!(static mut 1; 20);

	let _: &'static mut BitSlice<Msb0, Cell<u16>> =
		bits!(static mut Msb0, Cell<u16>; 1, 0, 1, 1, 0);
	let _: &'static mut BitSlice<Lsb0, u32> =
		bits!(static mut Lsb0, u32; 1, 0, 1, 1, 0);
	let _: &'static mut BitSlice = bits!(static mut 1, 0, 1, 1, 0);

	let _: &'static BitSlice<Msb0, Cell<u16>> =
		bits!(static Msb0, Cell<u16>; 1; 20);
	let _: &'static BitSlice<Lsb0, u32> = bits!(static Lsb0, u32; 1; 20);
	let _: &'static BitSlice = bits!(static 1; 20);

	let _: &'static BitSlice<Msb0, Cell<u16>> =
		bits!(static Msb0, Cell<u16>; 1, 0, 1, 1, 0);
	let _: &'static BitSlice<Lsb0, u32> = bits!(static Lsb0, u32; 1, 0, 1, 1, 0);
	let _: &'static BitSlice = bits!(static 1, 0, 1, 1, 0);
}

#[test]
fn compile_bitarr() {
	let uint: BitArray<Lsb0, [u8; 1]> = bitarr![Lsb0, u8; 1, 0, 1, 0];
	assert_eq!(uint.into_inner(), [5u8]);
	let cell: BitArray<Lsb0, [Cell<u8>; 1]> =
		bitarr![Lsb0, Cell<u8>; 1, 0, 1, 0];
	assert_eq!(cell.into_inner()[0].get(), 5u8);

	let uint: BitArray<Msb0, [u16; 2]> = bitarr![Msb0, u16;
		0, 1, 0, 1, 0, 1, 0, 1,
		0, 1, 1, 0, 1, 0, 0, 1,
		0, 1, 1, 0, 1, 1, 1, 0,
		0, 1, 1, 1, 0, 1, 0, 0,
	];
	assert_eq!(uint.into_inner(), [0x5569, 0x6e74]);
	let cell: BitArray<Msb0, [Cell<u16>; 2]> = bitarr![Msb0, Cell<u16>;
		0, 1, 0, 1, 0, 1, 0, 1,
		0, 1, 1, 0, 1, 0, 0, 1,
		0, 1, 1, 0, 1, 1, 1, 0,
		0, 1, 1, 1, 0, 1, 0, 0,
	];
	let cells = cell.into_inner();
	assert_eq!(cells[0].get(), 0x5569);
	assert_eq!(cells[1].get(), 0x6e74);

	let uint: BitArray<Lsb0, [u32; 1]> = bitarr![crate::order::Lsb0, u32;
		1, 0, 1, 1,
	];
	assert_eq!(uint.into_inner(), [13u32]);
	let cell: BitArray<Lsb0, [Cell<u32>; 1]> = bitarr![
		crate::order::Lsb0, Cell<u32>;
		1, 0, 1, 1,
	];
	assert_eq!(cell.into_inner()[0].get(), 13u32);

	#[cfg(target_pointer_width = "64")]
	{
		let uint: BitArray<LocalBits, [u64; 2]> = bitarr![LocalBits, u64; 1; 70];
		assert_eq!(uint.into_inner(), [!0u64; 2]);

		let cell: BitArray<LocalBits, [Cell<u64>; 2]> = bitarr![
			LocalBits, Cell<u64>; 1; 70
		];
		assert_eq!(cell.clone().into_inner()[0].get(), !0u64);
		assert_eq!(cell.into_inner()[1].get(), !0u64);
	}

	let uint: BitArray<Lsb0, [usize; 1]> = bitarr![1, 0, 1];
	assert_eq!(uint.into_inner(), [5usize]);
	let uint: BitArray<Lsb0, [usize; 1]> = bitarr![1; 30];
	assert_eq!(uint.into_inner(), [!0usize]);
}

#[test]
fn compile_bits() {
	let a: &mut BitSlice<Lsb0, Cell<u8>> = bits![mut Lsb0, Cell<u8>; 1, 0, 1];
	let b: &mut BitSlice<Lsb0, u8> = bits![mut Lsb0, u8; 1, 0, 1];
	let c: &mut BitSlice<Msb0, Cell<u8>> =
		bits![mut crate::order::Msb0, Cell<u8>; 1, 0, 1];
	let d: &mut BitSlice<Msb0, u8> = bits![mut crate::order::Msb0, u8; 1, 0, 1];
	assert_eq!(a, c);
	assert_eq!(b, d);

	let e: &mut BitSlice<Lsb0, Cell<u8>> = bits![mut Lsb0, Cell<u8>; 1; 100];
	let f: &mut BitSlice<Lsb0, u8> = bits![mut Lsb0, u8; 1; 100];
	let g: &mut BitSlice<Msb0, Cell<u8>> =
		bits![mut crate::order::Msb0, Cell<u8>; 1; 100];
	let h: &mut BitSlice<Msb0, u8> = bits![mut crate::order::Msb0, u8; 1; 100];
	assert_eq!(e, g);
	assert_eq!(f, h);
	assert_eq!(h.as_raw_slice(), [!0u8; 13]);

	let i: &mut BitSlice<Lsb0, usize> = bits![mut 1, 0, 1];
	let j: &mut BitSlice<Lsb0, usize> = bits![mut 1; 3];
	j.set(1, false);
	assert_eq!(i, j);

	let _: &BitSlice<Lsb0, Cell<u8>> = bits![Lsb0, Cell<u8>; 1, 0, 1];
	let _: &BitSlice<Lsb0, u8> = bits![Lsb0, u8; 1, 0, 1];
	let _: &BitSlice<Msb0, Cell<u8>> =
		bits![crate::order::Msb0, Cell<u8>; 1, 0, 1];
	let _: &BitSlice<Msb0, u8> = bits![crate::order::Msb0, u8; 1, 0, 1];

	let _: &BitSlice<Lsb0, Cell<u8>> = bits![Lsb0, Cell<u8>; 1; 100];
	let _: &BitSlice<Lsb0, u8> = bits![Lsb0, u8; 1; 100];
	let _: &BitSlice<Msb0, Cell<u8>> =
		bits![crate::order::Msb0, Cell<u8>; 1; 100];
	let _: &BitSlice<Msb0, u8> = bits![crate::order::Msb0, u8; 1; 100];

	let _: &BitSlice<Lsb0, usize> = bits![1, 0, 1];
	let _: &BitSlice<Lsb0, usize> = bits![1; 100];

	let _: &BitSlice<Lsb0, Cell<u16>> = bits![Lsb0, Cell<u16>; 1, 0, 1];
	let _: &BitSlice<Lsb0, u16> = bits![Lsb0, u16; 1, 0, 1];
	let _: &BitSlice<Msb0, Cell<u16>> =
		bits![crate::order::Msb0, Cell<u16>; 1, 0, 1];
	let _: &BitSlice<Msb0, u16> = bits![crate::order::Msb0, u16; 1, 0, 1];

	let _: &BitSlice<Lsb0, Cell<u16>> = bits![Lsb0, Cell<u16>; 1; 100];
	let _: &BitSlice<Lsb0, u16> = bits![Lsb0, u16; 1; 100];
	let _: &BitSlice<Msb0, Cell<u16>> =
		bits![crate::order::Msb0, Cell<u16>; 1; 100];
	let _: &BitSlice<Msb0, u16> = bits![crate::order::Msb0, u16; 1; 100];

	let _: &BitSlice<Lsb0, Cell<u32>> = bits![Lsb0, Cell<u32>; 1, 0, 1];
	let _: &BitSlice<Lsb0, u32> = bits![Lsb0, u32; 1, 0, 1];
	let _: &BitSlice<Msb0, Cell<u32>> =
		bits![crate::order::Msb0, Cell<u32>; 1, 0, 1];
	let _: &BitSlice<Msb0, u32> = bits![crate::order::Msb0, u32; 1, 0, 1];

	let _: &BitSlice<Lsb0, Cell<u32>> = bits![Lsb0, Cell<u32>; 1; 100];
	let _: &BitSlice<Lsb0, u32> = bits![Lsb0, u32; 1; 100];
	let _: &BitSlice<Msb0, Cell<u32>> =
		bits![crate::order::Msb0, Cell<u32>; 1; 100];
	let _: &BitSlice<Msb0, u32> = bits![crate::order::Msb0, u32; 1; 100];

	let _: &BitSlice<Lsb0, Cell<usize>> = bits![Lsb0, Cell<usize>; 1, 0, 1];
	let _: &BitSlice<Lsb0, usize> = bits![Lsb0, usize; 1, 0, 1];
	let _: &BitSlice<Msb0, Cell<usize>> =
		bits![crate::order::Msb0, Cell<usize>; 1, 0, 1];
	let _: &BitSlice<Msb0, usize> = bits![crate::order::Msb0, usize; 1, 0, 1];

	let _: &BitSlice<Lsb0, Cell<usize>> = bits![Lsb0, Cell<usize>; 1; 100];
	let _: &BitSlice<Lsb0, usize> = bits![Lsb0, usize; 1; 100];
	let _: &BitSlice<Msb0, Cell<usize>> =
		bits![crate::order::Msb0, Cell<usize>; 1; 100];
	let _: &BitSlice<Msb0, usize> = bits![crate::order::Msb0, usize; 1; 100];

	#[cfg(target_pointer_width = "64")]
	{
		let _: &BitSlice<Lsb0, Cell<u64>> = bits![Lsb0, Cell<u64>; 1, 0, 1];
		let _: &BitSlice<Lsb0, u64> = bits![Lsb0, u64; 1, 0, 1];
		let _: &BitSlice<Msb0, Cell<u64>> =
			bits![crate::order::Msb0, Cell<u64>; 1, 0, 1];
		let _: &BitSlice<Msb0, u64> = bits![crate::order::Msb0, u64; 1, 0, 1];

		let _: &BitSlice<Lsb0, Cell<u64>> = bits![Lsb0, Cell<u64>; 1; 100];
		let _: &BitSlice<Lsb0, u64> = bits![Lsb0, u64; 1; 100];
		let _: &BitSlice<Msb0, Cell<u64>> =
			bits![crate::order::Msb0, Cell<u64>; 1; 100];
		let _: &BitSlice<Msb0, u64> = bits![crate::order::Msb0, u64; 1; 100];
	}

	radium::if_atomic! {
		if atomic(8) {
			use core::sync::atomic::*;

			let _: &BitSlice<LocalBits, AtomicU8> = bits![LocalBits, AtomicU8; 0, 1];
			let _: &BitSlice<Lsb0, AtomicU8> = bits![Lsb0, AtomicU8; 0, 1];
			let _: &BitSlice<Msb0, AtomicU8> = bits![Msb0, AtomicU8; 0, 1];
			let _: &BitSlice<LocalBits, AtomicU8> = bits![LocalBits, AtomicU8; 1; 100];
			let _: &BitSlice<Lsb0, AtomicU8> = bits![Lsb0, AtomicU8; 1; 100];
			let _: &BitSlice<Msb0, AtomicU8> = bits![Msb0, AtomicU8; 1; 100];
		}
		if atomic(16) {
			let _: &BitSlice<LocalBits, AtomicU16> = bits![LocalBits, AtomicU16; 0, 1];
			let _: &BitSlice<Lsb0, AtomicU16> = bits![Lsb0, AtomicU16; 0, 1];
			let _: &BitSlice<Msb0, AtomicU16> = bits![Msb0, AtomicU16; 0, 1];
			let _: &BitSlice<LocalBits, AtomicU16> = bits![LocalBits, AtomicU16; 1; 100];
			let _: &BitSlice<Lsb0, AtomicU16> = bits![Lsb0, AtomicU16; 1; 100];
			let _: &BitSlice<Msb0, AtomicU16> = bits![Msb0, AtomicU16; 1; 100];
		}
		if atomic(32) {
			let _: &BitSlice<LocalBits, AtomicU32> = bits![LocalBits, AtomicU32; 0, 1];
			let _: &BitSlice<Lsb0, AtomicU32> = bits![Lsb0, AtomicU32; 0, 1];
			let _: &BitSlice<Msb0, AtomicU32> = bits![Msb0, AtomicU32; 0, 1];
			let _: &BitSlice<LocalBits, AtomicU32> = bits![LocalBits, AtomicU32; 1; 100];
			let _: &BitSlice<Lsb0, AtomicU32> = bits![Lsb0, AtomicU32; 1; 100];
			let _: &BitSlice<Msb0, AtomicU32> = bits![Msb0, AtomicU32; 1; 100];
		}
		if atomic(size) {
			let _: &BitSlice<LocalBits, AtomicUsize> = bits![LocalBits, AtomicUsize; 0, 1];
			let _: &BitSlice<Lsb0, AtomicUsize> = bits![Lsb0, AtomicUsize; 0, 1];
			let _: &BitSlice<Msb0, AtomicUsize> = bits![Msb0, AtomicUsize; 0, 1];
			let _: &BitSlice<LocalBits, AtomicUsize> = bits![LocalBits, AtomicUsize; 1; 100];
			let _: &BitSlice<Lsb0, AtomicUsize> = bits![Lsb0, AtomicUsize; 1; 100];
			let _: &BitSlice<Msb0, AtomicUsize> = bits![Msb0, AtomicUsize; 1; 100];
		}
	}
	#[cfg(target_pointer_width = "64")]
	radium::if_atomic! {
		if atomic(64) {
			let _: &BitSlice<LocalBits, AtomicU64> = bits![LocalBits, AtomicU64; 0, 1];
			let _: &BitSlice<Lsb0, AtomicU64> = bits![Lsb0, AtomicU64; 0, 1];
			let _: &BitSlice<Msb0, AtomicU64> = bits![Msb0, AtomicU64; 0, 1];
			let _: &BitSlice<LocalBits, AtomicU64> = bits![LocalBits, AtomicU64; 1; 100];
			let _: &BitSlice<Lsb0, AtomicU64> = bits![Lsb0, AtomicU64; 1; 100];
			let _: &BitSlice<Msb0, AtomicU64> = bits![Msb0, AtomicU64; 1; 100];
		}
	}
}

#[test]
#[cfg(feature = "alloc")]
fn compile_bitvec() {
	let _: BitVec<Lsb0, Cell<u8>> = bitvec![Lsb0, Cell<u8>; 1, 0, 1];
	let _: BitVec<Lsb0, u8> = bitvec![Lsb0, u8; 1, 0, 1];
	let _: BitVec<Msb0, Cell<u8>> =
		bitvec![crate::order::Msb0, Cell<u8>; 1, 0, 1];
	let _: BitVec<Msb0, u8> = bitvec![crate::order::Msb0, u8; 1, 0, 1];

	let _: BitVec<Lsb0, Cell<u8>> = bitvec![Lsb0, Cell<u8>; 1; 100];
	let _: BitVec<Lsb0, u8> = bitvec![Lsb0, u8; 1; 100];
	let _: BitVec<Msb0, Cell<u8>> =
		bitvec![crate::order::Msb0, Cell<u8>; 1; 100];
	let _: BitVec<Msb0, u8> = bitvec![crate::order::Msb0, u8; 1; 100];

	let _: BitVec<Lsb0, usize> = bitvec![1, 0, 1];
	let _: BitVec<Lsb0, usize> = bitvec![1; 100];

	let _: BitVec<Lsb0, Cell<u16>> = bitvec![Lsb0, Cell<u16>; 1, 0, 1];
	let _: BitVec<Lsb0, u16> = bitvec![Lsb0, u16; 1, 0, 1];
	let _: BitVec<Msb0, Cell<u16>> =
		bitvec![crate::order::Msb0, Cell<u16>; 1, 0, 1];
	let _: BitVec<Msb0, u16> = bitvec![crate::order::Msb0, u16; 1, 0, 1];

	let _: BitVec<Lsb0, Cell<u16>> = bitvec![Lsb0, Cell<u16>; 1; 100];
	let _: BitVec<Lsb0, u16> = bitvec![Lsb0, u16; 1; 100];
	let _: BitVec<Msb0, Cell<u16>> =
		bitvec![crate::order::Msb0, Cell<u16>; 1; 100];
	let _: BitVec<Msb0, u16> = bitvec![crate::order::Msb0, u16; 1; 100];

	let _: BitVec<Lsb0, Cell<u32>> = bitvec![Lsb0, Cell<u32>; 1, 0, 1];
	let _: BitVec<Lsb0, u32> = bitvec![Lsb0, u32; 1, 0, 1];
	let _: BitVec<Msb0, Cell<u32>> =
		bitvec![crate::order::Msb0, Cell<u32>; 1, 0, 1];
	let _: BitVec<Msb0, u32> = bitvec![crate::order::Msb0, u32; 1, 0, 1];

	let _: BitVec<Lsb0, Cell<u32>> = bitvec![Lsb0, Cell<u32>; 1; 100];
	let _: BitVec<Lsb0, u32> = bitvec![Lsb0, u32; 1; 100];
	let _: BitVec<Msb0, Cell<u32>> =
		bitvec![crate::order::Msb0, Cell<u32>; 1; 100];
	let _: BitVec<Msb0, u32> = bitvec![crate::order::Msb0, u32; 1; 100];

	let _: BitVec<Lsb0, Cell<usize>> = bitvec![Lsb0, Cell<usize>; 1, 0, 1];
	let _: BitVec<Lsb0, usize> = bitvec![Lsb0, usize; 1, 0, 1];
	let _: BitVec<Msb0, Cell<usize>> =
		bitvec![crate::order::Msb0, Cell<usize>; 1, 0, 1];
	let _: BitVec<Msb0, usize> = bitvec![crate::order::Msb0, usize; 1, 0, 1];

	let _: BitVec<Lsb0, Cell<usize>> = bitvec![Lsb0, Cell<usize>; 1; 100];
	let _: BitVec<Lsb0, usize> = bitvec![Lsb0, usize; 1; 100];
	let _: BitVec<Msb0, Cell<usize>> =
		bitvec![crate::order::Msb0, Cell<usize>; 1; 100];
	let _: BitVec<Msb0, usize> = bitvec![crate::order::Msb0, usize; 1; 100];

	#[cfg(target_pointer_width = "64")]
	{
		let _: BitVec<Lsb0, Cell<u64>> = bitvec![Lsb0, Cell<u64>; 1, 0, 1];
		let _: BitVec<Lsb0, u64> = bitvec![Lsb0, u64; 1, 0, 1];
		let _: BitVec<Msb0, Cell<u64>> =
			bitvec![crate::order::Msb0, Cell<u64>; 1, 0, 1];
		let _: BitVec<Msb0, u64> = bitvec![crate::order::Msb0, u64; 1, 0, 1];

		let _: BitVec<Lsb0, Cell<u64>> = bitvec![Lsb0, Cell<u64>; 1; 100];
		let _: BitVec<Lsb0, u64> = bitvec![Lsb0, u64; 1; 100];
		let _: BitVec<Msb0, Cell<u64>> =
			bitvec![crate::order::Msb0, Cell<u64>; 1; 100];
		let _: BitVec<Msb0, u64> = bitvec![crate::order::Msb0, u64; 1; 100];
	}

	radium::if_atomic! {
		if atomic(8) {
			use core::sync::atomic::*;

			let _: BitVec<LocalBits, AtomicU8> = bitvec![LocalBits, AtomicU8; 0, 1];
			let _: BitVec<Lsb0, AtomicU8> = bitvec![Lsb0, AtomicU8; 0, 1];
			let _: BitVec<Msb0, AtomicU8> = bitvec![Msb0, AtomicU8; 0, 1];
			let _: BitVec<LocalBits, AtomicU8> = bitvec![LocalBits, AtomicU8; 1; 100];
			let _: BitVec<Lsb0, AtomicU8> = bitvec![Lsb0, AtomicU8; 1; 100];
			let _: BitVec<Msb0, AtomicU8> = bitvec![Msb0, AtomicU8; 1; 100];
		}
		if atomic(16) {
			let _: BitVec<LocalBits, AtomicU16> = bitvec![LocalBits, AtomicU16; 0, 1];
			let _: BitVec<Lsb0, AtomicU16> = bitvec![Lsb0, AtomicU16; 0, 1];
			let _: BitVec<Msb0, AtomicU16> = bitvec![Msb0, AtomicU16; 0, 1];
			let _: BitVec<LocalBits, AtomicU16> = bitvec![LocalBits, AtomicU16; 1; 100];
			let _: BitVec<Lsb0, AtomicU16> = bitvec![Lsb0, AtomicU16; 1; 100];
			let _: BitVec<Msb0, AtomicU16> = bitvec![Msb0, AtomicU16; 1; 100];
		}
		if atomic(32) {
			let _: BitVec<LocalBits, AtomicU32> = bitvec![LocalBits, AtomicU32; 0, 1];
			let _: BitVec<Lsb0, AtomicU32> = bitvec![Lsb0, AtomicU32; 0, 1];
			let _: BitVec<Msb0, AtomicU32> = bitvec![Msb0, AtomicU32; 0, 1];
			let _: BitVec<LocalBits, AtomicU32> = bitvec![LocalBits, AtomicU32; 1; 100];
			let _: BitVec<Lsb0, AtomicU32> = bitvec![Lsb0, AtomicU32; 1; 100];
			let _: BitVec<Msb0, AtomicU32> = bitvec![Msb0, AtomicU32; 1; 100];
		}
		if atomic(size) {
			let _: BitVec<LocalBits, AtomicUsize> = bitvec![LocalBits, AtomicUsize; 0, 1];
			let _: BitVec<Lsb0, AtomicUsize> = bitvec![Lsb0, AtomicUsize; 0, 1];
			let _: BitVec<Msb0, AtomicUsize> = bitvec![Msb0, AtomicUsize; 0, 1];
			let _: BitVec<LocalBits, AtomicUsize> = bitvec![LocalBits, AtomicUsize; 1; 100];
			let _: BitVec<Lsb0, AtomicUsize> = bitvec![Lsb0, AtomicUsize; 1; 100];
			let _: BitVec<Msb0, AtomicUsize> = bitvec![Msb0, AtomicUsize; 1; 100];
		}
	}
	#[cfg(target_pointer_width = "64")]
	radium::if_atomic! {
		if atomic(64) {
			let _: BitVec<LocalBits, AtomicU64> = bitvec![LocalBits, AtomicU64; 0, 1];
			let _: BitVec<Lsb0, AtomicU64> = bitvec![Lsb0, AtomicU64; 0, 1];
			let _: BitVec<Msb0, AtomicU64> = bitvec![Msb0, AtomicU64; 0, 1];
			let _: BitVec<LocalBits, AtomicU64> = bitvec![LocalBits, AtomicU64; 1; 100];
			let _: BitVec<Lsb0, AtomicU64> = bitvec![Lsb0, AtomicU64; 1; 100];
			let _: BitVec<Msb0, AtomicU64> = bitvec![Msb0, AtomicU64; 1; 100];
		}
	}
}

#[test]
#[cfg(feature = "alloc")]
fn compile_bitbox() {
	let _: BitBox<Lsb0, Cell<u8>> = bitbox![Lsb0, Cell<u8>; 1, 0, 1];
	let _: BitBox<Lsb0, u8> = bitbox![Lsb0, u8; 1, 0, 1];
	let _: BitBox<Msb0, Cell<u8>> =
		bitbox![crate::order::Msb0, Cell<u8>; 1, 0, 1];
	let _: BitBox<Msb0, u8> = bitbox![crate::order::Msb0, u8; 1, 0, 1];

	let _: BitBox<Lsb0, Cell<u8>> = bitbox![Lsb0, Cell<u8>; 1; 100];
	let _: BitBox<Lsb0, u8> = bitbox![Lsb0, u8; 1; 100];
	let _: BitBox<Msb0, Cell<u8>> =
		bitbox![crate::order::Msb0, Cell<u8>; 1; 100];
	let _: BitBox<Msb0, u8> = bitbox![crate::order::Msb0, u8; 1; 100];

	let _: BitBox<Lsb0, usize> = bitbox![1, 0, 1];
	let _: BitBox<Lsb0, usize> = bitbox![1; 100];

	let _: BitBox<Lsb0, Cell<u16>> = bitbox![Lsb0, Cell<u16>; 1, 0, 1];
	let _: BitBox<Lsb0, u16> = bitbox![Lsb0, u16; 1, 0, 1];
	let _: BitBox<Msb0, Cell<u16>> =
		bitbox![crate::order::Msb0, Cell<u16>; 1, 0, 1];
	let _: BitBox<Msb0, u16> = bitbox![crate::order::Msb0, u16; 1, 0, 1];

	let _: BitBox<Lsb0, Cell<u16>> = bitbox![Lsb0, Cell<u16>; 1; 100];
	let _: BitBox<Lsb0, u16> = bitbox![Lsb0, u16; 1; 100];
	let _: BitBox<Msb0, Cell<u16>> =
		bitbox![crate::order::Msb0, Cell<u16>; 1; 100];
	let _: BitBox<Msb0, u16> = bitbox![crate::order::Msb0, u16; 1; 100];

	let _: BitBox<Lsb0, Cell<u32>> = bitbox![Lsb0, Cell<u32>; 1, 0, 1];
	let _: BitBox<Lsb0, u32> = bitbox![Lsb0, u32; 1, 0, 1];
	let _: BitBox<Msb0, Cell<u32>> =
		bitbox![crate::order::Msb0, Cell<u32>; 1, 0, 1];
	let _: BitBox<Msb0, u32> = bitbox![crate::order::Msb0, u32; 1, 0, 1];

	let _: BitBox<Lsb0, Cell<u32>> = bitbox![Lsb0, Cell<u32>; 1; 100];
	let _: BitBox<Lsb0, u32> = bitbox![Lsb0, u32; 1; 100];
	let _: BitBox<Msb0, Cell<u32>> =
		bitbox![crate::order::Msb0, Cell<u32>; 1; 100];
	let _: BitBox<Msb0, u32> = bitbox![crate::order::Msb0, u32; 1; 100];

	let _: BitBox<Lsb0, Cell<usize>> = bitbox![Lsb0, Cell<usize>; 1, 0, 1];
	let _: BitBox<Lsb0, usize> = bitbox![Lsb0, usize; 1, 0, 1];
	let _: BitBox<Msb0, Cell<usize>> =
		bitbox![crate::order::Msb0, Cell<usize>; 1, 0, 1];
	let _: BitBox<Msb0, usize> = bitbox![crate::order::Msb0, usize; 1, 0, 1];

	let _: BitBox<Lsb0, Cell<usize>> = bitbox![Lsb0, Cell<usize>; 1; 100];
	let _: BitBox<Lsb0, usize> = bitbox![Lsb0, usize; 1; 100];
	let _: BitBox<Msb0, Cell<usize>> =
		bitbox![crate::order::Msb0, Cell<usize>; 1; 100];
	let _: BitBox<Msb0, usize> = bitbox![crate::order::Msb0, usize; 1; 100];

	#[cfg(target_pointer_width = "64")]
	{
		let _: BitBox<Lsb0, Cell<u64>> = bitbox![Lsb0, Cell<u64>; 1, 0, 1];
		let _: BitBox<Lsb0, u64> = bitbox![Lsb0, u64; 1, 0, 1];
		let _: BitBox<Msb0, Cell<u64>> =
			bitbox![crate::order::Msb0, Cell<u64>; 1, 0, 1];
		let _: BitBox<Msb0, u64> = bitbox![crate::order::Msb0, u64; 1, 0, 1];

		let _: BitBox<Lsb0, Cell<u64>> = bitbox![Lsb0, Cell<u64>; 1; 100];
		let _: BitBox<Lsb0, u64> = bitbox![Lsb0, u64; 1; 100];
		let _: BitBox<Msb0, Cell<u64>> =
			bitbox![crate::order::Msb0, Cell<u64>; 1; 100];
		let _: BitBox<Msb0, u64> = bitbox![crate::order::Msb0, u64; 1; 100];
	}

	radium::if_atomic! {
		if atomic(8) {
			use core::sync::atomic::*;

			let _: BitBox<LocalBits, AtomicU8> = bitbox![LocalBits, AtomicU8; 0, 1];
			let _: BitBox<Lsb0, AtomicU8> = bitbox![Lsb0, AtomicU8; 0, 1];
			let _: BitBox<Msb0, AtomicU8> = bitbox![Msb0, AtomicU8; 0, 1];
			let _: BitBox<LocalBits, AtomicU8> = bitbox![LocalBits, AtomicU8; 1; 100];
			let _: BitBox<Lsb0, AtomicU8> = bitbox![Lsb0, AtomicU8; 1; 100];
			let _: BitBox<Msb0, AtomicU8> = bitbox![Msb0, AtomicU8; 1; 100];
		}
		if atomic(16) {
			let _: BitBox<LocalBits, AtomicU16> = bitbox![LocalBits, AtomicU16; 0, 1];
			let _: BitBox<Lsb0, AtomicU16> = bitbox![Lsb0, AtomicU16; 0, 1];
			let _: BitBox<Msb0, AtomicU16> = bitbox![Msb0, AtomicU16; 0, 1];
			let _: BitBox<LocalBits, AtomicU16> = bitbox![LocalBits, AtomicU16; 1; 100];
			let _: BitBox<Lsb0, AtomicU16> = bitbox![Lsb0, AtomicU16; 1; 100];
			let _: BitBox<Msb0, AtomicU16> = bitbox![Msb0, AtomicU16; 1; 100];
		}
		if atomic(32) {
			let _: BitBox<LocalBits, AtomicU32> = bitbox![LocalBits, AtomicU32; 0, 1];
			let _: BitBox<Lsb0, AtomicU32> = bitbox![Lsb0, AtomicU32; 0, 1];
			let _: BitBox<Msb0, AtomicU32> = bitbox![Msb0, AtomicU32; 0, 1];
			let _: BitBox<LocalBits, AtomicU32> = bitbox![LocalBits, AtomicU32; 1; 100];
			let _: BitBox<Lsb0, AtomicU32> = bitbox![Lsb0, AtomicU32; 1; 100];
			let _: BitBox<Msb0, AtomicU32> = bitbox![Msb0, AtomicU32; 1; 100];
		}
		if atomic(size) {
			let _: BitBox<LocalBits, AtomicUsize> = bitbox![LocalBits, AtomicUsize; 0, 1];
			let _: BitBox<Lsb0, AtomicUsize> = bitbox![Lsb0, AtomicUsize; 0, 1];
			let _: BitBox<Msb0, AtomicUsize> = bitbox![Msb0, AtomicUsize; 0, 1];
			let _: BitBox<LocalBits, AtomicUsize> = bitbox![LocalBits, AtomicUsize; 1; 100];
			let _: BitBox<Lsb0, AtomicUsize> = bitbox![Lsb0, AtomicUsize; 1; 100];
			let _: BitBox<Msb0, AtomicUsize> = bitbox![Msb0, AtomicUsize; 1; 100];
		}
	}
	#[cfg(target_pointer_width = "64")]
	radium::if_atomic! {
		if atomic(64) {
			let _: BitBox<LocalBits, AtomicU64> = bitbox![LocalBits, AtomicU64; 0, 1];
			let _: BitBox<Lsb0, AtomicU64> = bitbox![Lsb0, AtomicU64; 0, 1];
			let _: BitBox<Msb0, AtomicU64> = bitbox![Msb0, AtomicU64; 0, 1];
			let _: BitBox<LocalBits, AtomicU64> = bitbox![LocalBits, AtomicU64; 1; 100];
			let _: BitBox<Lsb0, AtomicU64> = bitbox![Lsb0, AtomicU64; 1; 100];
			let _: BitBox<Msb0, AtomicU64> = bitbox![Msb0, AtomicU64; 1; 100];
		}
	}
}

#[test]
fn encode_bits() {
	let uint: [u8; 1] = __encode_bits!(Lsb0, u8; 1, 0, 1, 0, 0, 0, 0, 0);
	assert_eq!(uint, [5]);

	let cell: [Cell<u8>; 1] =
		__encode_bits!(Lsb0, Cell<u8>; 1, 0, 1, 0, 0, 0, 0, 0);
	assert_eq!(cell[0].get(), 5);

	let uint: [u16; 1] = __encode_bits!(Msb0, u16;
		0, 1, 0, 0, 1, 0, 0, 0,
		0, 1, 1, 0, 1, 0, 0, 1
	);
	assert_eq!(uint, [0x4869]);

	let cell: [Cell<u16>; 1] = __encode_bits!(Msb0, Cell<u16>;
		0, 1, 0, 0, 1, 0, 0, 0,
		0, 1, 1, 0, 1, 0, 0, 1
	);
	assert_eq!(cell[0].get(), 0x4869);

	let uint: [u32; 1] = __encode_bits!(LocalBits, u32; 1, 0, 1);
	assert_eq!(uint.view_bits::<LocalBits>()[.. 3], bits![1, 0, 1]);

	let cell: [Cell<u32>; 1] = __encode_bits!(LocalBits, Cell<u32>; 1, 0, 1);
	let bits: &BitSlice<LocalBits, Cell<u32>> = cell.view_bits::<_>();
	assert_eq!(bits[.. 3], bits![1, 0, 1]);
}

#[test]
fn make_elem() {
	let uint: u8 = __make_elem!(Lsb0, u8 as u8; 1, 0, 1, 0, 0, 0, 0, 0);
	assert_eq!(uint, 5);

	let cell: Cell<u8> =
		__make_elem!(Lsb0, Cell<u8> as u8; 1, 0, 1, 0, 0, 0, 0, 0);
	assert_eq!(cell.get(), 5);

	let uint: u16 = __make_elem!(Msb0, u16 as u16;
		0, 1, 0, 0, 1, 0, 0, 0,
		0, 1, 1, 0, 1, 0, 0, 1
	);
	assert_eq!(uint, 0x4869);

	let cell: Cell<u16> = __make_elem!(Msb0, Cell<u16> as u16;
		0, 1, 0, 0, 1, 0, 0, 0,
		0, 1, 1, 0, 1, 0, 0, 1
	);
	assert_eq!(cell.get(), 0x4869);

	let uint: u32 = __make_elem!(LocalBits, u32 as u32; 1, 0, 1);
	assert_eq!(uint.view_bits::<LocalBits>()[.. 3], bits![1, 0, 1]);

	let cell: Cell<u32> = __make_elem!(LocalBits, Cell<u32> as u32; 1, 0, 1);
	let bits: &BitSlice<LocalBits, Cell<u32>> = cell.view_bits::<_>();
	assert_eq!(bits[.. 3], bits![1, 0, 1]);

	//  `__make_elem!` is only called after `$ord` has already been made
	// opaque  to matchers as a single `:tt`. Calling it directly with a path
	// will fail  the `:tt`, so this macro wraps it as one and forwards the
	// rest.
	macro_rules! invoke_make_elem {
		($ord:path, $($rest:tt)*) => { __make_elem!($ord, $($rest)*) };
	}
	let uint: usize =
		invoke_make_elem!(crate::order::Lsb0, usize as usize; 0, 0, 1, 1);
	assert_eq!(uint, 12);
	let cell: Cell<usize> =
		invoke_make_elem!(crate::order::Lsb0, Cell<usize> as usize; 0, 0, 1, 1);
	assert_eq!(cell.get(), 12);
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/macros/tests.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/macros.rs =====
//! Constructor macros for the crate’s collection types.

#![allow(deprecated)]

#[macro_use]
#[doc(hidden)]
pub mod internal;

/** Constructs a type definition for a [`BitArray`].

This macro takes a minimum number of bits, and optionally a set of [`BitOrder`]
and [`BitStore`] implementors, and creates a `BitArray` type definition that
satisfies them. Because this macro is used in type position, it uses
`PascalCase` rather than `snake_case` for its name.

# Grammar

```rust
use bitvec::prelude::*;
use core::cell::Cell;

const CENT: usize = bitvec::mem::elts::<usize>(100);
let a: BitArr!(for 100)
  = BitArray::<Lsb0, [usize; CENT]>::zeroed();

let b: BitArr!(for 100, in u32)
  = BitArray::<Lsb0, [u32; 4]>::zeroed();

let c: BitArr!(for 100, in Msb0, Cell<u16>)
  = BitArray::<Msb0, [Cell<u16>; 7]>::zeroed();
```

The length expression must be a `const`-expression. It may be a literal or a
named `const` expression. The type arguments have no restrictions, so long as
they resolve to valid trait implementors.

[`BitArray`]: crate::array::BitArray
[`BitOrder`]: crate::order::BitOrder
[`BitStore`]: crate::store::BitStore
**/
#[macro_export]
macro_rules! BitArr {
	(for $len:expr, in $order:ty, $store:ty $(,)?) => {
		$crate::array::BitArray::<
			$order, [$store; $crate::mem::elts::<$store>($len)]
		>
	};

	(for $len:expr, in $store:ty $(,)?) => {
		$crate::BitArr!(for $len, in $crate::order::Lsb0, $store)
	};

	(for $len:expr) => {
		$crate::BitArr!(for $len, in usize)
	};
}

/** Constructs a new [`BitArray`] from a bit-pattern description.

This macro takes a superset of the [`vec!`] argument syntax: it may be invoked
with either a sequence of bit expressions, or a single bit expression and a
repetition counter. Additionally, you may provide the names of a [`BitOrder`]
and a [`BitStore`] implementor as the `BitArray`’s type arguments.

# Argument Rules

Bit expressions must be integer literals. Ambiguity restrictions in the macro
syntax forbid the use of identifiers to existing variables, even `const` values.
These are converted to `bool` through the expression `$val != 0`. Any non-zero
enteger becomes `true`, and `0` becomes `false`.

You may use any name or path to a [`BitOrder`] implementation. However, the
identifier tokens `Lsb0`, `Msb0`, and `LocalBits` are matched directly and
specialized to have compile-time constructions, whereäs any other name or path
will not be known to the macro, and will execute at runtime.

The [`BitStore`] argument **must** be the name of an unsigned integer
fundamental, an atomic, or a `Cell<>` wrapper of that unsigned integer. These
are matched by token, not by type, and no other identifier is accepted. Using
any other token will cause the macro to fail.

## `const` Production

Prepending the argument list with `const` (so `bitarr!(ARGS…)` becomes
`bitarr!(const ARGS…)`) causes the macro to only expand to code that can be used
in `const` contexts. This limits any supplied ordering to be **only** the tokens
`Lsb0`, `Msb0`, and `LocalBits`; no other token is permitted, even if the token
resolves to the same ordering implementation.

The macro expands into code that can be used to initialize a `const` or `static`
binding. This is the **only** way to construct a `BitArray` in `const` contexts,
until the `const` system permits generics and trait methods.

# Examples

```rust
use bitvec::prelude::*;
use core::cell::Cell;

radium::if_atomic! { if atomic(32) {
  use core::sync::atomic::AtomicU32;
} }

let a: BitArray = bitarr![0, 1, 0, 1, 2];
assert_eq!(a.count_ones(), 3);

let b: BitArray = bitarr![2; 5];
assert!(b.all());
assert!(b.len() >= 5);

let c = bitarr![Lsb0, Cell<u16>; 0, 1, 0, 0, 1];
radium::if_atomic! { if atomic(32) {
  let d = bitarr![Msb0, AtomicU32; 0, 0, 1, 0, 1];
} }

let e: BitArr!(for 20, in LocalBits, u8) = bitarr![LocalBits, u8; 0; 20];
```

[`BitArray`]: crate::array::BitArray
[`BitOrder`]: crate::order::BitOrder
[`BitStore`]: crate::store::BitStore
[`vec!`]: macro@alloc::vec
**/
#[macro_export]
macro_rules! bitarr {
	/* `const`-expression constructors.

	These arms expand to expressions which are valid to use in `const` position,
	such as within `const fn` bodies, or as the initializers of `static` or
	`const` bindings.

	They are more restricted than the general variants below, because the trait
	system is not usable in `const` contexts and thus these expansions can only
	use codepaths defined within this module, and not any of the general crate
	systems.

	All valid invocations with a leading `const` token will remain valid if the
	`const` is removed, though their expansion may cease to be valid in `const`
	contexts.
	*/
	(const $order:ty, $store:ty; $val:expr; $len:expr) => {{
		use $crate::macros::internal::core;
		type Mem = <$store as $crate::store::BitStore>::Mem;

		const ELTS: usize = $crate::mem::elts::<$store>($len);
		const ELEM: Mem = $crate::__extend_bool!($val, $store);
		const DATA: [Mem; ELTS] = [ELEM; ELTS];

		type This = $crate::array::BitArray<$order, [$store; ELTS]>;
		unsafe { core::mem::transmute::<_, This>(DATA) }
	}};
	(const $val:expr; $len:expr) => {{
		$crate::bitarr!(const $crate::order::Lsb0, usize; $val; $len)
	}};

	(const $order:ident, Cell<$store:ident>; $($val:expr),* $(,)?) => {{
		use $crate::macros::internal::core;
		type Celled = core::cell::Cell<$store>;

		const ELTS: usize = $crate::__count_elts!($store; $($val),*);
		type Data = [$store; ELTS];
		const DATA: Data = $crate::__encode_bits!($order, $store; $($val),*);

		type This = $crate::array::BitArray<$order, [Celled; ELTS]>;
		unsafe { core::mem::transmute::<_, This>(DATA) }
	}};
	(const $order:ident, $store:ident; $($val:expr),* $(,)?) => {{
		use $crate::macros::internal::core;

		const ELTS: usize = $crate::__count_elts!($store; $($val),*);
		type Data = [$store; ELTS];
		const DATA: Data = $crate::__encode_bits!($order, $store; $($val),*);

		type This = $crate::array::BitArray<$order, Data>;
		unsafe { core::mem::transmute::<_, This>(DATA) }
	}};

	(const $($val:expr),* $(,)?) => {{
		$crate::bitarr!(const Lsb0, usize; $($val),*)
	}};

	/* Non-`const` constructors.

	These expansions are allowed to produce that does not run in `const`
	contexts. While it is *likely* that the expansions will be evaluated at
	compile-time, this is done in LLVM, not in Rust MIR.
	*/

	//  Bit-repetition syntax.
	($order:ty, $store:ty; $val:expr; $len:expr) => {{
		$crate::bitarr!(const $order, $store; $val; $len)
	}};
	($val:expr; $len:expr) => {{
		$crate::bitarr!(const $val; $len)
	}};

	//  Bit-sequence syntax.

	/* The duplicate matchers differing in `:ident` and `:path` exploit a rule
	of macro expansion so that the literal tokens `Lsb0`, `Msb0`, and
	`LocalBits` can be propagated through the entire expansion, thus selecting
	optimized construction sequences. Names of orderings other than these three
	tokens become opaque, and route to a fallback implementation that is less
	likely to be automatically optimized during codegen.

	`:ident` fragments are inspectable as literal tokens by future macros, while
	`:path` fragments become a single opaque object that can only match as
	`:path` or `:tt` bindings when passed along.
	*/

	($order:ident, Cell<$store:ident>; $($val:expr),* $(,)?) => {{
		use $crate::macros::internal::core;
		type Celled = core::cell::Cell<$store>;

		const ELTS: usize = $crate::__count_elts!($store; $($val),*);
		type Data = [Celled; ELTS];
		type This = $crate::array::BitArray<$order, Data>;

		This::new($crate::__encode_bits!($order, Cell<$store>; $($val),*))
	}};
	($order:ident, $store:ident; $($val:expr),* $(,)?) => {{
		const ELTS: usize = $crate::__count_elts!($store; $($val),*);
		type This = $crate::array::BitArray<$order, [$store; ELTS]>;

		This::new($crate::__encode_bits!($order, $store; $($val),*))
	}};

	($order:path, Cell<$store:ident>; $($val:expr),* $(,)?) => {{
		use $crate::macros::internal::core;
		type Celled = core::cell::Cell<$store>;

		const ELTS: usize = $crate::__count_elts!($store; $($val),*);
		type This = $crate::array::BitArray<$order, [Celled; ELTS]>;

		This::new($crate::__encode_bits!($order, Cell<$store>; $($val),*))
	}};
	($order:path, $store:ident; $($val:expr),* $(,)?) => {{
		const ELTS: usize = $crate::__count_elts!($store; $($val),*);
		type This = $crate::array::BitArray<$order, [$store; ELTS]>;

		This::new($crate::__encode_bits!($order, $store; $($val),*))
	}};

	($($val:expr),* $(,)?) => {
		$crate::bitarr!(Lsb0, usize; $($val),*)
	};
}

/** Creates a borrowed [`BitSlice`] in the local scope.

This macro constructs a [`BitArray`] temporary and then immediately borrows it
as a `BitSlice`. The compiler should extend the lifetime of the underlying
`BitArray` for the duration of the expression’s lifetime.

This macro takes a superset of the [`vec!`] argument syntax: it may be invoked
with either a sequence of bit expressions, or a single bit expression and a
repetiton counter. Additionally, you may provide the names of a [`BitOrder`] and
a [`BitStore`] implementor as the `BitArray`’s type arguments. You may also use
`mut` as the first argument of the macro in order to produce an `&mut BitSlice`
reference rather than a `&BitSlice` immutable reference.

# Argument Rules

Bit expressions must be integer literals. Ambiguity restrictions in the macro
syntax forbid the use of identifiers to existing variables, even `const` values.
These are converted to `bool` through the expression `$val != 0`. Any non-zero
enteger becomes `true`, and `0` becomes `false`.

You may use any name or path to a [`BitOrder`] implementation. However, the
identifier tokens `Lsb0`, `Msb0`, and `LocalBits` are matched directly and
specialized to have compile-time constructions, whereäs any other name or path
will not be known to the macro, and will execute at runtime.

The [`BitStore`] argument **must** be the name of an unsigned integer
fundamental, an atomic, or a `Cell<>` wrapper of that unsigned integer. These
are matched by token, not by type, and no other identifier is accepted. Using
any other token will cause the macro to fail.

## `static` Production

Prepending the argument list with `static` or `static mut` (so `bits!(ARGS…)`
becomes `bits!(static [mut] ARGS…)`) causes the macro to expand to code that
emits a hidden `static` or `static mut` value, initialized with a
`bitarr!(const ARGS…)` expansion and then reborrowed. The name of the hidden
static object does not escape the macro invocation, and so the returned
`BitSlice` handle is the single point of access to it.

Because both indexing and mutable reborrows are forbidden in `const` contexts,
the produced `BitSlice` references can only be bound to `let`, not to `static`.
They have the `&'static` lifetime, but to give the *names* a `static` binding,
you must use `bitarr!(const ARGS…)` and then borrowed as a `BitSlice` at the
point of use.

# Examples

```rust
use bitvec::prelude::*;
use core::cell::Cell;

radium::if_atomic! { if atomic(16) {
  use core::sync::atomic::AtomicU32;
} }

let a: &BitSlice = bits![0, 1, 0, 1, 2];
assert_eq!(a.count_ones(), 3);

let b: &mut BitSlice = bits![mut 2; 5];
assert!(b.all());
assert_eq!(b.len(), 5);

let c = bits![Lsb0, Cell<u16>; 0, 1, 0, 0, 1];
c.set_aliased(0, true);
let d = bits![Msb0, AtomicU32; 0, 0, 1, 0, 1];
d.set_aliased(0, true);
```

[`BitArray`]: crate::array::BitArray
[`BitOrder`]: crate::order::BitOrder
[`BitSlice`]: crate::slice::BitSlice
[`BitStore`]: crate::store::BitStore
[`vec!`]: macro@alloc::vec
**/
#[macro_export]
macro_rules! bits {
	(static mut $order:ty, Cell<$store:ident>; $val:expr; $len:expr) => {{
		use $crate::macros::internal::core;
		type Celled = core::cell::Cell<$store>;
		static mut DATA: $crate::BitArr!(for $len, in $order, $store) =
			$crate::bitarr!(const $order, $store; $val; $len);
		unsafe {
			&mut *(
				DATA.get_unchecked_mut(.. $len)
					as *mut $crate::slice::BitSlice<$order, $store>
					as *mut $crate::slice::BitSlice<$order, Celled>
			)
		}
	}};
	(static mut $order:ty, $store:ident; $val:expr; $len:expr) => {{
		static mut DATA: $crate::BitArr!(for $len, in $order, $store) =
			$crate::bitarr!(const $order, $store; $val; $len);
		unsafe { DATA.get_unchecked_mut(.. $len) }
	}};
	(static mut $val:expr; $len:expr) => {{
		static mut DATA: $crate::BitArr!(for $len) =
			$crate::bitarr!(const $crate::order::Lsb0, usize; $val; $len);
		unsafe { DATA.get_unchecked_mut(.. $len) }
	}};

	(static mut $order:ident, Cell<$store:ident>; $($val:expr),* $(,)?) => {{
		use $crate::macros::internal::core;
		type Celled = core::cell::Cell<$store>;
		const BITS: usize = $crate::__count!($($val),*);

		static mut DATA: $crate::BitArr!(for BITS, in $order, $store) =
			$crate::bitarr!(const $order, $store; $($val),*);
		unsafe {
			&mut *(
				DATA.get_unchecked_mut(.. BITS)
					as *mut $crate::slice::BitSlice<$order, $store>
					as *mut $crate::slice::BitSlice<$order, Celled>
			)
		}
	}};
	(static mut $order:ident, $store:ident; $($val:expr),* $(,)?) => {{
		const BITS: usize = $crate::__count!($($val),*);
		static mut DATA: $crate::BitArr!(for BITS, in $order, $store) =
			$crate::bitarr!(const $order, $store; $($val),*);
		unsafe { DATA.get_unchecked_mut(.. BITS) }
	}};
	(static mut $($val:expr),* $(,)?) => {{
		$crate::bits!(static mut Lsb0, usize; $($val),*)
	}};

	(static $order:ty, Cell<$store:ident>; $val:expr; $len:expr) => {{
		use $crate::macros::internal::core;
		type Celled = core::cell::Cell<$store>;
		static DATA: $crate::BitArr!(for $len, in $order, $store) =
			$crate::bitarr!(const $order, $store; $val; $len);
		unsafe {
			&*(
				DATA.get_unchecked(.. $len)
					as *const $crate::slice::BitSlice<$order, $store>
					as *const $crate::slice::BitSlice<$order, Celled>
			)
		}
	}};
	(static $order:ty, $store:ident; $val:expr; $len:expr) => {{
		static DATA: $crate::BitArr!(for $len, in $order, $store) =
			$crate::bitarr!(const $order, $store; $val; $len);
		unsafe { DATA.get_unchecked(.. $len) }
	}};
	(static $val:expr; $len:expr) => {{
		static DATA: $crate::BitArr!(for $len) =
			$crate::bitarr!(const $crate::order::Lsb0, usize; $val; $len);
		unsafe { DATA.get_unchecked(.. $len) }
	}};

	(static $order:ident, Cell<$store:ident>; $($val:expr),* $(,)?) => {{
		use $crate::macros::internal::core;
		type Celled = core::cell::Cell<$store>;
		const BITS: usize = $crate::__count!($($val),*);

		static mut DATA: $crate::BitArr!(for BITS, in $order, $store) =
			$crate::bitarr!(const $order, $store; $($val),*);
		unsafe {
			&*(
				DATA.get_unchecked_mut(.. BITS)
					as *const $crate::slice::BitSlice<$order, $store>
					as *const $crate::slice::BitSlice<$order, Celled>
			)
		}
	}};
	(static $order:ident, $store:ident; $($val:expr),* $(,)?) => {{
		const BITS: usize = $crate::__count!($($val),*);
		static DATA: $crate::BitArr!(for BITS, in $order, $store) =
			$crate::bitarr!(const $order, $store; $($val),*);
		unsafe { DATA.get_unchecked(.. BITS) }
	}};
	(static $($val:expr),* $(,)?) => {{
		$crate::bits!(static Lsb0, usize; $($val),*)
	}};

	//  Repetition syntax `[bit ; count]`.
	//  NOTE: `count` must be a `const`, as this is a non-allocating macro.

	//  Explicit order and store.
	(mut $order:ty, $store:ty; $val:expr; $len:expr) => {{
		&mut $crate::bitarr!($order, $store; $val; $len)[.. $len]
	}};
	//  Default order and store.
	(mut $val:expr; $len:expr) => {
		$crate::bits!(mut $crate::order::Lsb0, usize; $val; $len)
	};

	//  Sequence syntax `[bit (, bit)*]` or `[(bit ,)*]`.

	//  Explicit order and store.

	(mut $order:ident, Cell<$store:ident>; $($val:expr),* $(,)?) => {{
		const BITS: usize = $crate::__count!($($val),*);
		&mut $crate::bitarr!($order, Cell<$store>; $($val),*)[.. BITS]
	}};
	(mut $order:ident, $store:ident; $($val:expr),* $(,)?) => {{
		const BITS: usize = $crate::__count!($($val),*);
		&mut $crate::bitarr!($order, $store; $($val),*)[.. BITS]
	}};

	(mut $order:path, Cell<$store:ident>; $($val:expr),* $(,)?) => {{
		const BITS: usize = $crate::__count!($($val),*);
		&mut $crate::bitarr!($order, Cell<$store>; $($val),*)[.. BITS]
	}};
	(mut $order:path, $store:ident; $($val:expr),* $(,)?) => {{
		const BITS: usize = $crate::__count!($($val),*);
		&mut $crate::bitarr!($order, $store; $($val),*)[.. BITS]
	}};

	//  Default order and store.
	(mut $($val:expr),* $(,)?) => {
		$crate::bits!(mut Lsb0, usize; $($val),*)
	};

	//  Repeat everything from above, but now immutable.

	($order:ty, $store:ty; $val:expr; $len:expr) => {{
		&$crate::bitarr!($order, $store; $val; $len)[.. $len]
	}};
	($val:expr; $len:expr) => {
		$crate::bits!($crate::order::Lsb0, usize; $val; $len)
	};

	($order:ident, Cell<$store:ident>; $($val:expr),* $(,)?) => {{
		const BITS: usize = $crate::__count!($($val),*);
		&$crate::bitarr!($order, Cell<$store>; $($val),*)[.. BITS]
	}};
	($order:ident, $store:ident; $($val:expr),* $(,)?) => {{
		const BITS: usize = $crate::__count!($($val),*);
		&$crate::bitarr!($order, $store; $($val),*)[.. BITS]
	}};

	($order:path, Cell<$store:ident>; $($val:expr),* $(,)?) => {{
		const BITS: usize = $crate::__count!($($val),*);
		&$crate::bitarr!($order, Cell<$store>; $($val),*)[.. BITS]
	}};
	($order:path, $store:ident; $($val:expr),* $(,)?) => {{
		const BITS: usize = $crate::__count!($($val),*);
		&$crate::bitarr!($order, $store; $($val),*)[.. BITS]
	}};

	//  Default order and store.
	($($val:expr),* $(,)?) => {
		$crate::bits!(Lsb0, usize; $($val),*)
	};
}

/** Constructs a new [`BitVec`] from a bit-pattern description.

This macro takes a superset of the [`vec!`] argument syntax: it may be invoked
with either a sequence of bit expressions, or a single bit expression and a
repetition counter. Additionally, you may provide the names of a [`BitOrder`]
and a [`BitStore`] implementor as the `BitVec`’s type arguments.

# Argument Rules

Bit expressions must be integer literals. Ambiguity restrictions in the macro
syntax forbid the use of identifiers to existing variables, even `const` values.
These are converted to `bool` through the expression `$val != 0`. Any non-zero
enteger becomes `true`, and `0` becomes `false`.

You may use any name or path to a [`BitOrder`] implementation. However, the
identifier tokens `Lsb0`, `Msb0`, and `LocalBits` are matched directly and
specialized to have compile-time constructions, whereäs any other name or path
will not be known to the macro, and will execute at runtime.

The [`BitStore`] argument **must** be the name of an unsigned integer
fundamental, an atomic, or a `Cell<>` wrapper of that unsigned integer. These
are matched by token, not by type, and no other identifier as accepted. Using
any other token will cause the macro to fail.

# Examples

```rust
use bitvec::prelude::*;
use core::cell::Cell;

radium::if_atomic! { if atomic(32) {
  use core::sync::atomic::AtomicU32;
} }

let a: BitVec = bitvec![0, 1, 0, 1, 2];
assert_eq!(a.count_ones(), 3);

let b: BitVec = bitvec![2; 5];
assert!(b.all());
assert_eq!(b.len(), 5);

let c = bitvec![Lsb0, Cell<u16>; 0, 1, 0, 0, 1];
let d = bitvec![Msb0, AtomicU32; 0, 0, 1, 0, 1];
```

[`BitOrder`]: crate::order::BitOrder
[`BitStore`]: crate::store::BitStore
[`BitVec`]: crate::vec::BitVec
[`vec!`]: macro@alloc::vec
**/
#[macro_export]
#[cfg(feature = "alloc")]
macro_rules! bitvec {
	//  First, capture the repetition syntax, as it is permitted to use runtime
	//  values for the repetition count.
	($order:ty, $store:ty; $val:expr; $len:expr) => {
		$crate::vec::BitVec::<$order, $store>::repeat($val != 0, $len)
	};

	($val:expr; $len:expr) => {
		$crate::bitvec!($crate::order::Lsb0, usize; $val; $len)
	};

	//  Delegate all others to the `bits!` macro.
	($($arg:tt)*) => {{
		$crate::vec::BitVec::from_bitslice($crate::bits!($($arg)*))
	}};
}

/** Constructs a new [`BitBox`] from a bit-pattern description.

This forwards all its arguments to [`bitvec!`], and then calls
[`.into_boxed_bitslice()`] on the result to freeze the allocation.

[`BitBox`]: crate::boxed::BitBox
[`bitvec!`]: macro@crate::bitvec
[`.into_boxed_bitslice()`]: crate::vec::BitVec::into_boxed_bitslice
**/
#[macro_export]
#[cfg(feature = "alloc")]
macro_rules! bitbox {
	($($arg:tt)*) => {
		$crate::bitvec!($($arg)*).into_boxed_bitslice()
	};
}

#[cfg(test)]
mod tests;
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/macros.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/mem.rs =====
/*! Memory element descriptions.

This module describes memory integers and processor registers used to hold and
manipulate [`bitvec`] data buffers.

The [`BitMemory`] trait adds descriptive information to the unsigned integers
available in the language.

The [`BitRegister`] trait marks the unsigned integers that correspond to
processor registers, and can therefore be used for buffer control. The integers
that are `BitMemory` but not `BitRegister` can be composed out of register
values, but are unable to be used in buffer type parameters.

[`BitMemory`]: crate::mem::BitMemory
[`BitRegister`]: crate::mem::BitRegister
[`bitvec`]: crate
!*/

use core::mem;

use funty::IsUnsigned;
use radium::marker::BitOps;

/** Description of an integer memory element.

This trait provides information used to describe integer-typed regions of memory
and enables other parts of the project to adequately describe the memory bus.
This trait has **no** bearing on the processor instructions or registers used to
interact with memory. It solely describes integers that can exist on a system.

This trait cannot be implemented outside this crate.
**/
pub trait BitMemory: IsUnsigned + seal::Sealed {
	/// The number of bits required to store an index in the range `0 .. BITS`.
	const INDX: u8 = Self::BITS.trailing_zeros() as u8;

	/// A mask over all bits that can be used as an index within the element.
	/// This is the value with the least significant `INDX`-many bits set high.
	const MASK: u8 = Self::BITS as u8 - 1;
}

/** Description of a processor register.

This trait provides information used to describe processor registers. It only
needs to contain constant values for `1` and `!0`; the rest of its information
is contained in the presence or absence of its implementation on particular
integers.
**/
pub trait BitRegister: BitMemory + BitOps {
	/// The literal `1`.
	const ONE: Self;
	/// The literal `!0`.
	const ALL: Self;
}

macro_rules! memory {
	($($t:ident),+ $(,)?) => { $(
		impl BitMemory for $t {}
		impl seal::Sealed for $t {}
	)+ };
}

memory!(u8, u16, u32, u64, u128, usize);

macro_rules! register {
	($($t:ident),+ $(,)?) => { $(
		impl BitRegister for $t {
			const ONE: Self = 1;
			const ALL: Self = !0;
		}
	)+ };
}

register!(u8, u16, u32);

/** `u64` can only be used as a register on processors whose word size is at
least 64 bits.

This implementation is not present on targets with 32-bit processor words.
**/
#[cfg(target_pointer_width = "64")]
impl BitRegister for u64 {
	const ALL: Self = !0;
	const ONE: Self = 1;
}

register!(usize);

/** Computes the number of elements required to store some number of bits.

# Parameters

- `bits`: The number of bits to store in a `[T]` array.

# Returns

The number of elements `T` required to store `bits`.

As this is a const function, when `bits` is a constant expression, this can be
used to compute the size of an array type `[T; elts(bits)]`.
**/
#[doc(hidden)]
pub const fn elts<T>(bits: usize) -> usize {
	let width = mem::size_of::<T>() * 8;
	bits / width + (bits % width != 0) as usize
}

/** Tests that a type is aligned to at least its size.

This property is not necessarily true for all integers; for instance, `u64` on
32-bit x86 is permitted to be 4-byte-aligned. `bitvec` requires this property to
hold for the pointer representation to correctly function.

# Type Parameters

- `T`: A type whose alignment and size are to be compared

# Returns

`0` if the alignment is at least the size; `1` if the alignment is less.
**/
#[doc(hidden)]
pub(crate) const fn aligned_to_size<T>() -> usize {
	(mem::align_of::<T>() < mem::size_of::<T>()) as usize
}

/** Tests whether two types have compatible layouts.

# Type Parameters

- `A`
- `B`

# Returns

Zero if `A` and `B` have equal alignments and sizes, non-zero if they do not.

# Uses

This function is designed to be used in the expression
`const CHECK: [(): 0] = [(); cmp_layout::<A, B>()];`. It will cause a compiler
error if the conditions do not hold.
**/
#[doc(hidden)]
pub(crate) const fn cmp_layout<A, B>() -> usize {
	(mem::align_of::<A>() != mem::align_of::<B>()) as usize
		+ (mem::size_of::<A>() != mem::size_of::<B>()) as usize
}

#[doc(hidden)]
mod seal {
	#[doc(hidden)]
	pub trait Sealed {}
}

#[cfg(test)]
mod tests {
	use super::*;
	use crate::access::*;

	#[test]
	fn integer_properties() {
		assert_eq!(aligned_to_size::<u8>(), 0);
		assert_eq!(aligned_to_size::<BitSafeU8>(), 0);
		assert_eq!(cmp_layout::<u8, BitSafeU8>(), 0);

		assert_eq!(aligned_to_size::<u16>(), 0);
		assert_eq!(aligned_to_size::<BitSafeU16>(), 0);
		assert_eq!(cmp_layout::<u16, BitSafeU16>(), 0);

		assert_eq!(aligned_to_size::<u32>(), 0);
		assert_eq!(aligned_to_size::<BitSafeU32>(), 0);
		assert_eq!(cmp_layout::<u32, BitSafeU32>(), 0);

		assert_eq!(aligned_to_size::<usize>(), 0);
		assert_eq!(aligned_to_size::<BitSafeUsize>(), 0);
		assert_eq!(cmp_layout::<usize, BitSafeUsize>(), 0);

		#[cfg(target_pointer_width = "64")]
		{
			assert_eq!(aligned_to_size::<u64>(), 0);
			assert_eq!(aligned_to_size::<BitSafeU64>(), 0);
			assert_eq!(cmp_layout::<u64, BitSafeU64>(), 0);
		}
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/mem.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/order.rs =====
/*! Ordering of bits within register elements.

[`bitvec`] data structures are parametric over any ordering of bits within a
register type. The [`BitOrder`] trait translates a cursor position (indicated by
the [`BitIdx`] type) to an electrical position (indicated by the [`BitPos`]
type) within that register, thereby defining the order of traversal over a
register.

Implementors of [`BitOrder`] are required to satisfy a set of requirements on
their transform function, and must have identical behavior to the
default-provided trait functions if they choose to override them for
performance. These can all be proven by use of the [`verify`] or
[`verify_for_type`] functions in the implementor’s test suite.

[`BitOrder`] is a stateless trait, and implementors should be zero-sized types.

[`BitIdx`]: crate::index::BitIdx
[`BitOrder`]: crate::order::BitOrder
[`BitPos`]: crate::index::BitPos
[`bitvec`]: crate
[`verify`]: crate::order::verify
[`verify_for_type`]: crate::order::verify_for_type
!*/

use crate::{
	index::{
		BitIdx,
		BitMask,
		BitPos,
		BitSel,
		BitTail,
	},
	mem::BitRegister,
};

/** An ordering over a register.

# Usage

[`bitvec`] structures store and operate on semantic index counters, not
electrical bit positions. The [`BitOrder::at`] function takes a semantic
ordering, [`BitIdx`], and produces a corresponding electrical position,
[`BitPos`].

# Safety

If your implementation violates any of the requirements on these functions, then
the program will become incorrect, and have unspecified behavior. The best-case
outcome is that operations relying on your implementation will crash the
program; the worst-case is that memory access will silently become corrupt.

You are responsible for adhering to the requirements of these functions. There
are verification functions that you can use in your test suite; however, it is
not yet possible to prove correctness at compile-time.

This is an `unsafe trait` to implement because you are responsible for upholding
the stated requirements.

The implementations of `BitOrder` are trusted to drive safe code, and once data
leaves a `BitOrder` implementation, it is considered safe to use as the basis
for interaction with memory.

# Verification

The [`verify`] and [`verify_for_type`] functions are available for your test
suites. They ensure that a `BitOrder` implementation satisfies the requirements
when invoked for a given register type.

# Examples

Implementations are not required to remain contiguous over a register. This
example swizzles the high and low halves of each byte, but any translation is
valid as long as it satisfies the strict one-to-one requirement of
index-to-position.
**/
///
/// ```rust
/// use bitvec::{
///   prelude::BitOrder,
///   // Additional symbols:
///   index::{BitIdx, BitPos},
///   mem::BitRegister,
/// };
///
/// pub struct HiLo;
/// unsafe impl BitOrder for HiLo {
///   fn at<R: BitRegister>(idx: BitIdx<R>) -> BitPos<R> {
///     BitPos::new(idx.into_inner() ^ 4).unwrap()
///   }
/// }
///
/// #[test]
/// #[cfg(test)]
/// fn prove_hilo() {
///   bitvec::order::verify::<HiLo>();
/// }
/// ```
///
/// [`BitIdx`]: crate::index::BitIdx
/// [`BitOrder::at`]: Self::at
/// [`BitPos`]: crate::index::BitPos
/// [`bitvec`]: crate
/// [`verify`]: crate::order::verify
/// [`verify_for_type`]: crate::order::verify_for_type
pub unsafe trait BitOrder: 'static {
	/// Converts a semantic bit index into an electrical bit position.
	///
	/// This function is the basis of the trait, and must adhere to a number of
	/// requirements in order for an implementation to be correct.
	///
	/// # Type Parameters
	///
	/// - `R`: The register type that the index and position govern.
	///
	/// # Parameters
	///
	/// - `index`: The semantic index of a bit within a register `R`.
	///
	/// # Returns
	///
	/// The electrical position of the indexed bit within the register `R`. See
	/// the [`BitPos`] documentation for what electrical positions are
	/// considered to mean.
	///
	/// # Requirements
	///
	/// This function must satisfy the following requirements for all possible
	/// input and output values, for all possible `R` type parameters:
	///
	/// ## Totality
	///
	/// This function must be able to accept every input in the range
	/// [`BitIdx::ZERO`] to [`BitIdx::LAST`], and produce a value in the same
	/// range as a [`BitPos`].
	///
	/// ## Bijection
	///
	/// There must be an exactly one-to-one correspondence between input value
	/// and output value. No input index may choose its output from a set of
	/// more than one position, and no output position may be produced by more
	/// than one input index.
	///
	/// ## Purity
	///
	/// The translation from index to position must be consistent for the
	/// lifetime of *at least* all data structures in the program. This function
	/// *may* refer to global state, but that state **must** be immutable while
	/// any [`bitvec`] data structures exist, and must not be used to violate
	/// the totality or bijection requirements.
	///
	/// ## Output Validity
	///
	/// The produced [`BitPos`] must be within the valid range of that type.
	/// Call sites of this function will not take any steps to constrain or
	/// check the return value. If you use `unsafe` code to produce an invalid
	/// `BitPos`, the program is incorrect, and will likely crash.
	///
	/// # Usage
	///
	/// This function is only ever called with input values in the valid
	/// [`BitIdx`] range. Implementors are not required to consider any values
	/// outside this range in their function body.
	///
	/// [`BitIdx`]: crate::index::BitIdx
	/// [`BitIdx::LAST`]: crate::index::BitIdx::LAST
	/// [`BitIdx::ZERO`]: crate::index::BitIdx::ZERO
	/// [`BitPos`]: crate::index::BitPos
	/// [`bitvec`]: crate
	fn at<R>(index: BitIdx<R>) -> BitPos<R>
	where R: BitRegister;

	/// Converts a semantic bit index into a one-hot selector mask.
	///
	/// This is an optional function; a default implementation is provided for
	/// you. If you choose to override it, your implementation **must** retain
	/// the behavior of the default implementation.
	///
	/// The default implementation calls [`Self::at`] to convert the index into
	/// a position, then turns that position into a selector mask with the
	/// expression `1 << pos`. `BitOrder` implementations may choose to provide
	/// a faster mask production here, as long as they match this behavior.
	///
	/// # Type Parameters
	///
	/// - `R`: The register type that the index and selector govern.
	///
	/// # Parameters
	///
	/// - `index`: The semantic index of a bit within a register `R`.
	///
	/// # Returns
	///
	/// A one-hot selector mask for the bit indicated by the index value.
	///
	/// # Requirements
	///
	/// A one-hot encoding means that there is exactly one bit set in the
	/// produced value. It must be equivalent to `1 << Self::at::<R>(index)`.
	///
	/// As with `at`, this function must produce a unique mapping from each
	/// legal index in the [`BitIdx`] domain to a one-hot value of `R`.
	///
	/// [`BitIdx`]: crate::index::BitIdx
	/// [`Self::at`]: Self::at
	#[inline]
	#[cfg(not(tarpaulin_include))]

	fn select<R>(index: BitIdx<R>) -> BitSel<R>
	where R: BitRegister {
		Self::at::<R>(index).select()
	}

	/// Constructs a multiple-bit selector mask for batched operations on a
	/// register `R`.
	///
	/// The default implementation of this function traverses the index range,
	/// converting each index into a single-bit selector with [`Self::select`]
	/// and accumulating into a combined register value.
	///
	/// # Type Parameters
	///
	/// - `R`: The register type for which the mask is built.
	///
	/// # Parameters
	///
	/// - `from`: The inclusive starting index for the mask.
	/// - `upto`: The exclusive ending index for the mask.
	///
	/// # Returns
	///
	/// A bit-mask with all bits corresponding to the input index range set high
	/// and all others set low.
	///
	/// # Requirements
	///
	/// This function must always be equivalent to this expression:
	///
	/// ```rust,ignore
	/// (from .. upto)
	///   .map(Self::select::<R>)
	///   .fold(0, |mask, sel| mask | sel)
	/// ```
	///
	/// [`Self::select`]: Self::select
	fn mask<R>(
		from: impl Into<Option<BitIdx<R>>>,
		upto: impl Into<Option<BitTail<R>>>,
	) -> BitMask<R>
	where
		R: BitRegister,
	{
		let (from, upto) = match (from.into(), upto.into()) {
			(None, None) => return BitMask::ALL,
			(Some(from), None) => (from, BitTail::LAST),
			(None, Some(upto)) => (BitIdx::ZERO, upto),
			(Some(from), Some(upto)) => (from, upto),
		};
		from.range(upto).map(Self::select::<R>).sum()
	}
}

/// Traverses a register from the least significant bit to the most significant.
#[derive(Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Lsb0;

unsafe impl BitOrder for Lsb0 {
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	fn at<R>(index: BitIdx<R>) -> BitPos<R>
	where R: BitRegister {
		unsafe { BitPos::new_unchecked(index.into_inner()) }
	}

	#[cfg_attr(not(tarpaulin_include), inline(always))]
	fn select<R>(index: BitIdx<R>) -> BitSel<R>
	where R: BitRegister {
		unsafe { BitSel::new_unchecked(R::ONE << index.into_inner()) }
	}

	#[inline]
	fn mask<R>(
		from: impl Into<Option<BitIdx<R>>>,
		upto: impl Into<Option<BitTail<R>>>,
	) -> BitMask<R>
	where
		R: BitRegister,
	{
		let from = from.into().unwrap_or(BitIdx::ZERO).into_inner();
		let upto = upto.into().unwrap_or(BitTail::LAST).into_inner();
		debug_assert!(
			from <= upto,
			"Ranges must run from low index ({}) to high ({})",
			from,
			upto
		);
		let ct = upto - from;
		if ct == R::BITS as u8 {
			return BitMask::ALL;
		}
		//  1. Set all bits in the mask high
		//  2. Shift left by the number of bits in the mask. The mask bits are
		//     at LSedge and low.
		//  3. Invert. The mask bits are at LSedge and high; all else are low.
		//  4. Shift left by the `from` distance from LSedge.
		BitMask::new(!(R::ALL << ct) << from)
	}
}

/// Traverses a register from the most significant bit to the least significant.
#[derive(Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Msb0;

unsafe impl BitOrder for Msb0 {
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	fn at<R>(index: BitIdx<R>) -> BitPos<R>
	where R: BitRegister {
		unsafe { BitPos::new_unchecked(R::MASK - index.into_inner()) }
	}

	#[cfg_attr(not(tarpaulin_include), inline(always))]
	fn select<R>(index: BitIdx<R>) -> BitSel<R>
	where R: BitRegister {
		/* Shift the MSbit down by the index count. This is not equivalent to
		the expression `1 << (mask - index)`, because that lowers to a
		subtraction followed by a rshift, while this lowers to a single rshift.
		*/
		let msbit: R = R::ONE << R::MASK;
		unsafe { BitSel::new_unchecked(msbit >> index.into_inner()) }
	}

	#[inline]
	fn mask<R>(
		from: impl Into<Option<BitIdx<R>>>,
		upto: impl Into<Option<BitTail<R>>>,
	) -> BitMask<R>
	where
		R: BitRegister,
	{
		let from = from.into().unwrap_or(BitIdx::ZERO).into_inner();
		let upto = upto.into().unwrap_or(BitTail::LAST).into_inner();
		debug_assert!(
			from <= upto,
			"Ranges must run from low index ({}) to high ({})",
			from,
			upto
		);
		let ct = upto - from;
		if ct == R::BITS as u8 {
			return BitMask::ALL;
		}
		//  1. Set all bits in the mask high.
		//  2. Shift right by the number of bits in the mask. The mask bits are
		// at MSedge and low.  3. Invert. The mask bits are at MSedge and high;
		// all else are low.  4. Shift right by the `from` distance from MSedge.
		BitMask::new(!(R::ALL >> ct) >> from)
	}
}

/** A default bit ordering.

Typically, your platform’s C compiler uses least-significant-bit-first ordering
for bitfields. The [`Lsb0`] bit ordering and little-endian byte ordering are
otherwise completely unrelated.

[`Lsb0`]: crate::order::Lsb0
**/
#[cfg(target_endian = "little")]
pub use self::Lsb0 as LocalBits;
/** A default bit ordering.

Typically, your platform’s C compiler uses most-significant-bit-first ordering
for bitfields. The [`Msb0`] bit ordering and big-endian byte ordering are
otherwise completely unrelated.

[`Msb0`]: crate::order::Msb0
**/
#[cfg(target_endian = "big")]
pub use self::Msb0 as LocalBits;

#[cfg(not(any(target_endian = "big", target_endian = "little")))]
compile_fail!(concat!(
	"This architecture is currently not supported. File an issue at ",
	env!(CARGO_PKG_REPOSITORY)
));

/** Verifies a [`BitOrder`] implementation’s adherence to the stated rules.

This function checks some [`BitOrder`] implementation’s behavior on each of the
[`BitRegister`] types it must handle, and reports any violation of the rules
that it detects.

# Type Parameters

- `O`: The [`BitOrder`] implementation to test.

# Parameters

- `verbose`: Sets whether the test should print diagnostic information to
  `stdout`.

# Panics

This panics if it detects any violation of the [`BitOrder`] implementation rules
for `O`.

[`BitOrder`]: crate::order::BitOrder
[`BitRegister`]: crate::mem::BitRegister
**/
#[inline(never)]
pub fn verify<O>(verbose: bool)
where O: BitOrder {
	verify_for_type::<O, u8>(verbose);
	verify_for_type::<O, u16>(verbose);
	verify_for_type::<O, u32>(verbose);
	verify_for_type::<O, usize>(verbose);

	#[cfg(target_pointer_width = "64")]
	verify_for_type::<O, u64>(verbose);
}

/** Verifies a [`BitOrder`] implementation’s adherence to the stated rules, for
one register type.

This function checks some [`BitOrder`] implementation against only one of the
[`BitRegister`] types that it will encounter. This is useful if you are
implementing an ordering that only needs to be concerned with a subset of the
types, and you know that you will never use it with the types it does not
support.

# Type Parameters

- `O`: The [`BitOrder`] implementation to test.
- `R`: The [`BitRegister`] type for which to test `O`.

# Parameters

- `verbose`: Sets whether the test should print diagnostic information to
  `stdout`.

# Panics

This panics if it detects any violation of the [`BitOrder`] implementation rules
for the combination of input types and index values.

[`BitOrder`]: crate::order::BitOrder
[`BitRegister`]: crate::mem::BitRegister
**/
#[inline(never)]
pub fn verify_for_type<O, R>(verbose: bool)
where
	O: BitOrder,
	R: BitRegister,
{
	use core::any::type_name;
	let mut accum = BitMask::<R>::ZERO;

	let oname = type_name::<O>();
	let mname = type_name::<R>();

	for n in 0 .. R::BITS as u8 {
		//  Wrap the counter as an index.
		let idx = unsafe { BitIdx::<R>::new_unchecked(n) };

		//  Compute the bit position for the index.
		let pos = O::at::<R>(idx);
		if verbose {
			#[cfg(feature = "std")]
			println!(
				"`<{} as BitOrder>::at::<{}>({})` produces {}",
				oname,
				mname,
				n,
				pos.into_inner(),
			);
		}

		//  If the computed position exceeds the valid range, fail.
		assert!(
			pos.into_inner() < R::BITS as u8,
			"Error when verifying the implementation of `BitOrder` for `{}`: \
			 Index {} produces a bit position ({}) that exceeds the type width \
			 {}",
			oname,
			n,
			pos.into_inner(),
			R::BITS,
		);

		//  Check `O`’s implementation of `select`
		let sel = O::select::<R>(idx);
		if verbose {
			#[cfg(feature = "std")]
			println!(
				"`<{} as BitOrder>::select::<{}>({})` produces {:b}",
				oname, mname, n, sel,
			);
		}

		//  If the selector bit is not one-hot, fail.
		assert_eq!(
			sel.into_inner().count_ones(),
			1,
			"Error when verifying the implementation of `BitOrder` for `{}`: \
			 Index {} produces a bit selector ({:b}) that is not a one-hot mask",
			oname,
			n,
			sel,
		);

		//  Check that the selection computed from the index matches the
		//  selection computed from the position.
		let shl = pos.select();
		//  If `O::select(idx)` does not produce `1 << pos`, fail.
		assert_eq!(
			sel,
			shl,
			"Error when verifying the implementation of `BitOrder` for `{}`: \
			 Index {} produces a bit selector ({:b}) that is not equal to `1 \
			 << {}` ({:b})",
			oname,
			n,
			sel,
			pos.into_inner(),
			shl,
		);

		//  Check that the produced selector bit has not already been added to
		//  the accumulator.
		assert!(
			!accum.test(sel),
			"Error when verifying the implementation of `BitOrder` for `{}`: \
			 Index {} produces a bit position ({}) that has already been \
			 produced by a prior index",
			oname,
			n,
			pos.into_inner(),
		);
		accum.insert(sel);
		if verbose {
			#[cfg(feature = "std")]
			println!(
				"`<{} as BitOrder>::at::<{}>({})` accumulates  {:b}",
				oname, mname, n, accum,
			);
		}
	}

	//  Check that all indices produced all positions.
	assert_eq!(
		accum,
		BitMask::ALL,
		"Error when verifying the implementation of `BitOrder` for `{}`: The \
		 bit positions marked with a `0` here were never produced from an \
		 index, despite all possible indices being passed in for translation: \
		 {:b}",
		oname,
		accum,
	);

	//  Check that `O::mask` is correct for all range combinations.
	for from in BitIdx::<R>::range_all() {
		for upto in BitTail::<R>::range_from(from) {
			let mask = O::mask(from, upto);
			let check = from
				.range(upto)
				.map(O::at)
				.map(BitPos::select)
				.sum::<BitMask<R>>();
			assert_eq!(
				mask,
				check,
				"Error when verifying the implementation of `BitOrder` for \
				 `{o}`: `{o}::mask::<{m}>({f}, {u})` produced {bad:b}, but \
				 expected {good:b}",
				o = oname,
				m = mname,
				f = from,
				u = upto,
				bad = mask,
				good = check,
			);
		}
	}
}

#[cfg(all(test, not(miri)))]
mod tests {
	use super::*;

	#[test]
	fn verify_impls() {
		verify::<Lsb0>(cfg!(feature = "testing"));
		verify::<Msb0>(cfg!(feature = "testing"));
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/order.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/prelude.rs =====
/*! [`bitvec`] symbol export.

This module collects the general public API into a single spot for inclusion, as
`use bitvec::prelude::*;`, without polluting the root namespace of the crate.

[`bitvec`]: crate
!*/

pub use crate::{
	array::BitArray,
	bitarr,
	bits,
	field::BitField as _,
	order::{
		BitOrder,
		LocalBits,
		Lsb0,
		Msb0,
	},
	ptr::{
		BitPtr,
		BitPtrRange,
		BitRef,
	},
	slice::BitSlice,
	store::BitStore,
	view::BitView as _,
	BitArr,
};
#[cfg(feature = "alloc")]
pub use crate::{
	bitbox,
	bitvec,
	boxed::BitBox,
	vec::BitVec,
};
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/prelude.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/ptr/address.rs =====
/*! Address management.

This module only provides utilities for requiring that `T: BitStore` addresses
are well aligned to their type. It also exports the type-level mutability
tracking behavior now provided by [`wyz::comu`].
!*/

use core::{
	any,
	fmt::{
		self,
		Debug,
		Display,
		Formatter,
		Pointer,
	},
	mem,
};

use tap::{
	Pipe,
	TryConv,
};
pub use wyz::comu::{
	Address,
	Const,
	Mut,
	Mutability,
	NullPtrError,
};
use wyz::FmtForward;

/// Ensures that an address is well-aligned to its referent type.
#[inline]
pub fn check_alignment<M, T>(
	addr: Address<M, T>,
) -> Result<Address<M, T>, MisalignError<T>>
where M: Mutability {
	let ptr = addr.to_const();
	let mask = mem::align_of::<T>() - 1;
	if ptr as usize & mask != 0 {
		Err(MisalignError { ptr })
	}
	else {
		Ok(addr)
	}
}

/// Extension methods for raw pointers.
pub(crate) trait AddressExt<T> {
	/// Tracks the original mutation capability of the source pointer.
	type Permission: Mutability;

	/// Forcibly wraps the raw pointer as an `Address`, without handling errors.
	///
	/// In debug builds, this will panic on null or misaligned pointers. In
	/// release builds, it is permitted to remove the error-handling codepaths
	/// and assume those invariants are upheld by the caller.
	///
	/// # Safety
	///
	/// The caller must ensure that this is only called on non-null,
	/// well-aligned, pointers. Pointers derived from Rust references or calls
	/// to the Rust allocator API will always satisfy this.
	unsafe fn force_wrap(self) -> Address<Self::Permission, T>;
}

impl<T> AddressExt<T> for *const T {
	type Permission = Const;

	unsafe fn force_wrap(self) -> Address<Const, T> {
		self.try_conv::<Address<_, _>>()
			//  Don’t call this with null pointers.
			.unwrap_or_else(|err| unreachable!("{}", err))
			.pipe(check_alignment)
			//  Don’t call this with misaligned pointers either.
			.unwrap_or_else(|err| unreachable!("{}", err))
	}
}

impl<T> AddressExt<T> for *mut T {
	type Permission = Mut;

	unsafe fn force_wrap(self) -> Address<Mut, T> {
		self.try_conv::<Address<_, _>>()
			.unwrap_or_else(|err| unreachable!("{}", err))
			.pipe(check_alignment)
			.unwrap_or_else(|err| unreachable!("{}", err))
	}
}

/// Error produced when an address is insufficiently aligned to its type.
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct MisalignError<T> {
	/// The misaligned pointer.
	pub ptr: *const T,
}

impl<T> MisalignError<T> {
	const ALIGN: usize = mem::align_of::<T>();
	const CTTZ: usize = Self::ALIGN.trailing_zeros() as usize;
}

impl<T> Debug for MisalignError<T> {
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		fmt.debug_tuple("Misalign")
			.field(&self.ptr.fmt_pointer())
			.field(&Self::ALIGN)
			.finish()
	}
}

impl<T> Display for MisalignError<T> {
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		write!(
			fmt,
			"Type {} requires {}-byte alignment: address ",
			any::type_name::<T>(),
			Self::ALIGN,
		)?;
		Pointer::fmt(&self.ptr, fmt)?;
		write!(fmt, " must clear its least {} bits", Self::CTTZ)
	}
}

unsafe impl<T> Send for MisalignError<T> {
}

unsafe impl<T> Sync for MisalignError<T> {
}

#[cfg(feature = "std")]
impl<T> std::error::Error for MisalignError<T> {
}

#[test]
#[cfg(feature = "alloc")]
fn render() {
	#[cfg(not(feature = "std"))]
	use alloc::format;
	use core::ptr::NonNull;

	assert_eq!(
		format!(
			"{}",
			check_alignment(Address::<Const, u16>::new(
				NonNull::new(0x13579 as *mut _).unwrap()
			))
			.unwrap_err()
		),
		"Type u16 requires 2-byte alignment: address 0x13579 must clear its \
		 least 1 bits"
	);
	assert_eq!(
		format!(
			"{}",
			check_alignment(Address::<Const, u32>::new(
				NonNull::new(0x13579 as *mut _).unwrap()
			))
			.unwrap_err()
		),
		"Type u32 requires 4-byte alignment: address 0x13579 must clear its \
		 least 2 bits"
	);
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/ptr/address.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/ptr/proxy.rs =====
/*! Proxy reference for `&mut bool`.

Rust does not allow assignment through a reference type to be anything other
than a direct load from or store to memory, using the value in the reference as
the memory address. As such, this module provides a proxy type which contains a
pointer to a single bit, and acts as a referential façade, similar to the C++
type [`std::bitset<N>::reference`].

[`std::bitset<N>::reference`]: https://en.cppreference.com/w/cpp/utility/bitset/reference
!*/

use core::{
	cell::Cell,
	cmp,
	fmt::{
		self,
		Debug,
		Display,
		Formatter,
		Pointer,
	},
	hash::{
		Hash,
		Hasher,
	},
	marker::PhantomData,
	mem,
	ops::{
		Deref,
		DerefMut,
		Not,
	},
};

use super::{
	BitPtr,
	Const,
	Mut,
	Mutability,
};
use crate::{
	order::{
		BitOrder,
		Lsb0,
	},
	store::BitStore,
};

/** A proxy reference, equivalent to C++ [`std::bitset<N>::reference`].

This type wraps a `BitPtr` and caches a `bool` in a padding byte. It is then
able to freely produce references to the cached bool, and commits the cache back
to the referent bit location on `drop`.

# Lifetimes

- `'a`: The lifetime of the source `&'a mut BitSlice` that created the `BitRef`.

# Type Parameters

- `M`: The write permission of the reference. When this is `Const`, the
  `DerefMut` implementation is removed, forbidding the proxy from writing back
  to memory.
- `O`: The ordering used to address a bit in memory.
- `T`: The storage type containing the referent bit.

# Quirks

Because this type has both a lifetime and a destructor, it can introduce an
uncommon error condition in Rust. When an expression that produces this type is
in the final expression of a block, including if that expression is used as a
condition in a `match`, `if let`, or `if`, then the compiler will attempt to
extend the drop scope of this type to the outside of the block. This causes a
lifetime mismatch error if the source region from which this proxy is produced
goes out of scope at the end of the block.

If you get a compiler error that this type causes something to be dropped while
borrowed, you can end the borrow by putting any expression-ending syntax element
after the offending expression that produces this type, including a semicolon or
an item definition.

# Examples

```rust
use bitvec::prelude::*;

let bits = bits![mut 0; 2];

let (left, right) = bits.split_at_mut(1);
let mut first = left.get_mut(0).unwrap();
let second = right.get_mut(0).unwrap();

// Referential behavior
*first = true;
// Direct write
second.set(true);

drop(first); // it’s not a reference!
assert_eq!(bits, bits![1; 2]);
```

[`std::bitset<N>::reference`]: https://en.cppreference.com/w/cpp/utility/bitset/reference
**/
// Restore alignemnt properties, since `BitPtr` does not have them.
#[cfg_attr(target_pointer_width = "32", repr(C, align(4)))]
#[cfg_attr(target_pointer_width = "64", repr(C, align(8)))]
#[cfg_attr(
	not(any(target_pointer_width = "32", target_pointer_width = "64")),
	repr(C)
)]
pub struct BitRef<'a, M, O = Lsb0, T = usize>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	/// The proxied address.
	bitptr: BitPtr<M, O, T>,
	/// A local, dereferencable, cache of the proxied bit.
	data: bool,
	/// Pad the structure out to be two words wide.
	_pad: [u8; PADDING],
	/// Attach the lifetime and possibility of mutation.
	_ref: PhantomData<&'a Cell<bool>>,
}

impl<M, O, T> BitRef<'_, M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	/// Converts a bit-pointer into a proxy bit-reference.
	///
	/// The conversion reads from the pointer, then stores the `bool` in a
	/// padding byte.
	///
	/// # Parameters
	///
	/// - `bitptr`: A bit-pointer to turn into a bit-reference.
	///
	/// # Returns
	///
	/// A bit-reference pointing at `bitptr`.
	///
	/// # Safety
	///
	/// The `bitptr` must address a location that is valid for reads and, if `M`
	/// is `Mut`, writes.
	#[inline]
	pub unsafe fn from_bitptr(bitptr: BitPtr<M, O, T>) -> Self {
		let data = bitptr.read();
		Self {
			bitptr,
			data,
			_pad: [0; PADDING],
			_ref: PhantomData,
		}
	}

	/// Removes an alias marking.
	///
	/// This is only safe when the proxy is known to be the only handle to its
	/// referent element during its lifetime.
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub(crate) unsafe fn remove_alias(this: BitRef<M, O, T::Alias>) -> Self {
		Self {
			bitptr: this.bitptr.cast::<T>(),
			data: this.data,
			_pad: [0; PADDING],
			_ref: PhantomData,
		}
	}

	/// Decays the bit-reference to an ordinary bit-pointer.
	///
	/// # Parameters
	///
	/// - `self`
	///
	/// # Returns
	///
	/// The interior bit-pointer, without the associated cache. If this was a
	/// write-capable pointer, then the cached bit is committed to memory before
	/// this method returns.
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn into_bitptr(self) -> BitPtr<M, O, T> {
		self.bitptr
	}
}

impl<O, T> BitRef<'_, Mut, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// Moves `src` into the referenced bit, returning the previous value.
	///
	/// # Original
	///
	/// [`mem::replace`](core::mem::replace)
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn replace(&mut self, src: bool) -> bool {
		mem::replace(&mut self.data, src)
	}

	/// Swaps the values at two mutable locations, without deïnitializing either
	/// one.
	///
	/// # Original
	///
	/// [`mem::swap`](core::mem::swap)
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn swap<O2, T2>(&mut self, other: &mut BitRef<Mut, O2, T2>)
	where
		O2: BitOrder,
		T2: BitStore,
	{
		mem::swap(&mut self.data, &mut other.data)
	}

	/// Writes a bit into the proxied location without an intermediate copy.
	///
	/// This function writes `value` directly into the proxied location, and
	/// does not store `value` in the proxy’s internal cache. This should be
	/// equivalent to the behavior seen when using ordinary [`DerefMut`]
	/// proxying, but the latter depends on compiler optimization.
	///
	/// # Parameters
	///
	/// - `self`: This destroys the proxy, as it becomes invalid when writing
	///   directly to the location without updating the cache.
	/// - `value`: The new bit to write into the proxied slot.
	///
	/// [`DerefMut`]: core::ops::DerefMut
	#[inline]
	pub fn set(mut self, value: bool) {
		self.write(value);
		mem::forget(self);
	}

	/// Commits a bit into memory.
	///
	/// This is the internal function used to drive `.set()` and `.drop()`.
	#[inline]
	fn write(&mut self, value: bool) {
		self.data = value;
		unsafe {
			self.bitptr.write(value);
		}
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Clone for BitRef<'_, Const, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn clone(&self) -> Self {
		Self { ..*self }
	}
}

/// Implement equality by comparing the proxied `bool` values.
impl<M, O, T> Eq for BitRef<'_, M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
}

/// Implement ordering by comparing the proxied `bool` values.
#[cfg(not(tarpaulin_include))]
impl<M, O, T> Ord for BitRef<'_, M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn cmp(&self, other: &Self) -> cmp::Ordering {
		self.data.cmp(&other.data)
	}
}

/// Test equality of proxy references by the value of their proxied bit.
///
/// To test equality by address, decay to a [`BitPtr`] with [`into_bitptr`].
///
/// [`BitPtr`]: crate::ptr::BitPtr
/// [`into_bitptr`]: Self::into_bitptr
#[cfg(not(tarpaulin_include))]
impl<M1, M2, O1, O2, T1, T2> PartialEq<BitRef<'_, M2, O2, T2>>
	for BitRef<'_, M1, O1, T1>
where
	M1: Mutability,
	M2: Mutability,
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline(always)]
	fn eq(&self, other: &BitRef<'_, M2, O2, T2>) -> bool {
		self.data == other.data
	}
}

#[cfg(not(tarpaulin_include))]
impl<M, O, T> PartialEq<bool> for BitRef<'_, M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn eq(&self, other: &bool) -> bool {
		self.data == *other
	}
}

#[cfg(not(tarpaulin_include))]
impl<M, O, T> PartialEq<&bool> for BitRef<'_, M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn eq(&self, other: &&bool) -> bool {
		self.data == **other
	}
}

/// Order proxy references by the value of their proxied bit.
///
/// To order by address, decay to a [`BitPtr`] with [`into_bitptr`].
///
/// [`BitPtr`]: crate::ptr::BitPtr
/// [`into_bitptr`]: Self::into_bitptr
#[cfg(not(tarpaulin_include))]
impl<M1, M2, O1, O2, T1, T2> PartialOrd<BitRef<'_, M2, O2, T2>>
	for BitRef<'_, M1, O1, T1>
where
	M1: Mutability,
	M2: Mutability,
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline(always)]
	fn partial_cmp(
		&self,
		other: &BitRef<'_, M2, O2, T2>,
	) -> Option<cmp::Ordering> {
		self.data.partial_cmp(&other.data)
	}
}

#[cfg(not(tarpaulin_include))]
impl<M, O, T> PartialOrd<bool> for BitRef<'_, M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn partial_cmp(&self, other: &bool) -> Option<cmp::Ordering> {
		self.data.partial_cmp(other)
	}
}

#[cfg(not(tarpaulin_include))]
impl<M, O, T> PartialOrd<&bool> for BitRef<'_, M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn partial_cmp(&self, other: &&bool) -> Option<cmp::Ordering> {
		self.data.partial_cmp(*other)
	}
}

impl<M, O, T> Debug for BitRef<'_, M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		unsafe { self.bitptr.span_unchecked(1) }
			.render(fmt, "Ref", &[("bit", &self.data as &dyn Debug)])
	}
}

#[cfg(not(tarpaulin_include))]
impl<M, O, T> Display for BitRef<'_, M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		Display::fmt(&self.data, fmt)
	}
}

#[cfg(not(tarpaulin_include))]
impl<M, O, T> Pointer for BitRef<'_, M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		Pointer::fmt(&self.bitptr, fmt)
	}
}

#[cfg(not(tarpaulin_include))]
impl<M, O, T> Hash for BitRef<'_, M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn hash<H>(&self, state: &mut H)
	where H: Hasher {
		self.bitptr.hash(state);
	}
}

// This cannot be implemented until `Drop` is specialized to only
// `<Mut, O, T>`.
// impl<O, T> Copy for BitRef<'_, Const, O, T>
// where O: BitOrder, T: BitStore {}

#[cfg(not(tarpaulin_include))]
impl<M, O, T> Deref for BitRef<'_, M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	type Target = bool;

	#[inline(always)]
	fn deref(&self) -> &Self::Target {
		&self.data
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> DerefMut for BitRef<'_, Mut, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn deref_mut(&mut self) -> &mut Self::Target {
		&mut self.data
	}
}

impl<M, O, T> Drop for BitRef<'_, M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	fn drop(&mut self) {
		//  `Drop` cannot specialize, but only mutable proxies can commit to
		//  memory.
		if M::CONTAINS_MUTABILITY {
			unsafe {
				self.bitptr.assert_mut().write(self.data);
			}
		}
	}
}

#[cfg(not(tarpaulin_include))]
impl<M, O, T> Not for BitRef<'_, M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	type Output = bool;

	#[inline(always)]
	fn not(self) -> Self::Output {
		!self.data
	}
}

/// Compute the padding needed to make a packed `(BitPtr, bool)` tuple as wide
/// as a `(*const _, usize)` tuple.
const PADDING: usize = mem::size_of::<*const u8>() + mem::size_of::<usize>()
	- mem::size_of::<BitPtr<Const, Lsb0, usize>>()
	- mem::size_of::<bool>();

#[cfg(test)]
mod tests {
	use super::*;

	#[test]
	fn proxy_ref() {
		let bits = bits![mut 0; 2];
		assert!(bits.not_any());

		let mut proxy = bits.first_mut().unwrap();
		*proxy = true;

		//  We can inspect the cache, but `proxy` locks the entire `bits` for
		//  the duration of its binding, so we cannot observe that the cache is
		//  not written into the main buffer.
		assert!(*proxy);
		drop(proxy);

		//  The proxy commits the cache on drop, releasing its lock on the main
		//  buffer, permitting us to see that the writeback occurred.
		assert!(bits[0]);

		let proxy = bits.get_mut(1).unwrap();
		proxy.set(true);
		assert!(bits[1]);
	}

	#[test]
	#[cfg(feature = "alloc")]
	fn format() {
		#[cfg(not(feature = "std"))]
		use alloc::format;

		use crate::order::Msb0;

		let bits = bits![mut Msb0, u8; 0];
		let mut bit = bits.get_mut(0).unwrap();

		let text = format!("{:?}", bit);
		assert!(text.starts_with("BitRef<bitvec::order::Msb0, u8> { addr: 0x"));
		assert!(text.ends_with(", head: 000, bits: 1, bit: false }"));
		*bit = true;
		let text = format!("{:?}", bit);
		assert!(text.starts_with("BitRef<bitvec::order::Msb0, u8> { addr: 0x"));
		assert!(text.ends_with(", head: 000, bits: 1, bit: true }"));
	}

	#[test]
	fn assert_size() {
		assert_eq!(
			mem::size_of::<BitRef<'static, Const, Lsb0, u8>>(),
			2 * mem::size_of::<usize>(),
		);

		assert_eq!(
			mem::align_of::<BitRef<'static, Const, Lsb0, u8>>(),
			mem::align_of::<*const u8>(),
		);
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/ptr/proxy.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/ptr/range.rs =====
//! Implementation of `Range<BitPtr>`.

use core::{
	fmt::{
		self,
		Debug,
		Formatter,
		Pointer,
	},
	hash::{
		Hash,
		Hasher,
	},
	iter::FusedIterator,
	ops::{
		Bound,
		Range,
		RangeBounds,
	},
};

#[cfg(feature = "alloc")]
use super::Mut;
use super::{
	BitPtr,
	BitSpan,
	Mutability,
};
use crate::{
	devel as dvl,
	order::{
		BitOrder,
		Lsb0,
	},
	store::BitStore,
};

/** Equivalent to `Range<BitPtr<M, O, T>>`.

As with `Range`, this is a half-open set: the starting pointer is included in
the set of live addresses, while the ending pointer is one-past-the-end of live
addresses, and is not usable.

This structure exists because `Range` does not permit foreign implementations of
its internal traits.

# Original

[`Range<*bool>`](core::ops::Range)

# API Differences

This cannot be constructed directly from the `..` syntax, though a `From`
implementation is provided.

# Type Parameters

- `M`: The write permissions of the pointers this range produces.
- `O`: The bit-ordering within a storage element used to access bits.
- `T`: The storage element type containing the referent bits.
**/
// Restore alignemnt properties, since `BitPtr` does not have them.
#[cfg_attr(target_pointer_width = "32", repr(C, align(4)))]
#[cfg_attr(target_pointer_width = "64", repr(C, align(8)))]
#[cfg_attr(
	not(any(target_pointer_width = "32", target_pointer_width = "64")),
	repr(C)
)]
pub struct BitPtrRange<M, O = Lsb0, T = usize>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	/// The lower bound of the range (inclusive).
	pub start: BitPtr<M, O, T>,
	/// The higher bound of the range (exclusive).
	pub end: BitPtr<M, O, T>,
}

impl<M, O, T> BitPtrRange<M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	/// The canonical empty range. All ranges with zero length are equally
	/// empty.
	pub const EMPTY: Self = Self {
		start: BitPtr::DANGLING,
		end: BitPtr::DANGLING,
	};

	/// Destructures the range back into its start and end pointers.
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn raw_parts(&self) -> (BitPtr<M, O, T>, BitPtr<M, O, T>) {
		(self.start, self.end)
	}

	/// Converts the structure into an actual `Range`. The `Range` will have
	/// limited functionality compared to `self`.
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn into_range(self) -> Range<BitPtr<M, O, T>> {
		self.start .. self.end
	}

	/// Tests if the range is empty (the distance between pointers is `0`).
	///
	/// # Original
	///
	/// [`Range::is_empty`](core::ops::Range::is_empty)
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	/// use bitvec::ptr::BitPtrRange;
	///
	/// let data = 0u8;
	/// let ptr = BitPtr::<_, Lsb0, _>::from_ref(&data);
	/// let mut range = unsafe { ptr.range(1) };
	///
	/// assert!(!range.is_empty());
	/// range.next();
	/// assert!(range.is_empty());
	/// ```
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn is_empty(&self) -> bool {
		self.start == self.end
	}

	/// Returns `true` if the `pointer` is contained in the range.
	///
	/// # Original
	///
	/// [`Range::contains`](core::ops::Range::contains)
	///
	/// # API Differences
	///
	/// The candidate pointer may differ in mutability permissions and exact
	/// storage type.
	///
	/// If `T2::Mem` is not `T::Mem`, then this always returns `false`. If `T2`
	/// and `T` have the same memory type, but different alias permissions, then
	/// the comparison can continue.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	/// use bitvec::ptr::BitPtrRange;
	/// use core::cell::Cell;
	///
	/// let data = 0u16;
	/// let ptr = BitPtr::<_, Lsb0, _>::from_ref(&data);
	///
	/// let mut range = unsafe { ptr.range(16) };
	/// // Reduce the range contents.
	/// range.nth(2);
	/// range.nth_back(2);
	///
	/// // The start pointer is now excluded, but the interior remains.
	/// assert!(!range.contains(&ptr));
	/// assert!(range.contains(&unsafe { ptr.add(8) }));
	///
	/// // Different base types are always excluded.
	/// let casted = ptr.cast::<u8>();
	/// assert!(!range.contains(&unsafe { casted.add(8) }));
	///
	/// // Casting to a different alias model with the same width is valid.
	/// let casted = ptr.cast::<Cell<u16>>();
	/// assert!(range.contains(&unsafe { casted.add(8) }));
	/// ```
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn contains<M2, T2>(&self, pointer: &BitPtr<M2, O, T2>) -> bool
	where
		M2: Mutability,
		T2: BitStore,
	{
		self.start <= *pointer && *pointer < self.end
	}

	/// Converts the pair into a single span descriptor over all included bits.
	///
	/// The produced span does *not* include the bit addressed by the end
	/// pointer, as this is an exclusive range.
	#[inline]
	pub(crate) fn into_bitspan(self) -> BitSpan<M, O, T> {
		unsafe { self.start.span_unchecked(self.len()) }
	}

	/// Snapshots the current start pointer for return, then increments the
	/// start.
	///
	/// This method may only be called when the range is non-empty.
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	fn take_front(&mut self) -> BitPtr<M, O, T> {
		let start = self.start;
		self.start = unsafe { start.add(1) };
		start
	}

	/// Decrements the current end pointer, then returns it.
	///
	/// This method may only be called when the range is non-empty.
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	fn take_back(&mut self) -> BitPtr<M, O, T> {
		let prev = unsafe { self.end.sub(1) };
		self.end = prev;
		prev
	}
}

#[cfg(not(tarpaulin_include))]
impl<M, O, T> Clone for BitPtrRange<M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn clone(&self) -> Self {
		Self { ..*self }
	}
}

impl<M, O, T> Eq for BitPtrRange<M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
}

#[cfg(not(tarpaulin_include))]
impl<M1, M2, O, T1, T2> PartialEq<BitPtrRange<M2, O, T2>>
	for BitPtrRange<M1, O, T1>
where
	M1: Mutability,
	M2: Mutability,
	O: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline(always)]
	fn eq(&self, other: &BitPtrRange<M2, O, T2>) -> bool {
		if !dvl::match_store::<T1::Mem, T2::Mem>() {
			return false;
		}
		self.start == other.start && self.end == other.end
	}
}

#[cfg(not(tarpaulin_include))]
impl<M, O, T> Default for BitPtrRange<M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn default() -> Self {
		Self::EMPTY
	}
}

#[cfg(not(tarpaulin_include))]
impl<M, O, T> From<Range<BitPtr<M, O, T>>> for BitPtrRange<M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn from(Range { start, end }: Range<BitPtr<M, O, T>>) -> Self {
		Self { start, end }
	}
}

#[cfg(not(tarpaulin_include))]
impl<M, O, T> From<BitPtrRange<M, O, T>> for Range<BitPtr<M, O, T>>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn from(bpr: BitPtrRange<M, O, T>) -> Self {
		bpr.into_range()
	}
}

#[cfg(not(tarpaulin_include))]
impl<M, O, T> Debug for BitPtrRange<M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		let (start, end) = self.raw_parts();
		Pointer::fmt(&start, fmt)?;
		write!(fmt, "{0}..{0}", if fmt.alternate() { " " } else { "" })?;
		Pointer::fmt(&end, fmt)
	}
}

#[cfg(not(tarpaulin_include))]
impl<M, O, T> Hash for BitPtrRange<M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn hash<H>(&self, state: &mut H)
	where H: Hasher {
		self.start.hash(state);
		self.end.hash(state);
	}
}

impl<M, O, T> Iterator for BitPtrRange<M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	type Item = BitPtr<M, O, T>;

	#[inline]
	fn next(&mut self) -> Option<Self::Item> {
		if Self::is_empty(&*self) {
			return None;
		}
		Some(self.take_front())
	}

	#[inline]
	fn nth(&mut self, n: usize) -> Option<Self::Item> {
		if n >= self.len() {
			self.start = self.end;
			return None;
		}
		self.start = unsafe { self.start.add(n) };
		Some(self.take_front())
	}

	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	fn size_hint(&self) -> (usize, Option<usize>) {
		let len = self.len();
		(len, Some(len))
	}

	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	fn count(self) -> usize {
		self.len()
	}

	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	fn last(mut self) -> Option<Self::Item> {
		self.next_back()
	}
}

impl<M, O, T> DoubleEndedIterator for BitPtrRange<M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn next_back(&mut self) -> Option<Self::Item> {
		if Self::is_empty(&*self) {
			return None;
		}
		Some(self.take_back())
	}

	#[inline]
	fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
		if n >= self.len() {
			self.end = self.start;
			return None;
		}
		let out = unsafe { self.end.sub(n.wrapping_add(1)) };
		self.end = out;
		Some(out)
	}
}

impl<M, O, T> ExactSizeIterator for BitPtrRange<M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	fn len(&self) -> usize {
		(unsafe { self.end.offset_from(self.start) }) as usize
	}
}

impl<M, O, T> FusedIterator for BitPtrRange<M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
}

#[cfg(not(tarpaulin_include))]
impl<M, O, T> RangeBounds<BitPtr<M, O, T>> for BitPtrRange<M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn start_bound(&self) -> Bound<&BitPtr<M, O, T>> {
		Bound::Included(&self.start)
	}

	#[inline(always)]
	fn end_bound(&self) -> Bound<&BitPtr<M, O, T>> {
		Bound::Excluded(&self.end)
	}
}

/// Dereferences the bit-pointer. This is guaranteed to be valid by the
/// iterator.
#[inline(always)]
#[cfg(feature = "alloc")]
pub(crate) fn read_raw<O, T>(bp: BitPtr<Mut, O, T>) -> bool
where
	O: BitOrder,
	T: BitStore,
{
	unsafe { bp.read() }
}

#[cfg(test)]
mod tests {
	use core::mem::size_of;

	use super::*;
	use crate::{
		order::Lsb0,
		ptr::Const,
	};

	#[test]
	fn assert_size() {
		assert!(
			size_of::<BitPtrRange<Const, Lsb0, u8>>() <= 3 * size_of::<usize>()
		);
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/ptr/range.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/ptr/single.rs =====
//! A pointer to a single bit.

use core::{
	any,
	cmp,
	convert::{
		Infallible,
		TryFrom,
		TryInto,
	},
	fmt::{
		self,
		Debug,
		Display,
		Formatter,
		Pointer,
	},
	hash::{
		Hash,
		Hasher,
	},
	marker::PhantomData,
	ptr,
};

use funty::IsNumber;
use wyz::{
	comu::Frozen,
	fmt::FmtForward,
};

use super::{
	Address,
	AddressExt,
	BitPtrRange,
	BitRef,
	BitSpan,
	BitSpanError,
	Const,
	MisalignError,
	Mut,
	Mutability,
	NullPtrError,
};
use crate::{
	access::BitAccess,
	devel as dvl,
	index::{
		BitIdx,
		BitIdxError,
	},
	order::{
		BitOrder,
		Lsb0,
	},
	store::BitStore,
};

/** Pointer to an individual bit in a memory element. Analagous to `*bool`.

# Original

[`*bool`](https://doc.rust-lang.org/std/primitive.pointer.html) and
[`NonNull<bool>`](core::ptr::NonNull)

# API Differences

This must be a structure, rather than a raw pointer, for two reasons:

- It is larger than a raw pointer.
- Raw pointers are not `#[fundamental]` and cannot have foreign implementations.

Additionally, rather than create two structures to map to `*const bool` and
`*mut bool`, respectively, this takes mutability as a type parameter.

Because the encoded span pointer requires that memory addresses are well
aligned, this type also imposes the alignment requirement and refuses
construction for misaligned element addresses. While this type is used in the
API equivalent of ordinary raw pointers, it is restricted in value to only be
*references* to memory elements.

# ABI Differences

This has alignment `1`, rather than an alignment to the processor word. This is
necessary for some crate-internal optimizations.

# Type Parameters

- `M`: Marks whether the pointer permits mutation of memory through it.
- `O`: The ordering of bits within a memory element.
- `T`: A memory type used to select both the register size and the access
  behavior when performing loads/stores.

# Usage

This structure is used as the [`bitvec`] equivalent to `*bool`. It is used in
all raw-pointer APIs, and provides behavior to emulate raw pointers. It cannot
be directly dereferenced, as it is not a pointer; it can only be transformed
back into higher referential types, or used in [`bitvec::ptr`] free functions.

These pointers can never be null, or misaligned.

[`bitvec`]: crate
[`bitvec::ptr`]: crate::ptr
**/
#[repr(C, packed)]
pub struct BitPtr<M, O = Lsb0, T = usize>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	/// Memory addresses must be well-aligned and non-null.
	addr: Address<M, T>,
	/// The index of the referent bit within `*addr`.
	head: BitIdx<T::Mem>,
	/// The ordering used to select the bit at `head` in `*addr`.
	_ord: PhantomData<O>,
}

impl<M, O, T> BitPtr<M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	/// The dangling pointer. This selects the starting bit of the `T` dangling
	/// address.
	pub const DANGLING: Self = Self {
		addr: Address::DANGLING,
		head: BitIdx::ZERO,
		_ord: PhantomData,
	};

	/// Loads the address field, sidestepping any alignment problems.
	///
	/// This is the only safe way to access `(&self).addr`. Do not perform field
	/// access on `.addr` through a reference except through this method.
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub(crate) fn get_addr(&self) -> Address<M, T> {
		unsafe { ptr::addr_of!(self.addr).read_unaligned() }
	}

	/// Tries to construct a `BitPtr` from a memory location and a bit index.
	///
	/// # Type Parameters
	///
	/// - `A`: This accepts anything that may be used as a memory address.
	///
	/// # Parameters
	///
	/// - `addr`: The memory address to use in the `BitPtr`. If this value
	///   violates the [`Address`] rules, then its conversion error will be
	///   returned.
	/// - `head`: The index of the bit in `*addr` that this pointer selects. If
	///   this value violates the [`BitIdx`] rules, then its conversion error
	///   will be returned.
	///
	/// # Returns
	///
	/// A new `BitPtr`, selecting the memory location `addr` and the bit `head`.
	/// If either `addr` or `head` are invalid values, then this propagates
	/// their error.
	///
	/// [`Address`]: crate::ptr::Address
	/// [`BitIdx`]: crate::index::BitIdx
	#[inline]
	pub fn try_new<A>(addr: A, head: u8) -> Result<Self, BitPtrError<T>>
	where
		A: TryInto<Address<M, T>>,
		BitPtrError<T>: From<A::Error>,
	{
		Ok(Self::new(addr.try_into()?, BitIdx::new(head)?))
	}

	/// Constructs a `BitPtr` from a memory location and a bit index.
	///
	/// Since this requires that the address and bit index are already
	/// well-formed, it can assemble the `BitPtr` without inspecting their
	/// values.
	///
	/// # Parameters
	///
	/// - `addr`: A well-formed memory address of `T`.
	/// - `head`: A well-formed bit index within `T`.
	///
	/// # Returns
	///
	/// A `BitPtr` selecting the `head` bit in the location `addr`.
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn new(addr: Address<M, T>, head: BitIdx<T::Mem>) -> Self {
		Self {
			addr,
			head,
			_ord: PhantomData,
		}
	}

	/// Decomposes the pointer into its element address and bit index.
	///
	/// # Parameters
	///
	/// - `self`
	///
	/// # Returns
	///
	/// - `.0`: The memory address in which the referent bit is located.
	/// - `.1`: The index of the referent bit within `*.0`.
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn raw_parts(self) -> (Address<M, T>, BitIdx<T::Mem>) {
		(self.addr, self.head)
	}

	/// Gets just the head counter.
	#[inline(always)]
	#[cfg(feature = "alloc")]
	pub(crate) fn head(self) -> BitIdx<T::Mem> {
		self.head
	}

	/// Produces a `BitSpan`, starting at `self` and running for `bits`.
	///
	/// # Parameters
	///
	/// - `self`: The base bit-address of the returned span descriptor.
	/// - `bits`: The length in bits of the returned span descriptor.
	///
	/// # Returns
	///
	/// This returns an error if the combination of `self` and `bits` violates
	/// any of `BitSpan`’s requirements; otherwise, it encodes `self` and `bits`
	/// into a span descriptor and returns it. Conversion into a `BitSlice`
	/// pointer or reference is left to the caller.
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub(crate) fn span(
		self,
		bits: usize,
	) -> Result<BitSpan<M, O, T>, BitSpanError<T>> {
		BitSpan::new(self.addr, self.head, bits)
	}

	/// Produces a `BitSpan`, starting at `self` and running for `bits`.
	///
	/// This does not perform any validity checking; it only encodes the
	/// arguments into a `BitSpan`.
	///
	/// # Parameters
	///
	/// - `self`: The base bit-address of the returned span descriptor.
	/// - `bits`: The length in bits of the returned span descriptor.
	///
	/// # Retuns
	///
	/// `self` and `bits` encoded into a `BitSpan`. This `BitSpan` may be
	/// semantically invalid, and it may have modulated its length.
	///
	/// # Safety
	///
	/// This should only be called with values that had previously been
	/// extracted from a `BitSpan`.
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub(crate) unsafe fn span_unchecked(self, bits: usize) -> BitSpan<M, O, T> {
		BitSpan::new_unchecked(self.addr, self.head, bits)
	}

	/// Produces a pointer range starting at `self` and running for `count`
	/// bits.
	///
	/// This calls `self.add(count)`, then bundles the resulting pointer as the
	/// high end of the produced range.
	///
	/// # Parameters
	///
	/// - `self`: The starting pointer of the produced range.
	/// - `count`: The number of bits that the produced range includes.
	///
	/// # Returns
	///
	/// A half-open range of pointers, beginning at (and including) `self`,
	/// running for `count` bits, and ending at (and excluding)
	/// `self.add(count)`.
	///
	/// # Safety
	///
	/// `count` cannot violate the constraints in [`add`].
	///
	/// [`add`]: Self::add
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub unsafe fn range(self, count: usize) -> BitPtrRange<M, O, T> {
		BitPtrRange {
			start: self,
			end: self.add(count),
		}
	}

	/// Converts a bit-pointer into a proxy bit-reference.
	///
	/// # Safety
	///
	/// The pointer must be valid to dereference.
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub unsafe fn into_bitref<'a>(self) -> BitRef<'a, M, O, T> {
		BitRef::from_bitptr(self)
	}

	/// Removes write permissions from a bit-pointer.
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn immut(self) -> BitPtr<Const, O, T> {
		let Self { addr, head, .. } = self;
		BitPtr {
			addr: addr.immut(),
			head,
			..BitPtr::DANGLING
		}
	}

	/// Adds write permissions to a bit-pointer.
	///
	/// # Safety
	///
	/// This pointer must have been derived from a `*mut` pointer.
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub unsafe fn assert_mut(self) -> BitPtr<Mut, O, T> {
		let Self { addr, head, .. } = self;
		BitPtr {
			addr: addr.assert_mut(),
			head,
			..BitPtr::DANGLING
		}
	}

	/// Freezes the pointer, forbidding direct mutation.
	///
	/// This is used as a necessary prerequisite to all mutation of memory.
	/// `BitPtr` uses an implementation scoped to `Frozen<_>` to perform
	/// alias-aware writes; see below.
	#[inline]
	pub(crate) fn freeze(self) -> BitPtr<Frozen<M>, O, T> {
		let Self { addr, head, .. } = self;
		BitPtr {
			addr: addr.freeze(),
			head,
			..BitPtr::DANGLING
		}
	}

	//  `pointer` inherent API

	/// Tests if a bit-pointer is the null value.
	///
	/// This is always false, as `BitPtr` is a `NonNull` internally. Use
	/// `Option<BitPtr>` to express the potential for a null pointer.
	///
	/// # Original
	///
	/// [`pointer::is_null`](https://doc.rust-lang.org/std/primitive.pointer.html#method.is_null)
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	#[deprecated = "`BitPtr` is never null"]
	pub fn is_null(self) -> bool {
		false
	}

	/// Casts to a bit-pointer of another storage type, preserving the
	/// bit-ordering and mutability permissions.
	///
	/// # Original
	///
	/// [`pointer::cast`](https://doc.rust-lang.org/std/primitive.pointer.html#method.cast)
	///
	/// # Behavior
	///
	/// This is not a free typecast! It encodes the pointer as a crate-internal
	/// span descriptor, casts the span descriptor to the `U` storage element
	/// parameter, then decodes the result. This preserves general correctness,
	/// but will likely change both the virtual and physical bits addressed by
	/// this pointer.
	#[inline]
	pub fn cast<U>(self) -> BitPtr<M, O, U>
	where U: BitStore {
		let (addr, head, _) =
			unsafe { self.span_unchecked(1) }.cast::<U>().raw_parts();
		BitPtr::new(addr, head)
	}

	/// Produces a proxy reference to the referent bit.
	///
	/// Because `BitPtr` is a non-null, well-aligned, pointer, this never
	/// returns `None`.
	///
	/// # Original
	///
	/// [`pointer::as_ref`](https://doc.rust-lang.org/std/primitive.pointer.html#method.as_ref)
	///
	/// # API Differences
	///
	/// This produces a proxy type rather than a true reference. The proxy
	/// implements `Deref<Target = bool>`, and can be converted to `&bool` with
	/// `&*`.
	///
	/// # Safety
	///
	/// Since `BitPtr` does not permit null or misaligned pointers, this method
	/// will always dereference the pointer and you must ensure the following
	/// conditions are met:
	///
	/// - the pointer must be dereferencable as defined in the standard library
	///   documentation
	/// - the pointer must point to an initialized instance of `T`
	/// - you must ensure that no other pointer will race to modify the referent
	///   location while this call is reading from memory to produce the proxy
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let data = 1u8;
	/// let ptr = BitPtr::<_, Lsb0, _>::from_ref(&data);
	/// let val = unsafe { ptr.as_ref() }.unwrap();
	/// assert!(*val);
	/// ```
	#[inline]
	pub unsafe fn as_ref<'a>(self) -> Option<BitRef<'a, Const, O, T>> {
		Some(BitRef::from_bitptr(self.immut()))
	}

	/// Calculates the offset from a pointer.
	///
	/// `count` is in units of bits.
	///
	/// # Original
	///
	/// [`pointer::offset`](https://doc.rust-lang.org/std/primitive.pointer.html#method.offset)
	///
	/// # Safety
	///
	/// If any of the following conditions are violated, the result is Undefined
	/// Behavior:
	///
	/// - Both the starting and resulting pointer must be either in bounds or
	///   one byte past the end of the same allocated object. Note that in Rust,
	///   every (stack-allocated) variable is considered a separate allocated
	///   object.
	/// - The computed offset, **in bytes**, cannot overflow an `isize`.
	/// - The offset being in bounds cannot rely on “wrapping around” the
	///   address space. That is, the infinite-precision sum, **in bytes** must
	///   fit in a `usize`.
	///
	/// These pointers are almost always derived from [`BitSlice`] regions,
	/// which have an encoding limitation that the high three bits of the length
	/// counter are zero, so `bitvec` pointers are even less likely than
	/// ordinary pointers to run afoul of these limitations.
	///
	/// Use [`wrapping_offset`] if you expect to risk hitting the high edge of
	/// the address space.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let data = 5u8;
	/// let ptr = BitPtr::<_, Lsb0, _>::from_ref(&data);
	/// assert!(unsafe { ptr.read() });
	/// assert!(!unsafe { ptr.offset(1).read() });
	/// assert!(unsafe { ptr.offset(2).read() });
	/// ```
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	/// [`wrapping_offset`]: Self::wrapping_offset
	#[inline]
	pub unsafe fn offset(self, count: isize) -> Self {
		let (elts, head) = self.head.offset(count);
		Self::new(self.addr.offset(elts), head)
	}

	/// Calculates the offset from a pointer using wrapping arithmetic.
	///
	/// `count` is in units of bits.
	///
	/// # Original
	///
	/// [`pointer::wrapping_offset`](https://doc.rust/lang.org/std/primitive.pointer.html#method.wrapping_offset)
	///
	/// # Safety
	///
	/// The resulting pointer does not need to be in bounds, but it is
	/// potentially hazardous to dereference.
	///
	/// In particular, the resulting pointer remains attached to the same
	/// allocated object that `self` points to. It may *not* be used to access a
	/// different allocated object. Note that in Rust, every (stack-allocated)
	/// variable is considered a separate allocated object.
	///
	/// In other words, `x.wrapping_offset((y as usize).wrapping_sub(x as
	/// usize)` is not the same as `y`, and dereferencing it is undefined
	/// behavior unless `x` and `y` point into the same allocated object.
	///
	/// Compared to [`offset`], this method basically delays the requirement of
	/// staying within the same allocated object: [`offset`] is immediate
	/// Undefined Behavior when crossing object boundaries; `wrapping_offset`
	/// produces a pointer but still leads to Undefined Behavior if that pointer
	/// is dereferenced. [`offset`] can be optimized better and is thus
	/// preferable in performance-sensitive code.
	///
	/// If you need to cross object boundaries, destructure this pointer into
	/// its base address and bit index, cast the base address to an integer, and
	/// do the arithmetic in the purely integer space.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let data = 0u8;
	/// let mut ptr = BitPtr::<_, Lsb0, _>::from_ref(&data);
	/// let end = ptr.wrapping_offset(8);
	/// while ptr < end {
	///   # #[cfg(feature = "std")] {
	///   println!("{}", unsafe { ptr.read() });
	///   # }
	///   ptr = ptr.wrapping_offset(3);
	/// }
	/// ```
	///
	/// [`offset`]: Self::offset
	#[inline]
	pub fn wrapping_offset(self, count: isize) -> Self {
		let (elts, head) = self.head.offset(count);
		Self::new(self.addr.wrapping_offset(elts), head)
	}

	/// Calculates the distance between two pointers. The returned value is in
	/// units of bits.
	///
	/// This function is the inverse of [`offset`].
	///
	/// # Original
	///
	/// [`pointer::offset`](https://doc.rust-lang.org/std/primitive.pointer.html#method.offset_from)
	///
	/// # Safety
	///
	/// If any of the following conditions are violated, the result is Undefined
	/// Behavior:
	///
	/// - Both the starting and other pointer must be either in bounds or one
	///   byte past the end of the same allocated object. Note that in Rust,
	///   every (stack-allocated) variable is considered a separate allocated
	///   object.
	/// - Both pointers must be *derived from* a pointer to the same object.
	/// - The distance between the pointers, **in bytes**, cannot overflow an
	///   `isize`.
	/// - The distance being in bounds cannot rely on “wrapping around” the
	///   address space.
	///
	/// These pointers are almost always derived from [`BitSlice`] regions,
	/// which have an encoding limitation that the high three bits of the length
	/// counter are zero, so `bitvec` pointers are even less likely than
	/// ordinary pointers to run afoul of these limitations.
	///
	/// # Examples
	///
	/// Basic usage:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let data = 0u16;
	/// let base = BitPtr::<_, Lsb0, _>::from_ref(&data);
	/// let low = unsafe { base.add(5) };
	/// let high = unsafe { low.add(6) };
	/// unsafe {
	///   assert_eq!(high.offset_from(low), 6);
	///   assert_eq!(low.offset_from(high), -6);
	///   assert_eq!(low.offset(6), high);
	///   assert_eq!(high.offset(-6), low);
	/// }
	/// ```
	///
	/// *Incorrect* usage:
	///
	/// ```rust,no_run
	/// use bitvec::prelude::*;
	///
	/// let a = 0u8;
	/// let b = !0u8;
	/// let a_ptr = BitPtr::<_, Lsb0, _>::from_ref(&a);
	/// let b_ptr = BitPtr::<_, Lsb0, _>::from_ref(&b);
	/// let diff = (b_ptr.pointer() as isize)
	///   .wrapping_sub(a_ptr.pointer() as isize)
	///   // Remember: raw pointers are byte-addressed,
	///   // but these are bit-addressed.
	///   .wrapping_mul(8);
	/// // Create a pointer to `b`, derived from `a`.
	/// let b_ptr_2 = a_ptr.wrapping_offset(diff);
	///
	/// // The pointers are *arithmetically* equal now
	/// assert_eq!(b_ptr, b_ptr_2);
	/// // Undefined Behavior!
	/// unsafe {
	///   b_ptr_2.offset_from(b_ptr);
	/// }
	/// ```
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	/// [`offset`]: Self::offset
	#[inline]
	pub unsafe fn offset_from(self, origin: Self) -> isize {
		/* Miri complains when performing this arithmetic on pointers. To avoid
		both its costs, and the implicit scaling present in pointer arithmetic,
		this uses pure numeric arithmetic on the address values.
		*/
		(self.addr
			.to_const() as usize)
			.wrapping_sub(origin.addr.to_const()as usize)
			//  Pointers step by `T`, but **address values** step by `u8`.
			.wrapping_mul(<u8 as IsNumber>::BITS as usize)
			//  `self.head` moves the end farther from origin,
			.wrapping_add(self.head.into_inner() as usize)
			//  and `origin.head` moves the origin closer to the end.
			.wrapping_sub(origin.head.into_inner() as usize) as isize
	}

	/// Calculates the offset from a pointer (convenience for `.offset(count as
	/// isize)`).
	///
	/// `count` is in units of bits.
	///
	/// # Original
	///
	/// [`pointer::add`](https://doc.rust-lang.org/std/primitive.pointer.html#method.add)
	///
	/// # Safety
	///
	/// See [`offset`].
	///
	/// [`offset`]: Self::offset
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub unsafe fn add(self, count: usize) -> Self {
		self.offset(count as isize)
	}

	/// Calculates the offset from a pointer (convenience for `.offset((count as
	/// isize).wrapping_neg())`).
	///
	/// `count` is in units of bits.
	///
	/// # Original
	///
	/// [`pointer::sub`](https://doc.rust-lang.org/std/primitive.pointer.html#method.sub)
	///
	/// # Safety
	///
	/// See [`offset`].
	///
	/// [`offset`]: Self::offset
	#[inline]
	pub unsafe fn sub(self, count: usize) -> Self {
		self.offset((count as isize).wrapping_neg())
	}

	/// Calculates the offset from a pointer using wrapping arithmetic
	/// (convenience for `.wrapping_offset(count as isize)`).
	///
	/// # Original
	///
	/// [`pointer::wrapping_add`](https://doc.rust-lang.org/std/primitive.pointer.html#method.wrapping_add)
	///
	/// # Safety
	///
	/// See [`wrapping_offset`].
	///
	/// [`wrapping_offset`]: Self::wrapping_offset
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn wrapping_add(self, count: usize) -> Self {
		self.wrapping_offset(count as isize)
	}

	/// Calculates the offset from a pointer using wrapping arithmetic
	/// (convenience for `.wrapping_offset((count as isize).wrapping_neg())`).
	///
	/// # Original
	///
	/// [`pointer::wrapping_sub`](https://doc.rust-lang.org/std/primitive.pointer.html#method.wrapping_sub)
	///
	/// # Safety
	///
	/// See [`wrapping_offset`].
	///
	/// [`wrapping_offset`]: Self::wrapping_offset
	#[inline]
	#[cfg(not(tarpaulin_include))]
	pub fn wrapping_sub(self, count: usize) -> Self {
		self.wrapping_offset((count as isize).wrapping_neg())
	}

	/// Reads the bit from `*self`.
	///
	/// # Original
	///
	/// [`pointer::read`](https://doc.rust-lang.org/std/primitive.pointer.html#method.read)
	///
	/// # Safety
	///
	/// See [`ptr::read`] for safety concerns and examples.
	///
	/// [`ptr::read`]: crate::ptr::read
	#[inline]
	pub unsafe fn read(self) -> bool {
		(&*self.addr.to_const())
			.load_value()
			.get_bit::<O>(self.head)
	}

	/// Performs a volatile read of the bit from `self`.
	///
	/// Volatile operations are intended to act on I/O memory, and are
	/// guaranteed to not be elided or reördered by the compiler across other
	/// volatile operations.
	///
	/// # Original
	///
	/// [`pointer::read_volatile`](https://doc.rust-lang.org/std/primitive.pointer.html#method.read_volatile)
	///
	/// # Safety
	///
	/// See [`ptr::read_volatile`] for safety concerns and examples.
	///
	/// [`ptr::read_volatile`]: crate::ptr::read_volatile
	#[inline]
	pub unsafe fn read_volatile(self) -> bool {
		self.addr.to_const().read_volatile().get_bit::<O>(self.head)
	}

	/// Copies `count` bits from `self` to `dest`. The source and destination
	/// may overlap.
	///
	/// NOTE: this has the *same* argument order as [`ptr::copy`].
	///
	/// # Original
	///
	/// [`pointer::copy_to`](https://doc.rust-lang.org/std/primitive.pointer.html#method.copy_to)
	///
	/// # Safety
	///
	/// See [`ptr::copy`] for safety concerns and examples.
	///
	/// [`ptr::copy`]: crate::ptr::copy
	#[inline]
	pub unsafe fn copy_to<O2, T2>(self, dest: BitPtr<Mut, O2, T2>, count: usize)
	where
		O2: BitOrder,
		T2: BitStore,
	{
		//  If the orderings match, then overlap is permitted and defined.
		if dvl::match_order::<O, O2>() {
			let (addr, head) = dest.raw_parts();
			let dst = BitPtr::<Mut, O, T2>::new(addr, head);
			let src_pair = self.range(count);

			let rev = src_pair.contains(&dst);
			let iter = src_pair.zip(dest.range(count));
			if rev {
				for (from, to) in iter.rev() {
					to.write(from.read());
				}
			}
			else {
				for (from, to) in iter {
					to.write(from.read());
				}
			}
		}
		else {
			//  If the orderings differ, then it is undefined behavior to
			//  overlap in  memory.
			self.copy_to_nonoverlapping(dest, count);
		}
	}

	/// Copies `count` bits from `self` to `dest`. The source and destination
	/// may *not* overlap.
	///
	/// NOTE: this has the *same* argument order as
	/// [`ptr::copy_nonoverlapping`].
	///
	/// # Original
	///
	/// [`pointer::copy_to_nonoverlapping`](https://doc.rust-lang.org/std/primitive.pointer.html#method.copy_to_nonoverlapping)
	///
	/// # Safety
	///
	/// See [`ptr::copy_nonoverlapping`] for safety concerns and examples.
	///
	/// [`ptr::copy_nonoverlapping`](crate::ptr::copy_nonoverlapping)
	#[inline]
	pub unsafe fn copy_to_nonoverlapping<O2, T2>(
		self,
		dest: BitPtr<Mut, O2, T2>,
		count: usize,
	) where
		O2: BitOrder,
		T2: BitStore,
	{
		for (from, to) in self.range(count).zip(dest.range(count)) {
			to.write(from.read());
		}
	}

	/// Computes the offset (in bits) that needs to be applied to the pointer in
	/// order to make it aligned to `align`.
	///
	/// “Alignment” here means that the pointer is selecting the start bit of a
	/// memory location whose address satisfies the requested alignment.
	///
	/// `align` is measured in **bytes**. If you wish to align your bit-pointer
	/// to a specific fraction (½, ¼, or ⅛ of one byte), please file an issue
	/// and this functionality will be added to [`BitIdx`].
	///
	/// # Original
	///
	/// [`pointer::align_offset`](https://doc.rust-lang.org/std/primitive.pointer.html#method.align_offset)
	///
	/// If the base-element address of the pointer is already aligned to
	/// `align`, then this will return the bit-offset required to select the
	/// first bit of the successor element.
	///
	/// If it is not possible to align the pointer, the implementation returns
	/// `usize::MAX`. It is permissible for the implementation to *always*
	/// return `usize::MAX`. Only your algorithm’s performance can depend on
	/// getting a usable offset here, not its correctness.
	///
	/// The offset is expressed in number of bits, and not `T` elements or
	/// bytes. The value returned can be used with the [`wrapping_add`] method.
	///
	/// # Safety
	///
	/// There are no guarantees whatsoëver that offsetting the pointer will not
	/// overflow or go beyond the allocation that the pointer points into. It is
	/// up to the caller to ensure that the returned offset is correct in all
	/// terms other than alignment.
	///
	/// # Panics
	///
	/// The function panics if `align` is not a power-of-two.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let data = [0u8; 3];
	/// let ptr = BitPtr::<_, Lsb0, _>::from_ref(&data[0]);
	/// let ptr = unsafe { ptr.add(2) };
	/// let count = ptr.align_offset(2);
	/// assert!(count > 0);
	/// ```
	///
	/// [`BitIdx`]: crate::index::BitIdx
	/// [`wrapping_add`]: Self::wrapping_add
	#[inline]
	pub fn align_offset(self, align: usize) -> usize {
		let width = <T::Mem as IsNumber>::BITS as usize;
		match (
			self.addr.to_const().align_offset(align),
			self.head.into_inner() as usize,
		) {
			(0, 0) => 0,
			(0, head) => align * 8 - head,
			(usize::MAX, _) => !0,
			(elts, head) => elts.wrapping_mul(width).wrapping_sub(head),
		}
	}
}

impl<O, T> BitPtr<Const, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// Constructs a `BitPtr` from an element reference.
	///
	/// # Parameters
	///
	/// - `elem`: A borrowed memory element.
	///
	/// # Returns
	///
	/// A read-only bit-pointer to the zeroth bit in the `*elem` location.
	#[inline]
	pub fn from_ref(elem: &T) -> Self {
		Self::new(elem.into(), BitIdx::ZERO)
	}

	/// Attempts to construct a `BitPtr` from an element location.
	///
	/// # Parameters
	///
	/// - `elem`: A read-only element address.
	///
	/// # Returns
	///
	/// A read-only bit-pointer to the zeroth bit in the `*elem` location, if
	/// `elem` is well-formed.
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn from_ptr(elem: *const T) -> Result<Self, BitPtrError<T>> {
		Self::try_new(elem, 0)
	}

	/// Constructs a `BitPtr` from a slice reference.
	///
	/// This differs from [`from_ref`] in that the returned pointer keeps its
	/// provenance over the entire slice, whereas producing a pointer to the
	/// base bit of a slice with `BitPtr::from_ref(&slice[0])` narrows its
	/// provenance to only the `slice[0]` element, and calling [`add`] to leave
	/// that element, even remaining in the slice, may cause UB.
	///
	/// # Parameters
	///
	/// - `slice`: An immutabily borrowed slice of memory.
	///
	/// # Returns
	///
	/// A read-only bit-pointer to the zeroth bit in the base location of the
	/// slice.
	///
	/// This pointer has provenance over the entire `slice`, and may safely use
	/// [`add`] to traverse memory elements as long as it stays within the
	/// slice.
	///
	/// [`add`]: Self::add
	/// [`from_ref`]: Self::from_ref
	#[inline]
	pub fn from_slice(slice: &[T]) -> Self {
		Self::new(unsafe { slice.as_ptr().force_wrap() }, BitIdx::ZERO)
	}

	/// Gets the pointer to the base memory location containing the referent
	/// bit.
	#[inline]
	#[cfg(not(tarpaulin_include))]
	pub fn pointer(&self) -> *const T {
		self.get_addr().to_const()
	}
}

impl<O, T> BitPtr<Mut, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// Constructs a `BitPtr` from an element reference.
	///
	/// # Parameters
	///
	/// - `elem`: A mutably borrowed memory element.
	///
	/// # Returns
	///
	/// A write-capable bit-pointer to the zeroth bit in the `*elem` location.
	///
	/// Note that even if `elem` is an address within a contiguous array or
	/// slice, the returned bit-pointer only has provenance for the `elem`
	/// location, and no other.
	///
	/// # Safety
	///
	/// The exclusive borrow of `elem` is released after this function returns.
	/// However, you must not use any other pointer than that returned by this
	/// function to view or modify `*elem`, unless the `T` type supports aliased
	/// mutation.
	#[inline]
	pub fn from_mut(elem: &mut T) -> Self {
		Self::new(elem.into(), BitIdx::ZERO)
	}

	/// Attempts to construct a `BitPtr` from an element location.
	///
	/// # Parameters
	///
	/// - `elem`: A write-capable element address.
	///
	/// # Returns
	///
	/// A write-capable bit-pointer to the zeroth bit in the `*elem` location,
	/// if `elem` is well-formed.
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn from_mut_ptr(elem: *mut T) -> Result<Self, BitPtrError<T>> {
		Self::try_new(elem, 0)
	}

	/// Constructs a `BitPtr` from a slice reference.
	///
	/// This differs from [`from_mut`] in that the returned pointer keeps its
	/// provenance over the entire slice, whereas producing a pointer to the
	/// base bit of a slice with `BitPtr::from_mut(&mut slice[0])` narrows its
	/// provenance to only the `slice[0]` element, and calling [`add`] to leave
	/// that element, even remaining in the slice, may cause UB.
	///
	/// # Parameters
	///
	/// - `slice`: A mutabily borrowed slice of memory.
	///
	/// # Returns
	///
	/// A write-capable bit-pointer to the zeroth bit in the base location of
	/// the slice.
	///
	/// This pointer has provenance over the entire `slice`, and may safely use
	/// [`add`] to traverse memory elements as long as it stays within the
	/// slice.
	///
	/// [`add`]: Self::add
	/// [`from_mut`]: Self::from_mut
	#[inline]
	pub fn from_mut_slice(slice: &mut [T]) -> Self {
		Self::new(unsafe { slice.as_mut_ptr().force_wrap() }, BitIdx::ZERO)
	}

	/// Gets the pointer to the base memory location containing the referent
	/// bit.
	#[inline]
	#[cfg(not(tarpaulin_include))]
	pub fn pointer(&self) -> *mut T {
		self.get_addr().to_mut()
	}

	//  `pointer` fundamental inherent API

	/// Produces a proxy mutable reference to the referent bit.
	///
	/// Because `BitPtr` is a non-null, well-aligned, pointer, this never
	/// returns `None`.
	///
	/// # Original
	///
	/// [`pointer::as_mut`](https://doc.rust-lang.org/std/primitive.pointer.html#method.as_mut)
	///
	/// # API Differences
	///
	/// This produces a proxy type rather than a true reference. The proxy
	/// implements `DerefMut<Target = bool>`, and can be converted to `&mut
	/// bool` with `&mut *`. Writes to the proxy are not reflected in the
	/// proxied location until the proxy is destroyed, either through `Drop` or
	/// with its [`set`] method.
	///
	/// The proxy must be bound as `mut` in order to write through the binding.
	///
	/// # Safety
	///
	/// Since `BitPtr` does not permit null or misaligned pointers, this method
	/// will always dereference the pointer and you must ensure the following
	/// conditions are met:
	///
	/// - the pointer must be dereferencable as defined in the standard library
	///   documentation
	/// - the pointer must point to an initialized instance of `T`
	/// - you must ensure that no other pointer will race to modify the referent
	///   location while this call is reading from memory to produce the proxy
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut data = 0u8;
	/// let ptr = BitPtr::<_, Lsb0, _>::from_mut(&mut data);
	/// let mut val = unsafe { ptr.as_mut() }.unwrap();
	/// assert!(!*val);
	/// *val = true;
	/// assert!(*val);
	/// ```
	///
	/// [`set`]: crate::ptr::BitRef::set
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub unsafe fn as_mut<'a>(self) -> Option<BitRef<'a, Mut, O, T>> {
		Some(BitRef::from_bitptr(self))
	}

	/// Copies `count` bits from `src` to `self`. The source and destination may
	/// overlap.
	///
	/// Note: this has the *opposite* argument order of [`ptr::copy`].
	///
	/// # Original
	///
	/// [`pointer::copy_from`](https://doc.rust-lang.org/std/primitive.pointer.html#method.copy_from)
	///
	/// # Safety
	///
	/// See [`ptr::copy`] for safety concerns and examples.
	///
	/// [`ptr::copy`]: crate::ptr::copy
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub unsafe fn copy_from<O2, T2>(
		self,
		src: BitPtr<Const, O2, T2>,
		count: usize,
	) where
		O2: BitOrder,
		T2: BitStore,
	{
		src.copy_to(self, count);
	}

	/// Copies `count` bits from `src` to `self`. The source and destination may
	/// *not* overlap.
	///
	/// NOTE: this has the *opposite* argument order of
	/// [`ptr::copy_nonoverlapping`].
	///
	/// # Original
	///
	/// [`pointer::copy_from_nonoverlapping`](https://doc.rust-lang.org/std/primitive.pointer.html#method.copy_from_nonoverlapping)
	///
	/// # Safety
	///
	/// See [`ptr::copy_nonoverlapping`] for safety concerns and examples.
	///
	/// [`ptr::copy_nonoverlapping`]: crate::ptr::copy_nonoverlapping
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub unsafe fn copy_from_nonoverlapping<O2, T2>(
		self,
		src: BitPtr<Const, O2, T2>,
		count: usize,
	) where
		O2: BitOrder,
		T2: BitStore,
	{
		src.copy_to_nonoverlapping(self, count);
	}

	/// Overwrites a memory location with the given bit.
	///
	/// See [`ptr::write`] for safety concerns and examples.
	///
	/// # Original
	///
	/// [`pointer::write`](https://doc.rust-lang.org/std/primitive.pointer.html#method.write)
	///
	/// [`ptr::write`]: crate::ptr::write
	#[inline]
	#[allow(clippy::clippy::missing_safety_doc)]
	pub unsafe fn write(self, value: bool) {
		self.replace(value);
	}

	/// Performs a volatile write of a memory location with the given bit.
	///
	/// Because processors do not have single-bit write instructions, this must
	/// perform a volatile read of the location, perform the bit modification
	/// within the processor register, and then perform a volatile write back to
	/// memory. These three steps are guaranteed to be sequential, but are not
	/// guaranteed to be atomic.
	///
	/// Volatile operations are intended to act on I/O memory, and are
	/// guaranteed to not be elided or reördered by the compiler across other
	/// volatile operations.
	///
	/// # Original
	///
	/// [`pointer::write_volatile`](https://doc.rust-lang.org/std/primitive.pointer.html#method.write_volatile)
	///
	/// # Safety
	///
	/// See [`ptr::write_volatile`] for safety concerns and examples.
	///
	/// [`ptr::write_volatile`]: crate::ptr::write_volatile
	#[inline]
	pub unsafe fn write_volatile(self, val: bool) {
		let select = O::select(self.head).into_inner();
		let ptr = self.addr.cast::<T::Mem>().to_mut();
		let mut tmp = ptr.read_volatile();
		if val {
			tmp |= &select;
		}
		else {
			tmp &= &!select;
		}
		ptr.write_volatile(tmp);
	}

	/// Replaces the bit at `*self` with `src`, returning the old bit.
	///
	/// # Original
	///
	/// [`pointer::replace`](https://doc.rust-lang.org/std/primitive.pointer.html#method.replace)
	///
	/// # Safety
	///
	/// See [`ptr::replace`] for safety concerns and examples.
	///
	/// [`ptr::replace`]: crate::ptr::replace
	#[inline]
	pub unsafe fn replace(self, src: bool) -> bool {
		self.freeze().frozen_write_bit(src)
	}

	/// Swaps the bits at two mutable locations. They may overlap.
	///
	/// # Original
	///
	/// [`pointer::swap`](https://doc.rust-lang.org/std/primitive.pointer.html#method.swap)
	///
	/// # Safety
	///
	/// See [`ptr::swap`] for safety concerns and examples.
	///
	/// [`ptr::swap`]: crate::ptr::swap
	#[inline]
	pub unsafe fn swap<O2, T2>(self, with: BitPtr<Mut, O2, T2>)
	where
		O2: BitOrder,
		T2: BitStore,
	{
		self.write(with.replace(self.read()));
	}
}

impl<M, O, T> BitPtr<Frozen<M>, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	/// Writes to a bit in memory.
	///
	/// # Safety
	///
	/// The caller is responsible for ensuring that the referent bit is safe to
	/// modify. `bitvec` uses `&ref`/`*const` pointers for aliased write-capable
	/// views, which the mutability tracking system currently does not support.
	///
	/// Once a pointer is frozen, even if it does *not* have write permissions
	/// through either `Mut` or `Radium` in its start state, this method becomes
	/// available. Use on incorrect pointers (f.ex. freezing an `&u8`) is
	/// undefined.
	#[inline]
	pub(crate) unsafe fn frozen_write_bit(self, value: bool) -> bool {
		(&*self.addr.cast::<T::Access>().to_const())
			.write_bit::<O>(self.head, value)
	}
}

#[cfg(not(tarpaulin_include))]
impl<M, O, T> Clone for BitPtr<M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn clone(&self) -> Self {
		Self {
			addr: self.get_addr(),
			..*self
		}
	}
}

impl<M, O, T> Eq for BitPtr<M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
}

#[cfg(not(tarpaulin_include))]
impl<M, O, T> Ord for BitPtr<M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn cmp(&self, other: &Self) -> cmp::Ordering {
		self.partial_cmp(other).expect(
			"BitPtr has a total ordering when type parameters are identical",
		)
	}
}

#[cfg(not(tarpaulin_include))]
impl<M1, M2, O, T1, T2> PartialEq<BitPtr<M2, O, T2>> for BitPtr<M1, O, T1>
where
	M1: Mutability,
	M2: Mutability,
	O: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn eq(&self, other: &BitPtr<M2, O, T2>) -> bool {
		if !dvl::match_store::<T1::Mem, T2::Mem>() {
			return false;
		}
		self.get_addr().to_const() as usize
			== other.get_addr().to_const() as usize
			&& self.head.into_inner() == other.head.into_inner()
	}
}

#[cfg(not(tarpaulin_include))]
impl<M1, M2, O, T1, T2> PartialOrd<BitPtr<M2, O, T2>> for BitPtr<M1, O, T1>
where
	M1: Mutability,
	M2: Mutability,
	O: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn partial_cmp(&self, other: &BitPtr<M2, O, T2>) -> Option<cmp::Ordering> {
		if !dvl::match_store::<T1::Mem, T2::Mem>() {
			return None;
		}
		match (self.get_addr().to_const() as usize)
			.cmp(&(other.get_addr().to_const() as usize))
		{
			cmp::Ordering::Equal => {
				self.head.into_inner().partial_cmp(&other.head.into_inner())
			},
			ord => Some(ord),
		}
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> From<&T> for BitPtr<Const, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn from(elem: &T) -> Self {
		Self::new(elem.into(), BitIdx::ZERO)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> From<&mut T> for BitPtr<Mut, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn from(elem: &mut T) -> Self {
		Self::new(elem.into(), BitIdx::ZERO)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> TryFrom<*const T> for BitPtr<Const, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	type Error = BitPtrError<T>;

	#[inline(always)]
	fn try_from(elem: *const T) -> Result<Self, Self::Error> {
		Self::try_new(elem, 0)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> TryFrom<*mut T> for BitPtr<Mut, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	type Error = BitPtrError<T>;

	#[inline(always)]
	fn try_from(elem: *mut T) -> Result<Self, Self::Error> {
		Self::try_new(elem, 0)
	}
}

impl<M, O, T> Debug for BitPtr<M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		write!(
			fmt,
			"{} Bit<{}, {}>",
			M::RENDER,
			any::type_name::<O>(),
			any::type_name::<T>(),
		)?;
		Pointer::fmt(self, fmt)
	}
}

impl<M, O, T> Pointer for BitPtr<M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		fmt.debug_tuple("")
			.field(&self.get_addr().fmt_pointer())
			.field(&self.head.fmt_binary())
			.finish()
	}
}

#[cfg(not(tarpaulin_include))]
impl<M, O, T> Hash for BitPtr<M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn hash<H>(&self, state: &mut H)
	where H: Hasher {
		self.get_addr().hash(state);
		self.head.hash(state);
	}
}

impl<M, O, T> Copy for BitPtr<M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
}

/// Errors produced by invalid bit-pointer components.
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum BitPtrError<T>
where T: BitStore
{
	/// The null address was provided.
	Null(NullPtrError),
	/// The address was misaligned for the element type.
	Misaligned(MisalignError<T>),
	/// The bit index was invalid for the element type.
	BadIndex(BitIdxError<T::Mem>),
}

#[cfg(not(tarpaulin_include))]
impl<T> From<NullPtrError> for BitPtrError<T>
where T: BitStore
{
	#[inline(always)]
	fn from(err: NullPtrError) -> Self {
		Self::Null(err)
	}
}

#[cfg(not(tarpaulin_include))]
impl<T> From<MisalignError<T>> for BitPtrError<T>
where T: BitStore
{
	#[inline(always)]
	fn from(err: MisalignError<T>) -> Self {
		Self::Misaligned(err)
	}
}

#[cfg(not(tarpaulin_include))]
impl<T> From<BitIdxError<T::Mem>> for BitPtrError<T>
where T: BitStore
{
	#[inline(always)]
	fn from(err: BitIdxError<T::Mem>) -> Self {
		Self::BadIndex(err)
	}
}

#[cfg(not(tarpaulin_include))]
impl<T> From<Infallible> for BitPtrError<T>
where T: BitStore
{
	#[inline(always)]
	fn from(_: Infallible) -> Self {
		unreachable!("Infallible errors can never be produced");
	}
}

#[cfg(not(tarpaulin_include))]
impl<T> Display for BitPtrError<T>
where T: BitStore
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		match self {
			Self::Null(err) => Display::fmt(err, fmt),
			Self::Misaligned(err) => Display::fmt(err, fmt),
			Self::BadIndex(err) => Display::fmt(err, fmt),
		}
	}
}

#[cfg(feature = "std")]
impl<T> std::error::Error for BitPtrError<T> where T: BitStore
{
}

#[cfg(test)]
mod tests {
	use super::*;
	use crate::{
		prelude::Lsb0,
		ptr::Const,
	};

	#[test]
	fn ctor() {
		let data = 0u16;
		let head = 5;

		let bitptr = BitPtr::<Const, Lsb0, _>::try_new(&data, head).unwrap();
		let (addr, indx) = bitptr.raw_parts();
		assert_eq!(addr.to_const(), &data as *const _);
		assert_eq!(indx.into_inner(), head);
	}

	#[test]
	fn bitref() {
		let data = 1u32 << 23;
		let head = 23;
		let bitptr = BitPtr::<Const, Lsb0, _>::try_new(&data, head).unwrap();
		let bitref = unsafe { bitptr.as_ref() }.unwrap();
		assert!(*bitref);
	}

	#[test]
	fn assert_size() {
		assert!(
			core::mem::size_of::<BitPtr<Const, Lsb0, u8>>()
				<= core::mem::size_of::<usize>() + core::mem::size_of::<u8>(),
		);
	}

	#[test]
	#[cfg(feature = "alloc")]
	fn format() {
		#[cfg(not(feature = "std"))]
		use alloc::format;

		use crate::order::Msb0;

		let base = 0u16;
		let bitptr = BitPtr::<_, Msb0, _>::from_ref(&base);
		let text = format!("{:?}", unsafe { bitptr.add(3) });
		let render = format!(
			"*const Bit<bitvec::order::Msb0, u16>({:p}, {:04b})",
			&base as *const u16, 3
		);
		assert_eq!(text, render);
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/ptr/single.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/ptr/span.rs =====
//! Encoded pointer to a span region.

#[cfg(any(feature = "alloc", test))]
use core::convert::TryInto;
use core::{
	any,
	convert::Infallible,
	fmt::{
		self,
		Debug,
		Display,
		Formatter,
		Pointer,
	},
	marker::PhantomData,
	ptr::{
		self,
		NonNull,
	},
};

use funty::IsNumber;
use wyz::fmt::FmtForward;

use super::{
	Address,
	BitPtr,
	BitPtrError,
	BitPtrRange,
	Const,
	Mut,
	Mutability,
};
use crate::{
	domain::Domain,
	index::{
		BitIdx,
		BitTail,
	},
	mem::BitMemory,
	order::{
		BitOrder,
		Lsb0,
	},
	slice::BitSlice,
	store::BitStore,
};

/** Encoded handle to a bit-precision memory region.

Rust slices use a pointer/length encoding to represent regions of memory.
References to slices of data, `&[T]`, have the ABI layout `(*const T, usize)`.

`BitSpan` encodes a base address, a first-bit index, and a length counter, into
the Rust slice reference layout using this structure. This permits [`bitvec`] to
use an opaque reference type in its implementation of Rust interfaces that
require references, rather than immediate value types.

# Layout

This structure is a more complex version of the `*const T`/`usize` tuple that
Rust uses to represent slices throughout the language. It breaks the pointer and
counter fundamentals into sub-field components. Rust does not have bitfield
syntax, so the below description of the structure layout is in C++.

```cpp
template <typename T>
struct BitSpan {
  uintptr_t ptr_head : __builtin_ctzll(alignof(T));
  uintptr_t ptr_addr : sizeof(uintptr_T) * 8 - __builtin_ctzll(alignof(T));

  size_t len_head : 3;
  size_t len_bits : sizeof(size_t) * 8 - 3;
};
```

This means that the `BitSpan<O, T>` has three *logical* fields, stored in four
segments, across the two *structural* fields of the type. The widths and
placements of each segment are functions of the size of `*const T`, `usize`, and
of the alignment of the `T` referent buffer element type.

# Fields

This section describes the purpose, semantic meaning, and layout of the three
logical fields.

## Base Address

The address of the base element in a memory region is stored in all but the
lowest bits of the `ptr` field. An aligned pointer to `T` will always have its
lowest log<sub>2</sub>(byte width) bits zeroed, so those bits can be used to
store other information, as long as they are erased before dereferencing the
address as a pointer to `T`.

## Head Bit Index

For any referent element type `T`, the selection of a single bit within the
element requires log<sub>2</sub>(byte width) bits to select a byte within the
element `T`, and another three bits to select a bit within the selected byte.

|Type |Alignment|Trailing Zeros|Count Bits|
|:----|--------:|-------------:|---------:|
|`u8` |        1|             0|         3|
|`u16`|        2|             1|         4|
|`u32`|        4|             2|         5|
|`u64`|        8|             3|         6|

The index of the first live bit in the base element is split to have its three
least significant bits stored in the least significant edge of the `len` field,
and its remaining bits stored in the least significant edge of the `ptr` field.

## Length Counter

All but the lowest three bits of the `len` field are used to store a counter of
live bits in the referent region. When this is zero, the region is empty.
Because it is missing three bits, a `BitSpan` has only ⅛ of the index space of
a `usize` value.

# Significant Values

The following values represent significant instances of the `BitSpan` type.

## Null Slice

The fully-zeroed slot is not a valid member of the `BitSpan<O, T>` type; it is
reserved instead as the sentinel value for `Option::<BitSpan<O, T>>::None`.

## Canonical Empty Slice

All pointers with a `bits: 0` logical field are empty. Pointers that are used to
maintain ownership of heap buffers are not permitted to erase their `addr`
field. The canonical form of the empty slice has an `addr` value of
[`NonNull::<T>::dangling()`], but all pointers to an empty region are equivalent
regardless of address.

### Uninhabited Slices

Any empty pointer with a non-[`dangling()`] base address is considered to be an
uninhabited region. `BitSpan` never discards its address information, even as
operations may alter or erase its head-index or length values.

# Type Parameters

- `O`: The ordering within the register type. The bit-ordering used within a
  region colors all pointers to the region, and orderings can never mix.
- `T`: The memory type of the referent region. `BitSpan<O, T>` is a specialized
  `*[T]` slice pointer, and operates on memory in terms of the `T` type for
  access instructions and pointer calculation.

# Safety

`BitSpan` values may only be constructed from pointers provided by the
surrounding program.

# Undefined Behavior

Values of this type are binary-incompatible with slice pointers. Transmutation
of these values into any other type will result in an incorrect program, and
permit the program to begin illegal or undefined behaviors. This type may never
be manipulated in any way by user code outside of the APIs it offers to this
[`bitvec`]; it certainly may not be seen or observed by other crates.

[`NonNull::<T>::dangling()`]: core::ptr::NonNull::dangling
[`bitvec`]: crate
[`dangling()`]: core::ptr::NonNull::dangling
**/
#[repr(C)]
pub(crate) struct BitSpan<M = Const, O = Lsb0, T = usize>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	/// Memory address and high bits of the head index.
	///
	/// This stores the address of the zeroth element of the slice, as well as
	/// the high bits of the head bit cursor. It is typed as a [`NonNull<()>`]
	/// in order to provide null-value optimizations to `Option<BitSpan<O, T>>`,
	/// and because the presence of head-bit cursor information in the lowest
	/// bits means that the bit pattern will not uphold alignment properties
	/// required by `NonNull<T>`.
	///
	/// This field cannot be treated as the address of the zeroth byte of the
	/// slice domain, because the owning handle’s [`BitOrder`] implementation
	/// governs the bit pattern of the head cursor.
	///
	/// [`BitOrder`]: crate::order::BitOrder
	/// [`NonNull<()>`]: core::ptr::NonNull
	ptr: NonNull<()>,
	/// Length counter and low bits of the head index.
	///
	/// This stores the slice length counter (measured in bits) in all but its
	/// lowest three bits, and the lowest three bits of the index counter in its
	/// lowest three bits.
	len: usize,
	/// Bit-region pointers must be colored by the bit-ordering they use.
	_or: PhantomData<O>,
	/// This is semantically a pointer to a `T` element.
	_ty: PhantomData<Address<M, T>>,
}

impl<M, O, T> BitSpan<M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	/// The canonical form of a pointer to an empty region.
	pub(crate) const EMPTY: Self = Self {
		/* Note: this must always construct the `T` dangling pointer, and then
		convert it into a pointer to `u8`. Creating `NonNull::dangling()`
		directly will always instantiate the `NonNull::<u8>::dangling()`
		pointer, which is VERY incorrect for any other `T` typarams.
		*/
		ptr: NonNull::<T>::dangling().cast::<()>(),
		len: 0,
		_or: PhantomData,
		_ty: PhantomData,
	};
	/// The number of low bits of `self.len` required to hold the low bits of
	/// the head [`BitIdx`] cursor.
	///
	/// This is always `3`, until Rust tries to target an architecture that does
	/// not have 8-bit bytes.
	///
	/// [`BitIdx`]: crate::index::BitIdx
	pub(crate) const LEN_HEAD_BITS: usize = 3;
	/// Marks the bits of `self.len` that hold part of the `head` logical field.
	pub(crate) const LEN_HEAD_MASK: usize = 0b111;
	/// Marks the bits of `self.ptr` that hold the `addr` logical field.
	pub(crate) const PTR_ADDR_MASK: usize = !0 << Self::PTR_HEAD_BITS;
	/// The number of low bits of `self.ptr` required to hold the high bits of
	/// the head [`BitIdx`] cursor.
	///
	/// [`BitIdx`]: crate::index::BitIdx
	pub(crate) const PTR_HEAD_BITS: usize =
		T::Mem::INDX as usize - Self::LEN_HEAD_BITS;
	/// Marks the bits of `self.ptr` that hold part of the `head` logical field.
	pub(crate) const PTR_HEAD_MASK: usize = !Self::PTR_ADDR_MASK;
	/// The inclusive-maximum number of bits that a `BitSpan` can cover.
	pub(crate) const REGION_MAX_BITS: usize = !0 >> Self::LEN_HEAD_BITS;
	/// The inclusive-maximum number of elements that the region described by a
	/// `BitSpan` can cover in memory.
	///
	/// This is the number of elements required to store [`REGION_MAX_BITS`],
	/// plus one because a region could start in the middle of its base element
	/// and thus push the final bits into a new element.
	///
	/// Since the region is ⅛th the bit span of a `usize` counter already, this
	/// number is guaranteed to be well below the limits of arithmetic or Rust’s
	/// own constraints on memory region handles.
	///
	/// [`REGION_MAX_BITS`]: Self::REGION_MAX_BITS
	pub(crate) const REGION_MAX_ELTS: usize =
		crate::mem::elts::<T::Mem>(Self::REGION_MAX_BITS) + 1;

	//  Constructors

	/// Constructs an empty `BitSpan` at a bare pointer.
	///
	/// This is used when the region has no contents, but the pointer
	/// information must be retained.
	///
	/// # Parameters
	///
	/// - `addr`: Some address of a `T` element or region. It must be valid in
	///   the caller’s memory space.
	///
	/// # Returns
	///
	/// A zero-length `BitSpan` pointing to `addr`.
	///
	/// # Panics
	///
	/// This function panics if `addr` is null or misaligned. All pointers
	/// received from the allocation system are required to satisfy this
	/// constraint, so a failure is an exceptional program fault rather than an
	/// expected logical mistake.
	#[inline(always)]
	#[cfg(feature = "alloc")]
	#[cfg(not(tarpaulin_include))]
	pub(crate) fn uninhabited(addr: Address<M, T>) -> Self {
		Self {
			ptr: addr.into_inner().cast::<()>(),
			len: 0,
			_or: PhantomData,
			_ty: PhantomData,
		}
	}

	#[inline]
	pub(crate) fn new(
		addr: Address<M, T>,
		head: BitIdx<T::Mem>,
		bits: usize,
	) -> Result<Self, BitSpanError<T>> {
		if bits > Self::REGION_MAX_BITS {
			return Err(BitSpanError::TooLong(bits));
		};
		let base = BitPtr::<M, O, T>::new(addr, head);
		let last = base.wrapping_add(bits);
		if last < base {
			return Err(BitSpanError::TooHigh(addr.to_const()));
		};

		Ok(unsafe { Self::new_unchecked(addr, head, bits) })
	}

	/// Creates a new `BitSpan` from its components, without any validity
	/// checks.
	///
	/// # Safety
	///
	/// ***ABSOLUTELY NONE.*** This function *only* packs its arguments into the
	/// bit pattern of the `BitSpan` type. It should only be used in
	/// contexts where a previously extant `BitSpan` was constructed with
	/// ancestry known to have survived [`::new`], and any manipulations of its
	/// raw components are known to be valid for reconstruction.
	///
	/// # Parameters
	///
	/// See [`::new`].
	///
	/// # Returns
	///
	/// See [`::new`].
	///
	/// [`::new`]: Self::new
	#[inline]
	pub(crate) unsafe fn new_unchecked(
		addr: Address<M, T>,
		head: BitIdx<T::Mem>,
		bits: usize,
	) -> Self {
		let head = head.into_inner() as usize;
		let ptr_data = addr.to_const() as usize & Self::PTR_ADDR_MASK;
		let ptr_head = head >> Self::LEN_HEAD_BITS;

		let len_head = head & Self::LEN_HEAD_MASK;
		let len_bits = bits << Self::LEN_HEAD_BITS;

		Self {
			ptr: NonNull::new_unchecked((ptr_data | ptr_head) as *mut ()),
			len: len_bits | len_head,
			_or: PhantomData,
			_ty: PhantomData,
		}
	}

	//  Converters

	/// Converts an opaque `*BitSlice` wide pointer back into a `BitSpan`.
	///
	/// See [`::from_bitslice_ptr()`].
	///
	/// [`::from_bitslice_ptr()`]: Self::from_bitslice_ptr
	//  Mutable pointers can become mutable or immutable span descriptors.
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub(crate) fn from_bitslice_ptr_mut(raw: *mut BitSlice<O, T>) -> Self {
		let BitSpan { ptr, len, _or, .. } =
			BitSpan::from_bitslice_ptr(raw as *const BitSlice<O, T>);
		Self {
			ptr,
			len,
			_or,
			_ty: PhantomData,
		}
	}

	/// Casts the `BitSpan` to an opaque `*BitSlice` pointer.
	///
	/// This is the inverse of [`::from_bitslice_ptr()`].
	///
	/// # Parameters
	///
	/// - `self`
	///
	/// # Returns
	///
	/// `self`, opacified as a `*BitSlice` raw pointer rather than a `BitSpan`
	/// structure.
	///
	/// [`::from_bitslice_ptr()`]: Self::from_bitslice_ptr
	//  Mutable or immutable span descriptors can become immutable pointers.
	#[inline]
	pub(crate) fn to_bitslice_ptr(self) -> *const BitSlice<O, T> {
		ptr::slice_from_raw_parts(
			self.ptr.as_ptr() as *const u8 as *const (),
			self.len,
		) as *const BitSlice<O, T>
	}

	/// Casts the `BitSpan` to a `&BitSlice` reference.
	///
	/// This requires that the pointer be to a validly-allocated region that
	/// is not destroyed for the duration of the provided lifetime.
	/// Additionally, the bits described by `self` must not be writable by any
	/// other handle.
	///
	/// # Lifetimes
	///
	/// - `'a`: A caller-provided lifetime that must not be greater than the
	///   duration of the referent buffer.
	///
	/// # Parameters
	///
	/// - `self`
	///
	/// # Returns
	///
	/// `self`, opacified as a bit-slice region reference rather than a
	/// `BitSpan` structure.
	//  Mutable or immutable span descriptors can become immutable references.
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub(crate) fn to_bitslice_ref<'a>(self) -> &'a BitSlice<O, T> {
		unsafe { &*self.to_bitslice_ptr() }
	}

	/// Casts the span to another element type.
	///
	/// This does not alter the encoded value of the pointer! It only
	/// reinterprets the element type, and the encoded value may shift
	/// significantly in the result type. Use with caution.
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub(crate) fn cast<U>(self) -> BitSpan<M, O, U>
	where U: BitStore {
		let Self { ptr, len, .. } = self;
		BitSpan {
			ptr,
			len,
			..BitSpan::EMPTY
		}
	}

	/// Split the region descriptor into three descriptors, with the interior
	/// set to a different register type.
	///
	/// By placing the logic in `BitSpan` rather than in `BitSlice`, `BitSlice`
	/// can safely call into it for both shared and exclusive references,
	/// without running into any reference capability issues in the compiler.
	///
	/// # Type Parameters
	///
	/// - `U`: A second [`BitStore`] implementation. This **must** be of the
	///   same type family as `T`; this restriction cannot be enforced in the
	///   type system, but **must** hold at the call site.
	///
	/// # Safety
	///
	/// This can only be called within `BitSlice::align_to{,_mut}`.
	///
	/// # Algorithm
	///
	/// This uses the slice [`Domain`] to split the underlying slice into
	/// regions that cannot (edge) and can (center) be reäligned. The center
	/// slice is then reäligned to `U`, and the edge slices produced from *that*
	/// are merged with the edge slices produced by the domain check.
	///
	/// This results in edge pointers returned from this function that correctly
	/// handle partially-used edge elements as well as misaligned slice
	/// locations.
	///
	/// [`BitStore`]: crate::store::BitStore
	/// [`Domain`]: crate::domain::Domain
	/// [`slice::align_to`]: https://doc.rust-lang.org/stable/std/primitive.slice.html#method.align_to
	pub(crate) unsafe fn align_to<U>(self) -> (Self, BitSpan<M, O, U>, Self)
	where U: BitStore {
		match self.to_bitslice_ref().domain() {
			Domain::Enclave { .. } => (self, BitSpan::EMPTY, BitSpan::EMPTY),
			Domain::Region { head, body, tail } => {
				//  Reälign the fully-spanning center slice, creating edge
				//  slices of the original type to merge with `head` and `tail`.
				let (l, c, r) = body.align_to::<U::Mem>();

				let t_bits = T::Mem::BITS as usize;
				let u_bits = U::Mem::BITS as usize;

				let l_bits = l.len() * t_bits;
				let c_bits = c.len() * u_bits;
				let r_bits = r.len() * t_bits;

				let l_addr = l.as_ptr() as *const T as *mut T;
				let c_addr = c.as_ptr() as *const U as *mut U;
				let r_addr = r.as_ptr() as *const T as *mut T;

				/* Compute a pointer for the left-most return span.

				The left span must contain the domain’s head element, if
				produced, as well as the `l` slice produced above. The left span
				begins in:

				- if `head` exists, then `head.1`
				- else, if `l` is not empty, then `l`
				- else, it is the empty pointer
				*/
				let l_ptr = match head {
					/* If the head exists, then the left span begins in it, and
					runs for the remaining bits in it, and all the bits of `l`.
					*/
					Some((head, addr)) => BitSpan::new_unchecked(
						Address::new(NonNull::from(addr)),
						head,
						t_bits - head.into_inner() as usize + l_bits,
					),
					//  If the head does not exist, then the left span only
					//  covers `l`. If `l` is empty, then so is the span.
					None => {
						if l_bits == 0 {
							BitSpan::EMPTY
						}
						else {
							BitSpan::new_unchecked(
								Address::new(NonNull::new(l_addr).unwrap()),
								BitIdx::ZERO,
								l_bits,
							)
						}
					},
				};

				let c_ptr = if c_bits == 0 {
					BitSpan::EMPTY
				}
				else {
					BitSpan::new_unchecked(
						Address::new(NonNull::new(c_addr).unwrap()),
						BitIdx::ZERO,
						c_bits,
					)
				};

				/* Compute a pointer for the right-most return span.

				The right span must contain the `r` slice produced above, as
				well as the domain’s tail element, if produced. The right span
				begins in:

				- if `r` is not empty, then `r`
				- else, if `tail` exists, then `tail.0`
				- else, it is the empty pointer
				*/
				let r_ptr = match tail {
					//  If the tail exists, then the right span extends into it.
					Some((addr, tail)) => BitSpan::new_unchecked(
						//  If the `r` slice exists, then the right span
						//  *begins* in it.
						if r.is_empty() {
							Address::new(NonNull::from(addr))
						}
						else {
							Address::new(NonNull::new(r_addr).unwrap())
						},
						BitIdx::ZERO,
						tail.into_inner() as usize + r_bits,
					),
					//  If the tail does not exist, then the right span is only
					//  `r`.
					None => {
						//  If `r` exists, then the right span covers it.
						if !r.is_empty() {
							BitSpan::new_unchecked(
								Address::new(NonNull::new(r_addr).unwrap()),
								BitIdx::ZERO,
								r_bits,
							)
						}
						//  Otherwise, the right span is empty.
						else {
							BitSpan::EMPTY
						}
					},
				};

				(l_ptr, c_ptr, r_ptr)
			},
		}
	}

	//  Encoded fields

	/// Gets the base element address of the referent region.
	///
	/// # Parameters
	///
	/// - `&self`
	///
	/// # Returns
	///
	/// The address of the starting element of the memory region. This address
	/// is weakly typed so that it can be cast by call sites to the most useful
	/// access type.
	#[inline]
	pub(crate) fn address(&self) -> Address<M, T> {
		unsafe {
			Address::new(NonNull::new_unchecked(
				(self.ptr.as_ptr() as usize & Self::PTR_ADDR_MASK) as *mut T,
			))
		}
	}

	/// Overwrites the data pointer with a new address. This method does not
	/// perform safety checks on the new pointer.
	///
	/// # Parameters
	///
	/// - `&mut self`
	/// - `ptr`: The new address of the `BitSpan`’s domain.
	///
	/// # Safety
	///
	/// None. The invariants of [`::new`] must be checked at the caller.
	///
	/// [`::new`]: Self::new
	#[inline]
	#[cfg(any(feature = "alloc", test))]
	pub(crate) unsafe fn set_address<A>(&mut self, addr: A)
	where
		A: TryInto<Address<M, T>>,
		A::Error: Debug,
	{
		let addr = addr.try_into().unwrap();
		let mut addr_value = addr.to_const() as usize;
		addr_value &= Self::PTR_ADDR_MASK;
		addr_value |= self.ptr.as_ptr() as usize & Self::PTR_HEAD_MASK;
		self.ptr = NonNull::new_unchecked(addr_value as *mut ());
	}

	/// Gets the starting bit index of the referent region.
	///
	/// # Parameters
	///
	/// - `&self`
	///
	/// # Returns
	///
	/// A [`BitIdx`] of the first live bit in the element at the
	/// [`self.address()`] address.
	///
	/// [`BitIdx`]: crate::index::BitIdx
	/// [`self.address()`]: Self::pointer
	#[inline]
	pub(crate) fn head(&self) -> BitIdx<T::Mem> {
		//  Get the high part of the head counter out of the pointer.
		let ptr = self.ptr.as_ptr() as usize;
		let ptr_head = (ptr & Self::PTR_HEAD_MASK) << Self::LEN_HEAD_BITS;
		//  Get the low part of the head counter out of the length.
		let len_head = self.len & Self::LEN_HEAD_MASK;
		//  Combine and mark as an index.
		unsafe { BitIdx::new_unchecked((ptr_head | len_head) as u8) }
	}

	/// Write a new `head` value into the pointer, with no other effects.
	///
	/// # Parameters
	///
	/// - `&mut self`
	/// - `head`: A new starting index.
	///
	/// # Effects
	///
	/// `head` is written into the `.head` logical field, without affecting
	/// `.addr` or `.bits`.
	#[inline]
	#[cfg(any(feature = "alloc", test))]
	pub(crate) unsafe fn set_head(&mut self, head: BitIdx<T::Mem>) {
		let head = head.into_inner() as usize;
		let mut ptr = self.ptr.as_ptr() as usize;

		ptr &= Self::PTR_ADDR_MASK;
		ptr |= head >> Self::LEN_HEAD_BITS;
		self.ptr = NonNull::new_unchecked(ptr as *mut ());

		self.len &= !Self::LEN_HEAD_MASK;
		self.len |= head & Self::LEN_HEAD_MASK;
	}

	/// Gets the number of live bits in the referent region.
	///
	/// # Parameters
	///
	/// - `&self`
	///
	/// # Returns
	///
	/// A count of how many live bits the region pointer describes.
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub(crate) fn len(&self) -> usize {
		self.len >> Self::LEN_HEAD_BITS
	}

	/// Sets the `.bits` logical member to a new value.
	///
	/// # Parameters
	///
	/// - `&mut self`
	/// - `len`: A new bit length. This must not be greater than
	///   [`REGION_MAX_BITS`].
	///
	/// # Effects
	///
	/// The `new_len` value is written directly into the `.bits` logical field.
	///
	/// [`REGION_MAX_BITS`]: Self::REGION_MAX_BITS
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub(crate) unsafe fn set_len(&mut self, new_len: usize) {
		debug_assert!(
			new_len <= Self::REGION_MAX_BITS,
			"Length {} out of range",
			new_len,
		);
		self.len &= Self::LEN_HEAD_MASK;
		self.len |= new_len << Self::LEN_HEAD_BITS;
	}

	/// Gets a pointer to the starting bit of the span.
	#[inline]
	pub(crate) fn as_bitptr(self) -> BitPtr<M, O, T> {
		BitPtr::new(self.address(), self.head())
	}

	#[inline]
	pub(crate) fn as_bitptr_range(self) -> BitPtrRange<M, O, T> {
		unsafe { self.as_bitptr().range(self.len()) }
	}

	/// Gets the three logical components of the pointer.
	///
	/// # Parameters
	///
	/// - `&self`
	///
	/// # Returns
	///
	/// - `.0`: The base address of the referent memory region.
	/// - `.1`: The index of the first live bit in the first element of the
	///   region.
	/// - `.2`: The number of live bits in the region.
	#[inline]
	pub(crate) fn raw_parts(&self) -> (Address<M, T>, BitIdx<T::Mem>, usize) {
		(self.address(), self.head(), self.len())
	}

	//  Computed information

	/// Computes the number of elements, starting at [`self.address()`], that
	/// the region touches.
	///
	/// # Parameters
	///
	/// - `&self`
	///
	/// # Returns
	///
	/// The count of all elements, starting at [`self.address()`], that contain
	/// live bits included in the referent region.
	///
	/// [`self.address()`]: Self::pointer
	#[inline]
	pub(crate) fn elements(&self) -> usize {
		//  Find the distance of the last bit from the base address.
		let total = self.len() + self.head().into_inner() as usize;
		//  The element count is always the bit count divided by the bit width,
		let base = total >> T::Mem::INDX;
		//  plus whether any fractional element exists after the division.
		let tail = total as u8 & T::Mem::MASK;
		base + (tail != 0) as usize
	}

	/// Computes the tail index for the first dead bit after the live bits.
	///
	/// # Parameters
	///
	/// - `&self`
	///
	/// # Returns
	///
	/// A `BitTail` that is the index of the first dead bit after the last live
	/// bit in the last element. This will almost always be in the range `1 ..=
	/// T::Mem::BITS`.
	///
	/// It will be zero only when `self` is empty.
	#[inline]
	pub(crate) fn tail(&self) -> BitTail<T::Mem> {
		let (head, len) = (self.head(), self.len());

		if head.into_inner() == 0 && len == 0 {
			return BitTail::ZERO;
		}

		//  Compute the in-element tail index as the head plus the length,
		//  modulated by the element width.
		let tail = (head.into_inner() as usize + len) & T::Mem::MASK as usize;
		/* If the tail is zero, wrap it to `T::Mem::BITS` as the maximal. This
		upshifts `1` (tail is zero) or `0` (tail is not), then sets the upshift
		on the rest of the tail, producing something in the range
		`1 ..= T::Mem::BITS`.
		*/
		unsafe {
			BitTail::new_unchecked(
				(((tail == 0) as u8) << T::Mem::INDX) | tail as u8,
			)
		}
	}

	//  Manipulators

	/// Increments the `.head` logical field, rolling over into `.addr`.
	///
	/// # Parameters
	///
	/// - `&mut self`
	///
	/// # Effects
	///
	/// Increments `.head` by one. If the increment resulted in a rollover to
	/// `0`, then the `.addr` field is increased to the next [`T::Mem`]
	/// stepping.
	///
	/// [`T::Mem`]: crate::store::BitStore::Mem
	#[inline]
	pub(crate) unsafe fn incr_head(&mut self) {
		//  Increment the cursor, permitting rollover to `T::Mem::BITS`.
		let head = self.head().into_inner() as usize + 1;

		//  Write the low bits into the `.len` field, then discard them.
		self.len &= !Self::LEN_HEAD_MASK;
		self.len |= head & Self::LEN_HEAD_MASK;
		let head = head >> Self::LEN_HEAD_BITS;

		//  Erase the high bits of `.head` from `.ptr`,
		let mut ptr = self.ptr.as_ptr() as usize;
		ptr &= Self::PTR_ADDR_MASK;
		/* Then numerically add the high bits of `.head` into the low bits of
		`.ptr`. If the head increment rolled over into a new element, this will
		have the effect of raising the `.addr` logical field to the next element
		address, in one instruction.
		*/
		ptr += head;
		self.ptr = NonNull::new_unchecked(ptr as *mut ());
	}

	//  Comparators

	/// Renders the pointer structure into a formatter for use during
	/// higher-level type [`Debug`] implementations.
	///
	/// # Parameters
	///
	/// - `&self`
	/// - `fmt`: The formatter into which the pointer is rendered.
	/// - `name`: The suffix of the structure rendering its pointer. The `Bit`
	///   prefix is applied to the object type name in this format.
	/// - `fields`: Any additional fields in the object’s debug info to be
	///   rendered.
	///
	/// # Returns
	///
	/// The result of formatting the pointer into the receiver.
	///
	/// # Behavior
	///
	/// This function writes `Bit{name}<{ord}, {type}> {{ {fields } }}` into the
	/// `fmt` formatter, where `{fields}` includes the address, head index, and
	/// bit length of the pointer, as well as any additional fields provided by
	/// the caller.
	///
	/// Higher types in the crate should use this function to drive their
	/// [`Debug`] implementations, and then use [`BitSlice`]’s list formatters
	/// to display their buffer contents.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	/// [`Debug`]: core::fmt::Debug
	pub(crate) fn render<'a>(
		&'a self,
		fmt: &'a mut Formatter,
		name: &'a str,
		fields: impl IntoIterator<Item = &'a (&'a str, &'a dyn Debug)>,
	) -> fmt::Result {
		write!(
			fmt,
			"Bit{}<{}, {}>",
			name,
			any::type_name::<O>(),
			any::type_name::<T::Mem>()
		)?;
		let mut builder = fmt.debug_struct("");
		builder
			.field("addr", &self.address().fmt_pointer())
			.field("head", &self.head().fmt_binary())
			.field("bits", &self.len());
		for (name, value) in fields {
			builder.field(name, value);
		}
		builder.finish()
	}
}

impl<O, T> BitSpan<Const, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// Converts an opaque `*BitSlice` wide pointer back into a `BitSpan`.
	///
	/// This should compile down to a noöp, but the implementation should
	/// nevertheless be an explicit deconstruction and reconstruction rather
	/// than a bare [`mem::transmute`], to guard against unforseen compiler
	/// reördering.
	///
	/// # Parameters
	///
	/// - `raw`: An opaque bit-region pointer
	///
	/// # Returns
	///
	/// `raw`, interpreted as a `BitSpan` so that it can be used as more than an
	/// opaque handle.
	///
	/// [`mem::transmute`]: core::mem::transmute
	//  Immutable pointers can only become immutable span descriptors.
	#[inline]
	pub(crate) fn from_bitslice_ptr(raw: *const BitSlice<O, T>) -> Self {
		let slice_nn = match NonNull::new(raw as *const [()] as *mut [()]) {
			Some(nn) => nn,
			None => return Self::EMPTY,
		};
		let ptr = slice_nn.cast::<()>();
		let len = unsafe { slice_nn.as_ref() }.len();
		Self {
			ptr,
			len,
			_or: PhantomData,
			_ty: PhantomData,
		}
	}
}

impl<O, T> BitSpan<Mut, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// Casts the `BitSpan` to an opaque `*BitSlice` pointer.
	///
	/// See [`.to_bitslice_ptr()`].
	///
	/// [`.to_bitslice_ptr()`]: Self::to_bitslice_ptr
	//  Only mutable span descriptors can become mutable pointers.
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub(crate) fn to_bitslice_ptr_mut(self) -> *mut BitSlice<O, T> {
		self.to_bitslice_ptr() as *mut BitSlice<O, T>
	}

	/// Casts the `BitSpan` to a `&mut BitSlice` reference.
	///
	/// This requires that the pointer be to a validly-allocated region that is
	/// not destroyed for the duration of the provided lifetime. Additionally,
	/// the bits described by `self` must not be viewable by any other handle.
	///
	/// # Lifetimes
	///
	/// - `'a`: A caller-provided lifetime that must not be greater than the
	///   duration of the referent buffer.
	///
	/// # Parameters
	///
	/// - `self`
	///
	/// # Returns
	///
	/// `self`, opacified as an exclusive bit-slice region reference rather than
	/// a `BitSpan` structure.
	//  Only mutable span descriptors can become mutable references.
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub(crate) fn to_bitslice_mut<'a>(self) -> &'a mut BitSlice<O, T> {
		unsafe { &mut *self.to_bitslice_ptr_mut() }
	}
}

#[cfg(not(tarpaulin_include))]
impl<M, O, T> Clone for BitSpan<M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn clone(&self) -> Self {
		*self
	}
}

impl<M, O, T> Eq for BitSpan<M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
}

impl<M1, M2, O, T1, T2> PartialEq<BitSpan<M2, O, T2>> for BitSpan<M1, O, T1>
where
	M1: Mutability,
	M2: Mutability,
	O: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn eq(&self, other: &BitSpan<M2, O, T2>) -> bool {
		let (addr_a, head_a, bits_a) = self.raw_parts();
		let (addr_b, head_b, bits_b) = other.raw_parts();
		//  Since ::BITS is an associated const, the compiler will automatically
		//  replace the entire function with `false` when the types don’t match.
		T1::Mem::BITS == T2::Mem::BITS
			&& addr_a.to_const() as usize == addr_b.to_const() as usize
			&& head_a.into_inner() == head_b.into_inner()
			&& bits_a == bits_b
	}
}

#[cfg(not(tarpaulin_include))]
impl<M, O, T> Default for BitSpan<M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn default() -> Self {
		Self::EMPTY
	}
}

#[cfg(not(tarpaulin_include))]
impl<M, O, T> Debug for BitSpan<M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		Pointer::fmt(self, fmt)
	}
}

#[cfg(not(tarpaulin_include))]
impl<M, O, T> Pointer for BitSpan<M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		self.render(fmt, "Ptr", None)
	}
}

impl<M, O, T> Copy for BitSpan<M, O, T>
where
	M: Mutability,
	O: BitOrder,
	T: BitStore,
{
}

/// An error produced when creating `BitSpan` encoded references.
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
pub enum BitSpanError<T>
where T: BitStore
{
	/// The base `BitPtr` is invalid.
	InvalidBitptr(BitPtrError<T>),
	/// `BitSpan` domains have a length ceiling.
	TooLong(usize),
	/// `BitSpan` domains have an address ceiling.
	TooHigh(*const T),
}

#[cfg(not(tarpaulin_include))]
impl<T> From<BitPtrError<T>> for BitSpanError<T>
where T: BitStore
{
	#[inline(always)]
	fn from(err: BitPtrError<T>) -> Self {
		Self::InvalidBitptr(err)
	}
}

#[cfg(not(tarpaulin_include))]
impl<T> From<Infallible> for BitSpanError<T>
where T: BitStore
{
	#[inline(always)]
	fn from(_: Infallible) -> Self {
		unreachable!("Infallible errors can never be produced");
	}
}

#[cfg(not(tarpaulin_include))]
impl<T> Debug for BitSpanError<T>
where T: BitStore
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		let tname = any::type_name::<T>();
		write!(fmt, "BitSpanError<{}>::", tname,)?;
		match self {
			Self::InvalidBitptr(err) => {
				fmt.debug_tuple("InvalidBitptr").field(&err).finish()
			},
			Self::TooLong(len) => {
				fmt.debug_tuple("TooLong").field(&len).finish()
			},
			Self::TooHigh(addr) => {
				fmt.debug_tuple("TooHigh").field(&addr).finish()
			},
		}
	}
}

#[cfg(not(tarpaulin_include))]
impl<T> Display for BitSpanError<T>
where T: BitStore
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		match self {
			Self::InvalidBitptr(err) => Display::fmt(err, fmt),
			Self::TooLong(len) => write!(
				fmt,
				"Length {} is too long to encode in a bit slice, which can \
				 only accept {} bits",
				len,
				BitSpan::<Const, Lsb0, usize>::REGION_MAX_BITS
			),
			Self::TooHigh(addr) => {
				write!(fmt, "Address {:p} would wrap the address space", addr)
			},
		}
	}
}

unsafe impl<T> Send for BitSpanError<T> where T: BitStore
{
}

unsafe impl<T> Sync for BitSpanError<T> where T: BitStore
{
}

#[cfg(feature = "std")]
impl<T> std::error::Error for BitSpanError<T> where T: BitStore
{
}

#[cfg(test)]
mod tests {
	use core::{
		convert::TryFrom,
		mem,
		ptr,
	};

	use tap::Pipe;

	use super::*;
	use crate::{
		prelude::*,
		ptr::{
			check_alignment,
			MisalignError,
			NullPtrError,
		},
	};

	#[test]
	fn ctor() {
		assert!(matches!(
			Address::<Const, u8>::try_from(ptr::null()),
			Err(NullPtrError),
		));
		assert!(matches!(
			Address::<Const, u16>::try_from(3 as *const u16).unwrap().pipe(check_alignment),
			Err(MisalignError { ptr }) if ptr as usize == 3,
		));

		//  Double check the null pointers, but they are in practice impossible
		//  to construct.
		assert_eq!(
			BitSpan::<Const, LocalBits, u8>::from_bitslice_ptr(
				ptr::slice_from_raw_parts(ptr::null::<()>(), 1)
					as *mut BitSlice<LocalBits, u8>
			),
			BitSpan::<Const, LocalBits, u8>::EMPTY,
		);

		let data = 0u16;
		let mut addr = Address::from(&data);
		let head = BitIdx::new(5).unwrap();
		assert!(BitSpan::<_, Lsb0, _>::new(addr, head, !3).is_err());
		addr = Address::try_from(!1 as *const u16).unwrap();
		assert!(BitSpan::<_, Lsb0, _>::new(addr, head, 50).is_err());
	}

	#[test]
	fn recast() {
		let data = 0u32;
		let bitspan = unsafe { BitPtr::from_ref(&data).span_unchecked(32) };
		let raw_ptr = bitspan.to_bitslice_ptr();
		assert_eq!(
			bitspan,
			BitSpan::<Const, Lsb0, u32>::from_bitslice_ptr(raw_ptr)
		);
	}

	#[test]
	fn realign() {
		let data = [0u8; 10];
		let bits = data.view_bits::<LocalBits>();

		let (l, c, r) = unsafe { bits.as_bitspan().align_to::<u16>() };
		assert_eq!(l.len() + c.len() + r.len(), 80);

		let (l, c, r) = unsafe { bits[4 ..].as_bitspan().align_to::<u16>() };
		assert_eq!(l.len() + c.len() + r.len(), 76);

		let (l, c, r) = unsafe { bits[.. 76].as_bitspan().align_to::<u16>() };
		assert_eq!(l.len() + c.len() + r.len(), 76);

		let (l, c, r) = unsafe { bits[8 ..].as_bitspan().align_to::<u16>() };
		assert_eq!(l.len() + c.len() + r.len(), 72);

		let (l, c, r) = unsafe { bits[.. 72].as_bitspan().align_to::<u16>() };
		assert_eq!(l.len() + c.len() + r.len(), 72);

		let (l, c, r) = unsafe { bits[4 .. 76].as_bitspan().align_to::<u16>() };
		assert_eq!(l.len() + c.len() + r.len(), 72);
	}

	#[test]
	fn modify() {
		let (a, b) = (0u16, 1u16);

		let mut bitspan = a.view_bits::<LocalBits>().as_bitspan();
		let mut expected = (&a as *const _ as usize, 16usize << 3);

		assert_eq!(bitspan.address().to_const(), &a as *const _);
		assert_eq!(bitspan.ptr.as_ptr() as usize, expected.0);
		assert_eq!(bitspan.len, expected.1);

		expected.0 = &b as *const _ as usize;
		unsafe {
			bitspan.set_address(&b as *const _);
		}
		assert_eq!(bitspan.address().to_const(), &b as *const _);
		assert_eq!(bitspan.ptr.as_ptr() as usize, expected.0);
		assert_eq!(bitspan.len, expected.1);

		let orig_head = bitspan.head();
		unsafe {
			bitspan.set_head(orig_head.next().0);
		}
		assert_eq!(bitspan.head(), orig_head.next().0);
	}

	#[test]
	fn mem_size() {
		assert_eq!(
			mem::size_of::<BitSpan<Const, LocalBits, usize>>(),
			mem::size_of::<*const [usize]>()
		);
		assert_eq!(
			mem::size_of::<Option<BitSpan<Const, LocalBits, usize>>>(),
			mem::size_of::<*const [usize]>()
		);
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/ptr/span.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/ptr/tests.rs =====
#![cfg(test)]

use core::cell::Cell;

use static_assertions::assert_not_impl_any;

use super::{
	BitPtr,
	Const,
};
use crate::{
	order::{
		Lsb0,
		Msb0,
	},
	slice::BitSlice,
};

#[test]
fn pointers_not_send_sync() {
	assert_not_impl_any!(BitPtr<Const, Lsb0, u8>: Send, Sync);
}

#[test]
fn copies() {
	let mut data = [0xA5u8, 0, 0];

	let base = BitPtr::<_, Msb0, _>::from_mut_slice(&mut data);
	let step = unsafe { base.add(8) };

	unsafe {
		super::copy(base.immut(), step, 8);
		super::copy_nonoverlapping(base.add(4).immut(), step.add(8), 8);
	}
	assert_eq!(data[1], 0xA5);
	assert_eq!(data[2], 0x5A);

	unsafe {
		super::copy(base.add(4).immut(), step, 8);
	}
	assert_eq!(data[1], 0x5A);

	let mut other = 0u16;
	let dest = BitPtr::<_, Lsb0, _>::from_mut(&mut other);
	unsafe {
		super::copy(base.immut(), dest, 16);
	}
	if cfg!(target_endian = "little") {
		assert_eq!(other, 0x5AA5, "{:04x}", other);
	}
}

#[test]
fn misc() {
	let x = 0u32;
	let a = BitPtr::<_, Lsb0, _>::from_ref(&x);
	let b = a.cast::<Cell<u32>>();
	let c = unsafe { b.add(1) };

	assert!(super::eq(a, b));
	assert!(!super::eq(b, c));

	let d = a.cast::<u8>();
	let step = unsafe { d.add(1) }.align_offset(2);
	assert_eq!(step, 15);
	let step = unsafe { d.add(9) }.align_offset(4);
	assert_eq!(step, 23);
}

#[test]
fn io() {
	let mut data = 0u16;
	let base = BitPtr::<_, Msb0, _>::from_mut(&mut data);

	unsafe {
		assert!(!super::read(base.add(1).immut()));
		super::write(base.add(1), true);
		assert!(super::read(base.add(1).immut()));

		assert!(!super::read_volatile(base.add(2).immut()));
		super::write_volatile(base.add(2), true);
		assert!(super::read_volatile(base.add(2).immut()));
		super::write_volatile(base.add(2), false);

		assert!(!super::replace(base.add(3), true));
		assert!(super::read(base.add(3).immut()));

		super::swap(base, base.add(1));
		assert!(super::read(base.immut()));
		assert!(!super::read(base.add(1).immut()));

		super::swap_nonoverlapping(base, base.add(4), 4);
	}
}

#[test]
fn make_slices() {
	let mut data = 0u32;
	let base = BitPtr::<_, Msb0, _>::from_mut(&mut data);

	let a = super::bitslice_from_raw_parts_mut(base, 32);
	let b = super::bitslice_from_raw_parts(base.immut(), 32);

	assert!(core::ptr::eq(a as *const BitSlice<Msb0, u32>, b));
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/ptr/tests.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/ptr.rs =====
/*! Mirror of the [`core::ptr`] module and `bitvec`-specific pointer structures.

# Types

As `bitvec` is not the standard library, it does not have the freedom to use
language builtins such as actual pointers. Instead, `bitvec` uses its own
analagous structures:

- [`BitPtr<M, O, T>`]: This represents a pointer to a single bit, and is vaguely
  similar to `*const bool`, `*mut bool`, and `NonNull<bool>`. It consists of a
  (non-null, well-aligned) pointer to a `T` memory element and a bit-index
  within that element. It uses the `O` ordering implementation to access the
  selected bit, and uses `M` to determine whether it has write permissions to
  the location.
- [`BitPtrRange<M, O, T>`]: This is equivalent to `Range<BitPtr<M, O, T>>`. It
  exists because [`Range`] has some associated types that are still unstable to
  implement for its type parameters. It is also smaller than the `Range` would
  be, because it can take advantage of layout optimizations.
- [`BitRef<M, O, T>`]: This is a proxy reference type, equivalent to the C++
  [`bitset<N>::reference`]. It implements `Deref` and, if `M` is `Mut`,
  `DerefMut` to bool, so that it can be read from and written to as if it were
  an `&bool` or `&mut bool`. It is **not** a referent type, and cannot be used
  in APIs that expect actual references. It is implemented under the hood as a
  `BitPtr` with a `bool` cached in one of the padding bytes.
- `BitSpan<M, O, T>`: This is a crate-internal type that encodes a `BitPtr` and
  a length counter into a two-word structure that can be transmuted into
  `*BitSlice<O, T>`. This type enforces the non-null/well-aligned rule, and is
  the source of the limitation that `bitvec` region types can only address ⅛ of
  a `usize`, rather than the ½ limitation of the standard library collections.

  This type is not public API; it will only ever appear in its transmuted form,
  `*BitSlice<O, T>`. Users are **not permitted** to use any of the [`core::ptr`]
  or [`pointer`] functions to view or modify `*BitSlice` pointers, or their
  referent locations, in any way.

# Safety

The functions in this module take `bitvec` equivalents to raw pointers as their
arguments and read from or write to them. For this to be safe, these pointers
must be *valid*. Whether a pointer is valid depends on the operation it is used
for (reading or writing), and the extent of the memory that is accessed (i.e.
how many bits are read/written in and how many underlying memory elements are
accessed). Most functions use [`BitPtr`] to access only a single bit, in which
case the documentation omits the size and implicitly assumes it to be one bit in
one `T` element.

The Rust rules about pointer validity are always in effect; `bitvec` refines
them to a bit-precision granularity, but must still respect the byte-level and
element-level rules.

# Crate-Specific Restrictions

`bitvec` uses an internal encoding scheme to make bit-region pointers fit into a
standard Rust slice pointer. This encoding requires that the base element
address of a bit-pointer be *non-null* and *well-aligned* for all pointers that
are used in the encoding scheme.

The `bitvec` structure used to emulate a pointer to a single bit is larger than
one processor word, and thus cannot be encoded to fit in a `*const Bit`. To ease
internal complexity, these restrictions are universal in `bitvec`: the crate as
a whole refuses to operate on null pointers, or pointers that are not aligned to
their referent type, even if your usage never touches the span encoding.

As such, the pointer types in this module can essentially only be sourced from
references, not from arbitrary address values. While this module attempts to
rely on actual Rust references as much as possible, and instead use only the
ordinary [`core::ptr`] and [`pointer`] functions. This is not always possible;
in particular, Rust does not offer stable atomic intrinsics, and instead only
allows them to be used on references.

[`BitPtr`]: crate::ptr::BitPtr
[`BitPtr<M, O, T>`]: crate::ptr::BitPtr
[`BitPtrRange<M, O, T>`]: crate::ptr::BitPtrRange
[`BitRef<M, O, T>`]: crate::ptr::BitRef
[`BitSpan<M, O, T>`]: crate::ptr::BitSpan
[`Range`]: core::ops::Range
[`bitset<N>::reference`]: https://en.cppreference.com/w/cpp/utility/bitset/reference
[`core::ptr`]: core::ptr
[`pointer`]: https://doc.rust-lang.org/std/primitive.pointer.html
!*/

use core::hash::{
	Hash,
	Hasher,
};

use crate::{
	order::BitOrder,
	slice::BitSlice,
	store::BitStore,
};

mod address;
mod proxy;
pub(crate) mod range;
mod single;
mod span;

pub(crate) use self::{
	address::AddressExt,
	span::BitSpan,
};
pub use self::{
	address::{
		check_alignment,
		Address,
		Const,
		MisalignError,
		Mut,
		Mutability,
		NullPtrError,
	},
	proxy::BitRef,
	range::BitPtrRange,
	single::{
		BitPtr,
		BitPtrError,
	},
	span::BitSpanError,
};

/// Copies `count` bits from `src` to `dst`. The source and destination may
/// overlap.
///
/// If the source and destination will *never* overlap, [`copy_nonoverlapping`]
/// can be used instead.
///
/// `copy` is semantically equivalent to C’s [`memmove`], but with the argument
/// order swapped. Copying takes place as if the bits were copied from `src` to
/// a temporary array, then copied from the array into `dst`.
///
/// # Original
///
/// [`ptr::copy`](core::ptr::copy)
///
/// # API Differences
///
/// The pointers may differ in bit-ordering or storage element types. `bitvec`
/// considers it Undefined Behavior for two pointer regions to overlap in memory
/// if they have different bit-orderings, and so will only perform overlap
/// detection when `O1` and `O2` match.
///
/// # Safety
///
/// Behavior is undefined if any of the following conditions are violated:
///
/// - `src` must be [valid] for reads of `count` bits.
/// - `dst` must be [valid] for writes of `count` bits.
/// - `src` and `dst` must not overlap if they have different bit-ordering
///   parameters.
///
/// The type parameters `T1` and `T2` are permitted to differ.
///
/// # Examples
///
/// Basic usage:
///
/// ```rust
/// use bitvec::prelude::*;
///
/// let start = 0b1011u8;
/// let mut end = 0u16;
///
/// unsafe {
///   bitvec::ptr::copy::<Lsb0, Msb0, _, _>(
///     (&start).into(),
///     (&mut end).into(),
///     4,
///   );
/// }
/// assert_eq!(end, 0b1101_0000__0000_0000);
/// ```
///
/// Overlapping regions:
///
/// ```rust
/// use bitvec::prelude::*;
///
/// let mut x = 0b1111_0010u8;
/// let src = BitPtr::<_, Lsb0, _>::from_mut(&mut x);
/// let dst = unsafe { src.add(2) };
///
/// unsafe {
///   bitvec::ptr::copy(src.immut(), dst, 4);
/// }
/// assert_eq!(x, 0b1100_1010);
/// //                ^^ ^^ bottom nibble moved here
/// ```
///
/// [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
/// [`copy_nonoverlapping`]: crate::ptr::copy_nonoverlapping
/// [`memmove`]: https://en.cppreference.com/w/c/string/byte/memmove
#[cfg_attr(not(tarpaulin_include), inline(always))]
pub unsafe fn copy<O1, O2, T1, T2>(
	src: BitPtr<Const, O1, T1>,
	dst: BitPtr<Mut, O2, T2>,
	count: usize,
) where
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	src.copy_to(dst, count);
}

/// Copies `count` bits from `src` to `dst`. The source and destination must
/// *not* overlap.
///
/// For regions of memory which might overlap, use [`copy`] instead.
///
/// `copy_nonoverlapping` is semantically equivalent to C’s [`memcpy`], but with
/// the argument order swapped.
///
/// # Original
///
/// [`ptr::copy_nonoverlapping`](core::ptr::copy_nonoverlapping)
///
/// # API Differences
///
/// The pointers may differ in bit-ordering or storage element parameters.
///
/// # Safety
///
/// Behavior is undefined if any of the following conditions are violated:
///
/// - `src` must be [valid] for reads of `count` bits.
/// - `dst` must be [valid] for writes of `count` bits.
/// - The region of memory beginning at `src` with a size of `count` bits must
///   not overlap with the region of memory beginning at `dst` with the same
///   size.
///
/// # Examples
///
/// ```rust
/// use bitvec::prelude::*;
///
/// let mut data = 0b1011u8;
/// let ptr = BitPtr::<_, Msb0, _>::from_mut(&mut data);
///
/// unsafe {
///   bitvec::ptr::copy_nonoverlapping(
///     ptr.add(4).immut(),
///     ptr,
///     4,
///   );
/// }
/// assert_eq!(data, 0b1011_1011);
/// ```
///
/// [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
/// [`copy`]: crate::ptr::copy
/// [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy
#[cfg_attr(not(tarpaulin_include), inline(always))]
pub unsafe fn copy_nonoverlapping<O1, O2, T1, T2>(
	src: BitPtr<Const, O1, T1>,
	dst: BitPtr<Mut, O2, T2>,
	count: usize,
) where
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	src.copy_to_nonoverlapping(dst, count);
}

/** Compares raw bit-pointers for equality.

This is the same as using the `==` operator, but less generic: the arguments
have to be `BitPtr<Const, _, _>` bit-pointers, not anything that implements
`PartialEq`.

# Original

[`ptr::eq`](core::ptr::eq)

# API Differences

The two pointers can differ in their storage type parameters. `bitvec` defines
pointer equality only between pointers with the same underlying `BitStore::Mem`
register type.

This cannot compare span pointers. `*const BitSlice` can be used in the standard
library `ptr::eq` and does not need an override.

# Examples

```rust
use bitvec::prelude::*;
use core::cell::Cell;

let data = 0u8;
let bare_ptr = BitPtr::<_, Lsb0, _>::from_ref(&data);
let cell_ptr = bare_ptr.cast::<Cell<u8>>();

assert!(bitvec::ptr::eq(bare_ptr, cell_ptr));
```
**/
#[cfg_attr(not(tarpaulin_include), inline(always))]
pub fn eq<O, T1, T2>(a: BitPtr<Const, O, T1>, b: BitPtr<Const, O, T2>) -> bool
where
	O: BitOrder,
	T1: BitStore,
	T2: BitStore,
	BitPtr<Const, O, T1>: PartialEq<BitPtr<Const, O, T2>>,
{
	a == b
}

/** Hash a raw bit-pointer.

This can be used to prove hashing the pointer address value, rather than the
referent bit.

# Original

[`ptr::hash`](core::ptr::hash)
**/
#[inline(always)]
#[cfg(not(tarpaulin_include))]
pub fn hash<O, T, S>(hashee: BitPtr<Const, O, T>, into: &mut S)
where
	O: BitOrder,
	T: BitStore,
	S: Hasher,
{
	hashee.hash(into);
}

/** Reads the bit from `src`.

# Original

[`ptr::read`](core::ptr::read)

# Safety

Behavior is undefined if any of the following conditions are violated:

- `src` must be [valid] for reads.
- `src` must point to a properly initialized value of type `T`.

# Examples

```rust
use bitvec::prelude::*;

let data = 128u8;
let ptr = BitPtr::<_, Msb0, _>::from_ref(&data);
assert!(unsafe {
  bitvec::ptr::read(ptr)
});
```

[valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
**/
#[cfg_attr(not(tarpaulin_include), inline(always))]
pub unsafe fn read<O, T>(src: BitPtr<Const, O, T>) -> bool
where
	O: BitOrder,
	T: BitStore,
{
	src.read()
}

/** Performs a volatile read of the bit from `src`.

Volatile operations are intended to act on I/O memory, and are guaranteed to not
be elided or reördered by the compiler across other volatile operations.

# Original

[`ptr::read_volatile`](core::ptr::read_volatile)

# Notes

Rust does not curretnly have a rigorously and formally defined memory model, so
the precise semantics of what “volatile” means here is subject to change over
time. That being said, the semantics will almost always end up pretty similar to
[C11’s definition of volatile][c11].

The compiler shouldn’t change the relative order or number of volatile memory
operations.

# Safety

Behavior is undefined if any of the following conditions are violated:

- `dst` must be [valid] for reads
- `dst` must point to a properly initialized value of type `T`
- no other pointer must race `dst` to view or modify the referent location
  unless `T` is capable of ensuring race safety.

Just like in C, whether an operation is volatile has no bearing whatsoëver on
questions involving concurrent access from multiple threads. Volatile accesses
behave exactly like non-atomic accesses in that regard. In particular, a race
between a `read_volatile` and any write operation on the same location is
undefined behavior.

This is true even for atomic types! This instruction is an ordinary load that
the compiler will not remove. It is *not* an atomic instruction.

# Examples

```rust
use bitvec::prelude::*;

let data = 4u8;
let ptr = BitPtr::<_, Lsb0, _>::from_ref(&data);
unsafe {
  assert!(bitvec::ptr::read_volatile(ptr.add(2)));
}
```

[c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf
[valid]: https://doc.rust-lang.org/core/ptr/index.html#safety
**/
#[cfg_attr(not(tarpaulin_include), inline(always))]
pub unsafe fn read_volatile<O, T>(src: BitPtr<Const, O, T>) -> bool
where
	O: BitOrder,
	T: BitStore,
{
	src.read_volatile()
}

/** Moves `src` into the pointed `dst`, returning the previous `dst` bit.

This function is semantically equivalent to [`BitRef::replace`] except that it
operates on raw pointers instead of references. When a proxy reference is
available, prefer [`BitRef::replace`].

# Original

[`ptr::replace`](core::ptr::replace)

# Safety

Behavior is undefined if any of the following conditions are violated:

- `dst` must be [valid] for both reads and writes.
- `dst` must point to a properly initialized value of type `T`.

# Examples

```rust
use bitvec::prelude::*;

let mut data = 4u8;
let ptr = BitPtr::<_, Lsb0, _>::from_mut(&mut data);
assert!(unsafe {
  bitvec::ptr::replace(ptr.add(2), false)
});
assert_eq!(data, 0);
```

[valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
[`BitPtr::replace`]: crate::ptr::BitRef::replace
**/
#[cfg_attr(not(tarpaulin_include), inline(always))]
pub unsafe fn replace<O, T>(dst: BitPtr<Mut, O, T>, src: bool) -> bool
where
	O: BitOrder,
	T: BitStore,
{
	dst.replace(src)
}

/** Forms a raw bit-slice from a bit-pointer and a length.

The `len` argument is the number of **bits**, not the number of elements.

This function is safe, but actually using the return value is unsafe. See the
documentation of [`slice::from_raw_parts`] for bit-slice safety requirements.

# Original

[`ptr::slice_from_raw_parts`](core::ptr::slice_from_raw_parts)

# Examples

```rust
use bitvec::ptr;
use bitvec::order::Lsb0;

let x = [5u8, 10, 15];
let bitptr = ptr::BitPtr::<_, Lsb0, _>::from_ref(&x[0]);
let bitslice = ptr::bitslice_from_raw_parts(bitptr, 24);
assert_eq!(unsafe { &*bitslice }[2], true);
```

[`slice::from_raw_parts`]: crate::slice::from_raw_parts
**/
#[cfg_attr(not(tarpaulin_include), inline(always))]
pub fn bitslice_from_raw_parts<O, T>(
	data: BitPtr<Const, O, T>,
	len: usize,
) -> *const BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	unsafe { data.span_unchecked(len) }.to_bitslice_ptr()
}

/** Performs the same functionality as [`bitslice_from_raw_parts`], except that
a raw mutable bit-slice is returned, as opposed to a raw immutable bit-slice.

See the documentation of [`bitslice_from_raw_parts`] for more details.

This function is safe, but actually using the return value is unsafe. See the
documentation of [`slice::from_raw_parts_mut`] for bit-slice safety
requirements.

# Original

[`ptr::slice_from_raw_parts`](core::ptr::slice_from_raw_parts)

# Examples

```rust
use bitvec::ptr;
use bitvec::order::Lsb0;

let mut x = [5u8, 10, 15];
let bitptr = ptr::BitPtr::<_, Lsb0, _>::from_mut(&mut x[0]);
let bitslice = ptr::bitslice_from_raw_parts_mut(bitptr, 24);
unsafe { &mut *bitslice }.set(0, true);
assert!(unsafe { &*bitslice }[0]);
```

[`bitslice_from_raw_parts`]: crate::ptr::bitslice_from_raw_parts
[`slice::from_raw_parts_mut`]: crate::slice::from_raw_parts_mut
**/
#[cfg_attr(not(tarpaulin_include), inline(always))]
pub fn bitslice_from_raw_parts_mut<O, T>(
	data: BitPtr<Mut, O, T>,
	len: usize,
) -> *mut BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	unsafe { data.span_unchecked(len).to_bitslice_ptr_mut() }
}

/** Swaps the values at two mutable locations.

But for the following exception, this function is semantically equivalent to
[`BitRef::swap`]: it operates on raw pointers instead of references. When
references are available, prefer [`BitRef::swap`].

# Original

[`ptr::swap`](core::ptr::swap)

# Safety

Behavior is undefined if any of the following conditions are violated:

- Both `x` and `y` must be [valid] for both reads and writes.
- Both `x` and `y` must point to initialized instances of type `T1` and `T2`,
  respectively.

# Examples

```rust
use bitvec::prelude::*;

let mut data = 2u8;
let x = BitPtr::<_, Lsb0, _>::from_mut(&mut data);
let y = unsafe { x.add(1) };

unsafe {
  bitvec::ptr::swap(x, y);
}
assert_eq!(data, 1);
```

[valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
[`BitRef::swap`]: crate::ptr::BitRef::swap
**/
#[cfg_attr(not(tarpaulin_include), inline(always))]
pub unsafe fn swap<O1, O2, T1, T2>(
	x: BitPtr<Mut, O1, T1>,
	y: BitPtr<Mut, O2, T2>,
) where
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	x.swap(y);
}

/** Swaps `count` bits between the two regions of memory beginning at `x` and
`y`. The two regions must *not* overlap.

# Original

[`ptr::swap_nonoverlapping`](core::ptr::swap_nonoverlapping)

# Safety

Behavior is undefined if any of the following conditions are violated:

- Both `x` and `y` must be [valid] for both reads and writes of `count` bits.
- Both `x` and `y` must be fully initialized instances of `T` for all `count`
  bits.
- The regions may have overlapping elements, but must not overlap the concrete
  bits they describe.

Note that even if `count` is `0`, the pointers must still be validly
constructed, non-null, and well-aligned.

# Examples

```rust
use bitvec::prelude::*;

let mut x = [0u8; 2];
let mut y = !0u16;
let x_ptr = BitPtr::<_, Lsb0, _>::from_mut(&mut x[0]);
let y_ptr = BitPtr::<_, Msb0, _>::from_mut(&mut y);

unsafe {
  bitvec::ptr::swap_nonoverlapping(x_ptr, y_ptr, 16);
}
assert_eq!(x, [!0; 2]);
assert_eq!(y, 0);
```

[valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
**/
#[cfg_attr(not(tarpaulin_include), inline(always))]
pub unsafe fn swap_nonoverlapping<O1, O2, T1, T2>(
	x: BitPtr<Mut, O1, T1>,
	y: BitPtr<Mut, O2, T2>,
	count: usize,
) where
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	for (a, b) in x.range(count).zip(y.range(count)) {
		swap(a, b);
	}
}

/** Overwrites a memory location with the given bit.

Because this reads from memory in order to construct the new value, it cannot be
used to set uninitialized memory. The referent `T` element must be fully
initialized (such as with [`core::ptr::write`]) before setting bits with this
function.

# Original

[`ptr::write`](core::ptr::write)

# Safety

Behavior is undefined if any of the following conditions are violated:

- `dst` must be [valid] for writes
- `dst` must point to a properly initialized value of type `T`
- no other pointer must race `dst` to view or modify the referent location
  unless `T` is capable of ensuring race safety.

# Examples

```rust
use bitvec::prelude::*;

let mut data = 0u8;
let ptr = BitPtr::<_, Lsb0, _>::from_mut(&mut data);
unsafe {
  bitvec::ptr::write(ptr.add(2), true);
}
assert_eq!(data, 4);
```

[valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
[`core::ptr::write`]: core::ptr::write
**/
#[cfg_attr(not(tarpaulin_include), inline(always))]
pub unsafe fn write<O, T>(dst: BitPtr<Mut, O, T>, value: bool)
where
	O: BitOrder,
	T: BitStore,
{
	dst.write(value);
}

/** Performs a volatile write of a memory location with the given bit.

Because processors do not have single-bit write instructions, this must
perform a volatile read of the location, perform the bit modification within
the processor register, then perform a volatile write back to memory. These
three steps are guaranteed to be atomic.

Volatile operations are intended to act on I/O memory, and are guaranteed
not to be elided or reördered by the compiler across other volatile
operations.

# Original

[`ptr::write_volatile`](core::ptr::write_volatile)

# Notes

Rust does not curretnly have a rigorously and formally defined memory model,
so the precise semantics of what “volatile” means here is subject to change
over time. That being said, the semantics will almost always end up pretty
similar to [C11’s definition of volatile][c11].

The compiler shouldn’t change the relative order or number of volatile
memory operations.

# Safety

Behavior is undefined if any of the following conditions are violated:

- `dst` must be [valid] for writes
- no other pointer must race `dst` to view or modify the referent location
  unless `T` is capable of ensuring race safety.

Just like in C, whether an operation is volatile has no bearing whatsoëver
on questions involving concurrent access from multiple threads. Volatile
accesses behave exactly like non-atomic accesses in that regard. In
particular, a race between a `write_volatile` and any other operation
(reading or writing) on the same location is undefined behavior.

This is true even for atomic types! This instruction is an ordinary store
that the compiler will not remove. It is *not* an atomic instruction.

# Examples

```rust
use bitvec::prelude::*;

let mut data = 0u8;
let ptr = BitPtr::<_, Lsb0, _>::from_mut(&mut data);
unsafe {
  bitvec::ptr::write_volatile(ptr, true);
  assert!(bitvec::ptr::read_volatile(ptr.immut()));
}
```

[c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf
[valid]: https://doc.rust-lang.org/core/ptr/index.html#safety
**/
#[cfg_attr(not(tarpaulin_include), inline(always))]
pub unsafe fn write_volatile<O, T>(dst: BitPtr<Mut, O, T>, value: bool)
where
	O: BitOrder,
	T: BitStore,
{
	dst.write_volatile(value);
}

#[cfg(test)]
mod tests;
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/ptr.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/serdes.rs =====
/*! [`serde`]-powered de/serialization.

This module implements the Serde traits for the [`bitvec`] types.

As [`BitArray`] does not use dynamic indexing for its starting index or its
length, it implements [`Deserialize`] and [`Serialize`] by forwarding to the
interior buffer, and adds no additional information. This also renders it
incapable of deserializing a serialized [`BitSlice`]; it can only deserialize
bare value sequences.

[`BitSlice`] is able to implement [`Serialize`], but [`serde`] does not provide
a behavior to deserialize data into a buffer provided by the calling context, so
it cannot deserialize into any of the owning structures.

[`BitBox`] and [`BitVec`] implement [`Serialize`] through [`BitSlice`], and can
deserialize the [`BitSlice`] format into themselves.

If you require de/serialization compatibility between [`BitArray`] and the other
structures, please file an issue.

The exact implementation of the `serde` interfaces is considered an internal
detail and is not guaranteed; however, as it is technically public ABI, it will
only be modified in a major release (`0.X.n` to `0.Y.0` or `X.m.n` to `Y.0.0`).

[`BitArray`]: crate::array::BitArray
[`BitBox`]: crate::boxed::BitBox
[`BitSlice`]: crate::slice::BitSlice
[`BitVec`]: crate::vec::BitVec
[`Deserialize`]: serde::de::Deserialize
[`Serialize`]: serde::ser::Serialize
[`bitvec`]: crate
[`serde`]: serde
!*/

#![cfg(feature = "serde")]

use core::{
	cmp,
	fmt::{
		self,
		Formatter,
	},
	marker::PhantomData,
	mem::ManuallyDrop,
};

use funty::IsNumber;
use serde::{
	de::{
		self,
		Deserialize,
		Deserializer,
		MapAccess,
		SeqAccess,
		Unexpected,
		Visitor,
	},
	ser::{
		Serialize,
		SerializeSeq,
		SerializeStruct,
		Serializer,
	},
};
use tap::pipe::Pipe;

use crate::{
	array::BitArray,
	domain::Domain,
	order::BitOrder,
	ptr::{
		BitPtr,
		BitPtrError,
		BitSpanError,
		MisalignError,
		NullPtrError,
	},
	slice::BitSlice,
	store::BitStore,
	view::BitViewSized,
};
#[cfg(feature = "alloc")]
use crate::{
	boxed::BitBox,
	vec::BitVec,
};

impl<O, T> Serialize for BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
	T::Mem: Serialize,
{
	fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
	where S: Serializer {
		let head = self.as_bitspan().head();
		let mut state = serializer.serialize_struct("BitSeq", 3)?;

		state.serialize_field("head", &head.into_inner())?;
		state.serialize_field("bits", &(self.len() as u64))?;
		state.serialize_field("data", &self.domain())?;

		state.end()
	}
}

impl<T> Serialize for Domain<'_, T>
where
	T: BitStore,
	T::Mem: Serialize,
{
	fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
	where S: Serializer {
		let mut state = serializer.serialize_seq(Some(self.len()))?;
		for elem in *self {
			state.serialize_element(&elem)?;
		}
		state.end()
	}
}

/// Serializes the interior storage type directly, rather than routing through a
/// dynamic sequence serializer.
#[cfg(not(tarpaulin_include))]
impl<O, V> Serialize for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized + Serialize,
{
	#[inline]
	fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
	where S: Serializer {
		unsafe { core::ptr::read(self) }
			.into_inner()
			.serialize(serializer)
	}
}

#[cfg(feature = "alloc")]
#[cfg(not(tarpaulin_include))]
impl<O, T> Serialize for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore,
	T::Mem: Serialize,
{
	#[inline(always)]
	fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
	where S: Serializer {
		self.as_bitslice().serialize(serializer)
	}
}

#[cfg(feature = "alloc")]
#[cfg(not(tarpaulin_include))]
impl<O, T> Serialize for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
	T::Mem: Serialize,
{
	#[inline(always)]
	fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
	where S: Serializer {
		self.as_bitslice().serialize(serializer)
	}
}

impl<'de, O, V> Deserialize<'de> for BitArray<O, V>
where
	O: BitOrder,
	V: BitViewSized + Deserialize<'de>,
{
	#[inline]
	fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
	where D: Deserializer<'de> {
		deserializer
			.pipe(<V as Deserialize<'de>>::deserialize)
			.map(Self::new)
	}
}

/** Aid for deserializing a protocol into a [`BitVec`].

[`BitVec`]: crate::vec::BitVec
**/
#[cfg(feature = "alloc")]
#[derive(Clone, Copy, Debug, Default)]
struct BitVecVisitor<'de, O, T>
where
	O: BitOrder,
	T: BitStore + Deserialize<'de>,
{
	_lt: PhantomData<&'de ()>,
	_bv: PhantomData<BitVec<O, T>>,
}

#[cfg(feature = "alloc")]
impl<'de, O, T> BitVecVisitor<'de, O, T>
where
	O: BitOrder,
	T: BitStore + Deserialize<'de>,
{
	const THIS: Self = Self {
		_lt: PhantomData,
		_bv: PhantomData,
	};

	/// Constructs a [`BitVec`] from deserialized components.
	///
	/// # Parameters
	///
	/// - `&self`: A visitor, only needed for access to an error message.
	/// - `head`: The deserialized head-bit index.
	/// - `bits`: The deserialized length counter.
	/// - `data`: A vector of memory containing the bitslice. Its dest
	///
	/// # Returns
	///
	/// The result of assembling the deserialized components into a [`BitVec`].
	/// This can fail if the `head` is invalid, or if the deserialized data
	/// cannot be encoded into a `BitSpan`.
	///
	/// [`BitVec`]: crate::vec::BitVec
	fn assemble<E>(
		&self,
		head: u8,
		bits: usize,
		data: Vec<T>,
	) -> Result<<Self as Visitor<'de>>::Value, E>
	where
		E: de::Error,
	{
		//  Disable the destructor on the deserialized buffer
		let mut data = ManuallyDrop::new(data);
		//  Ensure that the `bits` counter is not lying about the data size.
		let bits = cmp::min(
			bits,
			data.len()
				.saturating_mul(<T::Mem as IsNumber>::BITS as usize)
				.saturating_sub(head as usize),
		);
		//  Assemble a pointer to the start bit,
		BitPtr::try_new(data.as_mut_slice().as_mut_ptr(), head)
			.map_err(Into::into)
			//  Extend it into a region descriptor,
			.and_then(|bp| bp.span(bits))
			//  Capture the errors that can arise from the deser data,
			.map_err(|err| match err {
				BitSpanError::InvalidBitptr(BitPtrError::BadIndex(err)) => {
					de::Error::invalid_value(
						Unexpected::Unsigned(err.into_inner() as u64),
						&"a head-bit index less than the deserialized element \
						  type’s bit width",
					)
				},
				BitSpanError::TooLong(len) => de::Error::invalid_value(
					Unexpected::Unsigned(len as u64),
					&"a bit length that can be encoded into a `*BitSlice` \
					  pointer",
				),
				BitSpanError::TooHigh(_) => unreachable!(
					"The allocator will not produce a vector too high in the \
					 memory space"
				),
				BitSpanError::InvalidBitptr(BitPtrError::Null(
					NullPtrError,
				)) => {
					unreachable!("The allocator will not produce a null pointer")
				},
				BitSpanError::InvalidBitptr(BitPtrError::Misaligned(
					MisalignError { ptr: _ },
				)) => {
					unreachable!(
						"The allocator will not produce a misaligned buffer"
					)
				},
			})
			//  And assemble a bit-vector over the allocated span.
			.map(|span| unsafe { BitVec::from_fields(span, data.capacity()) })
	}
}

#[cfg(feature = "alloc")]
impl<'de, O, T> Visitor<'de> for BitVecVisitor<'de, O, T>
where
	O: BitOrder,
	T: BitStore + Deserialize<'de>,
{
	type Value = BitVec<O, T>;

	#[inline]
	fn expecting(&self, fmt: &mut Formatter) -> fmt::Result {
		fmt.write_str("a BitSeq data series")
	}

	/// Visit a sequence of anonymous data elements. These must be in the order
	/// `u8` (head-bit index), `u64` (length counter), `[T]` (data contents).
	fn visit_seq<V>(self, mut seq: V) -> Result<Self::Value, V::Error>
	where V: SeqAccess<'de> {
		let head = seq
			.next_element::<u8>()?
			.ok_or_else(|| de::Error::invalid_length(0, &self))?;
		let bits = seq
			.next_element::<u64>()?
			.ok_or_else(|| de::Error::invalid_length(1, &self))?;
		let data = seq
			.next_element::<Vec<T>>()?
			.ok_or_else(|| de::Error::invalid_length(2, &self))?;

		self.assemble(head, bits as usize, data)
	}

	/// Visit a map of named data elements. These may be in any order, and must
	/// be the pairs `head: u8`, `bits: u64`, and `data: [T]`.
	fn visit_map<V>(self, mut map: V) -> Result<Self::Value, V::Error>
	where V: MapAccess<'de> {
		let mut head: Option<u8> = None;
		let mut bits: Option<u64> = None;
		let mut data: Option<Vec<T>> = None;

		while let Some(key) = map.next_key()? {
			match key {
				"head" => {
					if head.replace(map.next_value()?).is_some() {
						return Err(de::Error::duplicate_field("head"));
					}
				},
				"bits" => {
					if bits.replace(map.next_value()?).is_some() {
						return Err(de::Error::duplicate_field("bits"));
					}
				},
				"data" => {
					if data.replace(map.next_value()?).is_some() {
						return Err(de::Error::duplicate_field("data"));
					}
				},
				f => {
					/* Once a key is pulled from the map, a value **must** also
					be pulled, otherwise `serde` will fail with its own error
					rather than this one.
					*/
					let _ = map.next_value::<()>();
					return Err(de::Error::unknown_field(f, &[
						"head", "bits", "data",
					]));
				},
			}
		}
		let head = head.ok_or_else(|| de::Error::missing_field("head"))?;
		let bits = bits.ok_or_else(|| de::Error::missing_field("bits"))?;
		let data = data.ok_or_else(|| de::Error::missing_field("data"))?;

		self.assemble(head, bits as usize, data)
	}
}

#[cfg(feature = "alloc")]
impl<'de, O, T> Deserialize<'de> for BitBox<O, T>
where
	O: BitOrder,
	T: BitStore + Deserialize<'de>,
{
	#[inline]
	fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
	where D: Deserializer<'de> {
		deserializer
			.pipe(<BitVec<O, T> as Deserialize<'de>>::deserialize)
			.map(BitVec::into_boxed_bitslice)
	}
}

#[cfg(feature = "alloc")]
impl<'de, O, T> Deserialize<'de> for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore + Deserialize<'de>,
{
	#[inline]
	fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
	where D: Deserializer<'de> {
		deserializer.deserialize_struct(
			"BitSeq",
			&["head", "bits", "data"],
			BitVecVisitor::THIS,
		)
	}
}

#[cfg(test)]
mod tests {
	use serde::Deserialize;
	#[cfg(feature = "alloc")]
	use serde_test::{
		assert_de_tokens,
		assert_de_tokens_error,
	};
	use serde_test::{
		assert_ser_tokens,
		Token,
	};

	use crate::prelude::*;

	macro_rules! bvtok {
		( s $elts:expr, $head:expr, $bits:expr, $ty:ident $( , $data:expr )* ) => {
			&[
				Token::Struct { name: "BitSeq", len: 3, },
				Token::Str("head"), Token::U8( $head ),
				Token::Str("bits"), Token::U64( $bits ),
				Token::Str("data"), Token::Seq { len: Some( $elts ) },
				$( Token:: $ty ( $data ), )*
				Token::SeqEnd,
				Token::StructEnd,
			]
		};
		( d $elts:expr, $head:expr, $bits:expr, $ty:ident $( , $data:expr )* ) => {
			&[
				Token::Struct { name: "BitSeq", len: 3, },
				Token::BorrowedStr("head"), Token::U8( $head ),
				Token::BorrowedStr("bits"), Token::U64( $bits ),
				Token::BorrowedStr("data"), Token::Seq { len: Some( $elts ) },
				$( Token:: $ty ( $data ), )*
				Token::SeqEnd,
				Token::StructEnd,
			]
		};
	}

	#[test]
	fn empty() {
		let slice = BitSlice::<Msb0, u8>::empty();

		assert_ser_tokens(&slice, bvtok![s 0, 0, 0, U8]);

		#[cfg(feature = "alloc")]
		assert_de_tokens(&bitvec![], bvtok![ d 0, 0, 0, U8 ]);
	}

	#[test]
	fn small() {
		let bits = 0b1111_1000u8.view_bits::<Msb0>();
		let bits = &bits[1 .. 5];
		assert_ser_tokens(&bits, bvtok![s 1, 1, 4, U8, 0b1111_1000]);

		let bits = 0b00001111_11111111u16.view_bits::<Lsb0>();
		let bits = &bits[.. 12];
		assert_ser_tokens(&bits, bvtok![s 1, 0, 12, U16, 0b00001111_11111111]);

		let bits = 0b11_11111111u32.view_bits::<LocalBits>();
		let bits = &bits[.. 10];
		assert_ser_tokens(&bits, bvtok![s 1, 0, 10, U32, 0x00_00_03_FF]);
	}

	#[test]
	fn wide() {
		let src: &[u8] = &[0, !0];
		let bs = src.view_bits::<LocalBits>();
		assert_ser_tokens(&(&bs[1 .. 15]), bvtok![s 2, 1, 14, U8, 0, !0]);
	}

	#[test]
	#[cfg(feature = "alloc")]
	fn deser() {
		let bv = bitvec![Msb0, u8; 0, 1, 1, 0, 1, 0];
		let bb = bv.clone().into_boxed_bitslice();
		assert_de_tokens(&bv, bvtok![d 1, 0, 6, U8, 0b0110_1000]);
		//  test that the bits outside the bits domain don't matter in deser
		assert_de_tokens(&bv, bvtok![d 1, 0, 6, U8, 0b0110_1001]);
		assert_de_tokens(&bb, bvtok![d 1, 0, 6, U8, 0b0110_1010]);
		assert_de_tokens(&bb, bvtok![d 1, 0, 6, U8, 0b0110_1011]);
	}

	#[test]
	#[cfg(feature = "alloc")]
	fn ser() {
		let bv = bitvec![Msb0, u8; 0, 1, 1, 0, 1, 0];
		let bb = bv.clone().into_boxed_bitslice();

		assert_ser_tokens(&bv, bvtok![s 1, 0, 6, U8, 0b0110_1000]);
		assert_ser_tokens(&bb, bvtok![s 1, 0, 6, U8, 0b0110_1000]);
	}

	#[test]
	#[cfg(feature = "alloc")]
	fn error_paths() {
		assert_de_tokens_error::<BitVec<Msb0, u8>>(
			bvtok!(d 0, 9, 0, U8),
			"invalid value: integer `9`, expected a head-bit index less than \
			 the deserialized element type’s bit width",
		);

		for field in &["head", "bits"] {
			assert_de_tokens_error::<BitVec<Msb0, u8>>(
				&[
					Token::Struct {
						name: "BitSeq",
						len: 2,
					},
					Token::BorrowedStr(field),
					Token::U8(0),
					Token::BorrowedStr(field),
					Token::U8(1),
					Token::StructEnd,
				],
				&format!("duplicate field `{}`", field),
			);
		}

		assert_de_tokens_error::<BitVec<Msb0, u8>>(
			&[
				Token::Struct {
					name: "BitSeq",
					len: 2,
				},
				Token::BorrowedStr("data"),
				Token::Seq { len: Some(1) },
				Token::U8(2),
				Token::SeqEnd,
				Token::BorrowedStr("data"),
				Token::Seq { len: Some(1) },
				Token::U8(3),
				Token::SeqEnd,
				Token::StructEnd,
			],
			"duplicate field `data`",
		);

		assert_de_tokens_error::<BitVec<Msb0, u8>>(
			&[
				Token::Struct {
					name: "BitSeq",
					len: 1,
				},
				Token::BorrowedStr("garbage"),
				Token::BorrowedStr("field"),
				Token::StructEnd,
			],
			"unknown field `garbage`, expected one of `head`, `bits`, `data`",
		);
	}

	#[test]
	fn deser_seq() {
		let bv = bitvec![Msb0, u8; 0, 1];
		assert_de_tokens::<BitVec<Msb0, u8>>(&bv, &[
			Token::Seq { len: Some(3) },
			Token::U8(0),
			Token::U64(2),
			Token::Seq { len: Some(1) },
			Token::U8(66),
			Token::SeqEnd,
			Token::SeqEnd,
		]);

		assert_de_tokens_error::<BitVec<Msb0, u8>>(
			&[Token::Seq { len: Some(0) }, Token::SeqEnd],
			"invalid length 0, expected a BitSeq data series",
		);

		assert_de_tokens_error::<BitVec<Msb0, u8>>(
			&[Token::Seq { len: Some(1) }, Token::U8(0), Token::SeqEnd],
			"invalid length 1, expected a BitSeq data series",
		);

		assert_de_tokens_error::<BitVec<Msb0, u8>>(
			&[
				Token::Seq { len: Some(2) },
				Token::U8(0),
				Token::U64(2),
				Token::SeqEnd,
			],
			"invalid length 2, expected a BitSeq data series",
		);
	}

	#[test]
	fn trait_impls() {
		const _: fn() = || {
			fn assert_impl_all<'de, T: Deserialize<'de>>() {
			}
			assert_impl_all::<BitArray<LocalBits, [usize; 32]>>();
		};
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/serdes.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/slice/api.rs =====
//! Port of the `[T]` inherent API.

use core::{
	cmp,
	ops::{
		Range,
		RangeBounds,
		RangeFrom,
		RangeFull,
		RangeInclusive,
		RangeTo,
		RangeToInclusive,
	},
};

use funty::IsNumber;

use super::{
	iter::{
		Chunks,
		ChunksExact,
		ChunksExactMut,
		ChunksMut,
		Iter,
		IterMut,
		RChunks,
		RChunksExact,
		RChunksExactMut,
		RChunksMut,
		RSplit,
		RSplitMut,
		RSplitN,
		RSplitNMut,
		Split,
		SplitMut,
		SplitN,
		SplitNMut,
		Windows,
	},
	BitRef,
	BitSlice,
};
#[cfg(feature = "alloc")]
use crate::vec::BitVec;
use crate::{
	array::BitArray,
	devel as dvl,
	order::BitOrder,
	ptr::{
		BitPtr,
		BitPtrRange,
		BitSpan,
		BitSpanError,
		Const,
		Mut,
	},
	store::BitStore,
};

/// Port of the `[T]` inherent API.
impl<O, T> BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// Returns the number of bits in the slice.
	///
	/// # Original
	///
	/// [`slice::len`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.len)
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let a = bits![0, 0, 1];
	/// assert_eq!(a.len(), 3);
	/// ```
	#[inline]
	pub fn len(&self) -> usize {
		self.as_bitspan().len()
	}

	/// Returns `true` if the slice has a length of 0.
	///
	/// # Original
	///
	/// [`slice::is_empty`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.is_empty)
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let a = bits![0, 0, 1];
	/// assert!(!a.is_empty());
	/// ```
	#[inline]
	pub fn is_empty(&self) -> bool {
		self.as_bitspan().len() == 0
	}

	/// Returns the first bit of the slice, or `None` if it is empty.
	///
	/// # Original
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let v = bits![1, 0, 0];
	/// assert_eq!(Some(&true), v.first().as_deref());
	///
	/// let w = bits![];
	/// assert_eq!(None, w.first());
	/// ```
	#[inline]
	pub fn first(&self) -> Option<BitRef<Const, O, T>> {
		self.get(0)
	}

	/// Returns a mutable pointer to the first bit of the slice, or `None`
	/// if it is empty.
	///
	/// # Original
	///
	/// [`slice::first_mut`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.first_mut)
	///
	/// # API Differences
	///
	/// This crate cannot manifest `&mut bool` references, and must use the
	/// [`BitRef`] proxy type where `&mut bool` exists in the standard library
	/// API. The proxy value must be bound as `mut` in order to write through
	/// it.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let x = bits![mut 0, 1, 0];
	///
	/// if let Some(mut first) = x.first_mut() {
	///   *first = true;
	/// }
	/// assert_eq!(x, bits![1, 1, 0]);
	/// ```
	///
	/// [`BitRef`]: crate::ptr::BitRef
	#[inline]
	pub fn first_mut(&mut self) -> Option<BitRef<Mut, O, T>> {
		self.get_mut(0)
	}

	/// Returns the first and all the rest of the bits of the slice, or
	/// `None` if it is empty.
	///
	/// # Original
	///
	/// [`slice::split_first`](https://doc.rust-lang.org/stable/std/primitive.slice.html#split_first)
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let x = bits![1, 0, 0];
	///
	/// if let Some((first, rest)) = x.split_first() {
	///   assert_eq!(first, &true);
	///   assert_eq!(rest, bits![0; 2]);
	/// }
	/// # fn end_the_block() {}
	/// ```
	#[inline]
	pub fn split_first(&self) -> Option<(BitRef<Const, O, T>, &Self)> {
		match self.len() {
			0 => None,
			_ => unsafe {
				let (head, rest) = self.split_at_unchecked(1);
				Some((head.get_unchecked(0), rest))
			},
		}
	}

	/// Returns the first and all the rest of the bits of the slice, or
	/// `None` if it is empty.
	///
	/// # Original
	///
	/// [`slice::split_first_mut`](https://doc.rust-lang.org/stable/std/primitive.slice.html#split_first_mut)
	///
	/// # API Differences
	///
	/// This crate cannot manifest `&mut bool` references, and must use the
	/// [`BitRef`] proxy type where `&mut bool` exists in the standard library
	/// API. The proxy value must be bound as `mut` in order to write through
	/// it.
	///
	/// Because the references are permitted to use the same memory address,
	/// they are marked as aliasing in order to satisfy Rust’s requirements
	/// about freedom from data races.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let x = bits![mut 0, 0, 1];
	///
	/// if let Some((mut first, rest)) = x.split_first_mut() {
	///   *first = true;
	///   rest.set(0, true);
	///   rest.set(1, false);
	/// }
	/// assert_eq!(x, bits![1, 1, 0]);
	/// ```
	///
	/// [`BitRef`]: crate::ptr::BitRef
	//  `pub type Aliased = BitSlice<O, T::Alias>;` is not allowed in inherents,
	//  so this will not be aliased.
	#[inline]
	#[allow(clippy::type_complexity)]
	pub fn split_first_mut(
		&mut self,
	) -> Option<(BitRef<Mut, O, T::Alias>, &mut BitSlice<O, T::Alias>)> {
		match self.len() {
			0 => None,
			_ => unsafe {
				let (head, rest) = self.split_at_unchecked_mut(1);
				Some((head.get_unchecked_mut(0), rest))
			},
		}
	}

	/// Returns the last and all the rest of the bits of the slice, or
	/// `None` if it is empty.
	///
	/// # Original
	///
	/// [`slice::split_last`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_last)
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let x = bits![0, 0, 1];
	///
	/// if let Some((last, rest)) = x.split_last() {
	///   assert_eq!(last, &true);
	///   assert_eq!(rest, bits![0; 2]);
	/// }
	/// # fn end_the_block() {}
	/// ```
	#[inline]
	pub fn split_last(&self) -> Option<(BitRef<Const, O, T>, &Self)> {
		match self.len() {
			0 => None,
			len => unsafe {
				let (rest, tail) = self.split_at_unchecked(len.wrapping_sub(1));
				Some((tail.get_unchecked(0), rest))
			},
		}
	}

	/// Returns the last and all the rest of the bits of the slice, or
	/// `None` if it is empty.
	///
	/// # Original
	///
	/// [`slice::split_last_mut`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_last_mut)
	///
	/// # API Differences
	///
	/// This crate cannot manifest `&mut bool` references, and must use the
	/// [`BitRef`] proxy type where `&mut bool` exists in the standard library
	/// API. The proxy value must be bound as `mut` in order to write through
	/// it.
	///
	/// Because the references are permitted to use the same memory address,
	/// they are marked as aliasing in order to satisfy Rust’s requirements
	/// about freedom from data races.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let x = bits![mut 1, 0, 0];
	///
	/// if let Some((mut last, rest)) = x.split_last_mut() {
	///   *last = true;
	///   rest.set(0, false);
	///   rest.set(1, true);
	/// }
	/// assert_eq!(x, bits![0, 1, 1]);
	/// ```
	///
	/// [`BitRef`]: crate::slice::BitSlice
	//  `pub type Aliased = BitSlice<O, T::Alias>;` is not allowed in inherents,
	//  so this will not be aliased.
	#[inline]
	#[allow(clippy::type_complexity)]
	pub fn split_last_mut(
		&mut self,
	) -> Option<(BitRef<Mut, O, T::Alias>, &mut BitSlice<O, T::Alias>)> {
		match self.len() {
			0 => None,
			len => unsafe {
				let (rest, tail) = self.split_at_unchecked_mut(len - 1);
				Some((tail.get_unchecked_mut(0), rest))
			},
		}
	}

	/// Returns the last bit of the slice, or `None` if it is empty.
	///
	/// # Original
	///
	/// [`slice::last`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.last)
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let v = bits![0, 0, 1];
	/// assert_eq!(Some(&true), v.last().as_deref());
	///
	/// let w = bits![];
	/// assert_eq!(None, w.last());
	/// ```
	#[inline]
	pub fn last(&self) -> Option<BitRef<Const, O, T>> {
		match self.len() {
			0 => None,
			len => Some(unsafe { self.get_unchecked(len - 1) }),
		}
	}

	/// Returns a mutable pointer to the last bit in the slice.
	///
	/// # Original
	///
	/// [`slice::last_mut`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.last_mut)
	///
	/// # API Differences
	///
	/// This crate cannot manifest `&mut bool` references, and must use the
	/// [`BitRef`] proxy type where `&mut bool` exists in the standard library
	/// API. The proxy value must be bound as `mut` in order to write through
	/// it.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let x = bits![mut 0, 1, 0];
	///
	/// if let Some(mut last) = x.last_mut() {
	///   *last = true;
	/// }
	/// assert_eq!(x, bits![0, 1, 1]);
	/// ```
	///
	/// [`BitRef`]: crate::ptr::BitRef
	#[inline]
	pub fn last_mut(&mut self) -> Option<BitRef<Mut, O, T>> {
		match self.len() {
			0 => None,
			len => Some(unsafe { self.get_unchecked_mut(len - 1) }),
		}
	}

	/// Returns a reference to a bit or subslice depending on the type of index.
	///
	/// - If given a position, returns a reference to the bit at that position
	///   or `None` if out of bounds.
	/// - If given a range, returns the subslice corresponding to that range, or
	///   `None` if out of bounds.
	///
	/// # Original
	///
	/// [`slice::get`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.get)
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let v = bits![0, 1, 0];
	/// assert_eq!(Some(&true), v.get(1).as_deref());
	/// assert_eq!(Some(bits![0, 1]), v.get(0 .. 2));
	/// assert_eq!(None, v.get(3));
	/// assert_eq!(None, v.get(0 .. 4));
	/// ```
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn get<'a, I>(&'a self, index: I) -> Option<I::Immut>
	where I: BitSliceIndex<'a, O, T> {
		index.get(self)
	}

	/// Returns a mutable reference to a bit or subslice depending on the type
	/// of index (see [`.get()`]) or `None` if the index is out of bounds.
	///
	/// # Original
	///
	/// [`slice::get_mut`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.get_mut)
	///
	/// # API Differences
	///
	/// This crate cannot manifest `&mut bool` references, and must use the
	/// [`BitRef`] proxy type where `&mut bool` exists in the standard library
	/// API. The proxy value must be bound as `mut` in order to write through
	/// it.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let x = bits![mut 0, 0, 1];
	///
	/// if let Some(mut bit) = x.get_mut(1) {
	///   *bit = true;
	/// }
	/// assert_eq!(x, bits![0, 1, 1]);
	/// ```
	///
	/// [`BitRef`]: crate::ptr::BitRef
	/// [`.get()`]: Self::get
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn get_mut<'a, I>(&'a mut self, index: I) -> Option<I::Mut>
	where I: BitSliceIndex<'a, O, T> {
		index.get_mut(self)
	}

	/// Returns a reference to a bit or subslice, without doing bounds checking.
	///
	/// This is generally not recommended; use with caution! Calling this method
	/// with an out-of-bounds index is *[undefined behavior]* even if the
	/// resulting reference is not used. For a safe alternative, see [`.get()`].
	///
	/// # Original
	///
	/// [`slice::get_unchecked`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.get_unchecked)
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let x = bits![0, 1, 0];
	///
	/// unsafe {
	///   assert_eq!(x.get_unchecked(1), &true);
	/// }
	/// ```
	///
	/// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html
	/// [`.get()`]: Self::get
	#[allow(clippy::missing_safety_doc)]
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub unsafe fn get_unchecked<'a, I>(&'a self, index: I) -> I::Immut
	where I: BitSliceIndex<'a, O, T> {
		index.get_unchecked(self)
	}

	/// Returns a mutable reference to a bit or subslice, without doing bounds
	/// checking.
	///
	/// This is generally not recommended; use with caution! Calling this method
	/// with an out-of-bounds index is *[undefined behavior]* even if the
	/// resulting reference is not used. For a safe alternative, see
	/// [`.get_mut()`].
	///
	/// # Original
	///
	/// [`slice::get_unchecked_mut`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.get_unchecked_mut)
	///
	/// # API Differences
	///
	/// This crate cannot manifest `&mut bool` references, and must use the
	/// [`BitRef`] proxy type where `&mut bool` exists in the standard library
	/// API. The proxy value must be bound as `mut` in order to write through
	/// it.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let x = bits![mut 0; 3];
	/// unsafe {
	///   let mut bit = x.get_unchecked_mut(1);
	///   *bit = true;
	/// }
	/// assert_eq!(x, bits![0, 1, 0]);
	/// ```
	///
	/// [`BitRef`]: crate::ptr::BitRef
	/// [`get_mut`]: Self::get_mut
	/// [undefined behavior]: ../../reference/behavior-considered-undefined.html
	#[allow(clippy::missing_safety_doc)]
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub unsafe fn get_unchecked_mut<'a, I>(&'a mut self, index: I) -> I::Mut
	where I: BitSliceIndex<'a, O, T> {
		index.get_unchecked_mut(self)
	}

	#[doc(hidden)]
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	#[deprecated = "Use `as_bitptr` to access the region pointer"]
	pub fn as_ptr(&self) -> BitPtr<Const, O, T> {
		self.as_bitptr()
	}

	#[doc(hidden)]
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	#[deprecated = "Use `as_bitptr_range` to access the region pointers"]
	pub fn as_ptr_range(&self) -> BitPtrRange<Const, O, T> {
		self.as_bitptr_range()
	}

	#[doc(hidden)]
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	#[deprecated = "Use `as_mut_bitptr` to access the region pointer"]
	pub fn as_mut_ptr(&mut self) -> BitPtr<Mut, O, T> {
		self.as_mut_bitptr()
	}

	#[doc(hidden)]
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	#[deprecated = "Use `as_mut_bitptr_range` to access the region pointers"]
	pub fn as_mut_ptr_range(&mut self) -> BitPtrRange<Mut, O, T> {
		self.as_mut_bitptr_range()
	}

	/// Swaps two bits in the slice.
	///
	/// # Original
	///
	/// [`slice::swap`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.swap)
	///
	/// # Arguments
	///
	/// - `a`: The index of the first bit
	/// - `b`: The index of the second bit
	///
	/// # Panics
	///
	/// Panics if `a` or `b` are out of bounds.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let v = bits![mut 0, 1, 1, 0];
	/// v.swap(1, 3);
	/// assert_eq!(v, bits![0, 0, 1, 1]);
	/// ```
	#[inline]
	pub fn swap(&mut self, a: usize, b: usize) {
		self.assert_in_bounds(a, 0 .. self.len());
		self.assert_in_bounds(b, 0 .. self.len());
		unsafe {
			self.swap_unchecked(a, b);
		}
	}

	/// Reverses the order of bits in the slice, in place.
	///
	/// # Original
	///
	/// [`slice::reverse`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.reverse)
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let v = bits![mut 0, 1, 1];
	/// v.reverse();
	/// assert_eq!(v, bits![1, 1, 0]);
	/// ```
	#[inline]
	pub fn reverse(&mut self) {
		/* This would be better written as a recursive algorithm that swaps the
		edge bits and recurses on `[1 .. len - 1]`, but Rust does not guarantee
		tail-call optimization, and manual iteration allows for slight
		performance optimization on the range reduction.

		Begin with raw pointer manipulation. That’s how you know this is a good
		function.
		*/
		let mut bitspan = self.as_mut_bitspan();
		//  The length does not need to be encoded into, and decoded back out
		//  of, the pointer at each iteration. It is just a loop counter.
		let mut len = bitspan.len();
		//  Reversing 1 or 0 bits has no effect.
		while len > 1 {
			unsafe {
				//  Bring `len` from one past the last to the last exactly.
				len -= 1;
				//  Swap the 0 and last indices.
				bitspan.to_bitslice_mut().swap_unchecked(0, len);

				//  Move the pointer upwards by one bit.
				bitspan.incr_head();
				//  `incr_head` slides the tail up by one, so decrease it again.
				len -= 1;

				//  TODO(myrrlyn): See if range subslicing can be made faster
				//  than this unpacking.
			}
		}
	}

	/// Returns an iterator over the slice.
	///
	/// # Original
	///
	/// [`slice::iter`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.iter)
	///
	/// # API Differences
	///
	/// This iterator yields [`BitRef`] proxy references, rather than `&bool`
	/// ordinary references. It does so in order to promote consistency in the
	/// crate, and make switching between immutable and mutable single-bit
	/// access easier.
	///
	/// The produced iterator has a [`by_ref`] adapter that yields `&bool`
	/// references, and a [`by_val`] adapter that yields `bool` values. Use
	/// these methods to fit this iterator into APIs that expect ordinary `bool`
	/// inputs.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let x = bits![0, 0, 1];
	/// let mut iterator = x.iter();
	///
	/// assert_eq!(iterator.next().as_deref(), Some(&false));
	/// assert_eq!(iterator.next().as_deref(), Some(&false));
	/// assert_eq!(iterator.next().as_deref(), Some(&true));
	/// assert_eq!(iterator.next().as_deref(), None);
	/// ```
	///
	/// [`BitRef`]: crate::ptr::BitRef
	/// [`by_ref`]: crate::slice::Iter::by_ref
	/// [`by_val`]: crate::slice::Iter::by_val
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn iter(&self) -> Iter<O, T> {
		Iter::new(self)
	}

	/// Returns an iterator that allows modifying each bit.
	///
	/// # Original
	///
	/// [`slice::iter_mut`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.iter_mut)
	///
	/// # API Differences
	///
	/// This crate cannot manifest `&mut bool` references, and must use the
	/// [`BitRef`] proxy type where `&mut bool` exists in the standard library
	/// API. The proxy value must be bound as `mut` in order to write through
	/// it.
	///
	/// This iterator marks each yielded item as aliased, as iterators can be
	/// used to yield multiple items into the same scope. If you are using
	/// the iterator in a manner that ensures that all yielded items have
	/// disjoint lifetimes, you can use the [`.remove_alias()`] adapter on it to
	/// remove the alias marker from the yielded subslices.
	///
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let x = bits![mut 0, 0, 1];
	/// for mut bit in x.iter_mut() {
	///   *bit = !*bit;
	/// }
	/// assert_eq!(x, bits![1, 1, 0]);
	/// ```
	///
	/// [`BitRef`]: crate::ptr::BitRef
	/// [`.remove_alias()`]: crate::slice::IterMut::remove_alias
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn iter_mut(&mut self) -> IterMut<O, T> {
		IterMut::new(self)
	}

	/// Returns an iterator over all contiguous windows of length `size`. The
	/// windows overlap. If the slice is shorter than `size`, the iterator
	/// returns no values.
	///
	/// # Original
	///
	/// [`slice::windows`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.windows)
	///
	/// # Panics
	///
	/// Panics if `size` is 0.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let slice = bits![0, 0, 1, 1];
	/// let mut iter = slice.windows(2);
	/// assert_eq!(iter.next().unwrap(), bits![0; 2]);
	/// assert_eq!(iter.next().unwrap(), bits![0, 1]);
	/// assert_eq!(iter.next().unwrap(), bits![1; 2]);
	/// assert!(iter.next().is_none());
	/// ```
	///
	/// If the slice is shorter than `size`:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let slice = bits![0; 3];
	/// let mut iter = slice.windows(4);
	/// assert!(iter.next().is_none());
	/// ```
	#[inline]
	pub fn windows(&self, size: usize) -> Windows<O, T> {
		assert_ne!(size, 0, "Window width cannot be 0");
		Windows::new(self, size)
	}

	/// Returns an iterator over `chunk_size` bits of the slice at a time,
	/// starting at the beginning of the slice.
	///
	/// The chunks are slices and do not overlap. If `chunk_size` does not
	/// divide the length of the slice, then the last chunk will not have length
	/// `chunk_size`.
	///
	/// See [`.chunks_exact()`] for a variant of this iterator that returns
	/// chunks of always exactly `chunk_size` bits, and [`.rchunks()`] for the
	/// same iterator but starting at the end of the slice.
	///
	/// # Original
	///
	/// [`slice::chunks`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.chunks)
	///
	/// # Panics
	///
	/// Panics if `chunk_size` is 0.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let slice = bits![0, 1, 0, 0, 1];
	/// let mut iter = slice.chunks(2);
	/// assert_eq!(iter.next().unwrap(), bits![0, 1]);
	/// assert_eq!(iter.next().unwrap(), bits![0, 0]);
	/// assert_eq!(iter.next().unwrap(), bits![1]);
	/// assert!(iter.next().is_none());
	/// ```
	///
	/// [`.chunks_exact()`]: Self::chunks_exact
	/// [`.rchunks()`]: Self::rchunks
	#[inline]
	pub fn chunks(&self, chunk_size: usize) -> Chunks<O, T> {
		assert_ne!(chunk_size, 0, "Chunk width cannot be 0");
		Chunks::new(self, chunk_size)
	}

	/// Returns an iterator over `chunk_size` bits of the slice at a time,
	/// starting at the beginning of the slice.
	///
	/// The chunks are mutable slices, and do not overlap. If `chunk_size` does
	/// not divide the length of the slice, then the last chunk will not have
	/// length `chunk_size`.
	///
	/// See [`.chunks_exact_mut()`] for a variant of this iterator that returns
	/// chunks of always exactly `chunk_size` bits, and [`.rchunks_mut()`] for
	/// the same iterator but starting at the end of the slice.
	///
	/// # Original
	///
	/// [`slice::chunks_mut`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.chunks_mut)
	///
	/// # API Differences
	///
	/// This iterator marks each yielded item as aliased, as iterators can be
	/// used to yield multiple items into the same scope. If you are using
	/// the iterator in a manner that ensures that all yielded items have
	/// disjoint lifetimes, you can use the [`.remove_alias()`] adapter on it to
	/// remove the alias marker from the yielded subslices.
	///
	/// # Panics
	///
	/// Panics if `chunk_size` is 0.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let v = bits![mut 0; 5];
	/// let mut count = 1;
	///
	/// for chunk in v.chunks_mut(2) {
	///   for mut bit in chunk.iter_mut() {
	///     *bit = count % 2 == 0;
	///   }
	///   count += 1;
	/// }
	/// assert_eq!(v, bits![0, 0, 1, 1, 0]);
	/// ```
	///
	/// [`.chunks_exact_mut()`]: Self::chunks_exact_mut
	/// [`.rchunks_mut()`]: Self::rchunks_mut
	/// [`.remove_alias()`]: crate::slice::ChunksMut::remove_alias
	#[inline]
	pub fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<O, T> {
		assert_ne!(chunk_size, 0, "Chunk width cannot be 0");
		ChunksMut::new(self, chunk_size)
	}

	/// Returns an iterator over `chunk_size` bits of the slice at a time,
	/// starting at the beginning of the slice.
	///
	/// The chunks are slices and do not overlap. If `chunk_size` does not
	/// divide the length of the slice, then the last up to `chunk_size-1` bits
	/// will be omitted and can be retrieved from the [`.remainder()`] method of
	/// the iterator.
	///
	/// Due to each chunk having exactly `chunk_size` bits, the compiler may be
	/// able to optimize the resulting code better than in the case of
	/// [`.chunks()`].
	///
	/// See [`.chunks()`] for a variant of this iterator that also returns the
	/// remainder as a smaller chunk, and [`.rchunks_exact()`] for the same
	/// iterator but starting at the end of the slice.
	///
	/// # Original
	///
	/// [`slice::chunks_exact`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.chunks_exact)
	///
	/// # Panics
	///
	/// Panics if `chunk_size` is 0.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let slice = bits![0, 1, 1, 0, 0];
	/// let mut iter = slice.chunks_exact(2);
	/// assert_eq!(iter.next().unwrap(), bits![0, 1]);
	/// assert_eq!(iter.next().unwrap(), bits![1, 0]);
	/// assert!(iter.next().is_none());
	/// assert_eq!(iter.remainder(), bits![0]);
	/// ```
	///
	/// [`.chunks()`]: Self::chunks
	/// [`.rchunks_exact()`]: Self::rchunks_exact
	/// [`.remainder()`]: crate::slice::ChunksExact::remainder
	#[inline]
	pub fn chunks_exact(&self, chunk_size: usize) -> ChunksExact<O, T> {
		assert_ne!(chunk_size, 0, "Chunk width cannot be 0");
		ChunksExact::new(self, chunk_size)
	}

	/// Returns an iterator over `chunk_size` bits of the slice at a time,
	/// starting at the beginning of the slice.
	///
	/// The chunks are mutable slices, and do not overlap. If `chunk_size` does
	/// not divide the length of the slice, then the last up to `chunk_size-1`
	/// bits will be omitted and can be retrieved from the [`.into_remainder()`]
	/// method of the iterator.
	///
	/// Due to each chunk having exactly `chunk_size` bits, the compiler may be
	/// able to optimize the resulting code better than in the case of
	/// [`.chunks_mut()`].
	///
	/// See [`.chunks_mut()`] for a variant of this iterator that also returns
	/// the remainder as a smaller chunk, and [`.rchunks_exact_mut()`] for the
	/// same iterator but starting at the end of the slice.
	///
	/// # Original
	///
	/// [`slice::chunks_exact_mut`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.chunks_exact_mut)
	///
	/// # API Differences
	///
	/// This iterator marks each yielded item as aliased, as iterators can be
	/// used to yield multiple items into the same scope. If you are using
	/// the iterator in a manner that ensures that all yielded items have
	/// disjoint lifetimes, you can use the [`.remove_alias()`] adapter on it to
	/// remove the alias marker from the yielded subslices.
	///
	/// # Panics
	///
	/// Panics if `chunk_size` is 0.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let v = bits![mut 0; 5];
	///
	/// for chunk in v.chunks_exact_mut(2) {
	///   chunk.set_all(true);
	/// }
	/// assert_eq!(v, bits![1, 1, 1, 1, 0]);
	/// ```
	///
	/// [`.chunks_mut()`]: Self::chunks_mut
	/// [`.into_remainder()`]: crate::slice::ChunksExactMut::into_remainder
	/// [`.rchunks_exact_mut()`]: Self::rchunks_exact_mut
	/// [`.remove_alias()`]: crate::slice::ChunksExactMut::remove_alias
	#[inline]
	pub fn chunks_exact_mut(
		&mut self,
		chunk_size: usize,
	) -> ChunksExactMut<O, T> {
		assert_ne!(chunk_size, 0, "Chunk width cannot be 0");
		ChunksExactMut::new(self, chunk_size)
	}

	/// Returns an iterator over `chunk_size` bits of the slice at a time,
	/// starting at the end of the slice.
	///
	/// The chunks are slices and do not overlap. If `chunk_size` does not
	/// divide the length of the slice, then the last chunk will not have length
	/// `chunk_size`.
	///
	/// See [`.rchunks_exact()`] for a variant of this iterator that returns
	/// chunks of always exactly `chunk_size` bits, and [`.chunks()`] for the
	/// same iterator but starting at the beginning of the slice.
	///
	/// # Original
	///
	/// [`slice::rchunks`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.rchunks)
	///
	/// # Panics
	///
	/// Panics if `chunk_size` is 0.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let slice = bits![0, 1, 0, 0, 1];
	/// let mut iter = slice.rchunks(2);
	/// assert_eq!(iter.next().unwrap(), bits![0, 1]);
	/// assert_eq!(iter.next().unwrap(), bits![1, 0]);
	/// assert_eq!(iter.next().unwrap(), bits![0]);
	/// assert!(iter.next().is_none());
	/// ```
	///
	/// [`.chunks()`]: Self::chunks
	/// [`.rchunks_exact()`]: Self::rchunks_exact
	#[inline]
	pub fn rchunks(&self, chunk_size: usize) -> RChunks<O, T> {
		assert_ne!(chunk_size, 0, "Chunk width cannot be 0");
		RChunks::new(self, chunk_size)
	}

	/// Returns an iterator over `chunk_size` bits of the slice at a time,
	/// starting at the end of the slice.
	///
	/// The chunks are mutable slices, and do not overlap. If `chunk_size` does
	/// not divide the length of the slice, then the last chunk will not have
	/// length `chunk_size`.
	///
	/// See [`.rchunks_exact_mut()`] for a variant of this iterator that returns
	/// chunks of always exactly `chunk_size` bits, and [`.chunks_mut()`] for
	/// the same iterator but starting at the beginning of the slice.
	///
	/// # Original
	///
	/// [`slice::rchunks_mut`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.rchunks_mut)
	///
	/// # API Differences
	///
	/// This iterator marks each yielded item as aliased, as iterators can be
	/// used to yield multiple items into the same scope. If you are using
	/// the iterator in a manner that ensures that all yielded items have
	/// disjoint lifetimes, you can use the [`.remove_alias()`] adapter on it to
	/// remove the alias marker from the yielded subslices.
	///
	/// # Panics
	///
	/// Panics if `chunk_size` is 0.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let v = bits![mut 0; 5];
	/// let mut count = 1;
	///
	/// for chunk in v.rchunks_mut(2) {
	///   for mut bit in chunk.iter_mut() {
	///     *bit = count % 2 == 0;
	///   }
	///   count += 1;
	/// }
	/// assert_eq!(v, bits![0, 1, 1, 0, 0]);
	/// ```
	///
	/// [`.chunks_mut()`]: Self::chunks_mut
	/// [`.rchunks_exact_mut()`]: Self::rchunks_exact_mut
	/// [`.remove_alias()`]: crate::slice::RChunksMut::remove_alias
	#[inline]
	pub fn rchunks_mut(&mut self, chunk_size: usize) -> RChunksMut<O, T> {
		assert_ne!(chunk_size, 0, "Chunk width cannot be 0");
		RChunksMut::new(self, chunk_size)
	}

	/// Returns an iterator over `chunk_size` bits of the slice at a time,
	/// starting at the end of the slice.
	///
	/// The chunks are slices and do not overlap. If `chunk_size` does not
	/// divide the length of the slice, then the last up to `chunk_size-1` bits
	/// will be omitted and can be retrieved from the [`.remainder()`] method of
	/// the iterator.
	///
	/// Due to each chunk having exactly `chunk_size` bits, the compiler may be
	/// able to optimize the resulting code better than in the case of
	/// [`.rchunks()`].
	///
	/// See [`.rchunks()`] for a variant of this iterator that also returns the
	/// remainder as a smaller chunk, and [`.chunks_exact()`] for the same
	/// iterator but starting at the beginning of the slice.
	///
	/// # Original
	///
	/// [`slice::rchunks_exact`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.rchunks_exact)
	///
	/// # Panics
	///
	/// Panics if `chunk_size` is 0.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let slice = bits![0, 0, 1, 1, 0];
	/// let mut iter = slice.rchunks_exact(2);
	/// assert_eq!(iter.next().unwrap(), bits![1, 0]);
	/// assert_eq!(iter.next().unwrap(), bits![0, 1]);
	/// assert!(iter.next().is_none());
	/// assert_eq!(iter.remainder(), bits![0]);
	/// ```
	///
	/// [`.chunks_exact()`]: Self::chunks_exact
	/// [`.rchunks()`]: Self::rchunks
	/// [`.remainder()`]: crate::slice::ChunksExact::remainder
	#[inline]
	pub fn rchunks_exact(&self, chunk_size: usize) -> RChunksExact<O, T> {
		assert_ne!(chunk_size, 0, "Chunk width cannot be 0");
		RChunksExact::new(self, chunk_size)
	}

	/// Returns an iterator over `chunk_size` bits of the slice at a time,
	/// starting at the end of the slice.
	///
	/// The chunks are mutable slices, and do not overlap. If `chunk_size` does
	/// not divide the length of the slice, then the last up to `chunk_size-1`
	/// bits will be omitted and can be retrieved from the [`.into_remainder()`]
	/// method of the iterator.
	///
	/// Due to each chunk having exactly `chunk_size` bits, the compiler may be
	/// able to optimize the resulting code better than in the case of
	/// [`.rchunks_mut()`].
	///
	/// See [`.rchunks_mut()`] for a variant of this iterator that also returns
	/// the remainder as a smaller chunk, and [`.chunks_exact_mut()`] for the
	/// same iterator but starting at the beginning of the slice.
	///
	/// # Original
	///
	/// [`slice::rchunks_exact_mut`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.rchunks_exact_mut)
	///
	/// # API Differences
	///
	/// This iterator marks each yielded item as aliased, as iterators can be
	/// used to yield multiple items into the same scope. If you are using
	/// the iterator in a manner that ensures that all yielded items have
	/// disjoint lifetimes, you can use the [`.remove_alias()`] adapter on it to
	/// remove the alias marker from the yielded subslices.
	///
	/// # Panics
	///
	/// Panics if `chunk_size` is 0.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let v = bits![mut 0; 5];
	///
	/// for chunk in v.rchunks_exact_mut(2) {
	///   chunk.set_all(true);
	/// }
	/// assert_eq!(v, bits![0, 1, 1, 1, 1]);
	/// ```
	///
	/// [`.chunks_exact_mut()`]: Self::chunks_exact_mut
	/// [`.into_remainder()`]: crate::slice::ChunksExactMut::into_remainder
	/// [`.rchunks_mut()`]: Self::rchunks_mut
	/// [`.remove_alias()`]: crate::slice::ChunksExactMut::remove_alias
	#[inline]
	pub fn rchunks_exact_mut(
		&mut self,
		chunk_size: usize,
	) -> RChunksExactMut<O, T> {
		assert_ne!(chunk_size, 0, "Chunk width cannot be 0");
		RChunksExactMut::new(self, chunk_size)
	}

	/// Divides one slice into two at an index.
	///
	/// The first will contain all indices from `[0, mid)` (excluding the index
	/// `mid` itself) and the second will contain all indices from `[mid, len)`
	/// (excluding the index `len` itself).
	///
	/// # Original
	///
	/// [`slice::split_at`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_at)
	///
	/// # Panics
	///
	/// Panics if `mid > len`.
	///
	/// # Behavior
	///
	/// When `mid` is `0` or `self.len()`, then the left or right return values,
	/// respectively, are empty slices. Empty slice references produced by this
	/// method are specified to have the address information you would expect:
	/// a left empty slice has the same base address and start bit as `self`,
	/// and a right empty slice will have its address raised by `self.len()`.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let v = bits![0, 0, 0, 1, 1, 1];
	///
	/// {
	///   let (left, right) = v.split_at(0);
	///   assert_eq!(left, bits![]);
	///   assert_eq!(right, v);
	/// }
	///
	/// {
	///   let (left, right) = v.split_at(2);
	///   assert_eq!(left, bits![0, 0]);
	///   assert_eq!(right, bits![0, 1, 1, 1]);
	/// }
	///
	/// {
	///   let (left, right) = v.split_at(6);
	///   assert_eq!(left, v);
	///   assert_eq!(right, bits![]);
	/// }
	/// ```
	#[inline]
	pub fn split_at(&self, mid: usize) -> (&Self, &Self) {
		let len = self.len();
		assert!(mid <= len, "Index {} out of bounds: {}", mid, len);
		unsafe { self.split_at_unchecked(mid) }
	}

	/// Divides one mutable slice into two at an index.
	///
	/// The first will contain all indices from `[0, mid)` (excluding the index
	/// `mid` itself) and the second will contain all indices from `[mid, len)`
	/// (excluding the index `len` itself).
	///
	/// # Original
	///
	/// [`slice::split_at_mut`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_at_mut)
	///
	/// # API Differences
	///
	/// The partition index `mid` may occur anywhere in the slice, and as a
	/// result the two returned slices may both have write access to the memory
	/// address containing `mid`. As such, the returned slices must be marked
	/// with [`T::Alias`] in order to correctly manage memory access going
	/// forward.
	///
	/// This marking is applied to all memory accesses in both slices,
	/// regardless of whether any future accesses actually require it. To limit
	/// the alias marking to only the addresses that need it, use
	/// [`.bit_domain()`] or [`.bit_domain_mut()`] to split either slice into
	/// its aliased and unaliased subslices.
	///
	/// # Panics
	///
	/// Panics if `mid > len`.
	///
	/// # Behavior
	///
	/// When `mid` is `0` or `self.len()`, then the left or right return values,
	/// respectively, are empty slices. Empty slice references produced by this
	/// method are specified to have the address information you would expect:
	/// a left empty slice has the same base address and start bit as `self`,
	/// and a right empty slice will have its address raised by `self.len()`.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let v = bits![mut 0, 0, 0, 1, 1, 1];
	/// // scoped to restrict the lifetime of the borrows
	/// {
	///   let (left, right) = v.split_at_mut(2);
	///   assert_eq!(left, bits![0, 0]);
	///   assert_eq!(right, bits![0, 1, 1, 1]);
	///
	///   left.set(1, true);
	///   right.set(1, false);
	/// }
	/// {
	///   let mut v = bits![mut 0; 0];
	///   let (left, right) = v.split_at_mut(0);
	///   assert!(left.is_empty());
	///   assert!(right.is_empty());
	/// }
	/// assert_eq!(v, bits![0, 1, 0, 0, 1, 1]);
	/// ```
	///
	/// [`T::Alias`]: crate::store::BitStore::Alias
	/// [`.bit_domain`()]: Self::bit_domain
	/// [`.bit_domain_mut`()]: Self::bit_domain_mut
	//  `pub type Aliased = BitSlice<O, T::Alias>;` is not allowed in inherents,
	//  so this will not be aliased.
	#[inline]
	#[allow(clippy::type_complexity)]
	pub fn split_at_mut(
		&mut self,
		mid: usize,
	) -> (&mut BitSlice<O, T::Alias>, &mut BitSlice<O, T::Alias>) {
		self.assert_in_bounds(mid, 0 ..= self.len());
		unsafe { self.split_at_unchecked_mut(mid) }
	}

	/// Returns an iterator over subslices separated by bits that match `pred`.
	/// The matched bit is not contained in the subslices.
	///
	/// # Original
	///
	/// [`slice::split`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split)
	///
	/// # API Differences
	///
	/// In order to allow more than one bit of information for the split
	/// decision, the predicate receives the index of each bit, as well as its
	/// value.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let slice = bits![0, 1, 1, 0];
	/// let mut iter = slice.split(|pos, _bit| pos % 3 == 2);
	///
	/// assert_eq!(iter.next().unwrap(), bits![0, 1]);
	/// assert_eq!(iter.next().unwrap(), bits![0]);
	/// assert!(iter.next().is_none());
	/// ```
	///
	/// If the first bit is matched, an empty slice will be the first item
	/// returned by the iterator. Similarly, if the last bit in the slice is
	/// matched, an empty slice will be the last item returned by the iterator:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let slice = bits![0, 0, 1];
	/// let mut iter = slice.split(|_pos, bit| *bit);
	///
	/// assert_eq!(iter.next().unwrap(), bits![0, 0]);
	/// assert_eq!(iter.next().unwrap(), bits![]);
	/// assert!(iter.next().is_none());
	/// ```
	///
	/// If two matched bits are directly adjacent, an empty slice will be
	/// present between them:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let slice = bits![1, 0, 0, 1];
	/// let mut iter = slice.split(|_pos, bit| !*bit);
	///
	/// assert_eq!(iter.next().unwrap(), bits![1]);
	/// assert_eq!(iter.next().unwrap(), bits![]);
	/// assert_eq!(iter.next().unwrap(), bits![1]);
	/// assert!(iter.next().is_none());
	/// ```
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn split<F>(&self, pred: F) -> Split<O, T, F>
	where F: FnMut(usize, &bool) -> bool {
		Split::new(self, pred)
	}

	/// Returns an iterator over mutable subslices separated by bits that match
	/// `pred`. The matched bit is not contained in the subslices.
	///
	/// # Original
	///
	/// [`slice::split_mut`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_mut)
	///
	/// # API Differences
	///
	/// In order to allow more than one bit of information for the split
	/// decision, the predicate receives the index of each bit, as well as its
	/// value.
	///
	/// This iterator marks each yielded item as aliased, as iterators can be
	/// used to yield multiple items into the same scope. If you are using
	/// the iterator in a manner that ensures that all yielded items have
	/// disjoint lifetimes, you can use the [`.remove_alias()`] adapter on it to
	/// remove the alias marker from the yielded subslices.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let v = bits![mut 0, 0, 1, 0, 1, 0];
	/// for group in v.split_mut(|_pos, bit| *bit) {
	///   group.set(0, true);
	/// }
	/// assert_eq!(v, bits![1, 0, 1, 1, 1, 1]);
	/// ```
	///
	/// [`.remove_alias()`]: crate::slice::SplitMut::remove_alias
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn split_mut<F>(&mut self, pred: F) -> SplitMut<O, T, F>
	where F: FnMut(usize, &bool) -> bool {
		SplitMut::new(self.alias_mut(), pred)
	}

	/// Returns an iterator over subslices separated by bits that match `pred`,
	/// starting at the end of the slice and working backwards. The matched bit
	/// is not contained in the subslices.
	///
	/// # Original
	///
	/// [`slice::rsplit`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.rsplit)
	///
	/// # API Differences
	///
	/// In order to allow more than one bit of information for the split
	/// decision, the predicate receives the index of each bit, as well as its
	/// value.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let slice = bits![1, 1, 1, 0, 1, 1];
	/// let mut iter = slice.rsplit(|_pos, bit| !*bit);
	///
	/// assert_eq!(iter.next().unwrap(), bits![1; 2]);
	/// assert_eq!(iter.next().unwrap(), bits![1; 3]);
	/// assert!(iter.next().is_none());
	/// ```
	///
	/// As with [`.split()`], if the first or last bit is matched, an empty
	/// slice will be the first (or last) item returned by the iterator.
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let v = bits![1, 0, 0, 1, 0, 0, 1];
	/// let mut it = v.rsplit(|_pos, bit| *bit);
	/// assert_eq!(it.next().unwrap(), bits![]);
	/// assert_eq!(it.next().unwrap(), bits![0; 2]);
	/// assert_eq!(it.next().unwrap(), bits![0; 2]);
	/// assert_eq!(it.next().unwrap(), bits![]);
	/// assert!(it.next().is_none());
	/// ```
	///
	/// [`.split()`]: Self::split
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn rsplit<F>(&self, pred: F) -> RSplit<O, T, F>
	where F: FnMut(usize, &bool) -> bool {
		RSplit::new(self, pred)
	}

	/// Returns an iterator over mutable subslices separated by bits that match
	/// `pred`, starting at the end of the slice and working backwards. The
	/// matched bit is not contained in the subslices.
	///
	/// # Original
	///
	/// [`slice::rsplit_mut`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.rsplit_mut)
	///
	/// # API Differences
	///
	/// In order to allow more than one bit of information for the split
	/// decision, the predicate receives the index of each bit, as well as its
	/// value.
	///
	/// This iterator marks each yielded item as aliased, as iterators can be
	/// used to yield multiple items into the same scope. If you are using
	/// the iterator in a manner that ensures that all yielded items have
	/// disjoint lifetimes, you can use the [`.remove_alias()`] adapter on it to
	/// remove the alias marker from the yielded subslices.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let v = bits![mut 0, 0, 1, 0, 1, 0];
	/// for group in v.rsplit_mut(|_pos, bit| *bit) {
	///   group.set(0, true);
	/// }
	/// assert_eq!(v, bits![1, 0, 1, 1, 1, 1]);
	/// ```
	///
	/// [`.remove_alias()`]: crate::slice::RSplitMut::remove_alias
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn rsplit_mut<F>(&mut self, pred: F) -> RSplitMut<O, T, F>
	where F: FnMut(usize, &bool) -> bool {
		RSplitMut::new(self.alias_mut(), pred)
	}

	/// Returns an iterator over subslices separated by bits that match `pred`,
	/// limited to returning at most `n` items. The matched bit is not contained
	/// in the subslices.
	///
	/// The last item returned, if any, will contain the remainder of the slice.
	///
	/// # Original
	///
	/// [`slice::splitn`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.splitn)
	///
	/// # API Differences
	///
	/// In order to allow more than one bit of information for the split
	/// decision, the predicate receives the index of each bit, as well as its
	/// value.
	///
	/// # Examples
	///
	/// Print the slice split once by set bits (i.e., `[0, 0,]`, `[0, 1, 0]`):
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let v = bits![0, 0, 1, 0, 1, 0];
	///
	/// for group in v.splitn(2, |_pos, bit| *bit) {
	///   # #[cfg(feature = "std")] {
	///   println!("{:b}", group);
	///   # }
	/// }
	/// ```
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn splitn<F>(&self, n: usize, pred: F) -> SplitN<O, T, F>
	where F: FnMut(usize, &bool) -> bool {
		SplitN::new(self, pred, n)
	}

	/// Returns an iterator over subslices separated by bits that match `pred`,
	/// limited to returning at most `n` items. The matched bit is not contained
	/// in the subslices.
	///
	/// The last item returned, if any, will contain the remainder of the slice.
	///
	/// # Original
	///
	/// [`slice::splitn_mut`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.splitn_mut)
	///
	/// # API Differences
	///
	/// In order to allow more than one bit of information for the split
	/// decision, the predicate receives the index of each bit, as well as its
	/// value.
	///
	/// This iterator marks each yielded item as aliased, as iterators can be
	/// used to yield multiple items into the same scope. If you are using
	/// the iterator in a manner that ensures that all yielded items have
	/// disjoint lifetimes, you can use the [`.remove_alias()`] adapter on it to
	/// remove the alias marker from the yielded subslices.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let v = bits![mut 0, 0, 1, 0, 1, 0];
	///
	/// for group in v.splitn_mut(2, |_pos, bit| *bit) {
	///   group.set(0, true);
	/// }
	/// assert_eq!(v, bits![1, 0, 1, 1, 1, 0]);
	/// ```
	///
	/// [`.remove_alias()`]: crate::slice::SplitNMut::remove_alias
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn splitn_mut<F>(&mut self, n: usize, pred: F) -> SplitNMut<O, T, F>
	where F: FnMut(usize, &bool) -> bool {
		SplitNMut::new(self.alias_mut(), pred, n)
	}

	/// Returns an iterator over subslices separated by bits that match `pred`,
	/// limited to returning at most `n` items. This starts at the end of the
	/// slice and works backwards. The matched bit is not contained in the
	/// subslices.
	///
	/// The last item returned, if any, will contain the remainder of the slice.
	///
	/// # Original
	///
	/// [`slice::rsplitn`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.rsplitn)
	///
	/// # API Differences
	///
	/// In order to allow more than one bit of information for the split
	/// decision, the predicate receives the index of each bit, as well as its
	/// value.
	///
	/// # Examples
	///
	/// Print the slice split once, starting from the end, by set bits (i.e.,
	/// `[0]`, `[0, 0, 1, 0]`):
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let v = bits![0, 0, 1, 0, 1, 0];
	///
	/// for group in v.rsplitn(2, |_pos, bit| *bit) {
	///   # #[cfg(feature = "std")] {
	///   println!("{:b}", group);
	///   # }
	/// }
	/// ```
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn rsplitn<F>(&self, n: usize, pred: F) -> RSplitN<O, T, F>
	where F: FnMut(usize, &bool) -> bool {
		RSplitN::new(self, pred, n)
	}

	/// Returns an iterator over subslices separated by bits that match `pred`,
	/// limited to returning at most `n` items. This starts at the end of the
	/// slice and works backwards. The matched bit is not contained in the
	/// subslices.
	///
	/// The last item returned, if any, will contain the remainder of the slice.
	///
	/// # Original
	///
	/// [`slice::rsplitn_mut`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.rsplitn_mut)
	///
	/// # API Differences
	///
	/// In order to allow more than one bit of information for the split
	/// decision, the predicate receives the index of each bit, as well as its
	/// value.
	///
	/// This iterator marks each yielded item as aliased, as iterators can be
	/// used to yield multiple items into the same scope. If you are using
	/// the iterator in a manner that ensures that all yielded items have
	/// disjoint lifetimes, you can use the [`.remove_alias()`] adapter on it to
	/// remove the alias marker from the yielded subslices.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let v = bits![mut 0, 0, 1, 0, 1, 0];
	///
	/// for group in v.rsplitn_mut(2, |_pos, bit| *bit) {
	///   group.set(0, true);
	/// }
	/// assert_eq!(v, bits![1, 0, 1, 0, 1, 1]);
	/// ```
	///
	/// [`.remove_alias()`]: crate::slice::RSplitNMut::remove_alias
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn rsplitn_mut<F>(&mut self, n: usize, pred: F) -> RSplitNMut<O, T, F>
	where F: FnMut(usize, &bool) -> bool {
		RSplitNMut::new(self.alias_mut(), pred, n)
	}

	/// Returns `true` if the slice contains a subslice that matches the given
	/// span.
	///
	/// # Original
	///
	/// [`slice::contains`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.contains)
	///
	/// # API Differences
	///
	/// This searches for a matching subslice (allowing different type
	/// parameters) rather than for a specific bit. Searching for a contained
	/// element with a given value is not as useful on a collection of `bool`.
	///
	/// Furthermore, `BitSlice` defines [`any`] and [`not_all`], which are
	/// optimized searchers for any `true` or `false` bit, respectively, in a
	/// sequence.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let data = 0b0101_1010u8;
	/// let bits_msb = data.view_bits::<Msb0>();
	/// let bits_lsb = data.view_bits::<Lsb0>();
	/// assert!(bits_msb.contains(&bits_lsb[1 .. 5]));
	/// ```
	///
	/// This example uses a palindrome pattern to demonstrate that the slice
	/// being searched for does not need to have the same type parameters as the
	/// slice being searched.
	///
	/// [`any`]: Self::any
	/// [`not_all`]: Self::not_all
	#[inline]
	pub fn contains<O2, T2>(&self, x: &BitSlice<O2, T2>) -> bool
	where
		O2: BitOrder,
		T2: BitStore,
	{
		let len = x.len();
		if len > self.len() {
			return false;
		};
		self.windows(len).any(|s| s == x)
	}

	/// Returns `true` if `needle` is a prefix of the slice.
	///
	/// # Original
	///
	/// [`slice::starts_with`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.starts_with)
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let v = bits![0, 1, 0, 0];
	/// assert!(v.starts_with(bits![0]));
	/// assert!(v.starts_with(bits![0, 1]));
	/// assert!(!v.starts_with(bits![1]));
	/// assert!(!v.starts_with(bits![1, 0]));
	/// ```
	///
	/// Always returns `true` if `needle` is an empty slice:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let v = bits![0, 1, 0];
	/// assert!(v.starts_with(bits![]));
	/// let v = bits![];
	/// assert!(v.starts_with(bits![]));
	/// ```
	#[inline]
	pub fn starts_with<O2, T2>(&self, needle: &BitSlice<O2, T2>) -> bool
	where
		O2: BitOrder,
		T2: BitStore,
	{
		let len = needle.len();
		self.len() >= len && needle == unsafe { self.get_unchecked(.. len) }
	}

	/// Returns `true` if `needle` is a suffix of the slice.
	///
	/// # Original
	///
	/// [`slice::ends_with`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.ends_with)
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let v = bits![0, 1, 0, 0];
	/// assert!(v.ends_with(bits![0]));
	/// assert!(v.ends_with(bits![0; 2]));
	/// assert!(!v.ends_with(bits![1]));
	/// assert!(!v.ends_with(bits![1, 0]));
	/// ```
	///
	/// Always returns `true` if `needle` is an empty slice:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let v = bits![0, 1, 0];
	/// assert!(v.ends_with(bits![]));
	/// let v = bits![];
	/// assert!(v.ends_with(bits![]));
	/// ```
	#[inline]
	pub fn ends_with<O2, T2>(&self, needle: &BitSlice<O2, T2>) -> bool
	where
		O2: BitOrder,
		T2: BitStore,
	{
		let nlen = needle.len();
		let len = self.len();
		len >= nlen && needle == unsafe { self.get_unchecked(len - nlen ..) }
	}

	/// Rotates the slice in-place such that the first `by` bits of the slice
	/// move to the end while the last `self.len() - by` bits move to the
	/// front. After calling `.rotate_left()`, the bit previously at index `by`
	/// will become the first bit in the slice.
	///
	/// # Original
	///
	/// [`slice::rotate_left`](https://doc.rust-lang.org/stable/std/primitive.slice.html#rotate_left)
	///
	/// # Panics
	///
	/// This function will panic if `by` is greater than the length of the
	/// slice. Note that `by == self.len()` does *not* panic and is a noöp.
	///
	/// # Complexity
	///
	/// Takes linear (in [`self.len()`]) time.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let a = bits![mut 0, 0, 1, 0, 1, 0];
	/// a.rotate_left(2);
	/// assert_eq!(a, bits![1, 0, 1, 0, 0, 0]);
	/// ```
	///
	/// Rotating a subslice:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let a = bits![mut 0, 0, 1, 0, 1, 1];
	/// a[1 .. 5].rotate_left(1);
	/// assert_eq!(a, bits![0, 1, 0, 1, 0, 1]);
	/// ```
	///
	/// [`self.len()`]: Self::len
	#[inline]
	pub fn rotate_left(&mut self, mut by: usize) {
		let len = self.len();
		assert!(
			by <= len,
			"Slices cannot be rotated by more than their length"
		);
		if by == 0 || by == len {
			return;
		}
		/* The standard one-element-at-a-time algorithm is necessary for `[T]`
		rotation, because it must not allocate, but bit slices have an advantage
		in that placing a single processor word on the stack as a temporary has
		significant logical acceleration.

		Instead, we can move `min(usize::BITS, by)` bits from the front of the
		slice into the stack, then shunt the rest of the slice downwards, then
		insert the stack bits into the now-open back, repeating until complete.

		There is no reason to use a stack temporary smaller than a processor
		word, so this uses `usize` instead of `T` for performance benefits.
		*/
		let mut tmp = BitArray::<O, usize>::zeroed();
		while by > 0 {
			let shamt = cmp::min(<usize as IsNumber>::BITS as usize, by);
			unsafe {
				let tmp_bits = tmp.get_unchecked_mut(.. shamt);
				tmp_bits.clone_from_bitslice(self.get_unchecked(.. shamt));
				self.copy_within_unchecked(shamt .., 0);
				self.get_unchecked_mut(len - shamt ..)
					.clone_from_bitslice(tmp_bits);
			}
			by -= shamt;
		}
	}

	/// Rotates the slice in-place such that the first `self.len() - by` bits of
	/// the slice move to the end while the last `by` bits move to the front.
	/// After calling `.rotate_right()`, the bit previously at index `self.len()
	/// - by` will become the first bit in the slice.
	///
	/// # Original
	///
	/// [`slice::rotate_right`](https://doc.rust-lang.org/stable/std/primitive.slice.html#rotate_right)
	///
	/// # Panics
	///
	/// This function will panic if `by` is greater than the length of the
	/// slice. Note that `by == self.len()` does *not* panic and is a noöp.
	///
	/// # Complexity
	///
	/// Takes linear (in [`self.len()`]) time.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let a = bits![mut 0, 0, 1, 1, 1, 0];
	/// a.rotate_right(2);
	/// assert_eq!(a, bits![1, 0, 0, 0, 1, 1]);
	/// ```
	///
	/// Rotating a subslice:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let a = bits![mut 0, 0, 1, 0, 1, 1];
	/// a[1 .. 5].rotate_right(1);
	/// assert_eq!(a, bits![0, 1, 0, 1, 0, 1]);
	/// ```
	///
	/// [`self.len()`]: Self::len
	#[inline]
	pub fn rotate_right(&mut self, mut by: usize) {
		let len = self.len();
		assert!(
			by <= len,
			"Slices cannot be rotated by more than their length"
		);
		if by == 0 || by == len {
			return;
		}
		let mut tmp = BitArray::<O, usize>::zeroed();
		while by > 0 {
			let shamt = cmp::min(<usize as IsNumber>::BITS as usize, by);
			let mid = len - shamt;
			unsafe {
				let tmp_bits = tmp.get_unchecked_mut(.. shamt);
				tmp_bits.clone_from_bitslice(self.get_unchecked(mid ..));
				self.copy_within_unchecked(.. mid, shamt);
				self.get_unchecked_mut(.. shamt)
					.clone_from_bitslice(tmp_bits);
			}
			by -= shamt;
		}
	}

	#[doc(hidden)]
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	#[deprecated = "Use `clone_from_bitslice` to copy between bitslices"]
	pub fn clone_from_slice<O2, T2>(&mut self, src: &BitSlice<O2, T2>)
	where
		O2: BitOrder,
		T2: BitStore,
	{
		self.clone_from_bitslice(src)
	}

	#[doc(hidden)]
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	#[deprecated = "Use `copy_from_bitslice` to copy between bitslices"]
	pub fn copy_from_slice(&mut self, src: &Self) {
		self.copy_from_bitslice(src)
	}

	/// Copies bits from one part of the slice to another part of itself.
	///
	/// `src` is the range within `self` to copy from. `dest` is the starting
	/// index of the range within `self` to copy to, which will have the same
	/// length as `src`. The two ranges may overlap. The ends of the two ranges
	/// must be less than or equal to [`self.len()`].
	///
	/// # Original
	///
	/// [`slice::copy_within`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.copy_within)
	///
	/// # Panics
	///
	/// This function will panic if either range exceeds the end of the slice,
	/// or if the end of `src` is before the start.
	///
	/// # Examples
	///
	/// Copying four bits within a slice:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bits = bits![mut 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0];
	///
	/// bits.copy_within(1 .. 5, 8);
	///
	/// assert_eq!(bits, bits![1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0]);
	/// ```
	///
	/// [`self.len()`]: Self::len
	#[inline]
	pub fn copy_within<R>(&mut self, src: R, dest: usize)
	where R: RangeBounds<usize> {
		let len = self.len();
		let src = dvl::normalize_range(src, len);
		//  Check that the source range is within bounds,
		dvl::assert_range(src.clone(), len);
		//  And that the destination range is within bounds.
		dvl::assert_range(dest .. dest + (src.end - src.start), len);
		unsafe {
			self.copy_within_unchecked(src, dest);
		}
	}

	#[doc(hidden)]
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	#[deprecated = "Use `swap_with_bitslice` to swap between bitslices"]
	pub fn swap_with_slice<O2, T2>(&mut self, other: &mut BitSlice<O2, T2>)
	where
		O2: BitOrder,
		T2: BitStore,
	{
		self.swap_with_bitslice(other);
	}

	/// Transmute the bit-slice to a bit-slice of another type, ensuring
	/// alignment of the types is maintained.
	///
	/// # Original
	///
	/// [`slice::align_to`]
	///
	/// # API Differences
	///
	/// Type `U` is **required** to have the same [`BitStore`] type family as
	/// type `T`. If `T` is a fundamental integer, so must `U` be; if `T` is an
	/// [`::Alias`] type, then so must `U`. Changing the type family with this
	/// method is **unsound** and strictly forbidden. Unfortunately, this cannot
	/// be encoded in the type system, so you are required to abide by this
	/// limitation yourself.
	///
	/// # Implementation
	///
	/// The algorithm used to implement this function attempts to create the
	/// widest possible span for the middle slice. However, the slice divisions
	/// must abide by the [`Domain`] restrictions: the left and right slices
	/// produced by this function will include the head and tail elements of the
	/// domain (if present), as well as the left and right subslices (if any)
	/// produced by calling [`slice::align_to`] on the domain body (if present).
	///
	/// The standard library implementation currently maximizes the width of the
	/// center slice, but its API does not guarantee this property, and retains
	/// the right to produce pessimal slices. As such, this function cannot
	/// guarantee maximal center slice width either, and you cannot rely on this
	/// behavior for *correctness* of your work; it is only a possible
	/// performance improvement.
	///
	/// # Safety
	///
	/// This method is essentially a [`mem::transmute`][mt] with respect to the
	/// memory region in the retured middle slice, so all of the usual caveats
	/// pertaining to [`mem::transmute::<T, U>`][mt] also apply here.
	///
	/// # Examples
	///
	/// Basic usage:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// unsafe {
	///   let bytes: [u8; 7] = [1, 2, 3, 4, 5, 6, 7];
	///   let bits = bytes.view_bits::<LocalBits>();
	///   let (prefix, shorts, suffix) = bits.align_to::<u16>();
	///   match prefix.len() {
	///     0 => {
	///       assert_eq!(shorts, bits[.. 48]);
	///       assert_eq!(suffix, bits[48 ..]);
	///     },
	///     8 => {
	///       assert_eq!(prefix, bits[.. 8]);
	///       assert_eq!(shorts, bits[8 ..]);
	///     },
	///     _ => unreachable!("This case will not occur")
	///   }
	/// }
	/// ```
	///
	/// [mt]: core::mem::transmute
	/// [`BitStore`]: crate::store::BitStore
	/// [`Domain`]: crate::domain::Domain
	/// [`slice::align_to`]: https://doc.rust-lang.org/stable/std/primitive.slice.html#method.align_to
	/// [`::Alias`]: crate::store::BitStore::Alias
	#[inline]
	pub unsafe fn align_to<U>(&self) -> (&Self, &BitSlice<O, U>, &Self)
	where U: BitStore {
		let (l, c, r) = self.as_bitspan().align_to::<U>();
		(
			l.to_bitslice_ref(),
			c.to_bitslice_ref(),
			r.to_bitslice_ref(),
		)
	}

	/// Transmute the bit-slice to a bit-slice of another type, ensuring
	/// alignment of the types is maintained.
	///
	/// # Original
	///
	/// [`slice::align_to_mut`]
	///
	/// # API Differences
	///
	/// Type `U` is **required** to have the same [`BitStore`] type family as
	/// type `T`. If `T` is a fundamental integer, so must `U` be; if `T` is an
	/// [`::Alias`] type, then so must `U`. Changing the type family with this
	/// method is **unsound** and strictly forbidden. Unfortunately, this cannot
	/// be encoded in the type system, so you are required to abide by this
	/// limitation yourself.
	///
	/// # Implementation
	///
	/// The algorithm used to implement this function attempts to create the
	/// widest possible span for the middle slice. However, the slice divisions
	/// must abide by the [`DomainMut`] restrictions: the left and right slices
	/// produced by this function will include the head and tail elements of the
	/// domain (if present), as well as the left and right subslices (if any)
	/// produced by calling [`slice::align_to_mut`] on the domain body (if
	/// present).
	///
	/// The standard library implementation currently maximizes the width of the
	/// center slice, but its API does not guarantee this property, and retains
	/// the right to produce pessimal slices. As such, this function cannot
	/// guarantee maximal center slice width either, and you cannot rely on this
	/// behavior for *correctness* of your work; it is only a possible
	/// performance improvement.
	///
	/// # Safety
	///
	/// This method is essentially a [`mem::transmute`][mt] with respect to the
	/// memory region in the retured middle slice, so all of the usual caveats
	/// pertaining to [`mem::transmute::<T, U>`][mt] also apply here.
	///
	/// # Examples
	///
	/// Basic usage:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// unsafe {
	///   let mut bytes: [u8; 7] = [1, 2, 3, 4, 5, 6, 7];
	///   let bits = bytes.view_bits_mut::<LocalBits>();
	///   let (prefix, shorts, suffix) = bits.align_to_mut::<u16>();
	///   //  same access and behavior as in `align_to`
	/// }
	/// ```
	///
	/// [mt]: core::mem::transmute
	/// [`BitStore`]: crate::store::BitStore
	/// [`DomainMut`]: crate::domain::DomainMut
	/// [`slice::align_to_mut`]: https://doc.rust-lang.org/stable/std/primitive.slice.html#method.align_to_mut
	/// [`::Alias`]: crate::store::BitStore::Alias
	#[inline]
	pub unsafe fn align_to_mut<U>(
		&mut self,
	) -> (&mut Self, &mut BitSlice<O, U>, &mut Self)
	where U: BitStore {
		let (l, c, r) = self.as_mut_bitspan().align_to::<U>();
		(
			l.to_bitslice_mut(),
			c.to_bitslice_mut(),
			r.to_bitslice_mut(),
		)
	}
}

/** These functions only exist when [`BitVec`] does.

[`BitVec`]: crate::vec::BitVec
**/
#[cfg(feature = "alloc")]
impl<O, T> BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[doc(hidden)]
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	#[deprecated = "Prefer `to_bitvec`"]
	pub fn to_vec(&self) -> BitVec<O, T::Unalias> {
		self.to_bitvec()
	}

	/// Creates a vector by repeating a slice `n` times.
	///
	/// # Original
	///
	/// [`slice::repeat`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.repeat)
	///
	/// # Panics
	///
	/// This function will panic if the capacity would overflow.
	///
	/// # Examples
	///
	/// Basic usage:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// assert_eq!(bits![0, 1].repeat(3), bits![0, 1, 0, 1, 0, 1]);
	/// ```
	///
	/// A panic upon overflow:
	///
	/// ```rust,should_panic
	/// use bitvec::prelude::*;
	///
	/// // this will panic at runtime
	/// bits![0, 1].repeat(BitSlice::<LocalBits, usize>::MAX_BITS);
	/// ```
	#[inline]
	pub fn repeat(&self, n: usize) -> BitVec<O, T::Unalias> {
		let len = self.len();
		let total = len.checked_mul(n).expect("capacity overflow");

		//  The memory has to be initialized before `.clone_from_bitslice` can
		//  write into it.
		let mut out = BitVec::repeat(false, total);

		for chunk in unsafe { out.chunks_exact_mut(len).remove_alias() } {
			//  TODO(myrrlyn): Specialize for `BitField` access
			chunk.clone_from_bitslice(self);
		}

		out
	}

	/* As of 1.51, the `concat` and `join` methods use still-unstable traits to
	govern the collection of multiple subslices into one vector. These are
	possible to copy over and redefine locally, but unless a user asks for it,
	doing so is considered a low priority.
	*/
}

/** Converts a reference to `T` into a [`BitSlice`] over one element.

# Original

[`slice::from_ref`](core::slice::from_ref)

[`BitSlice`]: crate::slice::BitSlice
**/
#[inline(always)]
#[cfg(not(tarpaulin_include))]
pub fn from_ref<O, T>(elem: &T) -> &BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	BitSlice::from_element(elem)
}

/** Converts a reference to `T` into a [`BitSlice`] over one element.

# Original

[`slice::from_mut`](core::slice::from_mut)

[`BitSlice`]: crate::slice::BitSlice
**/
#[inline(always)]
#[cfg(not(tarpaulin_include))]
pub fn from_mut<O, T>(elem: &mut T) -> &mut BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	BitSlice::from_element_mut(elem)
}

/* NOTE: Crate style is to use block doc comments at the left margin. A bug in
`rustfmt` replaces four spaces at left margin with hard tab, which is incorrect
in comments. Once `rustfmt` is fixed, revert these to block comments.
*/

/// Forms a bit-slice from a bit-pointer and a length.
///
/// The `len` argument is the number of **bits**, not the number of bytes or
/// elements.
///
/// # Original
///
/// [`slice::from_raw_parts`](core::slice::from_raw_parts)
///
/// # API Differences
///
/// This takes a [`BitPtr`] as its base address, rather than a raw `*Bit`
/// pointer, as `bitvec` does not provide raw pointers to individual bits.
///
/// It returns a `Result`, because the `len` argument may be invalid to encode
/// into a `&BitSlice` reference.
///
/// # Safety
///
/// Behavior is undefined if any of the following conditions are violated:
///
/// - `data` must be valid for reads for `len` many bits, and it must be
///   properly aligned. This means in particular:
///   - The entire memory range of this slice must be contained within a single
///     allocated object! Slices can never span across multiple allocated
///     objects. See [below] for an example incorrectly not taking this into
///     account.
///   - `data` must be non-null, and its `T` portion must be aligned. Both of
///     these conditions are checked during safe construction of the [`BitPtr`],
///     and `unsafe` construction of it **must not** violate them. Doing so will
///     cause incorrect behavior in the crate.
/// - `data` must point to `len` consecutive bits within properly initialized
///   memory elements `T`.
/// - The memory referenced by the returned slice must not be mutated for the
///   duration of the lifetime `'a`, except if `T` is an atomic or a `Cell`
///   type.
/// - `len` cannot exceed [`BitSlice::MAX_BITS`].
///
/// # Caveat
///
/// The lifetime for the returned slice is inferred from its usage. To prevent
/// accidental misuse, it’s suggested to tie the lifetime to whichever source
/// lifetime is safe in the context, such as by providing a helper function
/// taking the lifetime of a host value for the slice, or by explicit
/// annotation.
///
/// # Examples
///
/// ```rust
/// use bitvec::prelude::*;
/// use bitvec::slice as bv_slice;
///
/// let x = 42u8;
/// let bitptr = BitPtr::from(&x);
/// let bits: &BitSlice<LocalBits, _> = unsafe {
///   bv_slice::from_raw_parts(bitptr, 8)
/// }
/// .unwrap();
/// assert_eq!(bits, x.view_bits::<LocalBits>());
/// ```
///
/// ### Incorrect Usage
///
/// The following `join_slices` function is **unsound** ⚠️
///
/// ```rust,no_run
/// use bitvec::prelude::*;
/// use bitvec::slice as bv_slice;
///
/// fn join_bitslices<'a, O, T>(
///   fst: &'a BitSlice<O, T>,
///   snd: &'a BitSlice<O, T>,
/// ) -> &'a BitSlice<O, T>
/// where O: BitOrder, T: BitStore {
///   let fst_end = unsafe {
///     fst.as_bitptr().wrapping_add(fst.len())
///   };
///   let snd_start = snd.as_bitptr();
///   assert_eq!(snd_start, fst_end, "Slices must be adjacent");
///   unsafe {
///     bv_slice::from_raw_parts(fst.as_bitptr(), fst.len() + snd.len())
///   }
///   .unwrap()
/// }
///
/// let a = [0u8; 3];
/// let b = [!0u8; 3];
/// let c = join_bitslices(
///   a.view_bits::<LocalBits>(),
///   b.view_bits::<LocalBits>(),
/// );
/// ```
///
/// In this example, the compiler may elect to place `a` and `b` in adjacent
/// stack slots, but because they are still *separate allocation* regions, it is
/// illegal for a single region descriptor to be created over both of them.
///
/// [below]: #incorrect-usage
/// [`BitPtr`]: crate::ptr::BitPtr
/// [`BitSlice::MAX_BITS`]: crate::slice::BitSlice::MAX_BITS
#[inline]
pub unsafe fn from_raw_parts<'a, O, T>(
	data: BitPtr<Const, O, T>,
	len: usize,
) -> Result<&'a BitSlice<O, T>, BitSpanError<T>>
where
	O: BitOrder,
	T: BitStore,
{
	data.span(len).map(BitSpan::to_bitslice_ref)
}

/// Performs the same functionality as [`from_raw_parts`], except that a mutable
/// slice is returned.
///
/// # Original
///
/// [`slice::from_raw_parts_mut`](core::slice::from_raw_parts_mut)
///
/// # API Differences
///
/// This takes a [`BitPtr`] as its base address, rather than a raw `*Bit`
/// pointer, as `bitvec` does not provide raw pointers to individual bits.
///
/// It returns a `Result`, because the `len` argument may be invalid to encode
/// into a `&BitSlice` reference.
///
/// # Safety
///
/// Behavior is undefined if any of the following conditions are violated:
///
/// - `data` must be [valid] for boths reads and writes for `len` many bits, and
///   it must be properly aligned. This means in particular:
///   - The entire memory range of this slice must be contained within a single
///     allocated object! Slices can never span across multiple allocated
///     objects.
///   - `data` must be non-null, and its `T` portion must be aligned. Both of
///     these conditions are checked during safe construction of the [`BitPtr`],
///     and `unsafe` construction of it **must not** violate them. Doing so will
///     cause incorrect behavior in the crate.
/// - `data` must point to `len` consecutive bits within properly initialized
///   memory elements `T`.
/// - The memory referenced by the returned slice must not be accessed through
///   any other pointer (not derived from the return value) for the duration of
///   lifetime `'a`. Both read and write accesses are forbidden. This is true
///   even if `T` supports aliased mutation! An `&mut` reference requires
///   **exclusive** access for its lifetime.
/// - `len` cannot exceed [`BitSlice::MAX_BITS`].
///
/// [valid]: https://doc.rust-lang.org/stable/core/ptr/index.html#safety
/// [`BitPtr`]: crate::ptr::BitPtr
/// [`from_raw_parts`]: crate::slice::from_raw_parts
#[inline]
pub unsafe fn from_raw_parts_mut<'a, O, T>(
	data: BitPtr<Mut, O, T>,
	len: usize,
) -> Result<&'a mut BitSlice<O, T>, BitSpanError<T>>
where
	O: BitOrder,
	T: BitStore,
{
	data.span(len).map(BitSpan::to_bitslice_mut)
}

/** A helper trait used for indexing operations.

This trait has its definition stabilized, but has not stabilized its associated
methods. This means it cannot be implemented outside of the distribution
libraries. *Furthermore*, since [`bitvec`] cannot create `&mut bool` references,
it is insufficient for `bitvec`’s uses.

There is no tracking issue for `feature(slice_index_methods)`.

# Original

[`slice::SliceIndex`](core::slice::SliceIndex)

# API Differences

[`SliceIndex::Output`] is not usable here, because the `usize` implementation
cannot produce `&mut bool`. Instead, two output types `Immut` and `Mut` are
defined. The range implementations define these to be the appropriately mutable
[`BitSlice`] reference; the `usize` implementation defines them to be `&bool`
and the proxy type.

[`BitSlice`]: crate::slice::BitSlice
[`SliceIndex::Output`]: core::slice::SliceIndex::Output
[`bitvec`]: crate
**/
pub trait BitSliceIndex<'a, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// The output type for immutable accessors.
	type Immut;

	/// The output type for mutable accessors.
	type Mut;

	/// Returns a shared reference to the output at this location, if in bounds.
	///
	/// # Original
	///
	/// [`SliceIndex::get`](core::slice::SliceIndex::get)
	fn get(self, slice: &'a BitSlice<O, T>) -> Option<Self::Immut>;

	/// Returns a mutable reference to the output at this location, if in
	/// bounds.
	///
	/// # Original
	///
	/// [`SliceIndex::get_mut`](core::slice::SliceIndex::get_mut)
	fn get_mut(self, slice: &'a mut BitSlice<O, T>) -> Option<Self::Mut>;

	/// Returns a shared reference to the output at this location, without
	/// performing any bounds checking. Calling this method with an
	/// out-of-bounds index is [undefined behavior] even if the resulting
	/// reference is not used.
	///
	/// # Original
	///
	/// [`SliceIndex::get_unchecked`](core::slice::SliceIndex::get_unchecked)
	///
	/// # Safety
	///
	/// As this function does not perform boundary checking, the caller must
	/// ensure that `self` is an index within the boundaries of `slice` before
	/// calling in order to prevent boundary escapes and the ensuing safety
	/// violations.
	///
	/// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html
	unsafe fn get_unchecked(self, slice: &'a BitSlice<O, T>) -> Self::Immut;

	/// Returns a mutable reference to the output at this location, without
	/// performing any bounds checking. Calling this method with an
	/// out-of-bounds index is [undefined behavior] even if the resulting
	/// reference is not used.
	///
	/// # Original
	///
	/// [`SliceIndex::get_unchecked_mut`][orig]
	///
	/// # Safety
	///
	/// As this function does not perform boundary checking, the caller must
	/// ensure that `self` is an index within the boundaries of `slice` before
	/// calling in order to prevent boundary escapes and the ensuing safety
	/// violations.
	///
	/// [orig]: core::slice::SliceIndex::get_unchecked_mut
	/// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html
	unsafe fn get_unchecked_mut(
		self,
		slice: &'a mut BitSlice<O, T>,
	) -> Self::Mut;

	/// Returns a shared reference to the output at this location, panicking if
	/// out of bounds.
	///
	/// # Original
	///
	/// [`SliceIndex::index`](core::slice::SliceIndex::index)
	fn index(self, slice: &'a BitSlice<O, T>) -> Self::Immut;

	/// Returns a mutable reference to the output at this location, panicking if
	/// out of bounds.
	///
	/// # Original
	///
	/// [`SliceIndex::index_mut`](core::slice::SliceIndex::index_mut)
	fn index_mut(self, slice: &'a mut BitSlice<O, T>) -> Self::Mut;
}

impl<'a, O, T> BitSliceIndex<'a, O, T> for usize
where
	O: BitOrder,
	T: BitStore,
{
	type Immut = BitRef<'a, Const, O, T>;
	type Mut = BitRef<'a, Mut, O, T>;

	#[inline]
	fn get(self, slice: &'a BitSlice<O, T>) -> Option<Self::Immut> {
		if self < slice.len() {
			Some(unsafe { self.get_unchecked(slice) })
		}
		else {
			None
		}
	}

	#[inline]
	fn get_mut(self, slice: &'a mut BitSlice<O, T>) -> Option<Self::Mut> {
		if self < slice.len() {
			Some(unsafe { self.get_unchecked_mut(slice) })
		}
		else {
			None
		}
	}

	#[inline]
	unsafe fn get_unchecked(self, slice: &'a BitSlice<O, T>) -> Self::Immut {
		BitRef::from_bitptr(slice.as_bitptr().add(self))
	}

	#[inline]
	unsafe fn get_unchecked_mut(
		self,
		slice: &'a mut BitSlice<O, T>,
	) -> Self::Mut {
		BitRef::from_bitptr(slice.as_mut_bitptr().add(self))
	}

	#[inline]
	fn index(self, slice: &'a BitSlice<O, T>) -> Self::Immut {
		self.get(slice).unwrap_or_else(|| {
			panic!("Index {} out of bounds: {}", self, slice.len())
		})
	}

	#[inline]
	fn index_mut(self, slice: &'a mut BitSlice<O, T>) -> Self::Mut {
		let len = slice.len();
		self.get_mut(slice)
			.unwrap_or_else(|| panic!("Index {} out of bounds: {}", self, len))
	}
}

/// Implement indexing for the different range types.

macro_rules! range_impl {
	($r:ty { check $check:expr; select $select:expr; }) => {
		impl<'a, O, T> BitSliceIndex<'a, O, T> for $r
		where
			O: BitOrder,
			T: BitStore,
		{
			type Immut = &'a BitSlice<O, T>;
			type Mut = &'a mut BitSlice<O, T>;

			#[inline]
			#[allow(
				clippy::blocks_in_if_conditions,
				clippy::redundant_closure_call
			)]
			fn get(self, slice: Self::Immut) -> Option<Self::Immut> {
				if ($check)(self.clone(), slice.as_bitspan()) {
					Some(unsafe { self.get_unchecked(slice) })
				}
				else {
					None
				}
			}

			#[inline]
			#[allow(
				clippy::blocks_in_if_conditions,
				clippy::redundant_closure_call
			)]
			fn get_mut(self, slice: Self::Mut) -> Option<Self::Mut> {
				if ($check)(self.clone(), slice.as_bitspan()) {
					Some(unsafe { self.get_unchecked_mut(slice) })
				}
				else {
					None
				}
			}

			#[inline]
			#[allow(clippy::redundant_closure_call)]
			unsafe fn get_unchecked(self, slice: Self::Immut) -> Self::Immut {
				($select)(self, slice.as_bitspan()).to_bitslice_ref()
			}

			#[inline]
			#[allow(clippy::redundant_closure_call)]
			unsafe fn get_unchecked_mut(self, slice: Self::Mut) -> Self::Mut {
				($select)(self, slice.as_mut_bitspan()).to_bitslice_mut()
			}

			#[inline]
			fn index(self, slice: Self::Immut) -> Self::Immut {
				let r = self.clone();
				let l = slice.len();
				self.get(slice).unwrap_or_else(|| {
					panic!("Range {:?} out of bounds: {}", r, l)
				})
			}

			#[inline]
			fn index_mut(self, slice: Self::Mut) -> Self::Mut {
				let r = self.clone();
				let l = slice.len();
				self.get_mut(slice).unwrap_or_else(|| {
					panic!("Range {:?} out of bounds: {}", r, l)
				})
			}
		}
	};
}

range_impl!(Range<usize> {
	check |range: Self, span: BitSpan<_, _, _>| {
		let len = span.len();

		range.start < len && range.end <= len && range.start <= range.end
	};

	select |range: Self, span: BitSpan<_, _, _>| {
		span.as_bitptr().add(range.start).span_unchecked(range.len())
	};
});

range_impl!(RangeFrom<usize> {
	check |range: Self, span: BitSpan<_, _, _>| {
		let len = span.len();
		range.start <= len
	};

	select |range: Self, span: BitSpan<_, _, _>| {
		span.as_bitptr().add(range.start).span_unchecked(span.len() - range.start)
	};
});

range_impl!(RangeTo<usize> {
	check |range: Self, span: BitSpan<_, _, _>| {
		range.end <= span.len()
	};

	select |range: Self, mut span: BitSpan<_, _, _>| {
		span.set_len(range.end);
		span
	};
});

range_impl!(RangeInclusive<usize> {
	check |range: Self, span: BitSpan<_, _, _>| {
		let len = span.len();
		let start = *range.start();
		let end = *range.end();

		start < len && end < len && start <= end
	};

	select |range: Self, span: BitSpan<_, _, _>| {
		let start = *range.start();
		let end = *range.end();
		span.as_bitptr().add(start).span_unchecked(end + 1 - start)
	};
});

range_impl!(RangeToInclusive<usize> {
	check |range: Self, span: BitSpan<_, _, _>| {
		range.end < span.len()
	};

	select |range: Self, mut span: BitSpan<_, _, _>| {
		span.set_len(range.end + 1);
		span
	};
});

/// `RangeFull` is the identity function.
#[cfg(not(tarpaulin_include))]
impl<'a, O, T> BitSliceIndex<'a, O, T> for RangeFull
where
	O: BitOrder,
	T: BitStore,
{
	type Immut = &'a BitSlice<O, T>;
	type Mut = &'a mut BitSlice<O, T>;

	#[inline(always)]
	fn get(self, slice: Self::Immut) -> Option<Self::Immut> {
		Some(slice)
	}

	#[inline(always)]
	fn get_mut(self, slice: Self::Mut) -> Option<Self::Mut> {
		Some(slice)
	}

	#[inline(always)]
	unsafe fn get_unchecked(self, slice: Self::Immut) -> Self::Immut {
		slice
	}

	#[inline(always)]
	unsafe fn get_unchecked_mut(self, slice: Self::Mut) -> Self::Mut {
		slice
	}

	#[inline(always)]
	fn index(self, slice: Self::Immut) -> Self::Immut {
		slice
	}

	#[inline(always)]
	fn index_mut(self, slice: Self::Mut) -> Self::Mut {
		slice
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/slice/api.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/slice/iter.rs =====
//! Iterators over `[T]`.

use core::{
	cmp,
	fmt::{
		self,
		Debug,
		Formatter,
	},
	iter::FusedIterator,
	marker::PhantomData,
	mem,
};

use super::{
	BitSlice,
	BitSliceIndex,
};
use crate::{
	devel as dvl,
	order::{
		BitOrder,
		Lsb0,
		Msb0,
	},
	ptr::{
		BitPtrRange,
		BitRef,
		Const,
		Mut,
	},
	store::BitStore,
};

#[cfg(not(tarpaulin_include))]
impl<'a, O, T> IntoIterator for &'a BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	type IntoIter = Iter<'a, O, T>;
	type Item = <Self::IntoIter as Iterator>::Item;

	#[inline(always)]
	fn into_iter(self) -> Self::IntoIter {
		Iter::new(self)
	}
}

#[cfg(not(tarpaulin_include))]
impl<'a, O, T> IntoIterator for &'a mut BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	type IntoIter = IterMut<'a, O, T>;
	type Item = <Self::IntoIter as Iterator>::Item;

	#[inline(always)]
	fn into_iter(self) -> Self::IntoIter {
		IterMut::new(self)
	}
}

/** Immutable [`BitSlice`] iterator.

This struct is created by the [`.iter()`] method on [`BitSlice`]s.

# Original

[`slice::Iter`](core::slice::Iter)

# Examples

Basic usage:

```rust
use bitvec::prelude::*;

let bits = bits![0, 1];
for bit in bits.iter() {
  # #[cfg(feature = "std")]
  println!("{}", bit);
}
```

[`BitSlice`]: crate::slice::BitSlice
[`.iter()`]: crate::slice::BitSlice::iter
**/
#[repr(transparent)]
pub struct Iter<'a, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// Dual-pointer range of the span being iterated.
	///
	/// This structure stores two fully-decoded pointers to the start and end
	/// bits, trading increased size for faster performance during iteration.
	range: BitPtrRange<Const, O, T>,
	/// `Iter` is semantically equivalent to a [`&BitSlice`].
	///
	/// [`&BitSlice`]: crate::slice::BitSlice
	_ref: PhantomData<&'a BitSlice<O, T>>,
}

impl<'a, O, T> Iter<'a, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// Constructs a new slice iterator from a slice reference.
	#[inline]
	pub(super) fn new(slice: &'a BitSlice<O, T>) -> Self {
		Self {
			range: unsafe { slice.as_bitptr().range(slice.len()) },
			_ref: PhantomData,
		}
	}

	/// Views the underlying data as a subslice of the original data.
	///
	/// This has the same lifetime as the original [`BitSlice`], and so the
	/// iterator can continue to be used while this exists.
	///
	/// # Original
	///
	/// [`Iter::as_slice`](core::slice::Iter::as_slice)
	///
	/// # API Differences
	///
	/// As this views a [`BitSlice`], rather than a `[T]` or `[bool]` slice, it
	/// has been renamed.
	///
	/// # Examples
	///
	/// Basic usage:
	///
	/// ```rust
	/// # #[cfg(feature = "std")] {
	/// use bitvec::prelude::*;
	///
	/// let bits = bits![0, 0, 1, 1];
	///
	/// // Get the iterator:
	/// let mut iter = bits.iter();
	/// // So if we print what `as_bitslice` returns
	/// // here, we have "[0011]":
	/// println!("{:b}", iter.as_bitslice());
	///
	/// // Next, we move to the second element of the slice:
	/// iter.next();
	/// // Now `as_bitslice` returns "[011]":
	/// println!("{:b}", iter.as_bitslice());
	/// # }
	/// ```
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	#[inline]
	pub fn as_bitslice(&self) -> &'a BitSlice<O, T> {
		self.range.clone().into_bitspan().to_bitslice_ref()
	}

	#[doc(hidden)]
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	#[deprecated = "Use `as_bitslice` to view the underlying slice"]
	pub fn as_slice(&self) -> &'a BitSlice<O, T> {
		self.as_bitslice()
	}

	/// Adapts the iterator to yield `&bool` references rather than `BitRef`
	/// proxies.
	///
	/// This allows the iterator to be used in APIs that expect ordinary
	/// references and are not easily modified to receive the proxy structure.
	///
	/// It works by yielding `&'static` references to hidden statics; these
	/// references will **not** have an address value that fits in the context
	/// of the iterator.
	///
	/// # Parameters
	///
	/// - `self`
	///
	/// # Returns
	///
	/// An iterator equivalent to `self`, that yields `&bool` instead of
	/// `BitRef`.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bits = bits![0, 1];
	/// let mut iter = bits.iter().by_ref();
	/// assert_eq!(iter.next(), Some(&false));
	/// assert_eq!(iter.next(), Some(&true));
	/// assert!(iter.next().is_none());
	/// ```
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn by_ref(
		self,
	) -> impl 'a
	+ Iterator<Item = &'a bool>
	+ DoubleEndedIterator
	+ ExactSizeIterator
	+ FusedIterator {
		self.map(|bit| match *bit {
			true => &true,
			false => &false,
		})
	}

	/// Adapts the iterator to yield `bool` values rather than `BitRef` proxy
	/// references.
	///
	/// This allows the iterator to be used in APIs that expect ordinary values.
	/// It dereferences the proxy and produces the proxied `bool` directly.
	///
	/// This is equivalent to `[bool].iter().copied()`, as [`Iterator::copied`]
	/// is not available on this iterator.
	///
	/// # Parameters
	///
	/// - `self`
	///
	/// # Returns
	///
	/// An iterator equivalent to `self`, that yields `bool` instead of
	/// `BitRef`.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bits = bits![0, 1];
	/// let mut iter = bits.iter().by_val();
	/// assert_eq!(iter.next(), Some(false));
	/// assert_eq!(iter.next(), Some(true));
	/// assert!(iter.next().is_none());
	/// ```
	///
	/// [`Iterator::copied`]: core::iter::Iterator::copied
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn by_val(
		self,
	) -> impl 'a
	+ Iterator<Item = bool>
	+ DoubleEndedIterator
	+ ExactSizeIterator
	+ FusedIterator {
		self.map(|bit| *bit)
	}

	/// Forwards to [`by_val`].
	///
	/// This exists to allow ported code to continue to compile when
	/// `[bool].iter().copied()` is replaced with `BitSlice.iter().copied()`.
	///
	/// However, because [`Iterator::copied`] is not available on this iterator,
	/// this name raises a deprecation warning and encourages the user to use
	/// the correct inherent method instead of the overloaded method name.
	///
	/// [`by_val`]: Self::by_val
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	#[deprecated = "`Iterator::copied` does not exist on this iterator. Use \
	                `by_val` instead to achieve the same effect."]
	pub fn copied(
		self,
	) -> impl 'a
	+ Iterator<Item = bool>
	+ DoubleEndedIterator
	+ ExactSizeIterator
	+ FusedIterator {
		self.by_val()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Clone for Iter<'_, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn clone(&self) -> Self {
		Self {
			range: self.range.clone(),
			..*self
		}
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> AsRef<BitSlice<O, T>> for Iter<'_, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn as_ref(&self) -> &BitSlice<O, T> {
		self.as_bitslice()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Debug for Iter<'_, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		fmt.debug_tuple("Iter").field(&self.as_bitslice()).finish()
	}
}

/** Mutable [`BitSlice`] iterator.

This struct is created by the [`.iter_mut()`] method on [`BitSlice`]s.

# Original

[`slice::IterMut`](crate::slice::IterMut)

# Examples

Basic usage:

```rust
use bitvec::prelude::*;

let bits = bits![mut 0; 2];
for mut bit in bits.iter_mut() {
  *bit = true;
}
assert_eq!(bits, bits![1; 2]);
```

[`BitSlice`]: crate::slice::BitSlice
[`.iter_mut()`]: crate::slice::BitSlice::iter_mut
**/
#[repr(transparent)]
pub struct IterMut<'a, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// Dual-pointer range of the span being iterated.
	///
	/// This structure stores two fully-decoded pointers to the start and end
	/// bits, trading increased size for faster performance during iteration.
	range: BitPtrRange<Mut, O, T::Alias>,
	/// `IterMut` is semantically equivalent to an aliasing [`&mut BitSlice`].
	///
	/// [`&mut BitSlice`]: crate::slice::BitSlice
	_ref: PhantomData<&'a mut BitSlice<O, T::Alias>>,
}

impl<'a, O, T> IterMut<'a, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// Constructs a new slice mutable iterator from a slice reference.
	#[inline]
	pub(super) fn new(slice: &'a mut BitSlice<O, T>) -> Self {
		let len = slice.len();
		Self {
			range: unsafe { slice.alias_mut().as_mut_bitptr().range(len) },
			_ref: PhantomData,
		}
	}

	/// Views the underlying data as a subslice of the original data.
	///
	/// To avoid creating `&mut` references that alias, this is forced to
	/// consume the iterator.
	///
	/// # Original
	///
	/// [`IterMut::into_slice`](core::slice::IterMut::into_slice)
	///
	/// # API Differences
	///
	/// As this views a [`BitSlice`], rather than a `[T]` or `[bool]` slice, it
	/// has been renamed.
	///
	/// # Examples
	///
	/// Basic usage:
	///
	/// ```rust
	/// # #[cfg(feature = "std")] {
	/// use bitvec::prelude::*;
	///
	/// let bits = bits![mut 0, 1, 0];
	///
	/// {
	///   // Get the iterator:
	///   let mut iter = bits.iter_mut();
	///   // We move to the next element:
	///   iter.next();
	///   // So if we print what `into_bitslice`
	///   // returns here, we have "[10]":
	///   println!("{:b}", iter.into_slice());
	/// }
	///
	/// // Now let’s modify a value of the slice:
	/// {
	///   // First we get back the iterator:
	///   let mut iter = bits.iter_mut();
	///   // We change the value of the first bit of
	///   // the slice returned by the `next` method:
	///   *iter.next().unwrap() = true;
	/// }
	/// // Now bits is "[110]":
	/// println!("{:b}", bits);
	/// # }
	/// ```
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	#[inline]
	pub fn into_bitslice(self) -> &'a mut BitSlice<O, T::Alias> {
		self.range.into_bitspan().to_bitslice_mut()
	}

	#[doc(hidden)]
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	#[deprecated = "Use `into_bitslice` to view the underlying slice"]
	pub fn into_slice(self) -> &'a mut BitSlice<O, T::Alias> {
		self.into_bitslice()
	}

	#[inline]
	pub(crate) fn as_bitslice(&self) -> &BitSlice<O, T::Alias> {
		unsafe { core::ptr::read(self) }.into_bitslice()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Debug for IterMut<'_, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		fmt.debug_tuple("IterMut")
			.field(&self.as_bitslice())
			.finish()
	}
}

/// `Iter` and `IterMut` have very nearly the same implementation text.
macro_rules! iter {
	($($t:ident => $i:ty),+ $(,)?) => { $(
		impl<'a, O, T> Iterator for $t<'a, O, T>
		where
			O: BitOrder,
			T: BitStore,
		{
			type Item = $i;

			#[inline]
			fn next(&mut self) -> Option<Self::Item> {
				self.range
					.next()
					.map(|bp| unsafe { BitRef::from_bitptr(bp) })
			}

			#[inline(always)]
			fn size_hint(&self) -> (usize, Option<usize>) {
				self.range.size_hint()
			}

			#[inline(always)]
			fn count(self) -> usize {
				self.len()
			}

			#[inline]
			fn nth(&mut self, n: usize) -> Option<Self::Item> {
				self.range
					.nth(n)
					.map(|bp| unsafe { BitRef::from_bitptr(bp) })
			}

			#[inline(always)]
			fn last(mut self) -> Option<Self::Item> {
				self.next_back()
			}
		}

		impl<'a, O, T> DoubleEndedIterator for $t <'a, O, T>
		where
			O: BitOrder,
			T: BitStore,
		{
			#[inline]
			fn next_back(&mut self) -> Option<Self::Item> {
				self.range
				.next_back()
				.map(|bp| unsafe { BitRef::from_bitptr(bp) })
			}

			#[inline]
			fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
				self.range
				.nth_back(n)
				.map(|bp| unsafe { BitRef::from_bitptr(bp) })
			}
		}

		impl<O, T> ExactSizeIterator for $t <'_, O, T>
		where
			O: BitOrder,
			T: BitStore,
		{
			#[inline(always)]
			fn len(&self) -> usize {
				self.range.len()
			}
		}

		impl<O, T> FusedIterator for $t <'_, O, T>
		where
			O: BitOrder,
			T: BitStore
		{
		}

		unsafe impl<O, T> Send for $t <'_, O, T>
		where
			O: BitOrder,
			T: BitStore,
		{
		}

		unsafe impl<O, T> Sync for $t <'_, O, T>
		where
			O: BitOrder,
			T: BitStore,
		{
		}
	)+ };
}

iter!(
	Iter => <usize as BitSliceIndex<'a, O, T>>::Immut,
	IterMut => <usize as BitSliceIndex<'a, O, T::Alias>>::Mut,
);

/// Creates a full iterator set from only the base functions needed to build it.
macro_rules! group {
	(
		//  The type for the iteration set. This must be an immutable group.
		$iter:ident => $item:ty $( where $alias:ident )? {
			//  The eponymous functions from the iterator traits.
			$next:item
			$nth:item
			$next_back:item
			$nth_back:item
			$len:item
		}
	) => {
		//  Immutable iterator implementation
		impl<'a, O, T> Iterator for $iter <'a, O, T>
		where
			O: BitOrder,
			T: BitStore,
		{
			type Item = $item;

			#[inline]
			$next

			#[inline]
			$nth

			#[inline(always)]
			fn size_hint(&self) -> (usize, Option<usize>) {
				let len = self.len();
				(len, Some(len))
			}

			#[inline(always)]
			fn count(self) -> usize {
				self.len()
			}

			#[inline(always)]
			fn last(mut self) -> Option<Self::Item> {
				self.next_back()
			}
		}

		impl<'a, O, T> DoubleEndedIterator for $iter <'a, O, T>
		where
			O: BitOrder,
			T: BitStore,
		{
			#[inline]
			$next_back

			#[inline]
			$nth_back
		}

		impl<O, T> ExactSizeIterator for $iter <'_, O, T>
		where
			O: BitOrder,
			T: BitStore,
		{
			#[inline]
			$len
		}

		impl<O, T> FusedIterator for $iter <'_, O, T>
		where
			O: BitOrder,
			T: BitStore,
		{
		}
	}
}

/** An iterator over overlapping subslices of length `size`.

This struct is created by the [`.windows()`] method on [`BitSlice`]s.

# Original

[`slice::Windows`](core::slice::Windows)

[`BitSlice`]: crate::slice::BitSlice
[`.windows()`]: crate::slice::BitSlice::windows
**/
#[derive(Clone, Debug)]
pub struct Windows<'a, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// The [`BitSlice`] being windowed.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	slice: &'a BitSlice<O, T>,
	/// The width of the produced windows.
	width: usize,
}

group!(Windows => &'a BitSlice<O, T> {
	fn next(&mut self) -> Option<Self::Item> {
		if self.width > self.slice.len() {
			self.slice = Default::default();
			return None;
		}
		unsafe {
			let out = self.slice.get_unchecked(.. self.width);
			self.slice = self.slice.get_unchecked(1 ..);
			Some(out)
		}
	}

	fn nth(&mut self, n: usize) -> Option<Self::Item> {
		let (end, ovf) = self.width.overflowing_add(n);
		if end > self.slice.len() || ovf {
			self.slice = Default::default();
			return None;
		}
		unsafe {
			let out = self.slice.get_unchecked(n .. end);
			self.slice = self.slice.get_unchecked(n + 1 ..);
			Some(out)
		}
	}

	fn next_back(&mut self) -> Option<Self::Item> {
		let len = self.slice.len();
		if self.width > len {
			self.slice = Default::default();
			return None;
		}
		unsafe {
			let out = self.slice.get_unchecked(len - self.width ..);
			self.slice = self.slice.get_unchecked(.. len - 1);
			Some(out)
		}
	}

	fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
		let (end, ovf) = self.slice.len().overflowing_sub(n);
		if end < self.width || ovf {
			self.slice = Default::default();
			return None;
		}
		unsafe {
			let out = self.slice.get_unchecked(end - self.width .. end);
			self.slice = self.slice.get_unchecked(.. end - 1);
			Some(out)
		}
	}

	fn len(&self) -> usize {
		let len = self.slice.len();
		if self.width > len {
			return 0;
		}
		len - self.width + 1
	}
});

/** An iterator over a [`BitSlice`] in (non-overlapping) chunks (`chunk_size`
bits at a time), starting at the beginning of the slice.

When the slice length is not evenly divided by the chunk size, the last slice of
the iteration will be the remainder.

This struct is created by the [`.chunks()`] method on [`BitSlice`]s.

# Original

[`slice::Chunks`](core::slice::Chunks)

[`BitSlice`]: crate::slice::BitSlice
[`.chunks()`]: crate::slice::BitSlice::chunks
**/
#[derive(Clone, Debug)]
pub struct Chunks<'a, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// The [`BitSlice`] being chunked.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	slice: &'a BitSlice<O, T>,
	/// The width of the produced chunks.
	width: usize,
}

group!(Chunks => &'a BitSlice<O, T> {
	fn next(&mut self) -> Option<Self::Item> {
		let len = self.slice.len();
		if len == 0 {
			return None;
		}
		let mid = cmp::min(len, self.width);
		let (out, rest) = unsafe { self.slice.split_at_unchecked(mid) };
		self.slice = rest;
		Some(out)
	}

	fn nth(&mut self, n: usize) -> Option<Self::Item> {
		let len = self.slice.len();
		let (start, ovf) = n.overflowing_mul(self.width);
		if start >= len || ovf {
			self.slice = Default::default();
			return None;
		}
		let (out, rest) = unsafe {
			self.slice
				//  Discard the skipped front chunks,
				.get_unchecked(start ..)
				//  then split at the chunk width, or remnant length.
				.split_at_unchecked(cmp::min(len, self.width))
		};
		self.slice = rest;
		Some(out)
	}

	fn next_back(&mut self) -> Option<Self::Item> {
		match self.slice.len() {
			0 => None,
			len => {
				//  Determine if the back chunk is a remnant or a whole chunk.
				let rem = len % self.width;
				let size = if rem == 0 { self.width } else { rem };
				let (rest, out) =
					unsafe { self.slice.split_at_unchecked(len - size) };
				self.slice = rest;
				Some(out)
			},
		}
	}

	fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
		let len = self.len();
		if n >= len {
			self.slice = Default::default();
			return None;
		}
		let start = (len - 1 - n) * self.width;
		let width = cmp::min(start + self.width, self.slice.len());
		let (rest, out) = unsafe {
			self.slice
				//  Truncate to the end of the returned chunk,
				.get_unchecked(.. start + width)
				//  then split at the start of the returned chunk.
				.split_at_unchecked(start)
		};
		self.slice = rest;
		Some(out)
	}

	fn len(&self) -> usize {
		match self.slice.len() {
			0 => 0,
			len => {
				//  an explicit `div_mod` would be nice here
				let (n, r) = (len / self.width, len % self.width);
				n + (r > 0) as usize
			},
		}
	}
});

/** An iterator over a [`BitSlice`] in (non-overlapping) mutable chunks
(`chunk_size` bits at a time), starting at the beginning of the slice.

When the slice length is not evenly divided by the chunk size, the last slice of
the iteration will be the remainder.

This struct is created by the [`.chunks_mut()`] method on [`BitSlice`]s.

# Original

[`slice::ChunksMut`](core::slice::ChunksMut)

# API Differences

All slices yielded from this iterator are marked as aliased.

[`BitSlice`]: crate::slice::BitSlice
[`.chunks_mut()`]: crate::slice::BitSlice::chunks_mut
**/
#[derive(Debug)]
pub struct ChunksMut<'a, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// The [`BitSlice`] being chunked.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	slice: &'a mut BitSlice<O, T::Alias>,
	/// The width of the produced chunks.
	width: usize,
}

group!(ChunksMut => &'a mut BitSlice<O, T::Alias> {
	fn next(&mut self) -> Option<Self::Item> {
		let slice = mem::take(&mut self.slice);
		let len = slice.len();
		if len == 0 {
			return None;
		}
		let mid = cmp::min(len, self.width);
		let (out, rest) = unsafe { slice.split_at_unchecked_mut_noalias(mid) };
		self.slice = rest;
		Some(out)
	}

	fn nth(&mut self, n: usize) -> Option<Self::Item> {
		let slice = mem::take(&mut self.slice);
		let len = slice.len();
		let (start, ovf) = n.overflowing_mul(self.width);
		if start >= len || ovf {
			return None;
		}
		let (out, rest) = unsafe {
			slice
				//  Discard the skipped front chunks,
				.get_unchecked_mut(start ..)
				//  then split at the chunk width, or remnant length.
				.split_at_unchecked_mut_noalias(cmp::min(len, self.width))
		};
		self.slice = rest;
		Some(out)
	}

	fn next_back(&mut self) -> Option<Self::Item> {
		let slice = mem::take(&mut self.slice);
		match slice.len() {
			0 => None,
			len => {
				//  Determine if the back chunk is a remnant or a whole chunk.
				let rem = len % self.width;
				let size = if rem == 0 { self.width } else { rem };
				let (rest, out) =
					unsafe { slice.split_at_unchecked_mut_noalias(len - size) };
				self.slice = rest;
				Some(out)
			},
		}
	}

	fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
		let len = self.len();
		let slice = mem::take(&mut self.slice);
		if n >= len {
			return None;
		}
		let start = (len - 1 - n) * self.width;
		let width = cmp::min(start + self.width, slice.len());
		let (rest, out) = unsafe {
			slice
				//  Truncate to the end of the returned chunk,
				.get_unchecked_mut(.. start + width)
				//  then split at the start of the returned chunk.
				.split_at_unchecked_mut_noalias(start)
		};
		self.slice = rest;
		Some(out)
	}

	fn len(&self) -> usize {
		match self.slice.len() {
			0 => 0,
			len => {
				//  an explicit `div_mod` would be nice here
				let (n, r) = (len / self.width, len % self.width);
				n + (r > 0) as usize
			},
		}
	}
});

/** An iterator over a [`BitSlice`] in (non-overlapping) chunks (`chunk_size`
bits at a time), starting at the beginning of the slice.

When the slice length is not evenly divided by the chunk size, the last up to
`chunk_size-1` bits will be ommitted but can be retrieved from the
[`.remainder()`] function from the iterator.

This struct is created by the [`.chunks_exact()`] method on [`BitSlice`]s.

# Original

[`slice::ChunksExact`](core::slice::ChunksExact)

[`BitSlice`]: crate::slice::BitSlice
[`.chunks_exact()`]: crate::slice::BitSlice::chunks_exact
[`.remainder()`]: Self::remainder
**/
#[derive(Clone, Debug)]
pub struct ChunksExact<'a, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// The [`BitSlice`] being chunked.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	slice: &'a BitSlice<O, T>,
	/// Any remnant of the chunked [`BitSlice`] not divisible by `width`.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	extra: &'a BitSlice<O, T>,
	/// The width of the produced chunks.
	width: usize,
}

impl<'a, O, T> ChunksExact<'a, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	pub(super) fn new(slice: &'a BitSlice<O, T>, width: usize) -> Self {
		let len = slice.len();
		let rem = len % width;
		let (slice, extra) = unsafe { slice.split_at_unchecked(len - rem) };
		Self {
			slice,
			extra,
			width,
		}
	}

	/// Returns the remainder of the original [`BitSlice`] that is not going to
	/// be returned by the iterator. The returned `BitSlice` has at most
	/// `chunk_size-1` bits.
	///
	/// # Original
	///
	/// [`slice::ChunksExact::remainder`](core::slice::ChunksExact::remainder)
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn remainder(&self) -> &'a BitSlice<O, T> {
		self.extra
	}
}

group!(ChunksExact => &'a BitSlice<O, T> {
	fn next(&mut self) -> Option<Self::Item> {
		if self.slice.len() < self.width {
			return None;
		}
		let (out, rest) = unsafe { self.slice.split_at_unchecked(self.width) };
		self.slice = rest;
		Some(out)
	}

	fn nth(&mut self, n: usize) -> Option<Self::Item> {
		let (start, ovf) = n.overflowing_mul(self.width);
		if start + self.width >= self.slice.len() || ovf {
			self.slice = Default::default();
			return None;
		}
		let (out, rest) = unsafe {
			self.slice
				.get_unchecked(start ..)
				.split_at_unchecked(self.width)
		};
		self.slice = rest;
		Some(out)
	}

	fn next_back(&mut self) -> Option<Self::Item> {
		let len = self.slice.len();
		if len < self.width {
			return None;
		}
		let (rest, out) =
			unsafe { self.slice.split_at_unchecked(len - self.width) };
		self.slice = rest;
		Some(out)
	}

	fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
		let len = self.len();
		if n >= len {
			self.slice = Default::default();
			return None;
		}
		let end = (len - n) * self.width;
		let (rest, out) = unsafe {
			self.slice
				.get_unchecked(.. end)
				.split_at_unchecked(end - self.width)
		};
		self.slice = rest;
		Some(out)
	}

	fn len(&self) -> usize {
		self.slice.len() / self.width
	}
});

/** An iterator over a [`BitSlice`] in (non-overlapping) mutable chunks
(`chunk_size` bits at a time), starting at the beginning of the slice.

When the slice length is not evenly divided by the chunk size, the last up to
`chunk_size-1` bits will be omitted but can be retrieved from the
[`.into_remainder()`] function from the iterator.

This struct is created by the [`.chunks_exact_mut()`] method on [`BitSlice`]s.

# Original

[`slice::ChunksExactMut`](core::slice::ChunksExactMut)

# API Differences

All slices yielded from this iterator are marked as aliased.

[`BitSlice`]: crate::slice::BitSlice
[`.chunks_exact_mut()`]: crate::slice::BitSlice::chunks_exact_mut
[`.into_remainder()`]: Self::into_remainder
**/
#[derive(Debug)]
pub struct ChunksExactMut<'a, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// The [`BitSlice`] being chunked.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	slice: &'a mut BitSlice<O, T::Alias>,
	/// Any remnant of the chunked [`BitSlice`] not divisible by `width`.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	extra: &'a mut BitSlice<O, T::Alias>,
	/// The width of the produced chunks.
	width: usize,
}

impl<'a, O, T> ChunksExactMut<'a, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	pub(super) fn new(slice: &'a mut BitSlice<O, T>, width: usize) -> Self {
		let len = slice.len();
		let rem = len % width;
		let (slice, extra) = unsafe { slice.split_at_unchecked_mut(len - rem) };
		Self {
			slice,
			extra,
			width,
		}
	}

	/// Returns the remainder of the original [`BitSlice`] that is not going to
	/// be returned by the iterator. The returned `BitSlice` has at most
	/// `chunk_size-1` bits.
	///
	/// # Original
	///
	/// [`slice::ChunksExactMut::into_remainder`][orig]
	///
	/// # API Differences
	///
	/// The remainder slice, as with all slices yielded from this iterator, is
	/// marked as aliased.
	///
	/// [orig]: core::slice::ChunksExactMut::into_remainder
	/// [`BitSlice`]: crate::slice::BitSlice
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn into_remainder(self) -> &'a mut BitSlice<O, T::Alias> {
		self.extra
	}
}

group!(ChunksExactMut => &'a mut BitSlice<O, T::Alias> {
	fn next(&mut self) -> Option<Self::Item> {
		let slice = mem::take(&mut self.slice);
		if slice.len() < self.width {
			return None;
		}
		let (out, rest) =
			unsafe { slice.split_at_unchecked_mut_noalias(self.width) };
		self.slice = rest;
		Some(out)
	}

	fn nth(&mut self, n: usize) -> Option<Self::Item> {
		let slice = mem::take(&mut self.slice);
		let (start, ovf) = n.overflowing_mul(self.width);
		if start + self.width >= slice.len() || ovf {
			return None;
		}
		let (out, rest) = unsafe {
			slice.get_unchecked_mut(start ..)
				.split_at_unchecked_mut_noalias(self.width)
		};
		self.slice = rest;
		Some(out)
	}

	fn next_back(&mut self) -> Option<Self::Item> {
		let slice = mem::take(&mut self.slice);
		let len = slice.len();
		if len < self.width {
			return None;
		}
		let (rest, out) =
			unsafe { slice.split_at_unchecked_mut_noalias(len - self.width) };
		self.slice = rest;
		Some(out)
	}

	fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
		let len = self.len();
		let slice = mem::take(&mut self.slice);
		if n >= len {
			return None;
		}
		let end = (len - n) * self.width;
		let (rest, out) = unsafe {
			slice.get_unchecked_mut(.. end)
				.split_at_unchecked_mut_noalias(end - self.width)
		};
		self.slice = rest;
		Some(out)
	}

	fn len(&self) -> usize {
		self.slice.len() / self.width
	}
});

/** An iterator over a [`BitSlice`] in (non-overlapping) chunks (`chunk_size`
bits at a time), starting at the end of the slice.

When the slice length is not evenly divided by the chunk size, the last
slice of the iteration will be the remainder.

This struct is created by the [`.rchunks()`] method on [`BitSlice`]s.

# Original

[`slice::RChunks`](core::slice::RChunks)

[`BitSlice`]: crate::slice::BitSlice
[`.rchunks()`]: crate::slice::BitSlice::rchunks
**/
#[derive(Clone, Debug)]
pub struct RChunks<'a, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// The [`BitSlice`] being chunked.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	slice: &'a BitSlice<O, T>,
	/// The width of the produced chunks.
	width: usize,
}

group!(RChunks => &'a BitSlice<O, T> {
	fn next(&mut self) -> Option<Self::Item> {
		let len = self.slice.len();
		if len == 0 {
			return None;
		}
		let mid = len - cmp::min(len, self.width);
		let (rest, out) = unsafe { self.slice.split_at_unchecked(mid) };
		self.slice = rest;
		Some(out)
	}

	fn nth(&mut self, n: usize) -> Option<Self::Item> {
		let len = self.slice.len();
		let (num, ovf) = n.overflowing_mul(self.width);
		if num >= len || ovf {
			self.slice = Default::default();
			return None;
		}
		let end = len - num;
		//  Find the partition between `[.. retain]` and `[return ..][..w]`
		let mid = end.saturating_sub(self.width);
		let (rest, out) = unsafe {
			self.slice
				.get_unchecked(.. end)
				.split_at_unchecked(mid)
		};
		self.slice = rest;
		Some(out)
	}

	fn next_back(&mut self) -> Option<Self::Item> {
		match self.slice.len() {
			0 => None,
			n => {
				let rem = n % self.width;
				let len = if rem == 0 { self.width } else { rem };
				let (out, rest) = unsafe { self.slice.split_at_unchecked(len) };
				self.slice = rest;
				Some(out)
			},
		}
	}

	fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
		let len = self.len();
		if n >= len {
			self.slice = Default::default();
			return None;
		}
		/* Taking from the back of a reverse iterator means taking from the
		front of the slice.

		`len` gives us the total number of subslices remaining. In order to find
		the partition point, we need to subtract `n - 1` full subslices from
		that count (because the back slice of the iteration might not be full),
		compute their bit width, and offset *that* from the end of the memory
		region. This gives us the zero-based index of the partition point
		between what is returned and what is retained.

		The `part ..` section of the slice is retained, and the very end of the
		`.. part` section is returned. The head section is split at no less than
		`self.width` bits below the end marker (this could be the partial
		section, so a wrapping subtraction cannot be used), and `.. start` is
		discarded.

		Source:
		https://doc.rust-lang.org/1.43.0/src/core/slice/mod.rs.html#5141-5156
		*/
		let from_end = (len - 1 - n) * self.width;
		let end = self.slice.len() - from_end;
		let start = end.saturating_sub(self.width);
		let (out, rest) = unsafe { self.slice.split_at_unchecked(end) };
		self.slice = rest;
		Some(unsafe { out.get_unchecked(start ..) })
	}

	fn len(&self) -> usize {
		match self.slice.len() {
			0 => 0,
			len => {
				let (n, r) = (len / self.width, len % self.width);
				n + (r > 0) as usize
			},
		}
	}
});

/** An iterator over a [`BitSlice`] in (non-overlapping) mutable chunks
(`chunk_size` bits at a time), starting at the end of the slice.

When the slice length is not evenly divided by the chunk size, the last slice of
the iteration will be the remainder.

This struct is created by the [`.rchunks_mut()`] method on [`BitSlice`]s.

# Original

[`slice::RChunksMut`](core::slice::RChunksMut)

# API Differences

All slices yielded from this iterator are marked as aliased.

[`BitSlice`]: crate::slice::BitSlice
[`.rchunks_mut()`]: crate::slice::BitSlice::rchunks_mut
**/
#[derive(Debug)]
pub struct RChunksMut<'a, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// The [`BitSlice`] being chunked.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	slice: &'a mut BitSlice<O, T::Alias>,
	/// The width of the produced chunks.
	width: usize,
}

group!(RChunksMut => &'a mut BitSlice<O, T::Alias> {
	fn next(&mut self) -> Option<Self::Item> {
		let slice = mem::take(&mut self.slice);
		let len = slice.len();
		if len == 0 {
			return None;
		}
		let mid = len - cmp::min(len, self.width);
		let (rest, out) = unsafe { slice.split_at_unchecked_mut_noalias(mid) };
		self.slice = rest;
		Some(out)
	}

	fn nth(&mut self, n: usize) -> Option<Self::Item> {
		let slice = mem::take(&mut self.slice);
		let len = slice.len();
		let (num, ovf) = n.overflowing_mul(self.width);
		if num >= len || ovf {
			return None;
		}
		let end = len - num;
		//  Find the partition between `[.. retain]` and `[return ..][..w]`
		let mid = end.saturating_sub(self.width);
		let (rest, out) = unsafe {
			slice.get_unchecked_mut(.. end)
				.split_at_unchecked_mut_noalias(mid)
		};
		self.slice = rest;
		Some(out)
	}

	fn next_back(&mut self) -> Option<Self::Item> {
		let slice = mem::take(&mut self.slice);
		match slice.len() {
			0 => None,
			n => {
				let rem = n % self.width;
				let len = if rem == 0 { self.width } else { rem };
				let (out, rest) =
					unsafe { slice.split_at_unchecked_mut_noalias(len) };
				self.slice = rest;
				Some(out)
			},
		}
	}

	fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
		let len = self.len();
		let slice = mem::take(&mut self.slice);
		if n >= len {
			return None;
		}
		let from_end = (len - 1 - n) * self.width;
		let end = slice.len() - from_end;
		let start = end.saturating_sub(self.width);
		let (out, rest) = unsafe { slice.split_at_unchecked_mut_noalias(end) };
		self.slice = rest;
		Some(unsafe { out.get_unchecked_mut(start ..) })
	}

	fn len(&self) -> usize {
		match self.slice.len() {
			0 => 0,
			len => {
				let (n, r) = (len / self.width, len % self.width);
				n + (r > 0) as usize
			},
		}
	}
});

/** An iterator over a [`BitSlice`] in (non-overlapping) chunks (`chunk_size`
bits at a time), starting at the end of the slice.

When the slice length is not evenly divided by the chunk size, the last up to
`chunk_size-1` bits will be omitted but can be retrieved from the
[`.remainder()`] function from the iterator.

This struct is created by the [`.rchunks_exact()`] method on [`BitSlice`]s.

# Original

[`slice::RChunksExact`](core::slice::RChunksExact)

[`BitSlice`]: crate::slice::BitSlice
[`.rchunks_exact()`]: crate::slice::BitSlice::rchunks_exact
[`.remainder()`]: Self::remainder
**/
#[derive(Clone, Debug)]
pub struct RChunksExact<'a, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// The [`BitSlice`] being chunked.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	slice: &'a BitSlice<O, T>,
	/// Any remnant of the chunked [`BitSlice`] not divisible by `width`.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	extra: &'a BitSlice<O, T>,
	/// The width of the produced chunks.
	width: usize,
}

impl<'a, O, T> RChunksExact<'a, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	pub(super) fn new(slice: &'a BitSlice<O, T>, width: usize) -> Self {
		let (extra, slice) =
			unsafe { slice.split_at_unchecked(slice.len() % width) };
		Self {
			slice,
			extra,
			width,
		}
	}

	/// Returns the remainder of the original [`BitSlice`] that is not going to
	/// be returned by the iterator. The returned `BitSlice` has at most
	/// `chunk_size-1` bits.
	///
	/// # Original
	///
	/// [`slice::RChunksExact::remainder`](core::slice::RChunksExact::remainder)
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn remainder(&self) -> &'a BitSlice<O, T> {
		self.extra
	}
}

group!(RChunksExact => &'a BitSlice<O, T> {
	fn next(&mut self) -> Option<Self::Item> {
		let len = self.slice.len();
		if len < self.width {
			return None;
		}
		let (rest, out) =
			unsafe { self.slice.split_at_unchecked(len - self.width) };
		self.slice = rest;
		Some(out)
	}

	fn nth(&mut self, n: usize) -> Option<Self::Item> {
		let len = self.slice.len();
		let (split, ovf) = n.overflowing_mul(self.width);
		if split >= len || ovf {
			self.slice = Default::default();
			return None;
		}
		let end = len - split;
		let (rest, out) = unsafe {
			self.slice
				.get_unchecked(.. end)
				.split_at_unchecked(end - self.width)
		};
		self.slice = rest;
		Some(out)
	}

	fn next_back(&mut self) -> Option<Self::Item> {
		if self.slice.len() < self.width {
			return None;
		}
		let (out, rest) = unsafe { self.slice.split_at_unchecked(self.width) };
		self.slice = rest;
		Some(out)
	}

	fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
		let len = self.slice.len();
		let (start, ovf) = n.overflowing_mul(self.width);
		if start >= len || ovf {
			self.slice = Default::default();
			return None;
		}
		//  At this point, `start` is at least `self.width` less than `len`.
		let (out, rest) = unsafe {
			self.slice.get_unchecked(start ..).split_at_unchecked(self.width)
		};
		self.slice = rest;
		Some(out)
	}

	fn len(&self) -> usize {
		self.slice.len() / self.width
	}
});

/** An iterator over a [`BitSlice`] in (non-overlapping) mutable chunks
(`chunk_size` bits at a time), starting at the end of the slice.

When the slice length is not evenly divided by the chunk size, the last up to
`chunk_size-1` bits will be omitted but can be retrieved from the
[`.into_remainder()`] function from the iterator.

This struct is created by the [`.rchunks_exact_mut()`] method on [`BitSlice`]s.

# Original

[`slice::RChunksExactMut`](core::slice::RChunksExactMut)

# API Differences

All slices yielded from this iterator are marked as aliased.

[`BitSlice`]: crate::slice::BitSlice
[`.into_remainder()`]: Self::into_remainder
[`.rchunks_exact_mut()`]: crate::slice::BitSlice::rchunks_exact_mut
**/
#[derive(Debug)]
pub struct RChunksExactMut<'a, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// The [`BitSlice`] being chunked.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	slice: &'a mut BitSlice<O, T::Alias>,
	/// Any remnant of the chunked [`BitSlice`] not divisible by `width`.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	extra: &'a mut BitSlice<O, T::Alias>,
	/// The width of the produced chunks.
	width: usize,
}

impl<'a, O, T> RChunksExactMut<'a, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	pub(super) fn new(slice: &'a mut BitSlice<O, T>, width: usize) -> Self {
		let (extra, slice) =
			unsafe { slice.split_at_unchecked_mut(slice.len() % width) };
		Self {
			slice,
			extra,
			width,
		}
	}

	/// Returns the remainder of the original [`BitSlice`] that is not going to
	/// be returned by the iterator. The returned `BitSlice` has at most
	/// `chunk_size-1` bits.
	///
	/// # Original
	///
	/// [`slice::RChunksExactMut::into_remainder`][orig]
	///
	/// # API Differences
	///
	/// The remainder slice, as with all slices yielded from this iterator, is
	/// marked as aliased.
	///
	/// [orig]: core::slice::RChunksExactMut::into_remainder
	/// [`BitSlice`]: crate::slice::BitSlice
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn into_remainder(self) -> &'a mut BitSlice<O, T::Alias> {
		self.extra
	}
}

group!(RChunksExactMut => &'a mut BitSlice<O, T::Alias> {
	fn next(&mut self) -> Option<Self::Item> {
		let slice = mem::take(&mut self.slice);
		let len = slice.len();
		if len < self.width {
			return None;
		}
		let (rest, out) =
			unsafe { slice.split_at_unchecked_mut_noalias(len - self.width) };
		self.slice = rest;
		Some(out)
	}

	fn nth(&mut self, n: usize) -> Option<Self::Item> {
		let slice = mem::take(&mut self.slice);
		let len = slice.len();
		let (split, ovf) = n.overflowing_mul(self.width);
		if split >= len || ovf {
			return None;
		}
		let end = len - split;
		let (rest, out) = unsafe {
			slice.get_unchecked_mut(.. end)
				.split_at_unchecked_mut_noalias(end - self.width)
		};
		self.slice = rest;
		Some(out)
	}

	fn next_back(&mut self) -> Option<Self::Item> {
		let slice = mem::take(&mut self.slice);
		if slice.len() < self.width {
			return None;
		}
		let (out, rest) =
			unsafe { slice.split_at_unchecked_mut_noalias(self.width) };
		self.slice = rest;
		Some(out)
	}

	fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
		let slice = mem::take(&mut self.slice);
		let len = slice.len();
		let (start, ovf) = n.overflowing_mul(self.width);
		if start >= len || ovf {
			return None;
		}
		//  At this point, `start` is at least `self.width` less than `len`.
		let (out, rest) = unsafe {
			slice.get_unchecked_mut(start ..)
				.split_at_unchecked_mut_noalias(self.width)
		};
		self.slice = rest;
		Some(out)
	}

	fn len(&self) -> usize {
		self.slice.len() / self.width
	}
});

macro_rules! new_group {
	($($t:ident $($m:ident)? $( . $a:ident ())?),+ $(,)?) => { $(
		impl<'a, O, T> $t <'a, O, T>
		where
			O: BitOrder,
			T: BitStore
		{
			#[inline]
			#[allow(clippy::redundant_field_names)]
			pub(super) fn new(
				slice: &'a $($m)? BitSlice<O, T>,
				width: usize,
			) -> Self {
				Self { slice: slice $( . $a () )?, width }
			}
		}
	)+ };
}

new_group!(
	Windows,
	Chunks,
	ChunksMut mut .alias_mut(),
	RChunks,
	RChunksMut mut .alias_mut(),
);

macro_rules! split {
	($iter:ident => $item:ty $( where $alias:ident )? {
		$next:item
		$next_back:item
	}) => {
		impl<'a, O, T, P> $iter <'a, O, T, P>
		where
			O: BitOrder,
			T: BitStore,
			P: FnMut(usize, &bool) -> bool,
		{
			#[cfg_attr(not(tarpaulin_include), inline(always))]
			pub(super) fn new(slice: $item, pred: P) -> Self {
				Self {
					slice,
					pred,
					done: false,
				}
			}
		}

		impl<O, T, P> Debug for $iter <'_, O, T, P>
		where
			O: BitOrder,
			T: BitStore,
			P: FnMut(usize, &bool) -> bool,
		{
			#[inline]
			fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
				fmt.debug_struct(stringify!($iter))
					.field("slice", &self.slice)
					.field("done", &self.done)
					.finish()
			}
		}

		impl<'a, O, T, P> Iterator for $iter <'a, O, T, P>
		where
			O: BitOrder,
			T: BitStore,
			P: FnMut(usize, &bool) -> bool,
		{
			type Item = $item;

			#[inline]
			$next

			#[inline]
			fn size_hint(&self) -> (usize, Option<usize>) {
				if self.done {
					(0, Some(0))
				}
				else {
					(1, Some(self.slice.len() + 1))
				}
			}
		}

		impl<'a, O, T, P> DoubleEndedIterator for $iter <'a, O, T, P>
		where
			O: BitOrder,
			T: BitStore,
			P: FnMut(usize, &bool) -> bool,
		{
			#[inline]
			$next_back
		}

		impl<'a, O, T, P> core::iter::FusedIterator for $iter <'a, O, T, P>
		where
			O: BitOrder,
			T: BitStore,
			P: FnMut(usize, &bool) -> bool,
		{
		}

		impl<'a, O, T, P> SplitIter for $iter <'a, O, T, P>
		where
			O: BitOrder,
			T: BitStore,
			P: FnMut(usize, &bool) -> bool,
		{
			#[inline]
			fn finish(&mut self) -> Option<Self::Item> {
				if self.done {
					None
				}
				else {
					self.done = true;
					Some(mem::take(&mut self.slice))
				}
			}
		}
	};
}

/** An iterator over subslices separated by bits that match a predicate
function.

This struct is created by the [`.split()`] method on [`BitSlice`]s.

# Original

[`slice::Split`](core::slice::Split)

# API Differences

In order to allow more than one bit of information for the split decision, the
predicate receives the index of each bit, as well as its value.

[`BitSlice`]: crate::slice::BitSlice
[`.split()`]: crate::slice::BitSlice::split
**/
#[derive(Clone)]
pub struct Split<'a, O, T, P>
where
	O: BitOrder,
	T: BitStore,
	P: FnMut(usize, &bool) -> bool,
{
	/// The [`BitSlice`] being split.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	slice: &'a BitSlice<O, T>,
	/// The function used to test whether a split should occur.
	pred: P,
	/// Whether the split is finished.
	done: bool,
}

split!(Split => &'a BitSlice<O, T> {
	fn next(&mut self) -> Option<Self::Item> {
		if self.done {
			return None;
		}
		match self.slice
			.iter()
			.by_ref()
			.enumerate()
			.position(|(idx, bit)| (self.pred)(idx, bit))
		{
			None => self.finish(),
			Some(idx) => unsafe {
				let out = self.slice.get_unchecked(.. idx);
				self.slice = self.slice.get_unchecked(idx + 1 ..);
				Some(out)
			},
		}
	}

	fn next_back(&mut self) -> Option<Self::Item> {
		if self.done {
			return None;
		}
		match self.slice
			.iter()
			.by_ref()
			.enumerate()
			.rposition(|(idx, bit)| (self.pred)(idx, bit))
		{
			None => self.finish(),
			Some(idx) => unsafe {
				let out = self.slice.get_unchecked(idx + 1 ..);
				self.slice = self.slice.get_unchecked(.. idx);
				Some(out)
			},
		}
	}
});

/** An iterator over the mutable subslices which are separated by bits that
match `pred`.

This struct is created by the [`.split_mut()`] method on [`BitSlice`]s.

# Original

[`slice::SplitMut`](core::slice::SplitMut)

# API Differences

In order to allow more than one bit of information for the split decision, the
predicate receives the index of each bit, as well as its value.

[`BitSlice`]: crate::slice::BitSlice
[`.split_mut()`]: crate::slice::BitSlice::split_mut
**/
pub struct SplitMut<'a, O, T, P>
where
	O: BitOrder,
	T: BitStore,
	P: FnMut(usize, &bool) -> bool,
{
	slice: &'a mut BitSlice<O, T::Alias>,
	pred: P,
	done: bool,
}

split!(SplitMut => &'a mut BitSlice<O, T::Alias> {
	fn next(&mut self) -> Option<Self::Item> {
		if self.done {
			return None;
		}
		let idx_opt = {
			let pred = &mut self.pred;
			self.slice
				.iter()
				.by_ref()
				.enumerate()
				.position(|(idx, bit)| (pred)(idx, bit))
		};
		match idx_opt
		{
			None => self.finish(),
			Some(idx) => unsafe {
				let slice = mem::take(&mut self.slice);
				let (out, rest) = slice.split_at_unchecked_mut_noalias(idx);
				self.slice = rest.get_unchecked_mut(1 ..);
				Some(out)
			},
		}
	}

	fn next_back(&mut self) -> Option<Self::Item> {
		if self.done {
			return None;
		}
		let idx_opt = {
			let pred = &mut self.pred;
			self.slice
				.iter()
				.by_ref()
				.enumerate()
				.rposition(|(idx, bit)| (pred)(idx, bit))
		};
		match idx_opt
		{
			None => self.finish(),
			Some(idx) => unsafe {
				let slice = mem::take(&mut self.slice);
				let (rest, out) = slice.split_at_unchecked_mut_noalias(idx);
				self.slice = rest;
				Some(out.get_unchecked_mut(1 ..))
			},
		}
	}
});

/** An iterator over subslices separated by bits that match a predicate
function, starting from the end of the [`BitSlice`].

This struct is created by the [`.rsplit()`] method on [`BitSlice`]s.

# Original

[`slice::RSplit`](core::slice::RSplit)

# API Differences

In order to allow more than one bit of information for the split decision, the
predicate receives the index of each bit, as well as its value.

[`BitSlice`]: crate::slice::BitSlice
[`.rsplit()`]: crate::slice::BitSlice::rsplit
**/
#[derive(Clone)]
pub struct RSplit<'a, O, T, P>
where
	O: BitOrder,
	T: BitStore,
	P: FnMut(usize, &bool) -> bool,
{
	/// The [`BitSlice`] being split.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	slice: &'a BitSlice<O, T>,
	/// The function used to test whether a split should occur.
	pred: P,
	/// Whether the split is finished.
	done: bool,
}

split!(RSplit => &'a BitSlice<O, T> {
	fn next(&mut self) -> Option<Self::Item> {
		let mut split = Split::<'a, O, T, &mut P> {
			slice: mem::take(&mut self.slice),
			pred: &mut self.pred,
			done: self.done,
		};
		let out = split.next_back();
		self.slice = mem::take(&mut split.slice);
		self.done = split.done;
		out
	}

	fn next_back(&mut self) -> Option<Self::Item> {
		let mut split = Split::<'a, O, T, &mut P> {
			slice: mem::take(&mut self.slice),
			pred: &mut self.pred,
			done: self.done,
		};
		let out = split.next();
		self.slice = mem::take(&mut split.slice);
		self.done = split.done;
		out
	}
});

/** An iterator over subslices separated by bits that match a predicate
function, starting from the end of the [`BitSlice`].

This struct is created by the [`.rsplit_mut()`] method on [`BitSlice`]s.

# Original

[`slice::RSplitMut`](core::slice::RSplitMut)

# API Differences

In order to allow more than one bit of information for the split decision, the
predicate receives the index of each bit, as well as its value.

[`BitSlice`]: crate::slice::BitSlice
[`.rsplit_mut()`]: crate::slice::BitSlice::rsplit_mut
**/
pub struct RSplitMut<'a, O, T, P>
where
	O: BitOrder,
	T: BitStore,
	P: FnMut(usize, &bool) -> bool,
{
	/// The [`BitSlice`] being split.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	slice: &'a mut BitSlice<O, T::Alias>,
	/// The function used to test whether a split should occur.
	pred: P,
	/// Whether the split is finished.
	done: bool,
}

split!(RSplitMut => &'a mut BitSlice<O, T::Alias> {
	fn next(&mut self) -> Option<Self::Item> {
		let mut split = SplitMut::<'a, O, T, &mut P> {
			slice: mem::take(&mut self.slice),
			pred: &mut self.pred,
			done: self.done,
		};
		let out = split.next_back();
		self.slice = mem::take(&mut split.slice);
		self.done = split.done;
		out
	}

	fn next_back(&mut self) -> Option<Self::Item> {
		let mut split = SplitMut::<'a, O, T, &mut P> {
			slice: mem::take(&mut self.slice),
			pred: &mut self.pred,
			done: self.done,
		};
		let out = split.next();
		self.slice = mem::take(&mut split.slice);
		self.done = split.done;
		out
	}
});

/// An internal abstraction over the splitting iterators, so that `splitn`,
/// `splitn_mut`, etc, can be implemented once.
#[doc(hidden)]
trait SplitIter: DoubleEndedIterator {
	/// Marks the underlying iterator as complete, extracting the remaining
	/// portion of the slice.
	fn finish(&mut self) -> Option<Self::Item>;
}

/** An iterator over subslices separated by bits that match a predicate
function, limited to a given number of splits.

This struct is created by the [`.splitn()`] method on [`BitSlice`]s.

# Original

[`slice::SplitN`](core::slice::SplitN)

# API Differences

In order to allow more than one bit of information for the split decision, the
predicate receives the index of each bit, as well as its value.

[`BitSlice`]: crate::slice::BitSlice
[`.splitn()`]: crate::slice::BitSlice::splitn
**/
pub struct SplitN<'a, O, T, P>
where
	O: BitOrder,
	T: BitStore,
	P: FnMut(usize, &bool) -> bool,
{
	/// The [`BitSlice`] being split.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	inner: Split<'a, O, T, P>,
	/// The number of splits remaining.
	count: usize,
}

/** An iterator over subslices separated by bits that match a predicate
function, limited to a given number of splits.

This struct is created by the [`splitn_mut`] method on [`BitSlice`]s.

# Original

[`slice::SplitNMut`](core::slice::SplitNMut)

# API Differences

In order to allow more than one bit of information for the split decision, the
predicate receives the index of each bit, as well as its value.

[`BitSlice`]: crate::slice::BitSlice
[`splitn_mut`]: crate::slice::BitSlice::splitn_mut
**/
pub struct SplitNMut<'a, O, T, P>
where
	O: BitOrder,
	T: BitStore,
	P: FnMut(usize, &bool) -> bool,
{
	/// The [`BitSlice`] being split.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	inner: SplitMut<'a, O, T, P>,
	/// The number of splits remaining.
	count: usize,
}

/** An iterator over subslices separated by bits that match a predicate
function, limited to a given number of splits, starting from the end of the
[`BitSlice`].

This struct is created by the [`rsplitn`] method on [`BitSlice`]s.

# Original

[`slice::RSplitN`](core::slice::RSplitN)

# API Differences

In order to allow more than one bit of information for the split decision, the
predicate receives the index of each bit, as well as its value.

[`BitSlice`]: crate::slice::BitSlice
[`rsplitn`]: crate::slice::BitSlice::rsplitn
**/
pub struct RSplitN<'a, O, T, P>
where
	O: BitOrder,
	T: BitStore,
	P: FnMut(usize, &bool) -> bool,
{
	/// The [`BitSlice`] being split.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	inner: RSplit<'a, O, T, P>,
	/// The number of splits remaining.
	count: usize,
}

/** An iterator over subslices separated by bits that match a predicate
function, limited to a given number of splits, starting from the end of the
[`BitSlice`].

This struct is created by the [`rsplitn_mut`] method on [`BitSlice`]s.

# Original

[`slice::RSplitNMut`](core::slice::RSplitNMut)

# API Differences

In order to allow more than one bit of information for the split decision, the
predicate receives the index of each bit, as well as its value.

[`BitSlice`]: crate::slice::BitSlice
[`rsplitn_mut`]: crate::slice::BitSlice::rsplitn_mut
**/
pub struct RSplitNMut<'a, O, T, P>
where
	O: BitOrder,
	T: BitStore,
	P: FnMut(usize, &bool) -> bool,
{
	/// The [`BitSlice`] being split.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	inner: RSplitMut<'a, O, T, P>,
	/// The number of splits remaining.
	count: usize,
}

macro_rules! split_n {
	($outer:ident => $inner:ident => $item:ty $( where $alias:ident )?) => {
		impl<'a, O, T, P> $outer <'a, O, T, P>
		where
			O: BitOrder,
			T: BitStore,
			P: FnMut(usize, &bool) -> bool,
		{
			#[inline]
			pub(super) fn new(
				slice: $item,
				pred: P,
				count: usize,
			) -> Self
			{Self{
				inner: <$inner<'a, O, T, P>>::new(slice, pred),
				count,
			}}
		}

		impl<O, T, P> Debug for $outer <'_, O, T, P>
		where
			O: BitOrder,
			T: BitStore,
			P: FnMut(usize, &bool) -> bool
		{
			#[inline]
			fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
				fmt.debug_struct(stringify!($outer))
					.field("slice", &self.inner.slice)
					.field("count", &self.count)
					.finish()
			}
		}

		impl<'a, O, T, P> Iterator for $outer <'a, O, T, P>
		where
			O: BitOrder,
			T: BitStore,
			P: FnMut(usize, &bool) -> bool,
			$( T::$alias: radium::Radium<<<T as BitStore>::Alias as BitStore>::Mem>, )?
		{
			type Item = <$inner <'a, O, T, P> as Iterator>::Item;

			#[inline]
			fn next(&mut self) -> Option<Self::Item> {
				match self.count {
					0 => None,
					1 => {
						self.count -= 1;
						self.inner.finish()
					},
					_ => {
						self.count -= 1;
						self.inner.next()
					},
				}
			}

			#[inline]
			fn size_hint(&self) -> (usize, Option<usize>) {
				let (low, hi) = self.inner.size_hint();
				(low, hi.map(|h| cmp::min(self.count, h)))
			}
		}

		impl<O, T, P> core::iter::FusedIterator for $outer <'_, O, T, P>
		where
			O: BitOrder,
			T: BitStore,
			P: FnMut(usize, &bool) -> bool,
			$( T::$alias: radium::Radium<<<T as BitStore>::Alias as BitStore>::Mem>, )?
		{
		}
	};
}

split_n!(SplitN => Split => &'a BitSlice<O, T>);
split_n!(SplitNMut => SplitMut => &'a mut BitSlice<O, T::Alias> );
split_n!(RSplitN => RSplit => &'a BitSlice<O, T>);
split_n!(RSplitNMut => RSplitMut => &'a mut BitSlice<O, T::Alias> );

/** Enumerates bits in a [`BitSlice`] that are set to `1`.

This struct is created by the [`.iter_ones()`] method on [`BitSlice`]s.

[`BitSlice`]: crate::slice::BitSlice
[`.iter_ones()`]: crate::slice::BitSlice::iter_ones
**/
#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct IterOnes<'a, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// The remaining slice whose `1` bits are to be found.
	inner: &'a BitSlice<O, T>,
	/// The offset from the front of the original slice to current `inner`.
	front: usize,
}

impl<'a, O, T> IterOnes<'a, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub(super) fn new(slice: &'a BitSlice<O, T>) -> Self {
		Self {
			inner: slice,
			front: 0,
		}
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Default for IterOnes<'_, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn default() -> Self {
		Self {
			inner: Default::default(),
			front: 0,
		}
	}
}

impl<O, T> Iterator for IterOnes<'_, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	type Item = usize;

	#[inline]
	fn next(&mut self) -> Option<Self::Item> {
		let pos = if dvl::match_order::<O, Lsb0>() {
			let slice = unsafe {
				&*(self.inner as *const _ as *const BitSlice<Lsb0, T>)
			};
			slice.sp_iter_ones_first()
		}
		else if dvl::match_order::<O, Msb0>() {
			let slice = unsafe {
				&*(self.inner as *const _ as *const BitSlice<Msb0, T>)
			};
			slice.sp_iter_ones_first()
		}
		else {
			self.inner.iter().by_val().position(|b| b)
		};

		match pos {
			Some(n) => {
				//  Split on the far side of the found index. This is always
				//  safe, as split(len) yields `(self, empty)`.
				let (_, rest) = unsafe { self.inner.split_at_unchecked(n + 1) };
				self.inner = rest;
				let out = self.front + n;
				//  Search resumes from the next index after the found.
				self.front = out + 1;
				Some(out)
			},
			None => {
				*self = Default::default();
				None
			},
		}
	}

	#[cfg_attr(not(tarpaulin_include), inline(always))]
	fn size_hint(&self) -> (usize, Option<usize>) {
		let len = self.len();
		(len, Some(len))
	}

	#[cfg_attr(not(tarpaulin_include), inline(always))]
	fn count(self) -> usize {
		self.len()
	}

	#[cfg_attr(not(tarpaulin_include), inline(always))]
	fn last(mut self) -> Option<Self::Item> {
		self.next_back()
	}
}

impl<O, T> DoubleEndedIterator for IterOnes<'_, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	fn next_back(&mut self) -> Option<Self::Item> {
		let pos = if dvl::match_order::<O, Lsb0>() {
			let slice = unsafe {
				&*(self.inner as *const _ as *const BitSlice<Lsb0, T>)
			};
			slice.sp_iter_ones_last()
		}
		else if dvl::match_order::<O, Msb0>() {
			let slice = unsafe {
				&*(self.inner as *const _ as *const BitSlice<Msb0, T>)
			};
			slice.sp_iter_ones_last()
		}
		else {
			self.inner.iter().by_val().rposition(|b| b)
		};

		match pos {
			Some(n) => {
				let (rest, _) = unsafe { self.inner.split_at_unchecked(n) };
				self.inner = rest;
				Some(self.front + n)
			},
			None => {
				*self = Default::default();
				None
			},
		}
	}
}

impl<O, T> ExactSizeIterator for IterOnes<'_, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn len(&self) -> usize {
		self.inner.count_ones()
	}
}

impl<O, T> FusedIterator for IterOnes<'_, O, T>
where
	O: BitOrder,
	T: BitStore,
{
}

/** Enumerates bits in a [`BitSlice`] that are cleared to `0`.

This struct is created by the [`.iter_zeros()`] method on [`BitSlice`]s.

[`BitSlice`]: crate::slice::BitSlice
[`.iter_zeros()`]: crate::slice::BitSlice::iter_zeros
**/
#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct IterZeros<'a, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// The remaining slice whose `0` bits are to be found.
	inner: &'a BitSlice<O, T>,
	/// The offset from the front of the original slice to current `inner`.
	front: usize,
}

impl<'a, O, T> IterZeros<'a, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub(super) fn new(slice: &'a BitSlice<O, T>) -> Self {
		Self {
			inner: slice,
			front: 0,
		}
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Default for IterZeros<'_, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn default() -> Self {
		Self {
			inner: Default::default(),
			front: 0,
		}
	}
}

impl<O, T> Iterator for IterZeros<'_, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	type Item = usize;

	fn next(&mut self) -> Option<Self::Item> {
		let pos = if dvl::match_order::<O, Lsb0>() {
			let slice = unsafe {
				&*(self.inner as *const _ as *const BitSlice<Lsb0, T>)
			};
			slice.sp_iter_zeros_first()
		}
		else if dvl::match_order::<O, Msb0>() {
			let slice = unsafe {
				&*(self.inner as *const _ as *const BitSlice<Msb0, T>)
			};
			slice.sp_iter_zeros_first()
		}
		else {
			self.inner.iter().by_val().position(|b| !b)
		};

		match pos {
			Some(n) => {
				let (_, rest) = unsafe { self.inner.split_at_unchecked(n + 1) };
				self.inner = rest;
				let out = self.front + n;
				self.front = out + 1;
				Some(out)
			},
			None => {
				*self = Default::default();
				None
			},
		}
	}

	#[cfg_attr(not(tarpaulin_include), inline(always))]
	fn size_hint(&self) -> (usize, Option<usize>) {
		let len = self.len();
		(len, Some(len))
	}

	#[cfg_attr(not(tarpaulin_include), inline(always))]
	fn count(self) -> usize {
		self.len()
	}

	#[cfg_attr(not(tarpaulin_include), inline(always))]
	fn last(mut self) -> Option<Self::Item> {
		self.next_back()
	}
}

impl<O, T> DoubleEndedIterator for IterZeros<'_, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	fn next_back(&mut self) -> Option<Self::Item> {
		let pos = if dvl::match_order::<O, Lsb0>() {
			let slice = unsafe {
				&*(self.inner as *const _ as *const BitSlice<Lsb0, T>)
			};
			slice.sp_iter_zeros_last()
		}
		else if dvl::match_order::<O, Msb0>() {
			let slice = unsafe {
				&*(self.inner as *const _ as *const BitSlice<Msb0, T>)
			};
			slice.sp_iter_zeros_last()
		}
		else {
			self.inner.iter().by_val().rposition(|b| !b)
		};

		match pos {
			Some(n) => {
				let (rest, _) = unsafe { self.inner.split_at_unchecked(n) };
				self.inner = rest;
				Some(self.front + n)
			},
			None => {
				*self = Default::default();
				None
			},
		}
	}
}

impl<O, T> ExactSizeIterator for IterZeros<'_, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn len(&self) -> usize {
		self.inner.count_zeros()
	}
}

impl<O, T> FusedIterator for IterZeros<'_, O, T>
where
	O: BitOrder,
	T: BitStore,
{
}

/* This macro has some very obnoxious call syntax that is necessary to handle
the different iteration protocols used above.

The `Split` iterators are not `DoubleEndedIterator` or `ExactSizeIterator`, and
must be excluded from those implementations. However, bounding on `DEI` causes
`.next_back()` and `.nth_back()` to return opaque associated types, rather than
the return type from the directly-resolved signatures. As such, the item type of
the source iterator must also be provided so that methods on it can be named.
*/
macro_rules! noalias {
	( $(
		$from:ident $( ( $p:ident ) )?
		=> $alias:ty
		=> $to:ident
		=> $item:ty
		=> $map:path
		;
	)+ ) => { $(
		/// An iterator variant that does not apply a [`T::Alias`] marker to its
		/// yielded items.
		///
		/// This iterator can be safely used in `for … in` loop headers, but
		/// cannot be used anywhere that its surrounding code may pull multiple
		/// yielded items into the same scope. This includes any iterator
		/// adapters that pull multiple yielded items into the same collection!
		/// Each yielded item **must** not have any sibling items in its scope.
		///
		/// This iterator does not yield [`T::Mem`] raw-typed references, as it
		/// may be produced from an already-aliased iterator and must retain its
		/// initial aliasing properties. It merely asserts that it will not be
		/// used in contexts that produce multiple yielded items in the same
		/// scope.
		///
		/// [`T::Alias`]: crate::store::BitStore::Alias
		/// [`T::Mem`]: crate::store::BitStore::Mem
		pub struct $to <'a, O, T $( , $p )? >
		where
			O: BitOrder,
			T: BitStore,
			$( $p : FnMut(usize, &bool) -> bool, )?
		{
			/// The actual iterator that this modifies.
			inner: $from <'a, O, T $( , $p )? >,
		}

		impl<'a, O, T $( , $p )? > $from <'a, O, T $( , $p )? >
		where
			O: BitOrder,
			T: BitStore,
			$( $p : FnMut(usize, &bool) -> bool, )?
		{
			/// Adapts the iterator to no longer mark its yielded items as
			/// aliased.
			///
			/// # Safety
			///
			/// This adapter can only be used in contexts where only one yielded
			/// item will be alive at any time. This is most commonly true in
			/// `for … in` loops, so long as no subsequent adapter collects
			/// multiple yielded items into a collection where they are live
			/// simultaneously.
			///
			/// The items yielded by this iterator will not have an additional
			/// alias marker applied to them, so their use in an iteration
			/// sequence will not be penalized when the surrounding code
			/// guarantees that each item yielded by the iterator is destroyed
			/// before the next is produced.
			///
			/// This adapter does **not** convert the iterator to use [`T::Mem`]
			/// raw types, as it can be applied to an iterator over an
			/// already-aliased slice and must preserve its condition. Its only
			/// effect is to prevent the addition of a new [`T::Alias`] marker.
			///
			/// [`T::Alias`]: crate::store::BitStore::Alias
			/// [`T::Mem`]: crate::store::BitStore::Mem
			#[inline(always)]
			pub unsafe fn remove_alias(self) -> $to <'a, O, T $( , $p )? > {
				$to ::new(self)
			}
		}

		impl<'a, O, T $( , $p )? > $to <'a, O, T $( , $p )? >
		where
			O: BitOrder,
			T: BitStore,
			$( $p : FnMut(usize, &bool) -> bool, )?
		{
			#[inline(always)]
			fn new(inner: $from<'a, O, T $( , $p )? >) -> Self {
				Self { inner }
			}
		}

		impl<'a, O, T $( , $p )? > Iterator for $to <'a, O, T $( , $p )? >
		where
			O: BitOrder,
			T: BitStore,
			$( $p : FnMut(usize, &bool) -> bool, )?
		{
			type Item = $item;

			#[inline]
			fn next(&mut self) -> Option<Self::Item> {
				self.inner.next().map(|item| unsafe { $map(item) })
			}

			#[cfg_attr(not(tarpaulin_include), inline(always))]
			fn size_hint(&self) -> (usize, Option<usize>) {
				self.inner.size_hint()
			}

			#[cfg_attr(not(tarpaulin_include), inline(always))]
			fn count(self) -> usize {
				self.inner.count()
			}

			#[inline]
			fn nth(&mut self, n: usize) -> Option<Self::Item> {
				self.inner.nth(n).map(|item| unsafe { $map(item) })
			}

			#[inline]
			fn last(self) -> Option<Self::Item> {
				self.inner.last().map(|item| unsafe { $map(item) })
			}
		}

		impl<'a, O, T $( , $p )? > DoubleEndedIterator for $to <'a, O, T $( , $p )? >
		where
			O: BitOrder,
			T: BitStore,
			$from <'a, O, T $( , $p )? >: DoubleEndedIterator<Item = $alias >,
			$( $p : FnMut(usize, &bool) -> bool, )?
		{
			#[inline]
			fn next_back(&mut self) -> Option<Self::Item> {
				self.inner
					.next_back()
					.map(|item| unsafe { $map(item) })
			}

			#[inline]
			fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
				self.inner
					.nth_back(n)
					.map(|item| unsafe { $map(item) })
			}
		}

		impl<'a, O, T $( , $p )? > ExactSizeIterator for $to <'a, O, T $( , $p )? >
		where
			O: BitOrder,
			T: BitStore,
			$from <'a, O, T $( , $p )? >: ExactSizeIterator,
			$( $p : FnMut(usize, &bool) -> bool, )?
		{
			#[cfg_attr(not(tarpaulin_include), inline(always))]
			fn len(&self) -> usize {
				self.inner.len()
			}
		}

		impl<O, T $( , $p )? > FusedIterator for $to <'_, O, T $( , $p )? >
		where
			O: BitOrder,
			T: BitStore,
			$( $p : FnMut(usize, &bool) -> bool, )?
		{
		}

		unsafe impl<O, T $( , $p )? > Send for $to <'_, O, T $( , $p )? >
		where
			O: BitOrder,
			T: BitStore,
			$( $p : FnMut(usize, &bool) -> bool, )?
		{
		}

		unsafe impl<O, T $( , $p )? > Sync for $to <'_, O, T $( , $p )? >
		where
			O: BitOrder,
			T: BitStore,
			$( $p : FnMut(usize, &bool) -> bool, )?
		{
		}
	)+ };
}

noalias! {
	IterMut => <usize as BitSliceIndex<'a, O, T::Alias>>::Mut
	=> IterMutNoAlias => <usize as BitSliceIndex<'a, O, T>>::Mut
	=> BitRef::remove_alias;

	ChunksMut => &'a mut BitSlice<O, T::Alias>
	=> ChunksMutNoAlias => &'a mut BitSlice<O, T>
	=> BitSlice::unalias_mut;

	ChunksExactMut => &'a mut BitSlice<O, T::Alias>
	=> ChunksExactMutNoAlias => &'a mut BitSlice<O, T>
	=> BitSlice::unalias_mut;

	RChunksMut => &'a mut BitSlice<O, T::Alias>
	=> RChunksMutNoAlias => &'a mut BitSlice<O, T>
	=> BitSlice::unalias_mut;

	RChunksExactMut => &'a mut BitSlice<O, T::Alias>
	=> RChunksExactMutNoAlias => &'a mut BitSlice<O, T>
	=> BitSlice::unalias_mut;

	SplitMut (P) => &'a mut BitSlice<O, T::Alias>
	=> SplitMutNoAlias => &'a mut BitSlice<O, T>
	=> BitSlice::unalias_mut;

	RSplitMut (P) => &'a mut BitSlice<O, T::Alias>
	=> RSplitMutNoAlias => &'a mut BitSlice<O, T>
	=> BitSlice::unalias_mut;

	SplitNMut (P) => &'a mut BitSlice<O, T::Alias>
	=> SplitNMutNoAlias => &'a mut BitSlice<O, T>
	=> BitSlice::unalias_mut;

	RSplitNMut (P) => &'a mut BitSlice<O, T::Alias>
	=> RSplitNMutNoAlias => &'a mut BitSlice<O, T>
	=> BitSlice::unalias_mut;
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/slice/iter.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/slice/ops.rs =====
//! Port of the `[T]` operator implementations.

use core::ops::{
	BitAndAssign,
	BitOrAssign,
	BitXorAssign,
	Index,
	IndexMut,
	Not,
	Range,
	RangeFrom,
	RangeFull,
	RangeInclusive,
	RangeTo,
	RangeToInclusive,
};

use super::{
	BitSlice,
	BitSliceIndex,
};
use crate::{
	access::BitAccess,
	domain::DomainMut,
	order::BitOrder,
	store::BitStore,
};

impl<O, T, Rhs> BitAndAssign<Rhs> for BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
	Rhs: IntoIterator<Item = bool>,
{
	#[inline]
	fn bitand_assign(&mut self, rhs: Rhs) {
		let mut iter = rhs.into_iter();
		self.for_each(|_, bit| bit & iter.next().unwrap_or(false));
	}
}

impl<O, T, Rhs> BitOrAssign<Rhs> for BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
	Rhs: IntoIterator<Item = bool>,
{
	#[inline]
	fn bitor_assign(&mut self, rhs: Rhs) {
		let mut iter = rhs.into_iter();
		self.for_each(|_, bit| bit | iter.next().unwrap_or(false));
	}
}

impl<O, T, Rhs> BitXorAssign<Rhs> for BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
	Rhs: IntoIterator<Item = bool>,
{
	#[inline]
	fn bitxor_assign(&mut self, rhs: Rhs) {
		let mut iter = rhs.into_iter();
		self.for_each(|_, bit| bit ^ iter.next().unwrap_or(false));
	}
}

impl<O, T> Index<usize> for BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	type Output = bool;

	/// Looks up a single bit by semantic index.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bits = bits![Msb0, u8; 0, 1, 0];
	/// assert!(!bits[0]); // -----^  |  |
	/// assert!( bits[1]); // --------^  |
	/// assert!(!bits[2]); // -----------^
	/// ```
	///
	/// If the index is greater than or equal to the length, indexing will
	/// panic.
	///
	/// The below test will panic when accessing index 1, as only index 0 is
	/// valid.
	///
	/// ```rust,should_panic
	/// use bitvec::prelude::*;
	///
	/// let bits = bits![0,  ];
	/// bits[1]; // --------^
	/// ```
	#[inline]
	fn index(&self, index: usize) -> &Self::Output {
		//  Convert the `BitRef` to `&'static bool`
		match *index.index(self) {
			true => &true,
			false => &false,
		}
	}
}

/// Generate `Index`/`Mut` implementations for subslicing.
macro_rules! index {
	($($t:ty),+ $(,)?) => { $(
		impl<O, T> Index<$t> for BitSlice<O, T>
		where
			O: BitOrder,
			T: BitStore,
		{
			type Output = Self;

			#[inline(always)]
			#[cfg(not(tarpaulin_include))]
			fn index(&self, index: $t) -> &Self::Output {
				index.index(self)
			}
		}

		impl<O, T> IndexMut<$t> for BitSlice<O, T>
		where
			O: BitOrder,
			T: BitStore,
		{
			#[inline(always)]
			#[cfg(not(tarpaulin_include))]
			fn index_mut(&mut self, index: $t) -> &mut Self::Output {
				index.index_mut(self)
			}
		}
	)+ };
}

//  Implement `Index`/`Mut` subslicing with all the ranges.
index!(
	Range<usize>,
	RangeFrom<usize>,
	RangeFull,
	RangeInclusive<usize>,
	RangeTo<usize>,
	RangeToInclusive<usize>,
);

impl<'a, O, T> Not for &'a mut BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	type Output = Self;

	fn not(self) -> Self::Output {
		match self.domain_mut() {
			DomainMut::Enclave { head, elem, tail } => {
				elem.invert_bits(O::mask(head, tail));
			},
			DomainMut::Region { head, body, tail } => {
				if let Some((head, elem)) = head {
					elem.invert_bits(O::mask(head, None));
				}
				for elem in body {
					elem.store_value(!elem.load_value());
				}
				if let Some((elem, tail)) = tail {
					elem.invert_bits(O::mask(None, tail));
				}
			},
		}
		self
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/slice/ops.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/slice/specialization.rs =====
/*! Specialization overrides.

This module contains override functions used when generic bit-by-bit iteration
can be accelerated for specific type parameters.

Call sites that wish to take advantage of specialization methods must first
inspect their type arguments to determine if specialization is even possible,
and transmute generic slices into slices with concrete type arguments applied.
!*/

use core::ops::RangeBounds;

use funty::{
	IsInteger,
	IsNumber,
};

use super::BitSlice;
use crate::{
	devel as dvl,
	domain::Domain,
	field::BitField,
	order::{
		BitOrder,
		Lsb0,
		Msb0,
	},
	store::BitStore,
};

/** Order-specialized function implementations.

These functions use [`BitField`] to provide batched load/store behavior.
Where loads or stores cross a `T` element boundary, they use the `_le`
behavior to ensure that bits stay in the correct order relative to each
other, even as they may change position within an element.

[`BitField`]: crate::field::BitField
**/
impl<T> BitSlice<Lsb0, T>
where T: BitStore
{
	/// Accelerates copies between disjoint slices with batch loads.
	#[inline]
	pub(crate) fn sp_copy_from_bitslice(&mut self, src: &Self) {
		assert_eq!(
			self.len(),
			src.len(),
			"Copying between slices requires equal lengths"
		);

		let chunk_size = <usize as IsNumber>::BITS as usize;
		for (to, from) in unsafe { self.chunks_mut(chunk_size).remove_alias() }
			.zip(src.chunks(chunk_size))
		{
			to.store_le::<usize>(from.load_le::<usize>())
		}
	}

	/// Accelerates possibly-overlapping copies within a single slice with batch
	/// loads.
	#[inline]
	pub(crate) unsafe fn sp_copy_within_unchecked<R>(
		&mut self,
		src: R,
		dest: usize,
	) where
		R: RangeBounds<usize>,
	{
		let source = dvl::normalize_range(src, self.len());
		let rev = source.contains(&dest);
		let dest = dest .. dest + source.len();

		/* The `&mut self` receiver ensures that this method has an exclusive
		access to the bits of its region prior to entry. In order to satisfy
		element-based aliasing rules, the correct but pessimal behavior is to
		mark the entirety of the source and destination subregions *may*
		overlap, either in the actual bits they affect **or** merely in the
		elements that contain them. As this is an `_unchecked` method, it is
		preferable to unconditionally taint the regions rather than compute
		whether the taint is necessary. For performance, the fact that this
		method has exclusive access to its bits (and will be already-tainted if
		external aliases exist) should suffice to ensure that issuing lock
		instructions will not in fact result in bus delays while the processor
		clears the bus.

		The actual alias tainting can be deferred to the loop header, since
		construction of aliased *pointers* is fine, and the reference tainting
		precludes the simultaneous liveness of untainted im/mut references.
		*/
		let from: *const Self = self.get_unchecked(source) as *const _;
		//  This can stay unaliased for now, because `.{,r}chunks_mut()` taints.
		let to: *mut Self = self.get_unchecked_mut(dest) as *mut _;
		let chunk_size = <usize as IsNumber>::BITS as usize;
		if rev {
			for (src, dst) in (&*from)
				.alias()
				.rchunks(chunk_size)
				.zip((&mut *to).rchunks_mut(chunk_size))
			{
				dst.store_le::<usize>(src.load_le::<usize>());
			}
		}
		else {
			for (src, dst) in (&*from)
				.alias()
				.chunks(chunk_size)
				.zip((&mut *to).chunks_mut(chunk_size))
			{
				dst.store_le::<usize>(src.load_le::<usize>());
			}
		}
	}

	/// Accelerates equality checking with batch loads.
	#[inline]
	pub(crate) fn sp_eq(&self, other: &Self) -> bool {
		if self.len() != other.len() {
			return false;
		}
		let chunk_size = <usize as IsNumber>::BITS as usize;
		self.chunks(chunk_size)
			.zip(other.chunks(chunk_size))
			.all(|(a, b)| a.load_le::<usize>() == b.load_le::<usize>())
	}

	/// Seeks the index of the first `1` bit in the bit-slice.
	#[inline]
	pub(crate) fn sp_iter_ones_first(&self) -> Option<usize> {
		let mut accum = 0;

		match self.domain() {
			Domain::Enclave { head, elem, tail } => {
				let val =
					(Lsb0::mask(head, tail) & elem.load_value()).into_inner();
				if val != T::Mem::ZERO {
					accum += val.trailing_zeros() as usize
						- head.into_inner() as usize;
					return Some(accum);
				}
				None
			},
			Domain::Region { head, body, tail } => {
				if let Some((head, elem)) = head {
					let val = (Lsb0::mask(head, None) & elem.load_value())
						.into_inner();
					accum += val.trailing_zeros() as usize
						- head.into_inner() as usize;
					if val != T::Mem::ZERO {
						return Some(accum);
					}
				}

				for elem in body {
					let val = elem.load_value();
					accum += val.trailing_zeros() as usize;
					if val != T::Mem::ZERO {
						return Some(accum);
					}
				}

				if let Some((elem, tail)) = tail {
					let val = (Lsb0::mask(None, tail) & elem.load_value())
						.into_inner();
					if val != T::Mem::ZERO {
						accum += val.trailing_zeros() as usize;
						return Some(accum);
					}
				}

				None
			},
		}
	}

	/// Seeks the index of the last `1` bit in the bit-slice.
	#[inline]
	pub(crate) fn sp_iter_ones_last(&self) -> Option<usize> {
		let mut out = match self.len() {
			0 => return None,
			n => n - 1,
		};
		match self.domain() {
			Domain::Enclave { head, elem, tail } => {
				let val =
					(Lsb0::mask(head, tail) & elem.load_value()).into_inner();
				let dead_bits = T::Mem::BITS as u8 - tail.into_inner();
				if val != T::Mem::ZERO {
					out -= val.leading_zeros() as usize - dead_bits as usize;
					return Some(out);
				}
				None
			},
			Domain::Region { head, body, tail } => {
				if let Some((elem, tail)) = tail {
					let val = (Lsb0::mask(None, tail) & elem.load_value())
						.into_inner();
					let dead_bits =
						T::Mem::BITS as usize - tail.into_inner() as usize;
					out -= val.leading_zeros() as usize - dead_bits;
					if val != T::Mem::ZERO {
						return Some(out);
					}
				}

				for elem in body.iter().rev() {
					let val = elem.load_value();
					out -= val.leading_zeros() as usize;
					if val != T::Mem::ZERO {
						return Some(out);
					}
				}

				if let Some((head, elem)) = head {
					let val = (Lsb0::mask(head, None) & elem.load_value())
						.into_inner();
					if val != T::Mem::ZERO {
						out -= val.leading_zeros() as usize;
						return Some(out);
					}
				}

				None
			},
		}
	}

	/// Seeks the index of the first `0` bit in the bit-slice.
	#[inline]
	pub(crate) fn sp_iter_zeros_first(&self) -> Option<usize> {
		let mut accum = 0;

		match self.domain() {
			Domain::Enclave { head, elem, tail } => {
				//  Load, invert, then mask and search for `1`.
				let val =
					(Lsb0::mask(head, tail) & !elem.load_value()).into_inner();
				accum +=
					val.trailing_zeros() as usize - head.into_inner() as usize;
				if val != T::Mem::ZERO {
					return Some(accum);
				}
				None
			},
			Domain::Region { head, body, tail } => {
				if let Some((head, elem)) = head {
					let val = (Lsb0::mask(head, None) & !elem.load_value())
						.into_inner();
					accum += val.trailing_zeros() as usize
						- head.into_inner() as usize;
					if val != T::Mem::ZERO {
						return Some(accum);
					}
				}

				for elem in body {
					let val = !elem.load_value();
					accum += val.trailing_zeros() as usize;
					if val != T::Mem::ZERO {
						return Some(accum);
					}
				}

				if let Some((elem, tail)) = tail {
					let val = (Lsb0::mask(None, tail) & !elem.load_value())
						.into_inner();
					accum += val.trailing_zeros() as usize;
					if val != T::Mem::ZERO {
						return Some(accum);
					}
				}

				None
			},
		}
	}

	/// Seeks the index of the last `0` bit in the bit-slice.
	#[inline]
	pub(crate) fn sp_iter_zeros_last(&self) -> Option<usize> {
		let mut out = match self.len() {
			0 => return None,
			n => n - 1,
		};
		match self.domain() {
			Domain::Enclave { head, elem, tail } => {
				let val =
					(Lsb0::mask(head, tail) & !elem.load_value()).into_inner();
				let dead_bits = T::Mem::BITS as u8 - tail.into_inner();
				if val != T::Mem::ZERO {
					out -= val.leading_zeros() as usize - dead_bits as usize;
					return Some(out);
				}
				None
			},
			Domain::Region { head, body, tail } => {
				if let Some((elem, tail)) = tail {
					let val = (Lsb0::mask(None, tail) & !elem.load_value())
						.into_inner();
					let dead_bits =
						T::Mem::BITS as usize - tail.into_inner() as usize;
					out -= val.leading_zeros() as usize - dead_bits;
					if val != T::Mem::ZERO {
						return Some(out);
					}
				}

				for elem in body.iter().rev() {
					let val = !elem.load_value();
					out -= val.leading_zeros() as usize;
					if val != T::Mem::ZERO {
						return Some(out);
					}
				}

				if let Some((head, elem)) = head {
					let val = (Lsb0::mask(head, None) & !elem.load_value())
						.into_inner();
					if val != T::Mem::ZERO {
						out -= val.leading_zeros() as usize;
						return Some(out);
					}
				}

				None
			},
		}
	}
}

/** Order-specialized function implementations.

These functions use [`BitField`] to provide batched load/store behavior.
Where loads or stores cross a `T` element boundary, they use the `_be`
behavior to ensure that bits stay in the correct order relative to each
other, even as they may change position within an element.

[`BitField`]: crate::field::BitField
**/
impl<T> BitSlice<Msb0, T>
where T: BitStore
{
	/// Accelerates copies between disjoint slices with batch loads.
	#[inline]
	pub(crate) fn sp_copy_from_bitslice(&mut self, src: &Self) {
		assert_eq!(
			self.len(),
			src.len(),
			"Copying between slices requires equal lengths"
		);

		let chunk_size = <usize as IsNumber>::BITS as usize;
		for (to, from) in unsafe { self.chunks_mut(chunk_size).remove_alias() }
			.zip(src.chunks(chunk_size))
		{
			to.store_be::<usize>(from.load_be::<usize>())
		}
	}

	/// Accelerates possibly-overlapping copies within a single slice with batch
	/// loads.
	#[inline]
	pub(crate) unsafe fn sp_copy_within_unchecked<R>(
		&mut self,
		src: R,
		dest: usize,
	) where
		R: RangeBounds<usize>,
	{
		let source = dvl::normalize_range(src, self.len());
		let rev = source.contains(&dest);
		let dest = dest .. dest + source.len();

		let from: *const Self = self.get_unchecked(source) as *const _;
		let to: *mut Self = self.get_unchecked_mut(dest) as *mut _;
		let chunk_size = <usize as IsNumber>::BITS as usize;
		if rev {
			for (src, dst) in (&*from)
				.alias()
				.rchunks(chunk_size)
				.zip((&mut *to).rchunks_mut(chunk_size))
			{
				dst.store_be::<usize>(src.load_be::<usize>());
			}
		}
		else {
			for (src, dst) in (&*from)
				.alias()
				.chunks(chunk_size)
				.zip((&mut *to).chunks_mut(chunk_size))
			{
				dst.store_be::<usize>(src.load_be::<usize>());
			}
		}
	}

	/// Accelerates equality checking with batch loads.
	#[inline]
	pub(crate) fn sp_eq(&self, other: &Self) -> bool {
		if self.len() != other.len() {
			return false;
		}
		let chunk_size = <usize as IsNumber>::BITS as usize;
		self.chunks(chunk_size)
			.zip(other.chunks(chunk_size))
			.all(|(a, b)| a.load_be::<usize>() == b.load_be::<usize>())
	}

	/// Seeks the index of the first `1` bit in the bit-slice.
	#[inline]
	pub(crate) fn sp_iter_ones_first(&self) -> Option<usize> {
		let mut accum = 0;

		match self.domain() {
			Domain::Enclave { head, elem, tail } => {
				let val =
					(Msb0::mask(head, tail) & elem.load_value()).into_inner();
				accum +=
					val.leading_zeros() as usize - head.into_inner() as usize;
				if val != T::Mem::ZERO {
					return Some(accum);
				}
				None
			},
			Domain::Region { head, body, tail } => {
				if let Some((head, elem)) = head {
					let val = (Msb0::mask(head, None) & elem.load_value())
						.into_inner();
					accum += val.leading_zeros() as usize
						- head.into_inner() as usize;
					if val != T::Mem::ZERO {
						return Some(accum);
					}
				}

				for elem in body {
					let val = elem.load_value();
					accum += val.leading_zeros() as usize;
					if val != T::Mem::ZERO {
						return Some(accum);
					}
				}

				if let Some((elem, tail)) = tail {
					let val = (Msb0::mask(None, tail) & elem.load_value())
						.into_inner();
					accum += val.leading_zeros() as usize;
					if val != T::Mem::ZERO {
						return Some(accum);
					}
				}

				None
			},
		}
	}

	/// Seeks the index of the last `1` bit in the bit-slice.
	#[inline]
	pub(crate) fn sp_iter_ones_last(&self) -> Option<usize> {
		//  Set the state tracker to the last live index in the bit-slice.
		let mut out = match self.len() {
			0 => return None,
			n => n - 1,
		};
		match self.domain() {
			Domain::Enclave { head, elem, tail } => {
				let val =
					(Msb0::mask(head, tail) & elem.load_value()).into_inner();
				let dead_bits = T::Mem::BITS as u8 - tail.into_inner();
				if val != T::Mem::ZERO {
					out -= val.trailing_zeros() as usize - dead_bits as usize;
					return Some(out);
				}
				None
			},
			Domain::Region { head, body, tail } => {
				if let Some((elem, tail)) = tail {
					let val = (Msb0::mask(None, tail) & elem.load_value())
						.into_inner();
					let dead_bits =
						T::Mem::BITS as usize - tail.into_inner() as usize;
					out -= val.trailing_zeros() as usize - dead_bits;
					if val != T::Mem::ZERO {
						return Some(out);
					}
				}

				for elem in body.iter().rev() {
					let val = elem.load_value();
					out -= val.trailing_zeros() as usize;
					if val != T::Mem::ZERO {
						return Some(out);
					}
				}

				if let Some((head, elem)) = head {
					let val = (Msb0::mask(head, None) & elem.load_value())
						.into_inner();
					if val != T::Mem::ZERO {
						out -= val.trailing_zeros() as usize;
						return Some(out);
					}
				}

				None
			},
		}
	}

	/// Seeks the index of the first `0` bit in the bit-slice.
	#[inline]
	pub(crate) fn sp_iter_zeros_first(&self) -> Option<usize> {
		let mut accum = 0;

		match self.domain() {
			Domain::Enclave { head, elem, tail } => {
				let val =
					(Msb0::mask(head, tail) & !elem.load_value()).into_inner();
				accum +=
					val.leading_zeros() as usize - head.into_inner() as usize;
				if val != T::Mem::ZERO {
					return Some(accum);
				}
				None
			},
			Domain::Region { head, body, tail } => {
				if let Some((head, elem)) = head {
					let val = (Msb0::mask(head, None) & !elem.load_value())
						.into_inner();
					accum += val.leading_zeros() as usize
						- head.into_inner() as usize;
					if val != T::Mem::ZERO {
						return Some(accum);
					}
				}

				for elem in body {
					let val = !elem.load_value();
					accum += val.leading_zeros() as usize;
					if val != T::Mem::ZERO {
						return Some(accum);
					}
				}

				if let Some((elem, tail)) = tail {
					let val = (Msb0::mask(None, tail) & !elem.load_value())
						.into_inner();
					accum += val.leading_zeros() as usize;
					if val != T::Mem::ZERO {
						return Some(accum);
					}
				}

				None
			},
		}
	}

	/// Seeks the index of the last `0` bit in the bit-slice.
	#[inline]
	pub(crate) fn sp_iter_zeros_last(&self) -> Option<usize> {
		let mut out = match self.len() {
			0 => return None,
			n => n - 1,
		};
		match self.domain() {
			Domain::Enclave { head, elem, tail } => {
				let val =
					(Msb0::mask(head, tail) & !elem.load_value()).into_inner();
				let dead_bits = T::Mem::BITS as u8 - tail.into_inner();
				if val != T::Mem::ZERO {
					out -= val.trailing_zeros() as usize - dead_bits as usize;
					return Some(out);
				}
				None
			},
			Domain::Region { head, body, tail } => {
				if let Some((elem, tail)) = tail {
					let val = (Msb0::mask(None, tail) & !elem.load_value())
						.into_inner();
					let dead_bits =
						T::Mem::BITS as usize - tail.into_inner() as usize;
					out -= val.trailing_zeros() as usize - dead_bits;
					if val != T::Mem::ZERO {
						return Some(out);
					}
				}

				for elem in body.iter().rev() {
					let val = !elem.load_value();
					out -= val.trailing_zeros() as usize;
					if val != T::Mem::ZERO {
						return Some(out);
					}
				}

				if let Some((head, elem)) = head {
					let val = (Msb0::mask(head, None) & !elem.load_value())
						.into_inner();
					if val != T::Mem::ZERO {
						out -= val.trailing_zeros() as usize;
						return Some(out);
					}
				}

				None
			},
		}
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/slice/specialization.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/slice/tests.rs =====
//! Unit tests for the `slice` module.

#![cfg(test)]

use tap::conv::TryConv;

use crate::prelude::*;

#[test]
fn construction() {
	#[cfg(not(miri))]
	use core::slice;

	let data = 0u8;
	let bits = data.view_bits::<LocalBits>();
	assert_eq!(bits.len(), 8);

	#[cfg(not(miri))]
	assert!(
		BitSlice::<LocalBits, u8>::from_slice(unsafe {
			slice::from_raw_parts(
				1usize as *const _,
				BitSlice::<LocalBits, u8>::MAX_ELTS,
			)
		})
		.is_err()
	);

	#[cfg(not(miri))]
	assert!(
		BitSlice::<LocalBits, u8>::from_slice_mut(unsafe {
			slice::from_raw_parts_mut(
				1usize as *mut _,
				BitSlice::<LocalBits, u8>::MAX_ELTS,
			)
		})
		.is_err()
	);

	let mut data = [0u16; 2];
	assert!((&data[..]).try_conv::<&BitSlice<Msb0, _>>().is_ok());
	assert!((&mut data[..]).try_conv::<&mut BitSlice<Msb0, _>>().is_ok());
}

#[test]
fn cmp() {
	let data = 0x45u8;
	let bits = data.view_bits::<Msb0>();
	let a = &bits[.. 3]; // 010
	let b = &bits[.. 4]; // 0100
	let c = &bits[.. 5]; // 01000
	let d = &bits[4 ..]; // 0101

	assert!(a < b); // by length
	assert!(b < c); // by length
	assert!(c < d); // by different bit

	let bits = bits![Msb0, u8;
		1, 0, 1, 1, 0, 0,
		1, 0, 1, 1, 0, 0,
	];
	let (l, r) = bits.split_at(6);
	assert_eq!(l, r, "{:b} {:b}", l.load::<u8>(), r.load::<u8>());
	let bits = bits![Lsb0, u8;
		1, 1, 0, 0, 1, 0,
		1, 1, 0, 0, 1, 0,
	];
	let (l, r) = bits.split_at(6);
	assert_eq!(l, r);
}

#[test]
fn get_set() {
	let bits = bits![mut LocalBits, u8; 0; 8];

	for n in 0 .. 8 {
		assert!(!bits.get(n).unwrap());
		bits.set(n, true);
		assert!(bits.get(n).unwrap());
	}

	assert!(bits.get(9).is_none());
	assert!(bits.get_mut(9).is_none());
	assert!(bits.get(8 .. 10).is_none());
	assert!(bits.get_mut(8 .. 10).is_none());

	assert_eq!(bits.first().as_deref(), Some(&true));
	*bits.first_mut().unwrap() = false;
	assert_eq!(bits.last().as_deref(), Some(&true));
	*bits.last_mut().unwrap() = false;

	*crate::slice::BitSliceIndex::index_mut(1usize, bits) = false;
	assert_eq!(bits, bits![0, 0, 1, 1, 1, 1, 1, 0]);
	assert!(bits.get(100 ..).is_none());
	assert!(bits.get(.. 100).is_none());

	let (a, b) = (bits![mut Msb0, u8; 0, 1], bits![mut Lsb0, u16; 1, 0]);
	assert_eq!(a, bits![0, 1]);
	assert_eq!(b, bits![1, 0]);
	a.swap_with_bitslice(b);
	assert_eq!(a, bits![1, 0]);
	assert_eq!(b, bits![0, 1]);

	let proxy = a.get_mut(0).unwrap();
	assert!(*proxy);

	let byte = core::cell::Cell::new(0u8);
	let shared = byte.view_bits::<Lsb0>();
	let shared_2 = shared;

	shared.set_aliased(0, true);
	assert!(shared_2[0]);
}

#[test]
#[should_panic = "Index 1 out of bounds: 1"]
fn index_out_of_bounds() {
	bits![0][1];
}

#[test]
fn memcpy() {
	let mut dst = bitarr![0; 500];
	let src = bitarr![1; 500];

	//  Equal heads will fall into the fast path.
	dst[10 .. 20].copy_from_bitslice(&src[74 .. 84]);
	dst[100 .. 500].copy_from_bitslice(&src[36 .. 436]);

	//  Unequal heads will trip the slow path.
	dst[.. 490].copy_from_bitslice(&src[10 .. 500]);
}

#[test]
fn batch_copy() {
	let mut l = bitarr![Lsb0, usize; 0; 500];
	let mut m = bitarr![Msb0, usize; 0; 500];

	let l2 = bitarr![Lsb0, usize; 1; 500];
	let m2 = bitarr![Msb0, usize; 1; 500];

	assert!(l.not_any());
	l.copy_from_bitslice(&l2);
	assert!(l.all());

	assert!(m.not_any());
	m.copy_from_bitslice(&m2);
	assert!(m.all());
}

#[test]
fn query() {
	let data = [0x0Fu8, !0, 0xF0, 0, 0x0E];
	let bits = data.view_bits::<Msb0>();

	assert!(bits[36 .. 39].all());
	assert!(bits[4 .. 20].all());
	assert!(bits[.. 8].any());
	assert!(bits[4 .. 20].any());
	assert!(bits[32 ..].not_all());
	assert!(bits[.. 4].not_any());
	assert!(bits[.. 8].some());

	assert_eq!(bits[1 .. 7].count_ones(), 3);
	assert_eq!(bits[1 .. 7].count_zeros(), 3);
	assert_eq!(bits[.. 24].count_ones(), 16);
	assert_eq!(bits[16 ..].count_zeros(), 17);

	assert!(!bits![0].contains(bits![0, 1]));
	assert!(bits![0, 1, 0].contains(bits![1, 0]));
	assert!(bits![0, 1, 0].starts_with(bits![0, 1]));
	assert!(bits![0, 1, 0].ends_with(bits![1, 0]));
}

#[test]
fn modify() {
	let mut data = 0b0000_1111u8;

	let bits = data.view_bits_mut::<LocalBits>();
	bits.swap(3, 4);
	assert_eq!(data, 0b0001_0111);

	let bits = data.view_bits_mut::<Lsb0>();
	bits[1 .. 7].reverse();
	assert_eq!(data, 0b0110_1001);
	data.view_bits_mut::<Msb0>()[1 .. 7].reverse();

	let bits = data.view_bits_mut::<Msb0>();
	bits.copy_within(2 .. 4, 0);
	assert_eq!(data, 0b0101_0111);

	let bits = data.view_bits_mut::<Msb0>();
	bits.copy_within(5 .., 2);
	assert_eq!(data, 0b0111_1111);
}

#[test]
fn split() {
	assert!(
		BitSlice::<LocalBits, usize>::empty()
			.split_first()
			.is_none()
	);
	let (head, rest) = 1u8.view_bits::<Lsb0>().split_first().unwrap();
	assert!(head);
	assert_eq!(rest, bits![0; 7]);

	assert!(
		BitSlice::<LocalBits, usize>::empty_mut()
			.split_first_mut()
			.is_none()
	);
	let mut data = 0u8;
	let (head, _) = data.view_bits_mut::<Lsb0>().split_first_mut().unwrap();
	head.set(true);
	assert_eq!(data, 1);

	assert!(BitSlice::<LocalBits, usize>::empty().split_last().is_none());
	let (tail, rest) = 1u8.view_bits::<Msb0>().split_last().unwrap();
	assert!(tail);
	assert_eq!(rest, bits![0; 7]);

	assert!(
		BitSlice::<LocalBits, usize>::empty_mut()
			.split_first_mut()
			.is_none()
	);
	let mut data = 0u8;
	let (head, _) = data.view_bits_mut::<Msb0>().split_last_mut().unwrap();
	head.set(true);
	assert_eq!(data, 1);

	let mut data = 0b0000_1111u8;

	let bits = data.view_bits::<Msb0>();
	let (left, right) = bits.split_at(4);
	assert!(left.not_any());
	assert!(right.all());

	let bits = data.view_bits_mut::<Msb0>();
	let (left, right) = bits.split_at_mut(4);
	left.set_all(true);
	right.set_all(false);
	assert_eq!(data, 0b1111_0000u8);

	let data = 0u8;
	let bits = data.view_bits::<Lsb0>();
	let base_ptr = BitPtr::from_ref(&data);
	let next_ptr = base_ptr.wrapping_add(8);
	let (l, _) = bits.split_at(0);
	let (_, r) = bits.split_at(8);
	let (l_ptr, r_ptr) = (l.as_bitspan(), r.as_bitspan());
	assert_eq!(l_ptr.as_bitptr(), base_ptr);
	assert_eq!(r_ptr.as_bitptr(), next_ptr);
}

#[test]
fn iterators() {
	assert!(bits![0; 2].iter().nth(2).is_none());
	assert!(bits![0; 2].iter().nth_back(2).is_none());

	let bits = bits![mut 0; 4];

	assert!(bits.chunks(2).nth(2).is_none());
	assert!(bits.chunks(2).nth_back(2).is_none());
	assert!(bits.chunks_mut(2).nth(2).is_none());
	assert!(bits.chunks_mut(2).nth_back(2).is_none());

	assert!(bits.rchunks(2).nth(2).is_none());
	assert!(bits.rchunks(2).nth_back(2).is_none());
	assert!(bits.rchunks_mut(2).nth(2).is_none());
	assert!(bits.rchunks_mut(2).nth_back(2).is_none());
	assert!(bits![mut].rchunks_mut(1).next().is_none());

	bits![Msb0, u8; 0, 1, 0, 0, 1, 0, 0, 0]
		.split(|_, bit| *bit)
		.zip([1usize, 2, 3].iter())
		.for_each(|(bits, len)| assert_eq!(bits.len(), *len));

	let mut data = 0b0100_1000u8;
	data.view_bits_mut::<Msb0>()
		.split_mut(|_, bit| *bit)
		.zip([1usize, 2, 3].iter())
		.for_each(|(bits, len)| {
			assert_eq!(bits.len(), *len);
			bits.set_all(true)
		});
	assert_eq!(data, !0);

	bits![Msb0, u8; 0, 1, 0, 0, 1, 0, 0, 0]
		.rsplit(|_, bit| *bit)
		.zip([3usize, 2, 1].iter())
		.for_each(|(bits, len)| assert_eq!(bits.len(), *len));

	let mut data = 0b0100_1000u8;
	data.view_bits_mut::<Msb0>()
		.rsplit_mut(|_, bit| *bit)
		.zip([3usize, 2, 1].iter())
		.for_each(|(bits, len)| {
			assert_eq!(bits.len(), *len);
			bits.set_all(true)
		});
	assert_eq!(data, !0);

	bits![Msb0, u8; 0, 1, 0, 0, 1, 0, 0, 0]
		.splitn(2, |_, bit| *bit)
		.zip([1usize, 6].iter())
		.for_each(|(bits, len)| assert_eq!(bits.len(), *len));

	let mut data = 0b0100_1000u8;
	data.view_bits_mut::<Msb0>()
		.splitn_mut(2, |_, bit| *bit)
		.zip([1usize, 6].iter())
		.for_each(|(bits, len)| {
			assert_eq!(bits.len(), *len);
			bits.set_all(true)
		});
	assert_eq!(data, !0);

	bits![Msb0, u8; 0, 1, 0, 0, 1, 0, 0, 0]
		.rsplitn(2, |_, bit| *bit)
		.zip([3usize, 4].iter())
		.for_each(|(bits, len)| assert_eq!(bits.len(), *len));

	let mut data = 0b0100_1000u8;
	data.view_bits_mut::<Msb0>()
		.rsplitn_mut(2, |_, bit| *bit)
		.zip([3usize, 4].iter())
		.for_each(|(bits, len)| {
			assert_eq!(bits.len(), *len);
			bits.set_all(true)
		});
	assert_eq!(data, !0);
}

#[test]
fn alignment() {
	let mut data = [0u32; 3];
	let bits = data.view_bits_mut::<Msb0>();

	let bp = bits[10 .. 20].as_bitspan();
	let (l0, c0, r0) = unsafe { bits[10 .. 20].align_to_mut::<u8>() };
	assert_eq!(l0.as_bitspan(), bp);
	assert!(c0.is_empty());
	assert!(r0.is_empty());

	let (l1, c1, r1) = unsafe { bits[10 .. 86].align_to::<u8>() };
	assert_eq!(l1.len(), 22);
	assert_eq!(r1.len(), 22);
	assert_eq!(c1.len(), 32);

	let (l2, c2, r2) = unsafe { c1.align_to::<u16>() };
	assert!(l2.is_empty());
	assert!(r2.is_empty());
	assert_eq!(c1.len(), c2.len());
}

#[test]
#[cfg(feature = "alloc")]
fn repetition() {
	let bits = bits![0, 0, 1, 1];
	let bv = bits.repeat(2);
	assert_eq!(bv, bits![0, 0, 1, 1, 0, 0, 1, 1]);
}

#[test]
fn pointer_offset() {
	let data = [0u8; 2];
	let msb0 = data.view_bits::<Msb0>();

	assert_eq!(msb0[2 ..].offset_from(&msb0[12 ..]), 10);
	assert_eq!(msb0[5 ..].offset_from(&msb0[10 ..]), 5);
	assert_eq!(msb0[8 ..].offset_from(&msb0[4 ..]), -4);
	assert_eq!(msb0[14 ..].offset_from(&msb0[1 ..]), -13);
}

#[test]
fn shift() {
	let bits = bits![mut 1; 6];
	bits.shift_left(0);
	bits.shift_right(0);
	assert_eq!(bits, bits![1; 6]);

	bits.shift_left(4);
	assert_eq!(bits, bits![1, 1, 0, 0, 0, 0]);
	bits.shift_right(2);
	assert_eq!(bits, bits![0, 0, 1, 1, 0, 0]);
}

#[test]
fn invert() {
	let mut data = [0u8; 4];
	let bits = data.view_bits_mut::<Lsb0>();

	let inv = !&mut bits[2 .. 6];
	assert!(inv.all());

	let inv = !&mut bits[12 .. 28];
	assert!(inv.all());

	assert_eq!(data, [0x3C, 0xF0, 0xFF, 0x0F]);
}

#[test]
fn rotate() {
	let bits = bits![mut 0, 1, 0, 0, 1, 0];

	bits.rotate_left(0);
	bits.rotate_right(0);
	bits.rotate_left(6);
	bits.rotate_right(6);

	assert_eq!(bits, bits![0, 1, 0, 0, 1, 0]);
}

#[test]
fn unspecialized() {
	use crate::{
		index::{
			BitIdx,
			BitPos,
		},
		mem::BitRegister,
		prelude::*,
	};

	pub struct Swizzle;

	unsafe impl BitOrder for Swizzle {
		fn at<R>(index: BitIdx<R>) -> BitPos<R>
		where R: BitRegister {
			match R::BITS {
				8 => BitPos::new(index.into_inner() ^ 0b100).unwrap(),
				16 => BitPos::new(index.into_inner() ^ 0b1100).unwrap(),
				32 => BitPos::new(index.into_inner() ^ 0b11100).unwrap(),
				64 => BitPos::new(index.into_inner() ^ 0b111100).unwrap(),
				_ => unreachable!("No other integers are supported"),
			}
		}
	}

	let mut data = [!0u8, 0];
	let bits = data.view_bits_mut::<Swizzle>();

	bits.copy_within(4 .. 12, 8);
	bits.copy_within(.. 4, 12);
	assert!(bits.all());
	assert_eq!(bits[.. 8], bits[8 ..]);

	//  Dodge the memcpy accelerant
	bits[.. 8].copy_from_bitslice(&bits![Swizzle, u8; 0; 9][1 ..]);
	assert_eq!(bits, [0u8, !0].view_bits::<Swizzle>());
}

#[test]
#[allow(deprecated)]
fn misc() {
	let a = bits![mut 0; 4];
	let b = bits![mut 0, 1, 0, 1];
	let c = bits![mut 0, 0, 1, 1];

	a.clone_from_slice(b);
	assert_eq!(a, b);
	b.swap_with_slice(c);
	a.copy_from_slice(b);
	assert_eq!(a, b);

	#[cfg(feature = "alloc")]
	{
		assert_eq!(a.to_vec(), bitvec![0, 0, 1, 1]);
	}
}

#[test]
#[allow(deprecated)]
fn iter() {
	let bits = bits![Lsb0, u8; 0, 1, 1, 0, 1, 0, 0, 1];
	let mut iter = bits.iter();

	assert_eq!(iter.as_bitslice(), bits);
	assert_eq!(iter.as_slice(), bits);
	assert_eq!(iter.next().as_deref(), Some(&false));
	assert_eq!(iter.as_bitslice(), &bits[1 ..]);
	assert_eq!(iter.next().as_deref(), Some(&true));

	assert_eq!(iter.as_bitslice(), &bits[2 ..]);
	assert_eq!(iter.next_back().as_deref(), Some(&true));
	assert_eq!(iter.as_bitslice(), &bits[2 .. 7]);
	assert_eq!(iter.next_back().as_deref(), Some(&false));

	assert_eq!(iter.as_bitslice(), &bits[2 .. 6]);
	assert_eq!(iter.next().as_deref(), Some(&true));
	assert_eq!(iter.as_bitslice(), &bits[3 .. 6]);
	assert_eq!(iter.next().as_deref(), Some(&false));

	assert_eq!(iter.as_bitslice(), &bits[4 .. 6]);
	assert_eq!(iter.next_back().as_deref(), Some(&false));
	assert_eq!(iter.as_bitslice(), &bits[4 .. 5]);

	assert_eq!(iter.next_back().as_deref(), Some(&true));
	assert!(iter.as_bitslice().is_empty());
	assert!(iter.next().is_none());
	assert!(iter.next_back().is_none());

	let iter2 = iter.clone();
	let bits: &BitSlice<_, _> = iter2.as_ref();
	assert!(bits.is_empty());
}

#[test]
#[allow(deprecated)]
fn iter_mut() {
	let bits = bits![mut Msb0, u8; 0, 1, 1, 0, 1, 0, 0, 1];
	let mut iter = bits.iter_mut();

	*iter.next().unwrap() = true;
	*iter.nth_back(1).unwrap() = true;
	*iter.nth(2).unwrap() = true;
	*iter.next_back().unwrap() = true;

	assert_eq!(iter.into_bitslice().as_bitspan(), bits[4 .. 5].as_bitspan());

	let bitspan = bits.as_bitspan();
	assert_eq!(bits.iter_mut().into_slice().as_bitspan(), bitspan);
	assert_eq!(bits.iter_mut().as_bitslice().as_bitspan(), bitspan);
}

#[test]
fn windows() {
	let bits = bits![LocalBits, u8; 0; 8];

	let mut windows = bits.windows(5);
	assert_eq!(
		windows.next().unwrap().as_bitspan(),
		bits[.. 5].as_bitspan()
	);
	assert_eq!(
		windows.next_back().unwrap().as_bitspan(),
		bits[3 ..].as_bitspan()
	);

	let mut windows = bits.windows(3);
	assert_eq!(
		windows.nth(2).unwrap().as_bitspan(),
		bits[2 .. 5].as_bitspan()
	);
	assert_eq!(
		windows.nth_back(2).unwrap().as_bitspan(),
		bits[3 .. 6].as_bitspan()
	);
	assert!(windows.next().is_none());
	assert!(windows.next_back().is_none());
	assert!(windows.nth(1).is_none());
	assert!(windows.nth_back(1).is_none());
}

#[test]
fn chunks() {
	let bits = bits![Lsb0, u16; 0; 16];

	let mut chunks = bits.chunks(5);
	assert_eq!(chunks.next().unwrap().as_bitspan(), bits[.. 5].as_bitspan());
	assert_eq!(
		chunks.next_back().unwrap().as_bitspan(),
		bits[15 ..].as_bitspan()
	);

	let mut chunks = bits.chunks(3);
	assert_eq!(
		chunks.nth(2).unwrap().as_bitspan(),
		bits[6 .. 9].as_bitspan()
	);
	assert_eq!(
		chunks.nth_back(2).unwrap().as_bitspan(),
		bits[9 .. 12].as_bitspan()
	);
}

#[test]
fn chunks_mut() {
	let bits = bits![mut Msb0, u16; 0; 16];

	let (one, two, three, four) = (
		bits[.. 5].as_bitspan(),
		bits[15 ..].as_bitspan(),
		bits[6 .. 9].as_bitspan(),
		bits[9 .. 12].as_bitspan(),
	);

	let mut chunks = bits.chunks_mut(5);
	assert_eq!(chunks.next().unwrap().as_bitspan(), one);
	assert_eq!(chunks.next_back().unwrap().as_bitspan(), two);

	let mut chunks = bits.chunks_mut(3);
	assert_eq!(chunks.nth(2).unwrap().as_bitspan(), three);
	assert_eq!(chunks.nth_back(2).unwrap().as_bitspan(), four);
}

#[test]
fn chunks_exact() {
	let bits = bits![Lsb0, u32; 0; 32];

	let mut chunks = bits.chunks_exact(5);
	assert_eq!(chunks.remainder().as_bitspan(), bits[30 ..].as_bitspan());
	assert_eq!(chunks.next().unwrap().as_bitspan(), bits[.. 5].as_bitspan());
	assert_eq!(
		chunks.next_back().unwrap().as_bitspan(),
		bits[25 .. 30].as_bitspan(),
	);
	assert_eq!(
		chunks.nth(1).unwrap().as_bitspan(),
		bits[10 .. 15].as_bitspan()
	);
	assert_eq!(
		chunks.nth_back(1).unwrap().as_bitspan(),
		bits[15 .. 20].as_bitspan(),
	);

	assert!(chunks.next().is_none());
	assert!(chunks.next_back().is_none());
	assert!(chunks.nth(1).is_none());
	assert!(chunks.nth_back(1).is_none());
}

#[test]
fn chunks_exact_mut() {
	let bits = bits![mut Msb0, u32; 0; 32];

	let (one, two, three, four, rest) = (
		bits[.. 5].as_bitspan(),
		bits[10 .. 15].as_bitspan(),
		bits[15 .. 20].as_bitspan(),
		bits[25 .. 30].as_bitspan(),
		bits[30 ..].as_bitspan(),
	);

	let mut chunks = bits.chunks_exact_mut(5);
	assert_eq!(chunks.next().unwrap().as_bitspan(), one);
	assert_eq!(chunks.next_back().unwrap().as_bitspan(), four);
	assert_eq!(chunks.nth(1).unwrap().as_bitspan(), two);
	assert_eq!(chunks.nth_back(1).unwrap().as_bitspan(), three);

	assert!(chunks.next().is_none());
	assert!(chunks.next_back().is_none());
	assert!(chunks.nth(1).is_none());
	assert!(chunks.nth_back(1).is_none());

	assert_eq!(chunks.into_remainder().as_bitspan(), rest);
}

#[test]
fn rchunks() {
	let bits = bits![Lsb0, u16; 0; 16];

	let mut rchunks = bits.rchunks(5);
	assert_eq!(
		rchunks.next().unwrap().as_bitspan(),
		bits[11 ..].as_bitspan()
	);
	assert_eq!(
		rchunks.next_back().unwrap().as_bitspan(),
		bits[.. 1].as_bitspan()
	);

	let mut rchunks = bits.rchunks(3);
	assert_eq!(
		rchunks.nth(2).unwrap().as_bitspan(),
		bits[7 .. 10].as_bitspan()
	);
	assert_eq!(
		rchunks.nth_back(2).unwrap().as_bitspan(),
		bits[4 .. 7].as_bitspan()
	);
}

#[test]
fn rchunks_mut() {
	let bits = bits![mut Msb0, u16; 0; 16];

	let (one, two, three, four) = (
		bits[11 ..].as_bitspan(),
		bits[.. 1].as_bitspan(),
		bits[7 .. 10].as_bitspan(),
		bits[4 .. 7].as_bitspan(),
	);

	let mut rchunks = bits.rchunks_mut(5);
	assert_eq!(rchunks.next().unwrap().as_bitspan(), one);
	assert_eq!(rchunks.next_back().unwrap().as_bitspan(), two);

	let mut rchunks = bits.rchunks_mut(3);
	assert_eq!(rchunks.nth(2).unwrap().as_bitspan(), three);
	assert_eq!(rchunks.nth_back(2).unwrap().as_bitspan(), four);
}

#[test]
fn rchunks_exact() {
	let bits = bits![Lsb0, u32; 0; 32];

	let mut rchunks = bits.rchunks_exact(5);
	assert_eq!(rchunks.remainder().as_bitspan(), bits[.. 2].as_bitspan());
	assert_eq!(
		rchunks.next().unwrap().as_bitspan(),
		bits[27 ..].as_bitspan()
	);
	assert_eq!(
		rchunks.next_back().unwrap().as_bitspan(),
		bits[2 .. 7].as_bitspan(),
	);
	assert_eq!(
		rchunks.nth(1).unwrap().as_bitspan(),
		bits[17 .. 22].as_bitspan()
	);
	assert_eq!(
		rchunks.nth_back(1).unwrap().as_bitspan(),
		bits[12 .. 17].as_bitspan(),
	);

	assert!(rchunks.next().is_none());
	assert!(rchunks.next_back().is_none());
	assert!(rchunks.nth(1).is_none());
	assert!(rchunks.nth_back(1).is_none());
}

#[test]
fn rchunks_exact_mut() {
	let bits = bits![mut Msb0, u32; 0; 32];

	let (rest, one, two, three, four) = (
		bits[.. 2].as_bitspan(),
		bits[2 .. 7].as_bitspan(),
		bits[12 .. 17].as_bitspan(),
		bits[17 .. 22].as_bitspan(),
		bits[27 ..].as_bitspan(),
	);

	let mut rchunks = bits.rchunks_exact_mut(5);
	assert_eq!(rchunks.next().unwrap().as_bitspan(), four);
	assert_eq!(rchunks.next_back().unwrap().as_bitspan(), one);
	assert_eq!(rchunks.nth(1).unwrap().as_bitspan(), three);
	assert_eq!(rchunks.nth_back(1).unwrap().as_bitspan(), two);

	assert!(rchunks.next().is_none());
	assert!(rchunks.next_back().is_none());
	assert!(rchunks.nth(1).is_none());
	assert!(rchunks.nth_back(1).is_none());

	assert_eq!(rchunks.into_remainder().as_bitspan(), rest);
}

#[test]
fn iter_ones_zeros() {
	//                          0  1  2  3  4  5  6  7
	let bits = bits![0, 0, 1, 1, 0, 1, 0, 1];
	let mut ones = bits.iter_ones();
	let mut zeros = bits.iter_zeros();

	assert_eq!(ones.next(), Some(2));
	assert_eq!(zeros.next(), Some(0));
	assert_eq!(ones.next_back(), Some(7));
	assert_eq!(zeros.next_back(), Some(6));

	assert_eq!(ones.size_hint(), (2, Some(2)));
	assert_eq!(zeros.size_hint(), (2, Some(2)));
	assert_eq!(ones.clone().count(), 2);
	assert_eq!(zeros.clone().count(), 2);

	assert_eq!(ones.clone().last(), Some(5));
	assert_eq!(zeros.clone().last(), Some(4));

	assert!(ones.nth(2).is_none());
	assert!(zeros.nth(2).is_none());
	assert!(ones.nth_back(0).is_none());
	assert!(zeros.nth_back(0).is_none());
}

#[test]
fn specialized_iter_ones() {
	let data = [0x08u8, 0x20, 0, 0x04, 0x08];

	let bits = data.view_bits::<Msb0>();
	assert!(bits[17 .. 23].sp_iter_ones_first().is_none());
	assert!(bits[17 .. 23].sp_iter_ones_last().is_none());
	assert!(bits[12 .. 28].sp_iter_ones_first().is_none());
	assert!(bits[12 .. 28].sp_iter_ones_last().is_none());

	assert_eq!(bits[3 ..].sp_iter_ones_first(), Some(1));
	assert_eq!(bits[5 ..].sp_iter_ones_first(), Some(5));
	assert_eq!(bits[11 ..].sp_iter_ones_first(), Some(18));
	assert_eq!(bits[30 .. 38].sp_iter_ones_first(), Some(6));
	assert_eq!(bits[34 .. 38].sp_iter_ones_first(), Some(2));

	assert_eq!(bits[.. 38].sp_iter_ones_last(), Some(36));
	assert_eq!(bits[.. 36].sp_iter_ones_last(), Some(29));
	assert_eq!(bits[.. 29].sp_iter_ones_last(), Some(10));
	assert_eq!(bits[2 .. 10].sp_iter_ones_last(), Some(2));
	assert_eq!(bits[2 .. 6].sp_iter_ones_last(), Some(2));

	let bits = data.view_bits::<Lsb0>();
	assert!(bits[17 .. 23].sp_iter_ones_first().is_none());
	assert!(bits[17 .. 23].sp_iter_ones_last().is_none());
	assert!(bits[14 .. 26].sp_iter_ones_first().is_none());
	assert!(bits[14 .. 26].sp_iter_ones_last().is_none());

	assert_eq!(bits[2 ..].sp_iter_ones_first(), Some(1));
	assert_eq!(bits[4 ..].sp_iter_ones_first(), Some(9));
	assert_eq!(bits[14 ..].sp_iter_ones_first(), Some(12));
	assert_eq!(bits[27 .. 38].sp_iter_ones_first(), Some(8));
	assert_eq!(bits[34 .. 38].sp_iter_ones_first(), Some(1));

	assert_eq!(bits[.. 38].sp_iter_ones_last(), Some(35));
	assert_eq!(bits[.. 35].sp_iter_ones_last(), Some(26));
	assert_eq!(bits[.. 26].sp_iter_ones_last(), Some(13));
	assert_eq!(bits[2 .. 13].sp_iter_ones_last(), Some(1));
	assert_eq!(bits[2 .. 6].sp_iter_ones_last(), Some(1));
}

#[test]
fn specialized_iter_zeros() {
	let data = [!0x08u8, !0x20, !0, !0x04, !0x08];

	let bits = data.view_bits::<Msb0>();
	assert!(bits[17 .. 23].sp_iter_zeros_first().is_none());
	assert!(bits[17 .. 23].sp_iter_zeros_last().is_none());
	assert!(bits[12 .. 28].sp_iter_zeros_first().is_none());
	assert!(bits[12 .. 28].sp_iter_zeros_last().is_none());

	assert_eq!(
		bits[3 ..].sp_iter_zeros_first(),
		Some(1),
		"{:b}",
		&bits[3 ..]
	);
	assert_eq!(bits[5 ..].sp_iter_zeros_first(), Some(5));
	assert_eq!(bits[11 ..].sp_iter_zeros_first(), Some(18));
	assert_eq!(bits[30 .. 38].sp_iter_zeros_first(), Some(6));
	assert_eq!(bits[34 .. 38].sp_iter_zeros_first(), Some(2));

	assert_eq!(bits[.. 38].sp_iter_zeros_last(), Some(36));
	assert_eq!(bits[.. 36].sp_iter_zeros_last(), Some(29));
	assert_eq!(bits[.. 29].sp_iter_zeros_last(), Some(10));
	assert_eq!(bits[2 .. 10].sp_iter_zeros_last(), Some(2));
	assert_eq!(bits[2 .. 6].sp_iter_zeros_last(), Some(2));

	let bits = data.view_bits::<Lsb0>();
	assert!(bits[17 .. 23].sp_iter_zeros_first().is_none());
	assert!(bits[17 .. 23].sp_iter_zeros_last().is_none());
	assert!(bits[14 .. 26].sp_iter_zeros_first().is_none());
	assert!(bits[14 .. 26].sp_iter_zeros_last().is_none());

	assert_eq!(bits[2 ..].sp_iter_zeros_first(), Some(1));
	assert_eq!(bits[4 ..].sp_iter_zeros_first(), Some(9));
	assert_eq!(bits[14 ..].sp_iter_zeros_first(), Some(12));
	assert_eq!(bits[27 .. 38].sp_iter_zeros_first(), Some(8));
	assert_eq!(bits[34 .. 38].sp_iter_zeros_first(), Some(1));

	assert_eq!(bits[.. 38].sp_iter_zeros_last(), Some(35));
	assert_eq!(bits[.. 35].sp_iter_zeros_last(), Some(26));
	assert_eq!(bits[.. 26].sp_iter_zeros_last(), Some(13));
	assert_eq!(bits[2 .. 13].sp_iter_zeros_last(), Some(1));
	assert_eq!(bits[2 .. 6].sp_iter_zeros_last(), Some(1));
}

#[cfg(feature = "alloc")]
mod format {
	#[cfg(not(feature = "std"))]
	use alloc::format;

	use crate::prelude::*;

	#[test]
	fn binary() {
		let data = [0u8, 0x0F, !0];
		let bits = data.view_bits::<Msb0>();

		assert_eq!(format!("{:b}", &bits[.. 0]), "[]");
		assert_eq!(format!("{:#b}", &bits[.. 0]), "[]");

		assert_eq!(format!("{:b}", &bits[9 .. 15]), "[000111]");
		assert_eq!(
			format!("{:#b}", &bits[9 .. 15]),
			"[
    0b000111,
]"
		);

		assert_eq!(format!("{:b}", &bits[4 .. 20]), "[0000, 00001111, 1111]");
		assert_eq!(
			format!("{:#b}", &bits[4 .. 20]),
			"[
    0b0000,
    0b00001111,
    0b1111,
]"
		);

		assert_eq!(format!("{:b}", &bits[4 ..]), "[0000, 00001111, 11111111]");
		assert_eq!(
			format!("{:#b}", &bits[4 ..]),
			"[
    0b0000,
    0b00001111,
    0b11111111,
]"
		);

		assert_eq!(format!("{:b}", &bits[.. 20]), "[00000000, 00001111, 1111]");
		assert_eq!(
			format!("{:#b}", &bits[.. 20]),
			"[
    0b00000000,
    0b00001111,
    0b1111,
]"
		);

		assert_eq!(format!("{:b}", bits), "[00000000, 00001111, 11111111]");
		assert_eq!(
			format!("{:#b}", bits),
			"[
    0b00000000,
    0b00001111,
    0b11111111,
]"
		);
	}

	#[test]
	fn octal() {
		let data = [0u8, 0x0F, !0];
		let bits = data.view_bits::<Msb0>();

		assert_eq!(format!("{:o}", &bits[.. 0]), "[]");
		assert_eq!(format!("{:#o}", &bits[.. 0]), "[]");

		assert_eq!(format!("{:o}", &bits[9 .. 15]), "[07]");
		assert_eq!(
			format!("{:#o}", &bits[9 .. 15]),
			"[
    0o07,
]"
		);

		//  …0_000 00_001_111 1_111…
		assert_eq!(format!("{:o}", &bits[4 .. 20]), "[00, 017, 17]");
		assert_eq!(
			format!("{:#o}", &bits[4 .. 20]),
			"[
    0o00,
    0o017,
    0o17,
]"
		);

		assert_eq!(format!("{:o}", &bits[4 ..]), "[00, 017, 377]");
		assert_eq!(
			format!("{:#o}", &bits[4 ..]),
			"[
    0o00,
    0o017,
    0o377,
]"
		);

		assert_eq!(format!("{:o}", &bits[.. 20]), "[000, 017, 17]");
		assert_eq!(
			format!("{:#o}", &bits[.. 20]),
			"[
    0o000,
    0o017,
    0o17,
]"
		);

		assert_eq!(format!("{:o}", bits), "[000, 017, 377]");
		assert_eq!(
			format!("{:#o}", bits),
			"[
    0o000,
    0o017,
    0o377,
]"
		);
	}

	#[test]
	fn hex_lower() {
		let data = [0u8, 0x0F, !0];
		let bits = data.view_bits::<Msb0>();

		assert_eq!(format!("{:x}", &bits[.. 0]), "[]");
		assert_eq!(format!("{:#x}", &bits[.. 0]), "[]");

		//  …00_0111 …
		assert_eq!(format!("{:x}", &bits[9 .. 15]), "[07]");
		assert_eq!(
			format!("{:#x}", &bits[9 .. 15]),
			"[
    0x07,
]"
		);

		//  …0000 00001111 1111…
		assert_eq!(format!("{:x}", &bits[4 .. 20]), "[0, 0f, f]");
		assert_eq!(
			format!("{:#x}", &bits[4 .. 20]),
			"[
    0x0,
    0x0f,
    0xf,
]"
		);

		assert_eq!(format!("{:x}", &bits[4 ..]), "[0, 0f, ff]");
		assert_eq!(
			format!("{:#x}", &bits[4 ..]),
			"[
    0x0,
    0x0f,
    0xff,
]"
		);

		assert_eq!(format!("{:x}", &bits[.. 20]), "[00, 0f, f]");
		assert_eq!(
			format!("{:#x}", &bits[.. 20]),
			"[
    0x00,
    0x0f,
    0xf,
]"
		);

		assert_eq!(format!("{:x}", bits), "[00, 0f, ff]");
		assert_eq!(
			format!("{:#x}", bits),
			"[
    0x00,
    0x0f,
    0xff,
]"
		);
	}

	#[test]
	fn hex_upper() {
		let data = [0u8, 0x0F, !0];
		let bits = data.view_bits::<Msb0>();

		assert_eq!(format!("{:X}", &bits[.. 0]), "[]");
		assert_eq!(format!("{:#X}", &bits[.. 0]), "[]");

		assert_eq!(format!("{:X}", &bits[9 .. 15]), "[07]");
		assert_eq!(
			format!("{:#X}", &bits[9 .. 15]),
			"[
    0x07,
]"
		);

		assert_eq!(format!("{:X}", &bits[4 .. 20]), "[0, 0F, F]");
		assert_eq!(
			format!("{:#X}", &bits[4 .. 20]),
			"[
    0x0,
    0x0F,
    0xF,
]"
		);

		assert_eq!(format!("{:X}", &bits[4 ..]), "[0, 0F, FF]");
		assert_eq!(
			format!("{:#X}", &bits[4 ..]),
			"[
    0x0,
    0x0F,
    0xFF,
]"
		);

		assert_eq!(format!("{:X}", &bits[.. 20]), "[00, 0F, F]");
		assert_eq!(
			format!("{:#X}", &bits[.. 20]),
			"[
    0x00,
    0x0F,
    0xF,
]"
		);

		assert_eq!(format!("{:X}", bits), "[00, 0F, FF]");
		assert_eq!(
			format!("{:#X}", bits),
			"[
    0x00,
    0x0F,
    0xFF,
]"
		);
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/slice/tests.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/slice/traits.rs =====
//! Non-operator trait implementations.

#[cfg(feature = "alloc")]
use alloc::borrow::ToOwned;
use core::{
	cmp,
	convert::TryFrom,
	fmt::{
		self,
		Binary,
		Debug,
		Display,
		Formatter,
		LowerHex,
		Octal,
		UpperHex,
	},
	hash::{
		Hash,
		Hasher,
	},
	hint,
	str,
};

use funty::IsNumber;
use tap::pipe::Pipe;

use super::BitSlice;
#[cfg(feature = "alloc")]
use crate::vec::BitVec;
use crate::{
	devel as dvl,
	domain::Domain,
	order::{
		BitOrder,
		Lsb0,
		Msb0,
	},
	store::BitStore,
	view::BitView,
};

impl<O, T> Eq for BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
{
}

impl<O, T> Ord for BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn cmp(&self, rhs: &Self) -> cmp::Ordering {
		self.partial_cmp(rhs)
			.expect("BitSlice has a total ordering")
	}
}

/** Tests if two `BitSlice`s are semantically — not bitwise — equal.

It is valid to compare slices of different ordering or memory types.

The equality condition requires that they have the same length and that at each
index, the two slices have the same bit value.
**/
impl<O1, O2, T1, T2> PartialEq<BitSlice<O2, T2>> for BitSlice<O1, T1>
where
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn eq(&self, rhs: &BitSlice<O2, T2>) -> bool {
		let fallback = || {
			if self.len() != rhs.len() {
				return false;
			}
			self.iter()
				.by_val()
				.zip(rhs.iter().by_val())
				.all(|(l, r)| l == r)
		};

		if dvl::match_types::<O1, T1, O2, T2>() {
			if dvl::match_order::<O1, Lsb0>() {
				let this: &BitSlice<Lsb0, T1> =
					unsafe { &*(self as *const _ as *const _) };
				let that: &BitSlice<Lsb0, T1> =
					unsafe { &*(rhs as *const _ as *const _) };
				this.sp_eq(that)
			}
			else if dvl::match_order::<O1, Msb0>() {
				let this: &BitSlice<Msb0, T1> =
					unsafe { &*(self as *const _ as *const _) };
				let that: &BitSlice<Msb0, T1> =
					unsafe { &*(rhs as *const _ as *const _) };
				this.sp_eq(that)
			}
			else {
				fallback()
			}
		}
		else {
			fallback()
		}
	}
}

//  ref-to-val equality

#[cfg(not(tarpaulin_include))]
impl<O1, O2, T1, T2> PartialEq<BitSlice<O2, T2>> for &BitSlice<O1, T1>
where
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn eq(&self, rhs: &BitSlice<O2, T2>) -> bool {
		**self == rhs
	}
}

#[cfg(not(tarpaulin_include))]
impl<O1, O2, T1, T2> PartialEq<BitSlice<O2, T2>> for &mut BitSlice<O1, T1>
where
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn eq(&self, rhs: &BitSlice<O2, T2>) -> bool {
		**self == rhs
	}
}

//  val-to-ref equality

#[cfg(not(tarpaulin_include))]
impl<O1, O2, T1, T2> PartialEq<&BitSlice<O2, T2>> for BitSlice<O1, T1>
where
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn eq(&self, rhs: &&BitSlice<O2, T2>) -> bool {
		*self == **rhs
	}
}

#[cfg(not(tarpaulin_include))]
impl<O1, O2, T1, T2> PartialEq<&mut BitSlice<O2, T2>> for BitSlice<O1, T1>
where
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn eq(&self, rhs: &&mut BitSlice<O2, T2>) -> bool {
		*self == **rhs
	}
}

/** Compares two `BitSlice`s by semantic — not bitwise — ordering.

The comparison sorts by testing at each index if one slice has a high bit where
the other has a low. At the first index where the slices differ, the slice with
the high bit is greater. If the slices are equal until at least one terminates,
then they are compared by length.
**/
impl<O1, O2, T1, T2> PartialOrd<BitSlice<O2, T2>> for BitSlice<O1, T1>
where
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn partial_cmp(&self, rhs: &BitSlice<O2, T2>) -> Option<cmp::Ordering> {
		for (l, r) in self.iter().zip(rhs.iter()) {
			match (*l, *r) {
				(true, false) => return Some(cmp::Ordering::Greater),
				(false, true) => return Some(cmp::Ordering::Less),
				_ => continue,
			}
		}
		self.len().partial_cmp(&rhs.len())
	}
}

//  ref-to-val ordering

#[cfg(not(tarpaulin_include))]
impl<O1, O2, T1, T2> PartialOrd<BitSlice<O2, T2>> for &BitSlice<O1, T1>
where
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn partial_cmp(&self, rhs: &BitSlice<O2, T2>) -> Option<cmp::Ordering> {
		(*self).partial_cmp(rhs)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O1, O2, T1, T2> PartialOrd<BitSlice<O2, T2>> for &mut BitSlice<O1, T1>
where
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn partial_cmp(&self, rhs: &BitSlice<O2, T2>) -> Option<cmp::Ordering> {
		(**self).partial_cmp(rhs)
	}
}

//  val-to-ref ordering

#[cfg(not(tarpaulin_include))]
impl<O1, O2, T1, T2> PartialOrd<&BitSlice<O2, T2>> for BitSlice<O1, T1>
where
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn partial_cmp(&self, rhs: &&BitSlice<O2, T2>) -> Option<cmp::Ordering> {
		(*self).partial_cmp(&**rhs)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O1, O2, T1, T2> PartialOrd<&mut BitSlice<O2, T2>> for BitSlice<O1, T1>
where
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn partial_cmp(&self, rhs: &&mut BitSlice<O2, T2>) -> Option<cmp::Ordering> {
		(*self).partial_cmp(&**rhs)
	}
}

//  &mut-to-& ordering

#[cfg(not(tarpaulin_include))]
impl<O1, O2, T1, T2> PartialOrd<&mut BitSlice<O2, T2>> for &BitSlice<O1, T1>
where
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn partial_cmp(&self, rhs: &&mut BitSlice<O2, T2>) -> Option<cmp::Ordering> {
		(**self).partial_cmp(&**rhs)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O1, O2, T1, T2> PartialOrd<&BitSlice<O2, T2>> for &mut BitSlice<O1, T1>
where
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn partial_cmp(&self, rhs: &&BitSlice<O2, T2>) -> Option<cmp::Ordering> {
		(**self).partial_cmp(&**rhs)
	}
}

#[cfg(not(tarpaulin_include))]
impl<'a, O, T> TryFrom<&'a [T]> for &'a BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	type Error = &'a [T];

	#[inline]
	fn try_from(slice: &'a [T]) -> Result<Self, Self::Error> {
		BitSlice::from_slice(slice).map_err(|_| slice)
	}
}

#[cfg(not(tarpaulin_include))]
impl<'a, O, T> TryFrom<&'a mut [T]> for &'a mut BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	type Error = &'a mut [T];

	#[inline]
	fn try_from(slice: &'a mut [T]) -> Result<Self, Self::Error> {
		let slice_ptr = slice as *mut [T];
		BitSlice::from_slice_mut(slice).map_err(|_| unsafe { &mut *slice_ptr })
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Default for &BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn default() -> Self {
		BitSlice::empty()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Default for &mut BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn default() -> Self {
		BitSlice::empty_mut()
	}
}

impl<O, T> Debug for BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		self.as_bitspan().render(fmt, "Slice", None)?;
		fmt.write_str(" ")?;
		Display::fmt(self, fmt)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Display for BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		Binary::fmt(self, fmt)
	}
}

/// Constructs numeric formatting implementations.
macro_rules! fmt {
	($trait:ident, $base:expr, $pfx:expr, $blksz:expr) => {
		/// Render the contents of a `BitSlice` in a numeric format.
		///
		/// These implementations render the bits of memory contained in a
		/// `BitSlice` as one of the three numeric bases that the Rust format
		/// system supports:
		///
		/// - `Binary` renders each bit individually as `0` or `1`,
		/// - `Octal` renders clusters of three bits as the numbers `0` through
		///   `7`,
		/// - and `UpperHex` and `LowerHex` render clusters of four bits as the
		///   numbers `0` through `9` and `A` through `F`.
		///
		/// The formatters produce a “word” for each element `T` of memory. The
		/// chunked formats (octal and hexadecimal) operate somewhat peculiarly:
		/// they show the semantic value of the memory, as interpreted by the
		/// ordering parameter’s implementation rather than the raw value of
		/// memory you might observe with a debugger. In order to ease the
		/// process of expanding numbers back into bits, each digit is grouped to
		/// the right edge of the memory element. So, for example, the byte
		/// `0xFF` would be rendered in as `0o377` rather than `0o773`.
		///
		/// Rendered words are chunked by memory elements, rather than by as
		/// clean as possible a number of digits, in order to aid visualization
		/// of the slice’s place in memory.
		impl<O, T> $trait for BitSlice<O, T>
		where
			O: BitOrder,
			T: BitStore,
		{
			fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
				/// Renders an accumulated text buffer as UTF-8.
				struct Seq<'a>(&'a [u8]);
				#[cfg(not(tarpaulin_include))]
				impl Debug for Seq<'_> {
					#[inline(always)]
					fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
						fmt.write_str(unsafe {
							str::from_utf8_unchecked(self.0)
						})
					}
				}

				//  If the alternate flag is set, include the radix prefix.
				let start = if fmt.alternate() { 0 } else { 2 };
				//  Create a list format accumulator.
				let mut dbg = fmt.debug_list();
				/* Create a static buffer sized for the maximum number of UTF-8
				bytes needed to render a `usize` in the selected radix.

				Rust does not yet grant access to trait constants for use in
				constant expressions within generics.
				*/
				const D: usize = <usize as IsNumber>::BITS as usize / $blksz;
				#[allow(clippy::modulo_one)]
				const M: usize = <usize as IsNumber>::BITS as usize % $blksz;
				const W: usize = D + (M != 0) as usize;
				let mut w: [u8; W + 2] = [b'0'; W + 2];
				//  Write the prefix symbol into the buffer.
				w[1] = $pfx;

				/* This closure does the main work of rendering a bit-slice as
				text. It will be called on each memory element of the slice
				being formatted.
				*/
				let mut writer = |bits: &BitSlice<O, T::Mem>| {
					//  Set the end index of the text accumulator.
					let mut end = 2;
					/* Taking `rchunks` clusters the bits to the right edge, so
					that any remainder is in the left-most (first-rendered)
					digit, in the same manner as English digit clusters in
					ordinary writing.

					Since `rchunks` takes from back to front, it must be
					reversed in order to traverse the slice from front to back.
					The enumeration provides the offset from the buffer start
					for writing the computed digit into the text accumulator.
					*/
					for chunk in bits.rchunks($blksz).rev() {
						/* Copy the bits of the slice into the temporary, in
						Msb0 order, at the LSedge of the temporary. This will
						translate the bit sequence into the binary digit that
						represents it.
						*/
						let mut val = 0u8;
						for bit in chunk {
							val <<= 1;
							val |= *bit as u8;
						}

						/* Translate the accumulator digit into the matching
						ASCII hexadecimal glyph, and write the glyph into the
						text accumulator.
						*/
						w[end] = match val {
							v @ 0 ..= 9 => b'0' + v,
							v @ 10 ..= 16 => $base + (v - 10),
							_ => unsafe { hint::unreachable_unchecked() },
						};
						end += 1;
					}

					//  View the text accumulator as UTF-8 and write it into the
					//  main formatter.
					dbg.entry(&Seq(&w[start .. end]));
				};

				/* Break the source `BitSlice` into its aliased sub-regions.
				This is necessary in order to load each element into local
				memory for formatting.
				*/
				match self.domain() {
					Domain::Enclave { head, elem, tail } => {
						//  Load a copy of `*elem` into the stack,
						let tmp = elem.load_value();
						//  View the whole element as bits, narrow it to the
						//  live span, and render.
						let bits = tmp.view_bits::<O>();
						unsafe {
							bits.get_unchecked(
								head.into_inner() as usize
									.. tail.into_inner() as usize,
							)
						}
						.pipe(writer);
					},
					//  Same process as above, but at different truncations.
					Domain::Region { head, body, tail } => {
						if let Some((head, elem)) = head {
							let tmp = elem.load_value();
							let bits = tmp.view_bits::<O>();
							unsafe {
								bits.get_unchecked(head.into_inner() as usize ..)
							}
							.pipe(&mut writer);
						}
						for elem in body.iter().map(BitStore::load_value) {
							elem.view_bits::<O>().pipe(&mut writer);
						}
						if let Some((elem, tail)) = tail {
							let tmp = elem.load_value();
							let bits = tmp.view_bits::<O>();
							unsafe {
								bits.get_unchecked(.. tail.into_inner() as usize)
							}
							.pipe(&mut writer);
						}
					},
				}
				dbg.finish()
			}
		}
	};
}

fmt!(Binary, b'0', b'b', 1);
fmt!(Octal, b'0', b'o', 3);
fmt!(LowerHex, b'a', b'x', 4);
fmt!(UpperHex, b'A', b'x', 4);

/// Writes the contents of the `BitSlice`, in semantic bit order, into a hasher.
#[cfg(not(tarpaulin_include))]
impl<O, T> Hash for BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn hash<H>(&self, hasher: &mut H)
	where H: Hasher {
		for bit in self.as_bitptr_range() {
			hasher.write_u8(unsafe { bit.read() } as u8);
		}
	}
}

/** Conditionally mark `BitSlice` as `Send` based on its `T` type argument.

In order for `BitSlice` to be `Send` (that is, `&mut BitSlice` can be moved
across thread boundaries), it must be capable of writing to memory without
invalidating any other `&BitSlice` handles that alias the same memory address.

This is true when `T` is one of the fundamental integers, because no other
`&BitSlice` handle is able to observe mutations, or when `T` is a `BitSafe` type
that implements atomic read-modify-write instructions, because other `&BitSlice`
types will be protected from data races by the hardware.

When `T` is a non-atomic `BitSafe` type, `BitSlice` cannot be `Send`, because
one `&mut BitSlice` moved across a thread boundary may cause mutation that
another `&BitSlice` may observe, but the instructions used to access memory do
not guard against data races.

A `&mut BitSlice` over aliased memory addresses is equivalent to either a
`&Cell` or `&AtomicT`, depending on what the [`radium`] crate makes available
for the register width.

[`radium`]: radium::types
**/
unsafe impl<O, T> Send for BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore + Sync,
{
}

/** Conditionally mark `BitSlice` as `Sync` based on its `T` type argument.

In order for `BitSlice` to be `Sync` (that is, `&BitSlice` can be copied across
thread boundaries), it must be capable of reading from memory without being
invalidated by any other `&mut BitSlice` handles that alias the same memory
address.

This is true when `T` is one of the fundamental integers, because no other
`&mut BitSlice` handle can exist to effect mutations, or when `T` is a `BitSafe`
type that implements atomic read-modify-write instructions, because it will
guard against other `&mut BitSlice` modifications in hardware.

When `T` is a non-atomic `BitSafe` type, `BitSlice` cannot be `Sync`, because
one `&BitSlice` moved across a thread boundary may read from memory that is
modified by the originally-owning thread, but the instructions used to access
memory do not guard against such data races.

A `&BitSlice` over aliased memory addresses is equivalent to either a `&Cell`
or `&AtomicT`, depending on what the [`radium`] crate makes available for the
register width.

[`radium`]: radium::types
**/
unsafe impl<O, T> Sync for BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore + Sync,
{
}

#[cfg(feature = "alloc")]
impl<O, T> ToOwned for BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	type Owned = BitVec<O, T>;

	#[cfg_attr(not(tarpaulin_include), inline(always))]
	fn to_owned(&self) -> Self::Owned {
		BitVec::from_bitslice(self)
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/slice/traits.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/slice.rs =====
/*! A dynamically-sized view into individual bits of a memory region.

You can read the language’s [`slice` module documentation][std] here.

This module defines the [`BitSlice`] region, and all of its associated support
code.

[`BitSlice`] is the primary working type of this crate. It is a wrapper type
over `[T]` which enables you to view, manipulate, and take the address of
individual bits in memory. It behaves in every possible respect exactly like an
ordinary slice: it is dynamically-sized, and must be held by `&` or `&mut`
reference, just like `[T]`, and implements every inherent method and trait that
`[T]` does, to the absolute limits of what Rust permits.

The key to [`BitSlice`]’s powerful capability is that references to it use a
special encoding that store, in addition to the address of the base element and
the bit length, the index of the starting bit in the base element. This custom
reference encoding has some costs in what APIs are possible – for instance, Rust
forbids it from supporting `&mut BitSlice[index] = bool` write indexing – but in
exchange, enables it to be *far* more capable than any other bit-slice crate in
existence.

Because of the volume of code that must be written to match the `[T]` standard
API, this module is organized very differently than the slice implementation in
the [`core`] and [`std`] distribution libraries.

- the root module `slice` contains new APIs that have no counterpart in `[T]`
- `slice/api` contains reïmplementations of the `[T]` inherent methods
- `slice/iter` implements all of the iteration capability
- `slice/ops` implements the traits in `core::ops`
- `slice/proxy` implements the proxy reference used in place of `&mut bool`
- `slice/traits` implements all other traits not in `core::ops`
- lastly, `slice/tests` contains all the unit tests.

[`BitSlice`]: struct.BitSlice.html
[`core`]: core
[`std`]: std
[std]: https://doc.rust-lang.org/stable/std/slice
!*/

#[cfg(feature = "alloc")]
use alloc::vec::Vec;
#[cfg(feature = "alloc")]
use core::mem::ManuallyDrop;
use core::{
	marker::PhantomData,
	ops::RangeBounds,
	ptr,
	slice,
};

use funty::{
	IsInteger,
	IsNumber,
};
use radium::Radium;
#[cfg(feature = "alloc")]
use tap::pipe::Pipe;

//  Match the `core::slice` module topology.
pub use self::{
	api::{
		from_mut,
		from_raw_parts,
		from_raw_parts_mut,
		from_ref,
		BitSliceIndex,
	},
	iter::{
		Chunks,
		ChunksExact,
		ChunksExactMut,
		ChunksMut,
		Iter,
		IterMut,
		IterOnes,
		IterZeros,
		RChunks,
		RChunksExact,
		RChunksExactMut,
		RChunksMut,
		RSplit,
		RSplitMut,
		RSplitN,
		RSplitNMut,
		Split,
		SplitMut,
		SplitN,
		SplitNMut,
		Windows,
	},
};
use crate::{
	access::BitAccess,
	devel as dvl,
	domain::{
		BitDomain,
		BitDomainMut,
		Domain,
		DomainMut,
	},
	index::BitMask,
	mem::BitRegister,
	order::{
		BitOrder,
		Lsb0,
		Msb0,
	},
	ptr::{
		BitPtr,
		BitPtrRange,
		BitRef,
		BitSpan,
		BitSpanError,
		Const,
		Mut,
	},
	store::BitStore,
};
#[cfg(feature = "alloc")]
use crate::{
	ptr::AddressExt,
	vec::BitVec,
};

mod api;
mod iter;
mod ops;
mod specialization;
mod traits;

/** A slice of individual bits, anywhere in memory.

`BitSlice<O, T>` is an unsized region type; you interact with it through
`&BitSlice<O, T>` and `&mut BitSlice<O, T>` references, which work exactly like
all other Rust references. As with the standard slice’s relationship to arrays
and vectors, this is [`bitvec`]’s primary working type, but you will probably
hold it through one of the provided [`BitArray`], [`BitBox`], or [`BitVec`]
containers.

`BitSlice` is conceptually a `[bool]` slice, and provides a nearly complete
mirror of `[bool]`’s API.

Every bit-vector crate can give you an opaque type that hides shift/mask
calculations from you. `BitSlice` does far more than this: it offers you the
full Rust guarantees about reference behavior, including lifetime tracking,
mutability and aliasing awareness, and explicit memory control, *as well as* the
full set of tools and APIs available to the standard `[bool]` slice type.
`BitSlice` can arbitrarily split and subslice, just like `[bool]`. You can write
a linear consuming function and keep the patterns you already know.

For example, to trim all the bits off either edge that match a condition, you
could write

```rust
use bitvec::prelude::*;

fn trim<O: BitOrder, T: BitStore>(
  bits: &BitSlice<O, T>,
  to_trim: bool,
) -> &BitSlice<O, T> {
  let stop = |b: &bool| *b != to_trim;
  let front = bits.iter().by_ref().position(stop).unwrap_or(0);
  let back = bits.iter().by_ref().rposition(stop).unwrap_or(0);
  &bits[front ..= back]
}
# assert_eq!(trim(bits![0, 0, 1, 1, 0, 1, 0], false), bits![1, 1, 0, 1]);
```

to get behavior something like
`trim(&BitSlice[0, 0, 1, 1, 0, 1, 0], false) == &BitSlice[1, 1, 0, 1]`.

# Documentation

All APIs that mirror something in the standard library will have an `Original`
section linking to the corresponding item. All APIs that have a different
signature or behavior than the original will have an `API Differences` section
explaining what has changed, and how to adapt your existing code to the change.

These sections look like this:

# Original

[`slice`](https://doc.rust-lang.org/stable/std/primitive.slice.html)

# API Differences

The slice type `[bool]` has no type parameters. `BitSlice<O, T>` has two: one
for the memory type used as backing storage, and one for the order of bits
within that memory type.

`&BitSlice<O, T>` is capable of producing `&bool` references to read bits out
of its memory, but is not capable of producing `&mut bool` references to write
bits *into* its memory. Any `[bool]` API that would produce a `&mut bool` will
instead produce a [`BitRef<Mut, O, T>`] proxy reference.

# Behavior

`BitSlice` is a wrapper over `[T]`. It describes a region of memory, and must be
handled indirectly. This is most commonly through the reference types
`&BitSlice` and `&mut BitSlice`, which borrow memory owned by some other value
in the program. These buffers can be directly owned by the sibling types
[`BitBox`], which behaves like [`Box<[T]>`](alloc::boxed::Box), and [`BitVec`],
which behaves like [`Vec<T>`]. It cannot be used as the type parameter to a
standard-library-provided handle type.

The `BitSlice` region provides access to each individual bit in the region, as
if each bit had a memory address that you could use to dereference it. It packs
each logical bit into exactly one bit of storage memory, just like
[`std::bitset`] and [`std::vector<bool>`] in C++.

# Type Parameters

`BitSlice` has two type parameters which propagate through nearly every public
API in the crate. These are very important to its operation, and your choice
of type arguments informs nearly every part of this library’s behavior.

## `T: BitStore`

[`BitStore`] is the simpler of the two parameters. It refers to the integer type
used to hold bits. It must be one of the Rust unsigned integer fundamentals:
`u8`, `u16`, `u32`, `usize`, and on 64-bit systems only, `u64`. In addition, it
can also be an alias-safed wrapper over them (see the [`access`] module) in
order to permit bit-slices to share underlying memory without interfering with
each other.

`BitSlice` references can only be constructed over the integers, not over their
aliasing wrappers. `BitSlice` will only use aliasing types in its `T` slots when
you invoke APIs that produce them, such as [`.split_at_mut()`].

The default type argument is `usize`.

The argument you choose is used as the basis of a `[T]` slice, over which the
`BitSlice` view type is placed. `BitSlice<_, T>` is subject to all of the rules
about alignment that `[T]` is. If you are working with in-memory representation
formats, chances are that you already have a `T` type with which you’ve been
working, and should use it here.

If you are only using this crate to discard the seven wasted bits per `bool`
of a collection of `bool`s, and are not too concerned about the in-memory
representation, then you should use the default type argument of `usize`. This
is because most processors work best when moving an entire `usize` between
memory and the processor itself, and using a smaller type may cause it to slow
down.

## `O: BitOrder`

[`BitOrder`] is the more complex parameter. It has a default argument which,
like `usize`, is the good-enough choice when you do not explicitly need to
control the representation of bits in memory.

This parameter determines how to index the bits within a single memory element
`T`. Computers all agree that in a slice of elements `T`, the element with the
lower index has a lower memory address than the element with the higher index.
But the individual bits within an element do not have addresses, and so there is
no uniform standard of which bit is the zeroth, which is the first, which is the
penultimate, and which is the last.

To make matters even more confusing, there are two predominant ideas of
in-element ordering that often *correlate* with the in-element *byte* ordering
of integer types, but are in fact wholly unrelated! [`bitvec`] provides these
two main orders as types for you, and if you need a different one, it also
provides the tools you need to make your own.

### Least Significant Bit Comes First

This ordering, named the [`Lsb0`] type, indexes bits within an element by
placing the `0` index at the least significant bit (numeric value `1`) and the
final index at the most significant bit (numeric value [`T::MIN`][minval] for
signed integers on most machines).

For example, this is the ordering used by most C compilers to lay out bit-field
struct members on little-endian **byte**-ordered machines.

### Most Significant Bit Comes First

This ordering, named the [`Msb0`] type, indexes bits within an element by
placing the `0` index at the most significant bit (numeric value
[`T::MIN`][minval] for most signed integers) and the final index at the least
significant bit (numeric value `1`).

For example, this is the ordering used by the [TCP wire format], and by most C
compilers to lay out bit-field struct members on big-endian **byte**-ordered
machines.

### Default Ordering

The default ordering is [`Lsb0`], as it typically produces shorter object code
than [`Msb0`] does. If you are implementing a collection, then `Lsb0` is likely
the more performant ordering; if you are implementing a buffer protocol, then
your choice of ordering is dictated by the protocol definition.

# Safety

`BitSlice` is designed to never introduce new memory unsafety that you did not
provide yourself, either before or during the use of this crate. Bugs do, and
have, occured, and you are encouraged to submit any discovered flaw as a defect
report.

The `&BitSlice` reference type uses a private encoding scheme to hold all the
information needed in its stack value. This encoding is **not** part of the
public API of the library, and is not binary-compatible with `&[T]`.
Furthermore, in order to satisfy Rust’s requirements about alias conditions,
`BitSlice` performs type transformations on the `T` parameter to ensure that it
never creates the potential for undefined behavior.

You must never attempt to type-cast a reference to `BitSlice` in any way. You
must not use [`mem::transmute`] with `BitSlice` anywhere in its type arguments.
You must not use `as`-casting to convert between `*BitSlice` and any other type.
You must not attempt to modify the binary representation of a `&BitSlice`
reference value. These actions will all lead to runtime memory unsafety, are
(hopefully) likely to induce a program crash, and may possibly cause undefined
behavior at compile-time.

Everything in the `BitSlice` public API, even the `unsafe` parts, are guaranteed
to have no more unsafety than their equivalent parts in the standard library.
All `unsafe` APIs will have documentation explicitly detailing what the API
requires you to uphold in order for it to function safely and correctly. All
safe APIs will do so themselves.

# Performance

Like the standard library’s `[T]` slice, `BitSlice` is designed to be very easy
to use safely, while supporting `unsafe` when necessary. Rust has a powerful
optimizing engine, and `BitSlice` will frequently be compiled to have zero
runtime cost. Where it is slower, it will not be significantly slower than a
manual replacement.

As the machine instructions operate on registers rather than bits, your choice
of [`T: BitStore`] type parameter can influence your slice’s performance. Using
larger register types means that slices can gallop over completely-filled
interior elements faster, while narrower register types permit more graceful
handling of subslicing and aliased splits.

# Construction

`BitSlice` views of memory can be constructed over borrowed data in a number of
ways. As this is a reference-only type, it can only ever be built by borrowing
an existing memory buffer and taking temporary control of your program’s view of
the region.

## Macro Constructor

`BitSlice` buffers can be constructed at compile-time through the [`bits!`]
macro. This macro accepts a superset of the [`vec!`] arguments, and creates an
appropriate buffer in the local scope. The macro expands to a borrowed
[`BitArray`] temporary; currently, it cannot be assigned to a `static` binding.

```rust
use bitvec::prelude::*;

let immut = bits![Lsb0, u8; 0, 1, 0, 0, 1, 0, 0, 1];
let mutable: &mut BitSlice<_, _> = bits![mut Msb0, u8; 0; 8];

assert_ne!(immut, mutable);
mutable.clone_from_bitslice(immut);
assert_eq!(immut, mutable);
```

## Borrowing Constructors

The functions [`from_element`], [`from_element_mut`], [`from_slice`], and
[`from_slice_mut`] take references to existing memory, and construct
`BitSlice` references over them. These are the most basic ways to borrow memory
and view it as bits.

```rust
use bitvec::prelude::*;

let data = [0u16; 3];
let local_borrow = BitSlice::<Lsb0, _>::from_slice(&data);

let mut data = [0u8; 5];
let local_mut = BitSlice::<Lsb0, _>::from_slice_mut(&mut data);
```

## Trait Method Constructors

The [`BitView`] trait implements [`.view_bits::<O>()`] and
[`.view_bits_mut::<O>()`] methods on elements, arrays not larger than 64
elements, and slices. This trait, imported in the crate prelude, is *probably*
the easiest way for you to borrow memory.

```rust
use bitvec::prelude::*;

let data = [0u32; 5];
let trait_view = data.view_bits::<Lsb0>();

let mut data = 0usize;
let trait_mut = data.view_bits_mut::<Msb0>();
```

## Owned Bit Slices

If you wish to take ownership of a memory region and enforce that it is always
viewed as a `BitSlice` by default, you can use one of the [`BitArray`],
[`BitBox`], or [`BitVec`] types, rather than pairing ordinary buffer types with
the borrowing constructors.

```rust
use bitvec::prelude::*;

let slice = bits![0; 27];
let array = bitarr![LocalBits, u8; 0; 10];
# #[cfg(feature = "alloc")] fn allocs() {
let boxed = bitbox![0; 10];
let vec = bitvec![0; 20];
# } #[cfg(feature = "alloc")] allocs();

// arrays always round up
assert_eq!(array.as_bitslice(), slice[.. 16]);
# #[cfg(feature = "alloc")] fn allocs2() {
# let slice = bits![0; 27];
# let boxed = bitbox![0; 10];
# let vec = bitvec![0; 20];
assert_eq!(boxed.as_bitslice(), slice[.. 10]);
assert_eq!(vec.as_bitslice(), slice[.. 20]);
# } #[cfg(feature = "alloc")] allocs2();
```

[TCP wire format]: https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure
[minval]: https://doc.rust-lang.org/stable/std/primitive.usize.html#associatedconstant.MIN

[`BitArray`]: crate::array::BitArray
[`BitBox`]: crate::boxed::BitBox
[`BitRef<Mut, O, T>`]: crate::ptr::BitRef
[`BitOrder`]: crate::order::BitOrder
[`BitStore`]: crate::store::BitStore
[`BitVec`]: crate::vec::BitVec
[`BitView`]: crate::view::BitView
[`Cell<T>`]: core::cell::Cell
[`Lsb0`]: crate::order::Lsb0
[`Msb0`]: crate::order::Msb0
[`T: BitStore`]: crate::store::BitStore
[`Vec<T>`]: alloc::vec::Vec

[`access`]: crate::access
[`bits!`]: macro@crate::bits
[`bitvec`]: crate
[`bitvec::prelude::LocalBits`]: crate::order::LocalBits
[`from_element`]: Self::from_element
[`from_element_mut`]: Self::from_element_mut
[`from_slice`]: Self::from_slice
[`from_slice_mut`]: Self::from_slice_mut
[`mem::transmute`]: core::mem::transmute
[`std::bitset`]: https://en.cppreference.com/w/cpp/utility/bitset
[`std::vector<bool>`]: https://en.cppreference.com/w/cpp/container/vector_bool
[`vec!`]: macro@alloc::vec

[`.split_at_mut()`]: Self::split_at_mut
[`.view_bits::<O>()`]: crate::view::BitView::view_bits
[`.view_bits_mut::<O>()`]: crate::view::BitView::view_bits_mut
**/
#[repr(transparent)]
pub struct BitSlice<O = Lsb0, T = usize>
where
	O: BitOrder,
	T: BitStore,
{
	/// The ordering of bits within a register `T`.
	_ord: PhantomData<O>,
	/// The register type used for storage.
	_typ: PhantomData<[T]>,
	/// Indicate that this is a newtype wrapper over a wholly-untyped slice.
	///
	/// This is necessary in order for the Rust compiler to remove restrictions
	/// on the possible values of references to this slice `&BitSlice` and
	/// `&mut BitSlice`.
	///
	/// Rust has firm requirements that *any* reference that is directly usable
	/// to dereference a real value must conform to its rules about address
	/// liveness, type alignment, and for slices, trustworthy length. It is
	/// undefined behavior for a slice reference *to a dereferencable type* to
	/// violate any of these restrictions.
	///
	/// However, the value of a reference to a zero-sized type has *no* such
	/// restrictions, because that reference can never perform direct memory
	/// access. The compiler will accept any value in a slot typed as `&[()]`,
	/// because the values in it will never be used for a load or store
	/// instruction. If this were `[T]`, then Rust would make the pointer
	/// encoding used to manage values of `&BitSlice` become undefined behavior.
	///
	/// See the `ptr` module for information on the encoding used.
	_mem: [()],
}

/// General-purpose functions not present on `[T]`.
impl<O, T> BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// Constructs a shared `&BitSlice` reference over a shared element.
	///
	/// The [`BitView`] trait, implemented on all [`BitStore`] implementors,
	/// provides a method [`.view_bits::<O>()`] which delegates to this function
	/// and may be more convenient for you to write.
	///
	/// # Parameters
	///
	/// - `elem`: A shared reference to a memory element.
	///
	/// # Returns
	///
	/// A shared `&BitSlice` over the `elem` element.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let elem = 0u8;
	/// let bits = BitSlice::<Lsb0, _>::from_element(&elem);
	/// assert_eq!(bits.len(), 8);
	/// ```
	///
	/// [`BitStore`]: crate::store::BitStore
	/// [`BitView`]: crate::view::BitView
	/// [`.view_bits::<O>()`]: crate::view::BitView::view_bits
	#[inline]
	pub fn from_element(elem: &T) -> &Self {
		unsafe { BitPtr::from_ref(elem).span_unchecked(T::Mem::BITS as usize) }
			.to_bitslice_ref()
	}

	/// Constructs an exclusive `&mut BitSlice` reference over an element.
	///
	/// The [`BitView`] trait, implemented on all [`BitStore`] implementors,
	/// provides a method [`.view_bits_mut::<O>()`] which delegates to this
	/// function and may be more convenient for you to write.
	///
	/// # Parameters
	///
	/// - `elem`: An exclusive reference to a memory element.
	///
	/// # Returns
	///
	/// An exclusive `&mut BitSlice` over the `elem` element.
	///
	/// Note that the original `elem` reference will be inaccessible for the
	/// duration of the returned slice handle’s lifetime.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut elem = 0u16;
	/// let bits = BitSlice::<Msb0, _>::from_element_mut(&mut elem);
	/// bits.set(15, true);
	/// assert!(bits.get(15).unwrap());
	/// assert_eq!(elem, 1);
	/// ```
	///
	/// [`BitStore`]: crate::store::BitStore
	/// [`BitView`]: crate::view::BitView
	/// [`.view_bits_mut::<O>()`]: crate::view::BitView::view_bits_mut
	#[inline]
	pub fn from_element_mut(elem: &mut T) -> &mut Self {
		unsafe { BitPtr::from_mut(elem).span_unchecked(T::Mem::BITS as usize) }
			.to_bitslice_mut()
	}

	/// Constructs a shared `&BitSlice` reference over a slice.
	///
	/// The [`BitView`] trait, implemented on all `[T]` slices, provides a
	/// method [`.view_bits::<O>()`] which delegates to this function and may be
	/// more convenient for you to write.
	///
	/// # Parameters
	///
	/// - `slice`: A shared reference over a sequence of memory elements.
	///
	/// # Returns
	///
	/// A `&BitSlice` view of the provided slice. The error condition is only
	/// encountered if the source slice is too long to be encoded in a
	/// `&BitSlice` handle, but such a slice is likely impossible to produce
	/// without causing errors long before calling this function.
	///
	/// # Conditions
	///
	/// The produced `&BitSlice` handle always begins at the zeroth bit of the
	/// zeroth element in `slice`.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let slice = &[0u8, 1];
	/// let bits = BitSlice::<Msb0, _>::from_slice(slice).unwrap();
	/// assert!(bits[15]);
	/// ```
	///
	/// An example showing this function failing would require a slice exceeding
	/// `!0usize >> 3` bytes in size, which is infeasible to produce.
	///
	/// [`BitView`]: crate::view::BitView
	/// [`MAX_ELTS`]: Self::MAX_ELTS
	/// [`.view_bits::<O>()`]: crate::view::BitView::view_bits
	#[inline]
	pub fn from_slice(slice: &[T]) -> Result<&Self, BitSpanError<T>> {
		let elts = slice.len();
		//  Starting at the zeroth bit makes this counter an exclusive cap, not
		//  an inclusive cap. This is also pretty much impossible to hit.
		if elts >= Self::MAX_ELTS {
			return Err(BitSpanError::TooLong(
				elts.saturating_mul(T::Mem::BITS as usize),
			));
		}
		Ok(unsafe { Self::from_slice_unchecked(slice) })
	}

	/// Constructs an exclusive `&mut BitSlice` reference over a slice.
	///
	/// The [`BitView`] trait, implemented on all `[T]` slices, provides a
	/// method [`.view_bits_mut::<O>()`] which delegates to this function and
	/// may be more convenient for you to write.
	///
	/// # Parameters
	///
	/// - `slice`: An exclusive reference over a sequence of memory elements.
	///
	/// # Returns
	///
	/// A `&mut BitSlice` view of the provided slice. The error condition is
	/// only encountered if the source slice is too long to be encoded in a
	/// `&mut BitSlice` handle, but such a slice is likely impossible to produce
	/// without causing errors long before calling this function.
	///
	/// Note that the original `slice` reference will be inaccessible for the
	/// duration of the returned slice handle’s lifetime.
	///
	/// # Conditions
	///
	/// The produced `&mut BitSlice` handle always begins at the zeroth bit of
	/// the zeroth element in `slice`.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut slice = [0u8; 2];
	/// let bits = BitSlice::<Lsb0, _>::from_slice_mut(&mut slice).unwrap();
	///
	/// assert!(!bits[0]);
	/// bits.set(0, true);
	/// assert!(bits[0]);
	/// assert_eq!(slice[0], 1);
	/// ```
	///
	/// This example attempts to construct a `&mut BitSlice` handle from a slice
	/// that is too large to index. Either the `vec!` allocation will fail, or
	/// the bit-slice constructor will fail.
	///
	/// ```rust,should_panic
	/// # #[cfg(feature = "alloc")] {
	/// use bitvec::prelude::*;
	///
	/// let mut data = vec![0usize; BitSlice::<Lsb0, usize>::MAX_ELTS];
	/// let bits = BitSlice::<Lsb0, _>::from_slice_mut(&mut data[..]).unwrap();
	/// # }
	/// # #[cfg(not(feature = "alloc"))] panic!("No allocator present");
	/// ```
	///
	/// [`BitView`]: crate::view::BitView
	/// [`MAX_ELTS`]: Self::MAX_ELTS
	/// [`.view_bits_mut::<O>()`]: crate::view::BitView::view_bits_mut
	#[inline]
	pub fn from_slice_mut(
		slice: &mut [T],
	) -> Result<&mut Self, BitSpanError<T>> {
		let elts = slice.len();
		if elts >= Self::MAX_ELTS {
			return Err(BitSpanError::TooLong(
				elts.saturating_mul(T::Mem::BITS as usize),
			));
		}
		Ok(unsafe { Self::from_slice_unchecked_mut(slice) })
	}

	/// Converts a slice reference into a `BitSlice` reference without checking
	/// that its size can be safely used.
	///
	/// # Safety
	///
	/// If the `slice` length is longer than [`MAX_ELTS`], then the returned
	/// `BitSlice` will have its length severely truncated. This is not a safety
	/// violation, but it is behavior that callers must avoid to remain correct.
	///
	/// Prefer [`::from_slice()`].
	///
	/// [`MAX_ELTS`]: Self::MAX_ELTS
	/// [`::from_slice()`]: Self::from_slice
	#[inline]
	pub unsafe fn from_slice_unchecked(slice: &[T]) -> &Self {
		let bits = slice.len().wrapping_mul(T::Mem::BITS as usize);
		BitPtr::from_slice(slice)
			.span_unchecked(bits)
			.to_bitslice_ref()
	}

	/// Converts a slice reference into a `BitSlice` reference without checking
	/// that its size can be safely used.
	///
	/// # Safety
	///
	/// If the `slice` length is longer than [`MAX_ELTS`], then the returned
	/// `BitSlice` will have its length severely truncated. This is not a safety
	/// violation, but it is behavior that callers must avoid to remain correct.
	///
	/// Prefer [`::from_slice_mut()`].
	///
	/// [`MAX_ELTS`]: Self::MAX_ELTS
	/// [`::from_slice_mut()`]: Self::from_slice_mut
	#[inline]
	pub unsafe fn from_slice_unchecked_mut(slice: &mut [T]) -> &mut Self {
		let bits = slice.len().wrapping_mul(T::Mem::BITS as usize);
		BitPtr::from_mut_slice(slice)
			.span_unchecked(bits)
			.to_bitslice_mut()
	}

	/// Produces the empty slice reference.
	///
	/// This is equivalent to `&[]` for ordinary slices.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bits: &BitSlice = BitSlice::empty();
	/// assert!(bits.is_empty());
	/// ```
	#[inline(always)]
	pub fn empty<'a>() -> &'a Self {
		BitSpan::<Const, O, T>::EMPTY.to_bitslice_ref()
	}

	/// Produces the empty mutable slice reference.
	///
	/// This is equivalent to `&mut []` for ordinary slices.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bits: &mut BitSlice = BitSlice::empty_mut();
	/// assert!(bits.is_empty());
	/// ```
	#[inline(always)]
	pub fn empty_mut<'a>() -> &'a mut Self {
		BitSpan::EMPTY.to_bitslice_mut()
	}

	/// Writes a new bit at a given index.
	///
	/// # Parameters
	///
	/// - `&mut self`
	/// - `index`: The bit index at which to write. It must be in the range `0
	///   .. self.len()`.
	/// - `value`: The value to be written; `true` for `1` or `false` for `0`.
	///
	/// # Effects
	///
	/// If `index` is valid, then the bit to which it refers is set to `value`.
	///
	/// # Panics
	///
	/// This method panics if `index` is not less than [`self.len()`].
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bits = bits![mut 0];
	///
	/// assert!(!bits[0]);
	/// bits.set(0, true);
	/// assert!(bits[0]);
	/// ```
	///
	/// This example panics when it attempts to set a bit that is out of bounds.
	///
	/// ```rust,should_panic
	/// use bitvec::prelude::*;
	///
	/// let bits = bits![mut 0];
	/// bits.set(1, false);
	/// ```
	///
	/// [`self.len()`]: Self::len
	#[inline]
	pub fn set(&mut self, index: usize, value: bool) {
		self.assert_in_bounds(index, 0 .. self.len());
		unsafe {
			self.set_unchecked(index, value);
		}
	}

	/// Tests if *any* bit in the slice is set (logical `∨`).
	///
	/// # Truth Table
	///
	/// ```text
	/// 0 0 => 0
	/// 0 1 => 1
	/// 1 0 => 1
	/// 1 1 => 1
	/// ```
	///
	/// # Parameters
	///
	/// - `&self`
	///
	/// # Returns
	///
	/// Whether any bit in the slice domain is set. The empty slice returns
	/// `false`.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bits = bits![0, 1, 0, 0];
	/// assert!(bits[.. 2].any());
	/// assert!(!bits[2 ..].any());
	/// ```
	#[inline]
	pub fn any(&self) -> bool {
		match self.domain() {
			Domain::Enclave { head, elem, tail } => {
				O::mask(head, tail) & elem.load_value() != BitMask::ZERO
			},
			Domain::Region { head, body, tail } => {
				head.map_or(false, |(head, elem)| {
					O::mask(head, None) & elem.load_value() != BitMask::ZERO
				}) || body.iter().any(|e| e.load_value() != T::Mem::ZERO)
					|| tail.map_or(false, |(elem, tail)| {
						O::mask(None, tail) & elem.load_value() != BitMask::ZERO
					})
			},
		}
	}

	/// Tests if *all* bits in the slice domain are set (logical `∧`).
	///
	/// # Truth Table
	///
	/// ```text
	/// 0 0 => 0
	/// 0 1 => 0
	/// 1 0 => 0
	/// 1 1 => 1
	/// ```
	///
	/// # Parameters
	///
	/// - `&self`
	///
	/// # Returns
	///
	/// Whether all bits in the slice domain are set. The empty slice returns
	/// `true`.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bits = bits![1, 1, 0, 1];
	/// assert!(bits[.. 2].all());
	/// assert!(!bits[2 ..].all());
	/// ```
	#[inline]
	pub fn all(&self) -> bool {
		match self.domain() {
			Domain::Enclave { head, elem, tail } => {
				/* Due to a bug in `rustc`, calling `.value()` on the two
				`BitMask` types, to use `T::Mem | T::Mem == T::Mem`, causes type
				resolution failure and only discovers the
				`for<'a> BitOr<&'a Self>` implementation in the trait bounds
				`T::Mem: BitMemory: IsUnsigned: BitOr<Self> + for<'a> BitOr<&'a Self>`.

				Until this is fixed, routing through the `BitMask`
				implementation suffices. The by-val and by-ref operator traits
				are at the same position in the bounds chain, making this quite
				a strange bug.
				*/
				!O::mask(head, tail) | elem.load_value() == BitMask::ALL
			},
			Domain::Region { head, body, tail } => {
				head.map_or(true, |(head, elem)| {
					!O::mask(head, None) | elem.load_value() == BitMask::ALL
				}) && body
					.iter()
					.map(BitStore::load_value)
					.all(|e| e == T::Mem::ALL)
					&& tail.map_or(true, |(elem, tail)| {
						!O::mask(None, tail) | elem.load_value() == BitMask::ALL
					})
			},
		}
	}

	/// Tests if *all* bits in the slice are unset (logical `¬∨`).
	///
	/// # Truth Table
	///
	/// ```text
	/// 0 0 => 1
	/// 0 1 => 0
	/// 1 0 => 0
	/// 1 1 => 0
	/// ```
	///
	/// # Parameters
	///
	/// - `&self`
	///
	/// # Returns
	///
	/// Whether all bits in the slice domain are unset.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bits = bits![0, 1, 0, 0];
	/// assert!(!bits[.. 2].not_any());
	/// assert!(bits[2 ..].not_any());
	/// ```
	#[inline(always)]
	pub fn not_any(&self) -> bool {
		!self.any()
	}

	/// Tests if *any* bit in the slice is unset (logical `¬∧`).
	///
	/// # Truth Table
	///
	/// ```text
	/// 0 0 => 1
	/// 0 1 => 1
	/// 1 0 => 1
	/// 1 1 => 0
	/// ```
	///
	/// # Parameters
	///
	/// - `&self`
	///
	/// # Returns
	///
	/// Whether any bit in the slice domain is unset.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bits = bits![1, 1, 0, 1];
	/// assert!(!bits[.. 2].not_all());
	/// assert!(bits[2 ..].not_all());
	/// ```
	#[inline(always)]
	pub fn not_all(&self) -> bool {
		!self.all()
	}

	/// Tests whether the slice has some, but not all, bits set and some, but
	/// not all, bits unset.
	///
	/// This is `false` if either [`.all()`] or [`.not_any()`] are `true`.
	///
	/// # Truth Table
	///
	/// ```text
	/// 0 0 => 0
	/// 0 1 => 1
	/// 1 0 => 1
	/// 1 1 => 0
	/// ```
	///
	/// # Parameters
	///
	/// - `&self`
	///
	/// # Returns
	///
	/// Whether the slice domain has mixed content. The empty slice returns
	/// `false`.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let data = 0b111_000_10u8;
	/// let bits = bits![1, 1, 0, 0, 1, 0];
	///
	/// assert!(!bits[.. 2].some());
	/// assert!(!bits[2 .. 4].some());
	/// assert!(bits.some());
	/// ```
	///
	/// [`.all()`]: Self::all
	/// [`.not_any()`]: Self::not_any
	#[inline(always)]
	pub fn some(&self) -> bool {
		self.any() && self.not_all()
	}

	/// Counts the number of bits set to `1` in the slice contents.
	///
	/// # Parameters
	///
	/// - `&self`
	///
	/// # Returns
	///
	/// The number of bits in the slice domain that are set to `1`.
	///
	/// # Examples
	///
	/// Basic usage:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bits = bits![1, 1, 0, 0];
	/// assert_eq!(bits[.. 2].count_ones(), 2);
	/// assert_eq!(bits[2 ..].count_ones(), 0);
	/// ```
	pub fn count_ones(&self) -> usize {
		match self.domain() {
			Domain::Enclave { head, elem, tail } => (O::mask(head, tail)
				& elem.load_value())
			.into_inner()
			.count_ones() as usize,
			Domain::Region { head, body, tail } => {
				head.map_or(0, |(head, elem)| {
					(O::mask(head, None) & elem.load_value())
						.into_inner()
						.count_ones() as usize
				}) + body
					.iter()
					.map(BitStore::load_value)
					.map(|e| e.count_ones() as usize)
					.sum::<usize>() + tail.map_or(0, |(elem, tail)| {
					(O::mask(None, tail) & elem.load_value())
						.into_inner()
						.count_ones() as usize
				})
			},
		}
	}

	/// Counts the number of bits cleared to `0` in the slice contents.
	///
	/// # Parameters
	///
	/// - `&self`
	///
	/// # Returns
	///
	/// The number of bits in the slice domain that are cleared to `0`.
	///
	/// # Examples
	///
	/// Basic usage:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bits = bits![1, 1, 0, 0];
	/// assert_eq!(bits[.. 2].count_zeros(), 0);
	/// assert_eq!(bits[2 ..].count_zeros(), 2);
	/// ```
	pub fn count_zeros(&self) -> usize {
		match self.domain() {
			Domain::Enclave { head, elem, tail } => (!O::mask(head, tail)
				| elem.load_value())
			.into_inner()
			.count_zeros() as usize,
			Domain::Region { head, body, tail } => {
				head.map_or(0, |(head, elem)| {
					(!O::mask(head, None) | elem.load_value())
						.into_inner()
						.count_zeros() as usize
				}) + body
					.iter()
					.map(BitStore::load_value)
					.map(|e| e.count_zeros() as usize)
					.sum::<usize>() + tail.map_or(0, |(elem, tail)| {
					(!O::mask(None, tail) | elem.load_value())
						.into_inner()
						.count_zeros() as usize
				})
			},
		}
	}

	/// Enumerates all bits in a `BitSlice` that are set to `1`.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bits = bits![0, 1, 0, 0, 1, 0, 0, 0, 1];
	/// let mut indices = [1, 4, 8].iter().copied();
	///
	/// let mut iter_ones = bits.iter_ones();
	/// let mut compose = bits.iter()
	///   .copied()
	///   .enumerate()
	///   .filter_map(|(idx, bit)| if bit { Some(idx) } else { None });
	///
	/// for ((a, b), c) in iter_ones.zip(compose).zip(indices) {
	///   assert_eq!(a, b);
	///   assert_eq!(b, c);
	/// }
	/// ```
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn iter_ones(&self) -> IterOnes<O, T> {
		IterOnes::new(self)
	}

	/// Enumerates all bits in a `BitSlice` that are cleared to `0`.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bits = bits![1, 0, 1, 1, 0, 1, 1, 1, 0];
	/// let mut indices = [1, 4, 8].iter().copied();
	///
	/// let mut iter_zeros = bits.iter_zeros();
	/// let mut compose = bits.iter()
	///   .copied()
	///   .enumerate()
	///   .filter_map(|(idx, bit)| if !bit { Some(idx) } else { None });
	///
	/// for ((a, b), c) in iter_zeros.zip(compose).zip(indices) {
	///   assert_eq!(a, b);
	///   assert_eq!(b, c);
	/// }
	/// ```
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn iter_zeros(&self) -> IterZeros<O, T> {
		IterZeros::new(self)
	}

	/// Gets the index of the first bit in the bit-slice set to `1`.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// assert!(bits![].first_one().is_none());
	/// assert_eq!(bits![0, 0, 1].first_one().unwrap(), 2);
	/// ```
	#[inline]
	pub fn first_one(&self) -> Option<usize> {
		self.iter_ones().next()
	}

	/// Gets the index of the first bit in the bit-slice set to `0`.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// assert!(bits![].first_zero().is_none());
	/// assert_eq!(bits![1, 1, 0].first_zero().unwrap(), 2);
	/// ```
	#[inline]
	pub fn first_zero(&self) -> Option<usize> {
		self.iter_zeros().next()
	}

	/// Gets the index of the last bit in the bit-slice set to `1`.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// assert!(bits![].last_one().is_none());
	/// assert_eq!(bits![1, 0, 0, 1].last_one().unwrap(), 3);
	/// ```
	#[inline]
	pub fn last_one(&self) -> Option<usize> {
		self.iter_ones().next_back()
	}

	/// Gets the index of the last bit in the bit-slice set to `0`.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// assert!(bits![].last_zero().is_none());
	/// assert_eq!(bits![0, 1, 1, 0].last_zero().unwrap(), 3);
	/// ```
	#[inline]
	pub fn last_zero(&self) -> Option<usize> {
		self.iter_zeros().next_back()
	}

	/// Counts the number of bits from the start of the bit-slice to the first
	/// bit set to `0`.
	///
	/// This returns `0` if the bit-slice is empty.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// assert_eq!(bits![].leading_ones(), 0);
	/// assert_eq!(bits![0].leading_ones(), 0);
	/// assert_eq!(bits![1, 0, 1, 1].leading_ones(), 1);
	/// ```
	#[inline]
	pub fn leading_ones(&self) -> usize {
		self.first_zero().unwrap_or_default()
	}

	/// Counts the number of bits from the start of the bit-slice to the first
	/// bit set to `1`.
	///
	/// This returns `0` if the bit-slice is empty.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// assert_eq!(bits![].leading_zeros(), 0);
	/// assert_eq!(bits![1].leading_zeros(), 0);
	/// assert_eq!(bits![0, 1, 0, 0].leading_zeros(), 1);
	/// ```
	#[inline]
	pub fn leading_zeros(&self) -> usize {
		self.first_one().unwrap_or_default()
	}

	/// Counts the number of bits from the end of the bit-slice to the last bit
	/// set to `0`.
	///
	/// This returns `0` if the bit-slice is empty.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// assert_eq!(bits![].trailing_ones(), 0);
	/// assert_eq!(bits![0].trailing_ones(), 0);
	/// assert_eq!(bits![1, 0, 1, 1].trailing_ones(), 2);
	/// ```
	#[inline]
	pub fn trailing_ones(&self) -> usize {
		self.last_zero()
			.map(|idx| self.len() - 1 - idx)
			.unwrap_or_default()
	}

	/// Counts the number of bits from the end of the bit-slice to the last bit
	/// set to `1`.
	///
	/// This returns `0` if the bit-slice is empty.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// assert_eq!(bits![].trailing_zeros(), 0);
	/// assert_eq!(bits![1].trailing_zeros(), 0);
	/// assert_eq!(bits![0, 1, 0, 0].trailing_zeros(), 2);
	/// ```
	#[inline]
	pub fn trailing_zeros(&self) -> usize {
		self.last_one()
			.map(|idx| self.len() - 1 - idx)
			.unwrap_or_default()
	}

	/// Copies the bits from `src` into `self`.
	///
	/// The length of `src` must be the same as `self.
	///
	/// If `src` has the same type arguments as `self`, it can be more
	/// performant to use [`.copy_from_bitslice()`].
	///
	/// # Original
	///
	/// [`slice::clone_from_bitslice`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.clone_from_bitslice)
	///
	/// # API Differences
	///
	/// This method is renamed, as it takes a bit slice rather than an element
	/// slice.
	///
	/// # Panics
	///
	/// This function will panic if the two slices have different lengths.
	///
	/// # Examples
	///
	/// Cloning two bits from a slice into another:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let src = bits![Msb0, u16; 1; 4];
	/// let dst = bits![mut Lsb0, u8; 0; 2];
	///
	/// dst.clone_from_bitslice(&src[2 ..]);
	/// assert_eq!(dst, bits![1; 2]);
	/// ```
	///
	/// Rust enforces that there can only be one mutable reference with no
	/// immutable references to a particular piece of data in a particular
	/// scope. Because of this, attempting to use clone_from_slice on a single
	/// slice will result in a compile failure:
	///
	/// ```rust,compile_fail
	/// use bitvec::prelude::*;
	///
	/// let slice = bits![mut 0, 0, 0, 1, 1];
	/// slice[.. 2].clone_from_bitslice(&slice[3 ..]); // compile fail!
	/// ```
	///
	/// To work around this, we can use [`.split_at_mut()`] to create two
	/// distinct sub-slices from a slice:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let slice = bits![mut 0, 0, 0, 1, 1];
	///
	/// {
	///   let (left, right) = slice.split_at_mut(2);
	///   left.clone_from_bitslice(&right[1 ..]);
	/// }
	///
	/// assert_eq!(slice, bits![1, 1, 0, 1, 1]);
	/// ```
	///
	/// # Performance
	///
	/// If `self` and `src` use the same type arguments, this specializes to
	/// [`.copy_from_bitslice()`]; if you know statically that this is the case,
	/// prefer to call that method directly and avoid the cost of detection at
	/// runtime. Otherwise, this is a bit-by-bit crawl across both slices, which
	/// is a slow process.
	///
	/// [`.copy_from_bitslice()`]: Self::copy_from_bitslice
	/// [`.split_at_mut()`]: Self::split_at_mut
	#[inline]
	pub fn clone_from_bitslice<O2, T2>(&mut self, src: &BitSlice<O2, T2>)
	where
		O2: BitOrder,
		T2: BitStore,
	{
		assert_eq!(
			self.len(),
			src.len(),
			"Cloning between slices requires equal lengths"
		);

		if dvl::match_types::<O, T, O2, T2>() {
			let that = src as *const _ as *const _;
			unsafe {
				self.copy_from_bitslice(&*that);
			}
		}
		else {
			for (to, from) in
				self.as_mut_bitptr_range().zip(src.as_bitptr_range())
			{
				unsafe {
					to.write(from.read());
				}
			}
		}
	}

	/// Copies all bits from `src` into `self`, using a memcpy wherever
	/// possible.
	///
	/// The length of `src` must be same as `self`.
	///
	/// If `src` does not use the same type arguments as `self`, use
	/// [`.clone_from_bitslice()`].
	///
	/// # Original
	///
	/// [`slice::copy_from_slice`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.copy_from_slice)
	///
	/// # API Differences
	///
	/// This method is renamed, as it takes a bit slice rather than an element
	/// slice.
	///
	/// # Panics
	///
	/// This function will panic if the two slices have different lengths.
	///
	/// # Examples
	///
	/// Copying two bits from a slice into another:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let src = bits![1; 4];
	/// let dst = bits![mut 0; 2];
	///
	/// // Because the slices have to be the same length,
	/// // we slice the source slice from four bits to
	/// // two. It will panic if we don't do this.
	/// dst.clone_from_bitslice(&src[2..]);
	/// ```
	///
	/// Rust enforces that there can only be one mutable reference with no
	/// immutable references to a particular piece of data in a particular
	/// scope. Because of this, attempting to use [.copy_from_slice()] on a
	/// single slice will result in a compile failure:
	///
	/// ```rust,compile_fail
	/// use bitvec::prelude::*;
	///
	/// let slice = bits![mut 0, 0, 0, 1, 1];
	///
	/// slice[.. 2].copy_from_bitslice(&bits[3 ..]); // compile fail!
	/// ```
	///
	/// To work around this, we can use [`.split_at_mut()`] to create two
	/// distinct sub-slices from a slice:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let slice = bits![mut 0, 0, 0, 1, 1];
	///
	/// {
	///   let (left, right) = slice.split_at_mut(2);
	///   left.copy_from_bitslice(&right[1 ..]);
	/// }
	///
	/// assert_eq!(slice, bits![1, 1, 0, 1, 1]);
	/// ```
	///
	/// [`.clone_from_bitslice()`]: Self::clone_from_bitslice
	/// [`.split_at_mut()`]: Self::split_at_mut
	pub fn copy_from_bitslice(&mut self, src: &Self) {
		assert_eq!(
			self.len(),
			src.len(),
			"Copying between slices requires equal lengths"
		);

		let (d_head, s_head) =
			(self.as_bitspan().head(), src.as_bitspan().head());
		//  Where the two slices have identical layouts (head index and length),
		//  the copy can be done by using the memory domains.
		if d_head == s_head {
			match (self.domain_mut(), src.domain()) {
				(
					DomainMut::Enclave {
						elem: d_elem, tail, ..
					},
					Domain::Enclave { elem: s_elem, .. },
				) => {
					let mask = O::mask(d_head, tail);
					d_elem.clear_bits(mask);
					d_elem.set_bits(mask & s_elem.load_value());
				},
				(
					DomainMut::Region {
						head: d_head,
						body: d_body,
						tail: d_tail,
					},
					Domain::Region {
						head: s_head,
						body: s_body,
						tail: s_tail,
					},
				) => {
					if let (Some((h_idx, dh_elem)), Some((_, sh_elem))) =
						(d_head, s_head)
					{
						let mask = O::mask(h_idx, None);
						dh_elem.clear_bits(mask);
						dh_elem.set_bits(mask & sh_elem.load_value());
					}
					for (dst, src) in d_body.iter_mut().zip(s_body.iter()) {
						dst.store_value(src.load_value())
					}
					if let (Some((dt_elem, t_idx)), Some((st_elem, _))) =
						(d_tail, s_tail)
					{
						let mask = O::mask(None, t_idx);
						dt_elem.clear_bits(mask);
						dt_elem.set_bits(mask & st_elem.load_value());
					}
				},
				_ => unreachable!(
					"Slices with equal type parameters, lengths, and heads \
					 will always have equal domains"
				),
			}
		}
		/* TODO(myrrlyn): Remove this when specialization stabilizes.

		This section simulates access to specialization through partial
		type-argument application. It detects accelerable type arguments (`O`
		values provided by `bitvec`, where `BitSlice<O, _>` implements
		`BitField`) and uses their batch load/store behavior to move more than
		one bit per cycle.

		Without language-level specialization, we cannot dispatch to
		individually well-typed functions, so instead this block uses the
		compiler’s `TypeId` API to inspect the type arguments passed to a
		monomorphization and select the appropriate codegen for it. We know that
		control will only enter any of these subsequent blocks when the type
		argument to monomorphization matches the guard, so the pointer casts
		become the identity function, which is safe and correct.

		This is only safe to do in `.copy_from_bitslice()`, not in
		`.clone_from_bitslice()`, because `BitField`’s behavior will only be
		correct when the two slices are matching in both their ordering and
		storage type arguments. Mismatches will cause an observed shuffling of
		sections as `BitField` reïnterprets raw bytes according to the machine
		register selected.
		*/
		else if dvl::match_order::<O, Lsb0>() {
			let this: &mut BitSlice<Lsb0, T> =
				unsafe { &mut *(self as *mut _ as *mut _) };
			let that: &BitSlice<Lsb0, T> =
				unsafe { &*(src as *const _ as *const _) };
			this.sp_copy_from_bitslice(that);
		}
		else if dvl::match_order::<O, Msb0>() {
			let this: &mut BitSlice<Msb0, T> =
				unsafe { &mut *(self as *mut _ as *mut _) };
			let that: &BitSlice<Msb0, T> =
				unsafe { &*(src as *const _ as *const _) };
			this.sp_copy_from_bitslice(that);
		}
		else {
			for (from, to) in
				src.as_bitptr_range().zip(self.as_mut_bitptr_range())
			{
				unsafe {
					to.write(from.read());
				}
			}
		}
	}

	/// Swaps all bits in `self` with those in `other`.
	///
	/// The length of `other` must be the same as `self`.
	///
	/// # Original
	///
	/// [`slice::swap_with_slice`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.swap_with_slice)
	///
	/// # API Differences
	///
	/// This method is renamed, as it takes a bit slice rather than an element
	/// slice.
	///
	/// # Panics
	///
	/// This function will panic if the two slices have different lengths.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut one = [0xA5u8, 0x69];
	/// let mut two = 0x1234u16;
	/// let one_bits = one.view_bits_mut::<Msb0>();
	/// let two_bits = two.view_bits_mut::<Lsb0>();
	///
	/// one_bits.swap_with_bitslice(two_bits);
	///
	/// assert_eq!(one, [0x2C, 0x48]);
	/// # #[cfg(target_endian = "little")] {
	/// assert_eq!(two, 0x96A5);
	/// # }
	/// ```
	#[inline]
	pub fn swap_with_bitslice<O2, T2>(&mut self, other: &mut BitSlice<O2, T2>)
	where
		O2: BitOrder,
		T2: BitStore,
	{
		let len = self.len();
		assert_eq!(len, other.len());
		for (a, b) in self.as_mut_bitptr_range().zip(other.as_mut_bitptr_range())
		{
			unsafe {
				a.swap(b);
			}
		}
	}

	/// Shifts the contents of a bit-slice left (towards index `0`).
	///
	/// This moves the contents of the slice from `by ..` down to
	/// `0 .. len - by`, and erases `len - by ..` to `0`. As this is a
	/// destructive (and linearly expensive) operation, you may prefer instead
	/// to use range subslicing.
	///
	/// # Parameters
	///
	/// - `&mut self`
	/// - `by`: The distance by which to shift the slice contents.
	///
	/// # Panics
	///
	/// This panics if `by` is not less than `self.len()`.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bits = bits![mut 1; 6];
	/// bits.shift_left(2);
	/// assert_eq!(bits, bits![1, 1, 1, 1, 0, 0]);
	/// ```
	#[inline]
	pub fn shift_left(&mut self, by: usize) {
		let len = self.len();
		if by == 0 {
			return;
		}
		assert!(
			by < len,
			"Cannot shift a slice by more than its length: {} exceeds {}",
			by,
			len
		);

		unsafe {
			self.copy_within_unchecked(by .., 0);
			let trunc = len - by;
			self.get_unchecked_mut(trunc ..).set_all(false);
		}
	}

	/// Shifts the contents of a bit-slice right (towards index `self.len()`).
	///
	/// This moves the contents of the slice from `.. len - by` up to `by ..`,
	/// and erases `.. by` to `0`. As this is a destructive (and linearly
	/// expensive) operation, you may prefer instead to use range subslicing.
	///
	/// # Parameters
	///
	/// - `&mut self`
	/// - `by`: The distance by which to shift the slice contents.
	///
	/// # Panics
	///
	/// This panics if `by` is not less than `self.len()`.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bits = bits![mut 1; 6];
	/// bits.shift_right(2);
	/// assert_eq!(bits, bits![0, 0, 1, 1, 1, 1]);
	/// ```
	#[inline]
	pub fn shift_right(&mut self, by: usize) {
		let len = self.len();
		if by == 0 {
			return;
		}
		assert!(
			by < len,
			"Cannot shift a slice by more than its length: {} exceeds {}",
			by,
			len
		);

		let trunc = len - by;
		unsafe {
			self.copy_within_unchecked(.. trunc, by);
			self.get_unchecked_mut(.. by).set_all(false);
		}
	}

	/// Sets all bits in the slice to a value.
	///
	/// # Parameters
	///
	/// - `&mut self`
	/// - `value`: The bit value to which all bits in the slice will be set.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut src = 0u8;
	/// let bits = src.view_bits_mut::<Msb0>();
	/// bits[2 .. 6].set_all(true);
	/// assert_eq!(bits.as_raw_slice(), &[0b0011_1100]);
	/// bits[3 .. 5].set_all(false);
	/// assert_eq!(bits.as_raw_slice(), &[0b0010_0100]);
	/// bits[.. 1].set_all(true);
	/// assert_eq!(bits.as_raw_slice(), &[0b1010_0100]);
	/// ```
	pub fn set_all(&mut self, value: bool) {
		//  Grab the function pointers used to commit bit-masks into memory.
		let setter = <T::Access>::get_writers(value);
		match self.domain_mut() {
			DomainMut::Enclave { head, elem, tail } => {
				setter(elem, O::mask(head, tail));
			},
			DomainMut::Region { head, body, tail } => {
				if let Some((head, elem)) = head {
					setter(elem, O::mask(head, None));
				}
				//  loop assignment is `memset`’s problem, not ours
				unsafe {
					ptr::write_bytes(
						body.as_mut_ptr(),
						[0, !0][value as usize],
						body.len(),
					);
				}
				if let Some((elem, tail)) = tail {
					setter(elem, O::mask(None, tail));
				}
			},
		}
	}

	/// Applies a function to each bit in the slice.
	///
	/// `BitSlice` cannot implement [`IndexMut`], as it cannot manifest `&mut
	/// bool` references, and the [`BitRef`] proxy reference has an unavoidable
	/// overhead. This method bypasses both problems, by applying a function to
	/// each pair of index and value in the slice, without constructing a proxy
	/// reference. Benchmarks indicate that this method is about 2–4 times
	/// faster than the `.iter_mut().enumerate()` equivalent.
	///
	/// # Parameters
	///
	/// - `&mut self`
	/// - `func`: A function which receives two arguments, `index: usize` and
	///   `value: bool`, and returns a `bool`.
	///
	/// # Effects
	///
	/// For each index in the slice, the result of invoking `func` with the
	/// index number and current bit value is written into the slice.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut data = 0u8;
	/// let bits = data.view_bits_mut::<Msb0>();
	/// bits.for_each(|idx, _bit| idx % 3 == 0);
	/// assert_eq!(data, 0b100_100_10);
	/// ```
	///
	/// [`BitRef`]: crate::ptr::BitRef
	/// [`IndexMut`]: core::ops::IndexMut
	#[inline]
	pub fn for_each<F>(&mut self, mut func: F)
	where F: FnMut(usize, bool) -> bool {
		for (idx, ptr) in self.as_mut_bitptr_range().enumerate() {
			unsafe {
				ptr.write(func(idx, ptr.read()));
			}
		}
	}

	/// Produces the absolute offset in bits between two slice heads.
	///
	/// While this method is sound for any two arbitrary bit slices, the answer
	/// it produces is meaningful *only* when one argument is a strict subslice
	/// of the other. If the two slices are created from different buffers
	/// entirely, a comparison is undefined; if the two slices are disjoint
	/// regions of the same buffer, then the semantically correct distance is
	/// between the tail of the lower and the head of the upper, which this
	/// does not measure.
	///
	/// # Visual Description
	///
	/// Consider the following sequence of bits:
	///
	/// ```text
	/// [ 0 1 2 3 4 5 6 7 8 9 a b ]
	///   |       ^^^^^^^       |
	///   ^^^^^^^^^^^^^^^^^^^^^^^
	/// ```
	///
	/// It does not matter whether there are bits between the tail of the
	/// smaller and the larger slices. The offset is computed from the bit
	/// distance between the two heads.
	///
	/// # Behavior
	///
	/// This function computes the *semantic* distance between the heads, rather
	/// than the *electrical. It does not take into account the `BitOrder`
	/// implementation of the slice.
	///
	/// # Safety and Soundness
	///
	/// One of `self` or `other` must contain the other for this comparison to
	/// be meaningful.
	///
	/// # Parameters
	///
	/// - `&self`
	/// - `other`: Another bit slice. This must be either a strict subregion or
	///   a strict superregion of `self`.
	///
	/// # Returns
	///
	/// The distance in (semantic) bits betwen the heads of each region. The
	/// value is positive when `other` is higher in the address space than
	/// `self`, and negative when `other` is lower in the address space than
	/// `self`.
	#[inline]
	pub fn offset_from(&self, other: &Self) -> isize {
		unsafe { other.as_bitptr().offset_from(self.as_bitptr()) }
	}

	#[doc(hidden)]
	#[inline(never)]
	#[deprecated = "Use `BitPtr::offset_from`"]
	pub fn electrical_distance(&self, _other: &Self) -> isize {
		unimplemented!(
			"This no longer exists! Offsets are only defined between two \
			 bit-pointers in the same bit-region, and `bitvec` considers two \
			 regions with different orderings, *even if they cover the same \
			 locations*, to be different. Use `BitPtr::offset_from`."
		);
	}
}

/// Unchecked variants of checked accessors.
impl<O, T> BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// Writes a new bit at a given index, without doing bounds checking.
	///
	/// This is generally not recommended; use with caution! Calling this method
	/// with an out-of-bounds index is *[undefined behavior]*. For a safe
	/// alternative, see [`.set()`].
	///
	/// # Parameters
	///
	/// - `&mut self`
	/// - `index`: The bit index at which to write. It must be in the range `0
	///   .. self.len()`.
	/// - `value`: The value to be written; `true` for `1` or `false` for `0`.
	///
	/// # Effects
	///
	/// The bit at `index` is set to `value`. If `index` is out of bounds, then
	/// the memory access is incorrect, and its behavior is unspecified.
	///
	/// # Safety
	///
	/// This method is **not** safe. It performs raw pointer arithmetic to seek
	/// from the start of the slice to the requested index, and set the bit
	/// there. It does not inspect the length of `self`, and it is free to
	/// perform out-of-bounds memory *write* access.
	///
	/// Use this method **only** when you have already performed the bounds
	/// check, and can guarantee that the call occurs with a safely in-bounds
	/// index.
	///
	/// # Examples
	///
	/// This example uses a bit slice of length 2, and demonstrates
	/// out-of-bounds access to the last bit in the element.
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bits = bits![mut 0; 2];
	/// let (first, _) = bits.split_at_mut(1);
	///
	/// unsafe {
	///   first.set_unchecked(1, true);
	/// }
	///
	/// assert_eq!(bits, bits![0, 1]);
	/// ```
	///
	/// [`self.len()`]: Self::len
	/// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html
	/// [`.set()`]: Self::set
	#[inline]
	pub unsafe fn set_unchecked(&mut self, index: usize, value: bool) {
		self.as_mut_bitptr().add(index).write(value);
	}

	/// Swaps two bits in the slice.
	///
	/// See [`.swap()`].
	///
	/// # Safety
	///
	/// `a` and `b` must both be less than [`self.len()`].
	///
	/// [`self.len()`]: Self::len
	/// [`.swap()`]: Self::swap
	#[inline]
	pub unsafe fn swap_unchecked(&mut self, a: usize, b: usize) {
		let a = self.as_mut_bitptr().add(a);
		let b = self.as_mut_bitptr().add(b);
		a.swap(b);
	}

	/// Divides one slice into two at an index, without performing any bounds
	/// checking.
	///
	/// See [`.split_at()`].
	///
	/// # Safety
	///
	/// `mid` must not be greater than [`self.len()`]. If this condition is
	/// violated, the function behavior is *unspecified*.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bits = bits![0, 0, 0, 1, 1, 1];
	/// let (l, r) = unsafe { bits.split_at_unchecked(3) };
	/// assert!(l.not_any());
	/// assert!(r.all());
	///
	/// let (l, r) = unsafe { bits.split_at_unchecked(6) };
	/// assert_eq!(l, bits);
	/// assert!(r.is_empty());
	/// ```
	///
	/// [`self.len()`]: Self::len
	/// [`.split_at()`]: Self::split_at
	#[inline]
	pub unsafe fn split_at_unchecked(&self, mid: usize) -> (&Self, &Self) {
		(self.get_unchecked(.. mid), self.get_unchecked(mid ..))
	}

	/// Divides one mutable slice into two at an index.
	///
	/// See [`.split_at_mut()`].
	///
	/// # Safety
	///
	/// `mid` must not be greater than [`self.len()`].
	///
	/// [`self.len()`]: Self::len
	/// [`.split_at_mut()`]: Self::split_at_mut
	#[inline]
	#[allow(clippy::type_complexity)]
	pub unsafe fn split_at_unchecked_mut(
		&mut self,
		mid: usize,
	) -> (&mut BitSlice<O, T::Alias>, &mut BitSlice<O, T::Alias>) {
		let bp = self.alias_mut().as_mut_bitspan();
		(
			bp.to_bitslice_mut().get_unchecked_mut(.. mid),
			bp.to_bitslice_mut().get_unchecked_mut(mid ..),
		)
	}

	/// Copies bits from one part of the slice to another part of itself,
	/// without doing bounds checks.
	///
	/// The ranges are allowed to overlap.
	///
	/// # Parameters
	///
	/// - `&mut self`
	/// - `src`: The range within `self` from which to copy.
	/// - `dst`: The starting index within `self` at which to paste.
	///
	/// # Effects
	///
	/// `self[src]` is copied to `self[dest .. dest + src.end() - src.start()]`.
	///
	/// # Safety
	///
	/// `src` and `dest .. dest + src.len()` must be entirely within
	/// [`self.len()`].
	///
	/// [`self.len()`]: Self::len
	pub unsafe fn copy_within_unchecked<R>(&mut self, src: R, dest: usize)
	where R: RangeBounds<usize> {
		if dvl::match_order::<O, Lsb0>() {
			let this: &mut BitSlice<Lsb0, T> = &mut *(self as *mut _ as *mut _);
			this.sp_copy_within_unchecked(src, dest);
		}
		else if dvl::match_order::<O, Msb0>() {
			let this: &mut BitSlice<Msb0, T> = &mut *(self as *mut _ as *mut _);
			this.sp_copy_within_unchecked(src, dest);
		}
		else {
			let source = dvl::normalize_range(src, self.len());
			let source_len = source.len();
			let rev = source.contains(&dest);
			let iter = self.get_unchecked(source).as_bitptr_range().zip(
				self.get_unchecked_mut(dest .. dest + source_len)
					.as_mut_bitptr_range(),
			);
			if rev {
				for (from, to) in iter.rev() {
					to.write(from.read());
				}
			}
			else {
				for (from, to) in iter {
					to.write(from.read());
				}
			}
		}
	}
}

/// View conversions.
#[cfg(not(tarpaulin_include))]
impl<O, T> BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// Returns a raw bit-pointer to the base of the bit-slice’s region.
	///
	/// The caller must ensure that the bit-slice outlives the bit-pointer this
	/// function returns, or else it will end up pointing to garbage.
	///
	/// The caller must also ensure that the memory the bit-pointer
	/// (non-transitively) points to is never written to using this bit-pointer
	/// or any bit-pointer derived from it. If you need to mutate the contents
	/// of the slice, use [`.as_mut_bitptr()`].
	///
	/// Modifying the container referenced by this bit-slice may cause its
	/// buffer to be reällocated, which would also make any bit-pointers to it
	/// invalid.
	///
	/// # Original
	///
	/// [`slice::as_ptr`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.as_ptr)
	///
	/// # API Differences
	///
	/// This returns a structure, [`BitPtr`], rather than an actual raw pointer
	/// `*Bit`. The information required to address a bit within a memory
	/// element cannot be encoded into a single pointer.
	///
	/// This structure can be converted back into a `&BitSlice` with the
	/// function [`from_raw_parts`].
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let x = bits![0, 0, 1];
	/// let x_ptr = x.as_ptr();
	///
	/// unsafe {
	///   for i in 0 .. x.len() {
	///     assert_eq!(*x.get_unchecked(i), (&*x)[i]);
	///   }
	/// }
	/// ```
	///
	/// [`.as_mut_bitptr()`]: Self::as_mut_bitptr
	/// [`from_raw_parts`]: crate::slice::from_raw_parts
	#[inline(always)]
	pub fn as_bitptr(&self) -> BitPtr<Const, O, T> {
		self.as_bitspan().as_bitptr()
	}

	/// Returns an unsafe mutable bit-pointer to the bit-slice’s region.
	///
	/// The caller must ensure that the bit-slice outlives the bit-pointer this
	/// function returns, or else it will end up pointing to garbage.
	///
	/// Modifying the container referenced by this bit-slice may cause its
	/// buffer to be reällocated, which would also make any bit-pointers to it
	/// invalid.
	///
	/// # Original
	///
	/// [`slice::as_mut_ptr`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.as_mut_ptr)
	///
	/// # API Differences
	///
	/// This returns `*mut BitSlice`, which is the equivalont of `*mut [T]`
	/// instead of `*mut T`. The pointer encoding used requires more than one
	/// CPU word of space to address a single bit, so there is no advantage to
	/// removing the length information from the encoded pointer value.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bits = bits![mut Lsb0, u8; 0; 8];
	/// let bits_ptr = bits.as_mut_ptr();
	///
	/// for i in 0 .. bits.len() {
	///   unsafe {
	///     bits_ptr.add(i).write(i % 3 == 0);
	///   }
	/// }
	/// assert_eq!(bits.as_raw_slice()[0], 0b0100_1001);
	/// ```
	#[inline(always)]
	pub fn as_mut_bitptr(&mut self) -> BitPtr<Mut, O, T> {
		self.as_mut_bitspan().as_bitptr()
	}

	/// Returns the two raw bit-pointers spanning the bit-slice.
	///
	/// The returned range is half-open, which means that the end bit-pointer
	/// points *one past* the last bit of the bit-slice. This way, an empty
	/// bit-slice is represented by two equal bit-pointers, and the difference
	/// between the two bit-pointers represents the size of the bit-slice.
	///
	/// See [`as_bitptr`] for warnings on using these bit-pointers. The end
	/// bit-pointer requires extra caution, as it does not point to a valid bit
	/// in the bit-slice.
	///
	/// This function allows a more direct access to bit-pointers, without
	/// paying the cost of encoding into a `*BitSlice`, at the cost of no longer
	/// fitting into ordinary Rust interfaces.
	///
	/// # Original
	///
	/// [`slice::as_ptr_range`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.as_ptr_range)
	///
	/// # API Differences
	///
	/// This returns a dedicated structure, rather than a range of [`BitPtr`]s,
	/// because the traits needed for non-`core` types to correctly operate in
	/// ranges are still unstable. The structure can be converted into a range,
	/// but that range will not be an iterator.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bits = bits![0, 1, 0, 0, 1];
	/// let mid_ptr = bits.get(2).unwrap().into_bitptr();
	/// let mut range = bits.as_bitptr_range();
	/// assert!(range.contains(&mid_ptr));
	/// unsafe {
	///   assert!(!range.next().unwrap().read());
	///   assert!(range.next_back().unwrap().read())
	/// }
	/// ```
	///
	/// [`BitPtr`]: crate::ptr::BitPtr
	/// [`as_bitptr`]: Self::as_bitptr
	#[inline(always)]
	pub fn as_bitptr_range(&self) -> BitPtrRange<Const, O, T> {
		self.as_bitspan().as_bitptr_range()
	}

	/// Returns the two unsafe mutable bit-pointers spanning the bit-slice.
	///
	/// The returned range is half-open, which means that the end bit-pointer
	/// points *one past* the last bitt of the bit-slice. This way, an empty
	/// bit-slice is represented by two equal bit-pointers, and the difference
	/// between the two bit-pointers represents the size of the bit-slice.
	///
	/// See [`as_mut_bitptr`] for warnings on using these bit-pointers. The end
	/// bit-pointer requires extra caution, as it does not point to a valid bit
	/// in the bit-slice.
	///
	/// # Original
	///
	/// [`slice::as_mut_ptr_range`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.as_mut_ptr_range)
	///
	/// # API Differences
	///
	/// This returns a dedicated structure, rather than a range of [`BitPtr`]s,
	/// because the traits needed for non-`core` types to correctly operate in
	/// ranges are still unstable. The structure can be converted into a range,
	/// but that range will not be an iterator.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	/// use bitvec::ptr as bv_ptr;
	///
	/// let mut data = 0u8;
	/// let bits = data.view_bits_mut::<Msb0>();
	/// for mut bitptr in bits.as_mut_bitptr_range() {
	///   unsafe { bv_ptr::write(bitptr, true); }
	/// }
	/// assert_eq!(data, !0);
	/// ```
	///
	/// [`BitPtr`]: crate::ptr::BitPtr
	/// [`as_mut_bitptr`]: Self::as_mut_bitptr
	#[inline(always)]
	pub fn as_mut_bitptr_range(&mut self) -> BitPtrRange<Mut, O, T> {
		self.as_mut_bitspan().as_bitptr_range()
	}

	/// Splits the slice into subslices at alias boundaries.
	///
	/// This splits `self` into the memory locations that it partially fills and
	/// the memory locations that it completely fills. The locations that are
	/// completely filled may be accessed without any `bitvec`-imposed alias
	/// conditions, while the locations that are only partially filled are left
	/// unchanged.
	///
	/// You can read more about the [`BitDomain`] splitting in its
	/// documentation.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut data = [0u16; 3];
	/// let all = data.view_bits_mut::<Msb0>();
	/// let (_, rest) = all.split_at_mut(8);
	/// let bits: &BitSlice<Msb0, <u16 as BitStore>::Alias> = &rest[.. 32];
	///
	/// let (head, body, tail) = bits
	///   .bit_domain()
	///   .region()
	///   .unwrap();
	/// assert_eq!(head.len(), 8);
	/// assert_eq!(tail.len(), 8);
	/// let _: &BitSlice<Msb0, <u16 as BitStore>::Alias> = head;
	/// let _: &BitSlice<Msb0, <u16 as BitStore>::Alias> = tail;
	/// let _: &BitSlice<Msb0, u16> = body;
	/// ```
	///
	/// [`BitDomain`]: crate::domain::BitDomain
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn bit_domain(&self) -> BitDomain<O, T> {
		BitDomain::new(self)
	}

	/// Splits the slice into subslices at alias boundaries.
	///
	/// This splits `self` into the memory locations that it partially fills and
	/// the memory locations that it completely fills. The locations that are
	/// completely filled may be accessed without any `bitvec`-imposed alias
	/// conditions, while the locations that are only partially filled are left
	/// unchanged.
	///
	/// You can read more about the [`BitDomainMut`] splitting in its
	/// documentation.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut data = [0u16; 3];
	/// let all = data.view_bits_mut::<Msb0>();
	/// let (_, rest) = all.split_at_mut(8);
	/// let bits: &mut BitSlice<Msb0, <u16 as BitStore>::Alias>
	///   = &mut rest[.. 32];
	///
	/// let (head, body, tail) = bits
	///   .bit_domain_mut()
	///   .region()
	///   .unwrap();
	/// assert_eq!(head.len(), 8);
	/// assert_eq!(tail.len(), 8);
	/// let _: &mut BitSlice<Msb0, <u16 as BitStore>::Alias> = head;
	/// let _: &mut BitSlice<Msb0, <u16 as BitStore>::Alias> = tail;
	/// let _: &mut BitSlice<Msb0, u16> = body;
	/// ```
	///
	/// [`BitDomainMut`]: crate::domain::BitDomainMut
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn bit_domain_mut(&mut self) -> BitDomainMut<O, T> {
		BitDomainMut::new(self)
	}

	/// Views the underlying memory containing the slice, split at alias
	/// boundaries.
	///
	/// This splits `self` into the memory locations that it partially fills and
	/// the memory locatinos that it completely fills. The locations that are
	/// completely filled may be accessed without any `bitvec`-imposed alias
	/// conditions, while the locations that are only partially filled are left
	/// unchanged.
	///
	/// You can read more about the [`Domain`] splitting in its documentation.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut data = [0u16; 3];
	/// let all = data.view_bits_mut::<Msb0>();
	/// let (_, rest) = all.split_at_mut(8);
	/// let bits: &BitSlice<Msb0, <u16 as BitStore>::Alias> = &rest[.. 32];
	///
	/// let (head, body, tail) = bits
	///   .domain()
	///   .region()
	///   .unwrap();
	/// assert_eq!(body.len(), 1);
	///
	/// let _: &<u16 as BitStore>::Alias = head.unwrap().1;
	/// let _: &<u16 as BitStore>::Alias = tail.unwrap().0;
	/// let _: &[u16] = body;
	/// ```
	///
	/// [`Domain`]: crate::domain::Domain
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn domain(&self) -> Domain<T> {
		Domain::new(self)
	}

	/// Views the underlying memory containing the slice, split at alias
	/// boundaries.
	///
	/// This splits `self` into the memory locations that it partially fills and
	/// the memory locations that it completely fills. The locations that are
	/// completely filled may be accessed without any `bitvec`-imposed alias
	/// conditions, while the locations that are only partially filled are left
	/// unchanged.
	///
	/// You can read more about the [`DomainMut`] splitting in its
	/// documentation.
	///
	/// # Examples
	///
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut data = [0u16; 3];
	/// let all = data.view_bits_mut::<Msb0>();
	/// let (_, rest) = all.split_at_mut(8);
	/// let bits: &mut BitSlice<Msb0, <u16 as BitStore>::Alias> = &mut rest[.. 32];
	///
	/// let (head, body, tail) = bits
	///   .domain_mut()
	///   .region()
	///   .unwrap();
	/// assert_eq!(body.len(), 1);
	///
	/// let _: &<<u16 as BitStore>::Alias as BitStore>::Access = head.unwrap().1;
	/// let _: &<<u16 as BitStore>::Alias as BitStore>::Access = tail.unwrap().0;
	/// let _: &mut [u16] = body;
	/// ```
	///
	/// [`DomainMut`]: crate::domain::DomainMut
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn domain_mut(&mut self) -> DomainMut<T> {
		DomainMut::new(self)
	}

	/// Views the underlying memory containing the slice.
	///
	/// The returned slice handle views all elements touched by `self`, and
	/// marks them all with `self`’s current aliasing state. For a more precise
	/// view, or one that permits mutation, use [`.domain()`] or
	/// [`.domain_mut()`].
	///
	/// [`.domain()`]: Self::domain
	/// [`.domain_mut()`]: Self::domain_mut
	#[inline]
	pub fn as_raw_slice(&self) -> &[T] {
		let bitspan = self.as_bitspan();
		let (base, elts) = (bitspan.address().to_const(), bitspan.elements());
		unsafe { slice::from_raw_parts(base, elts) }
	}
}

/// Crate-internal functions.
impl<O, T> BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// Type-cast the slice reference to its pointer structure.
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub(crate) fn as_bitspan(&self) -> BitSpan<Const, O, T> {
		BitSpan::from_bitslice_ptr(self)
	}

	/// Type-cast the slice reference to its pointer structure.
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub(crate) fn as_mut_bitspan(&mut self) -> BitSpan<Mut, O, T> {
		BitSpan::from_bitslice_ptr_mut(self)
	}

	/// Asserts that `index` is not out of `bounds`.
	///
	/// # Parameters
	///
	/// - `&self`
	/// - `index`: The index to test against [`self.len()`].
	/// - `bounds`: Bounds to check.
	///
	/// # Panics
	///
	/// This method panics if `bounds` doesn't contain the `index`.
	#[inline]
	#[cfg(not(tarpaulin_include))]
	pub(crate) fn assert_in_bounds<R>(&self, index: usize, bounds: R)
	where R: RangeBounds<usize> {
		assert!(
			bounds.contains(&index),
			"Index {} out of range: {:?}",
			index,
			bounds.end_bound()
		);
	}

	/// Marks an immutable slice as referring to aliased memory region.
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub(crate) fn alias(&self) -> &BitSlice<O, T::Alias> {
		self.as_bitspan().cast::<T::Alias>().to_bitslice_ref()
	}

	/// Marks a mutable slice as describing an aliased memory region.
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub(crate) fn alias_mut(&mut self) -> &mut BitSlice<O, T::Alias> {
		self.as_mut_bitspan().cast::<T::Alias>().to_bitslice_mut()
	}

	/// Removes the aliasing marker from a mutable slice handle.
	///
	/// # Safety
	///
	/// This must only be used when the slice is either known to be unaliased,
	/// or this call is combined with an operation that adds an aliasing marker
	/// and the total number of aliasing markers must remain unchanged.
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub(crate) unsafe fn unalias_mut(
		this: &mut BitSlice<O, T::Alias>,
	) -> &mut Self {
		this.as_mut_bitspan().cast::<T>().to_bitslice_mut()
	}

	/// Splits a mutable slice at some mid-point, without checking boundary
	/// conditions or adding an alias marker.
	///
	/// This method has the same behavior as [`.split_at_unchecked_mut()`],
	/// except that it does not apply an aliasing marker to the partitioned
	/// subslices.
	///
	/// # Safety
	///
	/// See [`.split_at_unchecked_mut()`] for safety requirements.
	///
	/// Additionally, this is only safe when `T` is alias-safe.
	///
	/// [`.split_at_unchecked_mut()`]: Self::split_at_unchecked_mut
	#[inline]
	pub(crate) unsafe fn split_at_unchecked_mut_noalias(
		&mut self,
		mid: usize,
	) -> (&mut Self, &mut Self) {
		//  Split the slice at the requested midpoint, adding an alias layer
		let (head, tail) = self.split_at_unchecked_mut(mid);
		//  Remove the new alias layer.
		(Self::unalias_mut(head), Self::unalias_mut(tail))
	}
}

/// Methods available only when `T` allows shared mutability.
impl<O, T> BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore + Radium,
{
	/// Writes a new bit at a given index.
	///
	/// This method supports writing through a shared reference to a bit that
	/// may be observed by other `BitSlice` handles. It is only present when the
	/// `T` type parameter supports such shared mutation (measured by the
	/// [`Radium`] trait).
	///
	/// # Parameters
	///
	/// - `&self`
	/// - `index`: The bit index at which to write. It must be in the range `0
	///   .. self.len()`.
	/// - `value`: The value to be written; `true` for `1` or `false` for `0`.
	///
	/// # Effects
	///
	/// If `index` is valid, then the bit to which it refers is set to `value`.
	/// If `T` is an [atomic], this will lock the memory bus for the referent
	/// address, and may cause stalls.
	///
	/// # Panics
	///
	/// This method panics if `index` is not less than [`self.len()`].
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	/// use core::cell::Cell;
	///
	/// let byte = Cell::new(0u8);
	/// let bits = byte.view_bits::<Msb0>();
	/// let bits_2 = bits;
	///
	/// bits.set_aliased(1, true);
	/// assert!(bits_2[1]);
	/// ```
	///
	/// This example panics when it attempts to set a bit that is out of bounds.
	///
	/// ```rust,should_panic
	/// use bitvec::prelude::*;
	/// use core::cell::Cell;
	///
	/// let byte = Cell::new(0u8);
	/// let bits = byte.view_bits::<Lsb0>();
	/// bits.set_aliased(8, false);
	/// ```
	///
	/// [atomic]: core::sync::atomic
	/// [`Radium`]: radium::Radium
	/// [`self.len()`]: Self::len
	#[inline]
	pub fn set_aliased(&self, index: usize, value: bool) {
		self.assert_in_bounds(index, 0 .. self.len());
		unsafe {
			self.set_aliased_unchecked(index, value);
		}
	}

	/// Writes a new bit at a given index, without doing bounds checking.
	///
	/// This method supports writing through a shared reference to a bit that
	/// may be observed by other `BitSlice` handles. It is only present when the
	/// `T` type parameter supports such shared mutation (measured by the
	/// [`Radium`] trait).
	///
	/// # Effects
	///
	/// The bit at `index` is set to `value`. If `index` is out of bounds, then
	/// the memory access is incorrect, and its behavior is unspecified. If `T`
	/// is an [atomic], this will lock the memory bus for the referent
	/// address, and may cause stalls.
	///
	/// # Safety
	///
	/// This method is **not** safe. It performs raw pointer arithmetic to seek
	/// from the start of the slice to the requested index, and set the bit
	/// there. It does not inspect the length of `self`, and it is free to
	/// perform out-of-bounds memory *write* access.
	///
	/// Use this method **only** when you have already performed the bounds
	/// check, and can guarantee that the call occurs with a safely in-bounds
	/// index.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	/// use core::cell::Cell;
	///
	/// let byte = Cell::new(0u8);
	/// let bits = byte.view_bits::<Msb0>();
	/// let bits_2 = bits;
	///
	/// let (first, _) = bits.split_at(1);
	/// assert_eq!(first.len(), 1);
	/// unsafe { first.set_aliased_unchecked(2, true); }
	///
	/// assert!(bits_2[2]);
	/// ```
	///
	/// [atomic]: core::sync::atomic
	/// [`Radium`]: radium::Radium
	#[inline]
	pub unsafe fn set_aliased_unchecked(&self, index: usize, value: bool) {
		self.as_bitptr().add(index).freeze().frozen_write_bit(value);
	}

	/// Splits a mutable slice at some mid-point.
	///
	/// This method has the same behavior as [`.split_at_mut()`], except that it
	/// does not apply an aliasing marker to the partitioned subslices.
	///
	/// # Safety
	///
	/// Because this method is defined only on `BitSlice`s whose `T` type is
	/// alias-safe, the subslices do not need to be additionally marked.
	///
	/// [`.split_at_mut()`]: Self::split_at_mut
	#[inline]
	pub fn split_at_aliased_mut(
		&mut self,
		mid: usize,
	) -> (&mut Self, &mut Self) {
		let (head, tail) = self.split_at_mut(mid);
		unsafe { (Self::unalias_mut(head), Self::unalias_mut(tail)) }
	}
}

/// Miscellaneous information.
impl<O, T> BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// The inclusive maximum length of a `BitSlice<_, T>`.
	///
	/// As `BitSlice` is zero-indexed, the largest possible index is one less
	/// than this value.
	///
	/// |CPU word width|         Value         |
	/// |-------------:|----------------------:|
	/// |32 bits       |     `0x1fff_ffff`     |
	/// |64 bits       |`0x1fff_ffff_ffff_ffff`|
	pub const MAX_BITS: usize = BitSpan::<Const, O, T>::REGION_MAX_BITS;
	/// The inclusive maximum length that a slice `[T]` can be for
	/// `BitSlice<_, T>` to cover it.
	///
	/// A `BitSlice<_, T>` that begins in the interior of an element and
	/// contains the maximum number of bits will extend one element past the
	/// cutoff that would occur if the slice began at the zeroth bit. Such a
	/// slice must be manually constructed, but will not otherwise fail.
	///
	/// |Type Bits|Max Elements (32-bit)| Max Elements (64-bit) |
	/// |--------:|--------------------:|----------------------:|
	/// |        8|    `0x0400_0001`    |`0x0400_0000_0000_0001`|
	/// |       16|    `0x0200_0001`    |`0x0200_0000_0000_0001`|
	/// |       32|    `0x0100_0001`    |`0x0100_0000_0000_0001`|
	/// |       64|    `0x0080_0001`    |`0x0080_0000_0000_0001`|
	pub const MAX_ELTS: usize = BitSpan::<Const, O, T>::REGION_MAX_ELTS;
}

#[cfg(feature = "alloc")]
impl<O, T> BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// Copies `self` into a new [`BitVec`].
	///
	/// This resets any alias markings from `self`, since the returned buffer is
	/// known to be newly allocated and thus unaliased.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bits = bits![0, 1, 0, 1];
	/// let bv = bits.to_bitvec();
	/// assert_eq!(bits, bv);
	/// ```
	///
	/// [`BitVec`]: crate::vec::BitVec
	pub fn to_bitvec(&self) -> BitVec<O, T::Unalias> {
		let bitspan = self.as_bitspan();
		//  Create an allocation and copy `*self` into it.
		let mut vec = self.domain().collect::<Vec<_>>().pipe(ManuallyDrop::new);
		let capacity = vec.capacity();
		unsafe {
			BitVec::from_fields(
				BitSpan::new_unchecked(
					vec.as_mut_ptr().cast::<T::Unalias>().force_wrap(),
					bitspan.head(),
					bitspan.len(),
				),
				capacity,
			)
		}
	}
}

/** Performs the same functionality as [`from_raw_parts`], without checking the
`len` argument.

# Parameters

- `data`: A `BitPtr` to a dereferencable region of memory.
- `len`: The length, in bits, of the region beginning at `*data`. This is not
  checked against the maximum value, and is encoded directly into the bit-slice
  reference. If it exceeds [`BitSlice::MAX_BITS`], it will be modulated to fit
  (the high bits will be discarded).

# Returns

A `&BitSlice` reference starting at `data` and running for `len & MAX_BITS`
bits.

# Safety

See [`from_raw_parts`].

[`BitSlice::MAX_BITS`]: crate::slice::BitSlice::MAX_BITS
[`from_raw_parts`]: crate::slice::from_raw_parts
**/
#[inline]
pub unsafe fn from_raw_parts_unchecked<'a, O, T>(
	data: BitPtr<Const, O, T>,
	len: usize,
) -> &'a BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	data.span_unchecked(len).to_bitslice_ref()
}

/** Performs the same functionality as [`from_raw_parts_mut`], without checking
the `len` argument.

# Parameters

- `data`: A `BitPtr` to a dereferencable region of memory.
- `len`: The length, in bits, of the region beginning at `*data`. This is not
  checked against the maximum value, and is encoded directly into the bit-slice
  reference. If it exceeds [`BitSlice::MAX_BITS`], it will be modulated to fit
  (the high bits will be discarded).

# Returns

A `&mut BitSlice` reference starting at `data` and running for `len & MAX_BITS`
bits.

# Safety

See [`from_raw_parts_mut`].

[`BitSlice::MAX_BITS`]: crate::slice::BitSlice::MAX_BITS
[`from_raw_parts_mut`]: crate::slice::from_raw_parts_mut
**/
#[inline]
pub unsafe fn from_raw_parts_unchecked_mut<'a, O, T>(
	data: BitPtr<Mut, O, T>,
	len: usize,
) -> &'a mut BitSlice<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	data.span_unchecked(len).to_bitslice_mut()
}

#[cfg(test)]
mod tests;
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/slice.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/store.rs =====
/*! Memory modeling.

This module provides the [`BitStore`] trait, which contains all of the logic
required to perform memory accesses from a data structure handle.

# `bitvec` Memory Model

`bitvec` considers all memory within [`BitSlice`] regions as if it were composed
of discrete bits, each divisible and indipendent from its neighbors, just as the
Rust memory model considers elements `T` in a slice `[T]`. Much as ordinary byte
slices `[u8]` provide an API where each byte is distinct and independent from
its neighbors, but the underlying processor silicon clusters them in words and
cachelines, both the processor silicon *and* the Rust compiler require that bits
in a `BitSlice` be grouped into memory elements, and collectively subjected to
aliasing rules within their batch.

`bitvec` manages this through the [`BitStore`] trait. It is implemented on three
type families available from the Rust standard libraries:

- [unsigned integers]
- [atomic] unsigned integers
- [`Cell`] wrappers of unsigned integers

`bitvec` receives a memory region typed with one of these three families and
wraps it in one of its data structures based on [`BitSlice`]. The target
processor is responsible for handling any contention between memory elements;
this is irrelevant to the `bitvec` model. `bitvec` is solely responsible for
proving to the Rust compiler that all memory accesses through its types are
correctly managed according to the `&`/`&mut` shared/exclusion reference model,
and the [`UnsafeCell`] shared-mutation model.

Through [`BitStore`], `bitvec` is able to demonstrate that `&mut BitSlice`
references to a region of *bits* have no other `BitSlice` references capable of
viewing those bits. However, `&mut BitSlice` references *may* have other
`&BitSlice` references capable of viewing the memory elements at locations that
it modifies, and the Rust compiler considers it undefined behavior for such
conditions to allow racing writes and reads without synchronization.

As such, [`BitStore`] provides a closed type-system graph that the [`BitSlice`]
API uses to mark events that can induce aliases to memory locations. When a
`&mut BitSlice<_, T>` typed with an ordinary unsigned integer use any of the
APIs that call [`.split_at_mut()`], it transitions to
`&mut BitSlice<_, T::Alias>`. The [`::Alias`] associated type is always a type
that manages aliasing references to a single memory location: either an [atomic]
unsigned integer `T` or a [`Cell`] of the unsigned integer `T`. The Rust
standard library guarantees that these types will behave correctly when multiple
references to a single location attempt to read from and write to it.

The [atomic] and [`Cell`] types stay as themselves when [`BitSlice`] introduces
aliasing conditions, as they are already alias-aware.

Lastly, the `bitvec` memory description model as implemented in the [`domain`]
module is able to perform the inverse transition: where it can demonstrate a
static awareness that the `&`/`&mut` exclusion rules are satisfied for a
particular element slice `[T]`, it may apply the [`::Unalias`] marker to undo
any `::Alias`ing, and present a type that has no more aliasing protection than
that with which the memory region was initially declared.

Namely, this means that the [atomic] and [`Cell`] wrappers will never be removed
from a region that had them before it was given to `bitvec`, while a region of
ordinary integers may regain the ability to be viewed without synchrony guards
if `bitvec` can prove safety in the [`domain`] module.

In order to retain `bitvec`’s promise that an `&mut BitSlice<_, T>` has the sole
right of observation for all bits in its region, the unsigned integers alias to
a crate-internal wrapper over the alias-capable standard-library types. This
wrapper forbids mutation through shared references, so two [`BitSlice`]
references that alias a memory location, but do not overlap in bits, may not be
coërced to interfere with each other.

[atomic]: core::sync::atomic
[unsigned integers]: core::primitive
[`BitSlice`]: crate::slice::BitSlice
[`BitStore`]: crate::store::BitStore
[`Cell`]: core::cell::Cell
[`UnsafeCell`]: core::cell::UnsafeCell
[`domain`]: crate::domain
[`::Alias`]: crate::store::BitStore::Alias
[`::Unalias`]: crate::store::BitStore::Unalias
[`.split_at_mut()`]: crate::slice::BitSlice::split_at_mut
!*/

use core::{
	cell::Cell,
	fmt::Debug,
};

use tap::pipe::Pipe;

use crate::{
	access::*,
	index::{
		BitIdx,
		BitMask,
	},
	mem::{
		self,
		BitRegister,
	},
	order::BitOrder,
};

/** Common interface for memory regions.

This trait is used to describe how [`BitSlice`] regions interact with the memory
bus when reading to or writing from locations. It manages the behavior required
when locations are contended for write permissions by multiple handles, and
ensures that Rust’s `&`/`&mut` shared/exclusion system, as well as its
[`UnsafeCell`] shared-mutation system, are upheld for individual bits as well as
for the memory operations that power the slice.

This trait is publicly implemented on the unsigned integers that implement
[`BitRegister`], their [`Cell`] wrappers, and (if present) their [atomic]
variants. You may freely construct [`BitSlice`] regions over elements or slices
of any of these types.

Shared [`BitSlice`] references (`&BitSlice<_, T: BitStore>`) permit multiple
handles to view the bits they describe. When `T` is a [`Cell`] or [atom], these
handles may use the methods [`.set_aliased()`] and [`.set_aliased_unchecked()`]
to modify memory; when `T` is an ordinary integer, they may not.

Exclusive [`BitSlice`] references (`&mut BitSlice<_, T: BitStore>`) do not allow
any other handle to view the bits they describe. However, other handles may view
the **memory locations** containing their bits! When `T` is a [`Cell`] or
[atom], no special behavior occurs. When `T` is an ordinary integer, [`bitvec`]
detects the creation of multiple `&mut BitSlice<_, T>` handles that do not alias
bits but *do* alias memory, and enforces that these handles use `Cell` or atomic
behavior to access the underlying memory, even though individual bits in the
slices are not contended.

# Integer Width Restricitons

Currently, [`bitvec`] is only tested on 32- and 64- bit architectures. This
means that `u8`, `u16`, `u32`, and `usize` unconditionally implement `BitStore`,
but `u64` will only do so on 64-bit targets. This is a necessary restriction of
`bitvec` internals. Please comment on [Issue #76] if this affects you.

[Issue #76]: https://github.com/myrrlyn/bitvec/issues/76
[atom]: core::sync::atomic
[atomic]: core::sync::atomic
[`BitSlice`]: crate::slice::BitSlice
[`BitRegister`]: crate::mem::BitRegister
[`Cell`]: core::cell::Cell
[`UnsafeCell`]: core::cell::UnsafeCell
[`bitvec`]: crate
[`.set_aliased()`]: crate::slice::BitSlice::set_aliased
[`.set_aliased_unchecked()`]: crate::slice::BitSlice::set_aliased_unchecked
**/
pub trait BitStore: 'static + seal::Sealed + Debug {
	/// The register type used in the slice region underlying a [`BitSlice`]
	/// handle. It is always an unsigned integer.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	type Mem: BitRegister + BitStore<Mem = Self::Mem>;
	/// A type that selects appropriate load/store instructions used for
	/// accessing the memory bus. It determines what instructions are used when
	/// moving a `Self::Mem` value between the processor and the memory system.
	type Access: BitAccess<Item = Self::Mem> + BitStore<Mem = Self::Mem>;
	/// A sibling `BitStore` implementor. It is used when a [`BitSlice`]
	/// introduces multiple handles that view the same memory location, and at
	/// least one of them has write permission to it.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	type Alias: BitStore<Mem = Self::Mem>;
	/// The inverse of `Alias`. It is used when a [`BitSlice`] removes the
	/// conditions that required a `T -> T::Alias` transition.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	type Unalias: BitStore<Mem = Self::Mem>;

	/// Loads a value out of the memory system according to the `::Access`
	/// rules.
	fn load_value(&self) -> Self::Mem;

	/// Stores a value into the memory system according to the `::Access` rules.
	fn store_value(&mut self, value: Self::Mem);

	/// Reads a single bit out of the memory system according to the `::Access`
	/// rules. This is lifted from [`BitAccess`] so that it can be used
	/// elsewhere without additional casts.
	///
	/// # Type Parameters
	///
	/// - `O`: The ordering of bits within `Self::Mem` to use for looking up the
	///   bit at `index`.
	///
	/// # Parameters
	///
	/// - `&self`
	/// - `index`: The semantic index of the bit in `*self` to read.
	///
	/// # Returns
	///
	/// The value of the bit in `*self` at `index`.
	///
	/// [`BitAccess`]: crate::access::BitAccess
	#[inline]
	fn get_bit<O>(&self, index: BitIdx<Self::Mem>) -> bool
	where O: BitOrder {
		self.load_value()
			.pipe(BitMask::new)
			.test(index.select::<O>())
	}

	/// Require that all implementors are aligned to their width.
	#[doc(hidden)]
	const __ALIGNED_TO_SIZE: [(); 0];

	/// Require that the `::Alias` associated type has the same width and
	/// alignment as `Self`.
	#[doc(hidden)]
	const __ALIAS_WIDTH: [(); 0];
}

/// Batch implementation of `BitStore` on integers, safety wrappers, and `Cell`s
macro_rules! store {
	( $($base:ty => $safe:ty),+ $(,)? ) => { $(
		impl BitStore for $base {
			type Mem = Self;
			/// The unsigned integers will only be `BitStore` type parameters
			/// for handles to unaliased memory, following the normal Rust
			/// reference rules.
			type Access = Cell<$base>;
			type Alias = $safe;
			type Unalias = Self;

			#[inline(always)]
			fn load_value(&self) -> Self::Mem {
				*self
			}

			#[inline(always)]
			fn store_value(&mut self, value: Self::Mem) {
				*self = value;
			}

			#[doc(hidden)]
			const __ALIGNED_TO_SIZE: [(); 0]
				= [(); mem::aligned_to_size::<Self>()];

			#[doc(hidden)]
			const __ALIAS_WIDTH: [(); 0]
				= [(); mem::cmp_layout::<Self, Self::Alias>()];
		}

		/// This type is only ever produced by calling [`.split_at_mut()`] on
		/// [`BitSlice<_, T>`] where `T` is an unsigned integer. It cannot be
		/// constructed as a base data source.
		///
		/// [`BitSlice<_, T>`]: crate::slice::BitSlice
		/// [`.split_at_mut()`]: crate::slice::BitSlice::split_at_mut
		impl BitStore for $safe {
			type Mem = $base;
			type Access = <Self as BitSafe>::Rad;
			type Alias = Self;
			type Unalias = $base;

			#[inline(always)]
			fn load_value(&self) -> Self::Mem {
				self.load()
			}

			#[inline(always)]
			fn store_value(&mut self, value: Self::Mem) {
				self.store(value);
			}

			#[doc(hidden)]
			const __ALIGNED_TO_SIZE: [(); 0]
				= [(); mem::aligned_to_size::<Self>()];

			#[doc(hidden)]
			const __ALIAS_WIDTH: [(); 0]
				= [(); mem::cmp_layout::<Self, Self::Unalias>()];
		}

		impl BitStore for Cell<$base> {
			type Mem = $base;
			type Access = Self;
			type Alias = Self;
			type Unalias = Self;

			#[inline(always)]
			fn load_value(&self) -> Self::Mem {
				self.get()
			}

			#[inline(always)]
			fn store_value(&mut self, value: Self::Mem) {
				self.set(value);
			}

			#[doc(hidden)]
			const __ALIGNED_TO_SIZE: [(); 0]
				= [(); mem::aligned_to_size::<Self>()];

			#[doc(hidden)]
			const __ALIAS_WIDTH: [(); 0] = [];
		}

		impl seal::Sealed for $base {}
		impl seal::Sealed for $safe {}
		impl seal::Sealed for Cell<$base> {}
	)+ };
}

store! {
	u8 => BitSafeU8,
	u16 => BitSafeU16,
	u32 => BitSafeU32,
}

#[cfg(target_pointer_width = "64")]
store!(u64 => BitSafeU64);

store!(usize => BitSafeUsize);

macro_rules! atomic_store {
	($($w:tt , $base:ty => $atom:ident);+ $(;)?) => { $(
		radium::if_atomic!(if atomic($w) {
			use core::sync::atomic::$atom;

			impl BitStore for $atom {
				type Mem = $base;
				type Access = Self;
				type Alias = Self;
				type Unalias = Self;

				#[inline]
				fn load_value(&self) -> Self::Mem {
					self.load(core::sync::atomic::Ordering::Relaxed)
				}

				#[inline]
				fn store_value(&mut self, value: Self::Mem) {
					self.store(value, core::sync::atomic::Ordering::Relaxed);
				}

				#[doc(hidden)]
				const __ALIGNED_TO_SIZE: [(); 0]
					= [(); mem::aligned_to_size::<Self>()];

				#[doc(hidden)]
				const __ALIAS_WIDTH: [(); 0] = [];
			}

			impl seal::Sealed for $atom {}
		});
	)+ };
}

atomic_store! {
	8, u8 => AtomicU8;
	16, u16 => AtomicU16;
	32, u32 => AtomicU32;
}

#[cfg(target_pointer_width = "64")]
atomic_store!(64, u64 => AtomicU64);

atomic_store!(size, usize => AtomicUsize);

#[cfg(not(any(target_pointer_width = "32", target_pointer_width = "64")))]
compile_fail!(concat!(
	"This architecture is currently not supported. File an issue at ",
	env!("CARGO_PKG_REPOSITORY")
));

/// Enclose the `Sealed` trait against client use.
mod seal {
	/// Marker trait to seal `BitStore` against downstream implementation.
	///
	/// This trait is public in the module, so that other modules in the crate
	/// can use it, but so long as it is not exported by the crate root and this
	/// module is private, this trait effectively forbids downstream
	/// implementation of the `BitStore` trait.
	#[doc(hidden)]
	pub trait Sealed {}
}

#[cfg(test)]
mod tests {
	use core::cell::Cell;

	use static_assertions::*;

	use super::*;
	use crate::prelude::*;

	#[test]
	fn load_store() {
		let mut word = 0usize;

		word.store_value(39usize);
		assert_eq!(word.load_value(), 39usize);

		let safe: &mut BitSafeUsize =
			unsafe { &mut *(&mut word as *mut _ as *mut _) };
		safe.store_value(57usize);
		assert_eq!(safe.load_value(), 57);

		let mut cell = Cell::new(0usize);
		cell.store_value(39);
		assert_eq!(cell.load_value(), 39);

		radium::if_atomic!(if atomic(size) {
			let mut atom = AtomicUsize::new(0);
			atom.store_value(39);
			assert_eq!(atom.load_value(), 39usize);
		});
	}

	/// Unaliased `BitSlice`s are universally threadsafe, because they satisfy
	/// Rust’s unysnchronized mutation rules.
	#[test]
	fn unaliased_send_sync() {
		assert_impl_all!(BitSlice<LocalBits, u8>: Send, Sync);
		assert_impl_all!(BitSlice<LocalBits, u16>: Send, Sync);
		assert_impl_all!(BitSlice<LocalBits, u32>: Send, Sync);
		assert_impl_all!(BitSlice<LocalBits, usize>: Send, Sync);

		#[cfg(target_pointer_width = "64")]
		assert_impl_all!(BitSlice<LocalBits, u64>: Send, Sync);
	}

	#[test]
	fn cell_unsend_unsync() {
		assert_not_impl_any!(BitSlice<LocalBits, Cell<u8>>: Send, Sync);
		assert_not_impl_any!(BitSlice<LocalBits, Cell<u16>>: Send, Sync);
		assert_not_impl_any!(BitSlice<LocalBits, Cell<u32>>: Send, Sync);
		assert_not_impl_any!(BitSlice<LocalBits, Cell<usize>>: Send, Sync);
		#[cfg(target_pointer_width = "64")]
		assert_not_impl_any!(BitSlice<LocalBits, Cell<u64>>: Send, Sync);
	}

	/// In non-atomic builds, aliased `BitSlice`s become universally
	/// thread-unsafe. An `&mut BitSlice` is an `&Cell`, and `&Cell` cannot be
	/// sent across threads.
	///
	/// This test cannot be meaningfully expressed in atomic builds, because the
	/// atomiticy of a `BitSafeUN` type is target-specific, and expressed in
	/// `radium` rather than in `bitvec`.
	#[test]
	#[cfg(not(feature = "atomic"))]
	fn aliased_nonatomic_unsend_unsync() {
		use crate::access::*;

		assert_not_impl_any!(BitSlice<LocalBits, BitSafeU8>: Send, Sync);
		assert_not_impl_any!(BitSlice<LocalBits, BitSafeU16>: Send, Sync);
		assert_not_impl_any!(BitSlice<LocalBits, BitSafeU32>: Send, Sync);
		assert_not_impl_any!(BitSlice<LocalBits, BitSafeUsize>: Send, Sync);

		#[cfg(target_pointer_width = "64")]
		assert_not_impl_any!(BitSlice<LocalBits, BitSafeU64>: Send, Sync);
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/store.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/vec/api.rs =====
//! Port of the `Vec<T>` inherent API.

use alloc::vec::Vec;
use core::{
	mem::{
		self,
		ManuallyDrop,
	},
	ops::RangeBounds,
};

use funty::IsNumber;
use tap::pipe::Pipe;

use super::{
	iter::{
		Drain,
		Splice,
	},
	BitVec,
};
use crate::{
	boxed::BitBox,
	index::BitTail,
	order::BitOrder,
	ptr::{
		AddressExt,
		BitPtr,
		BitSpan,
		Const,
		Mut,
	},
	slice::BitSlice,
	store::BitStore,
};

/// Port of the `Vec<T>` inherent API.
impl<O, T> BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// Constructs a new, empty, `BitVec<O, T>`.
	///
	/// The bit-vector will not allocate until bits are pushed onto it.
	///
	/// # Original
	///
	/// [`Vec::new`](alloc::vec::Vec::new)
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv: BitVec = BitVec::new();
	/// ```
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn new() -> Self {
		Self {
			bitspan: BitSpan::EMPTY,
			capacity: 0,
		}
	}

	/// Constructs a new, empty, `BitVec<O, T>` with the specified capacity (in
	/// bits).
	///
	/// The bit-vector will be able to hold at least `capacity` bits without
	/// reällocating. If `capacity` is 0, the bit-vector will not allocate.
	///
	/// It is important to note that although the returned bit-vector has the
	/// *capacity* specified, the bit-vector will have a zero *length*. For an
	/// explanation of the difference between length and capacity, see
	/// *[Capacity and reällocation]*.
	///
	/// # Original
	///
	/// [`Vec::with_capacity`](alloc::vec::Vec::with_capacity)
	///
	/// # Panics
	///
	/// Panics if the requested capacity exceeds the bit-vector’s limits.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv: BitVec = BitVec::with_capacity(128);
	///
	/// // The bit-vector contains no bits, even
	/// // though it has the capacity for more.
	/// assert_eq!(bv.len(), 0);
	/// assert!(bv.capacity() >= 128);
	///
	/// // These are all done
	/// // without reällocating…
	/// for i in 0 .. 128 {
	///   bv.push(i & 0xC0 == i);
	/// }
	/// assert_eq!(bv.len(), 128);
	/// assert!(bv.capacity() >= 128);
	///
	/// // …but this may make the
	/// // bit-vector reällocate.
	/// bv.push(false);
	/// assert_eq!(bv.len(), 129);
	/// assert!(bv.capacity() >= 129);
	/// ```
	///
	/// [Capacity and reällocation]: #capacity-and-reallocation
	#[inline]
	pub fn with_capacity(capacity: usize) -> Self {
		assert!(
			capacity <= BitSlice::<O, T>::MAX_BITS,
			"Bit-Vector capacity exceeded: {} > {}",
			capacity,
			BitSlice::<O, T>::MAX_BITS,
		);

		let mut vec = capacity
			.pipe(crate::mem::elts::<T>)
			.pipe(Vec::<T>::with_capacity)
			.pipe(ManuallyDrop::new);
		let (addr, capacity) = (vec.as_mut_ptr(), vec.capacity());
		let bitspan = BitSpan::uninhabited(unsafe { addr.force_wrap() });
		Self { bitspan, capacity }
	}

	/// Decomposes a `BitVec<O, T>` into its raw components.
	///
	/// Returns the raw bit-pointer to the underlying data, the length of the
	/// bit-vector (in bits), and the allocated capacity of the buffer (in
	/// bits). These are the same arguments in the same order as the arguments
	/// to [`from_raw_parts`].
	///
	/// After calling this function, the caller is responsible for the memory
	/// previously managed by the `BitVec`. The only way to do this is to
	/// convert the raw bit-pointer, length, and capacity back into a `BitVec`
	/// with the [`from_raw_parts`] function, allowing the destructor to perform
	/// the cleanup.
	///
	/// # Original
	///
	/// [`Vec::into_raw_parts`](alloc::vec::Vec::into_raw_parts)
	///
	/// # API Differences
	///
	/// This returns a `BitPtr`, rather than a `*mut T`. If you need the actual
	/// memory address, [`BitPtr::pointer`] will produce it.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	/// use core::cell::Cell;
	///
	/// let bv: BitVec = bitvec![0, 1, 0, 0, 1];
	///
	/// let (ptr, len, cap) = bv.into_raw_parts();
	///
	/// let rebuilt = unsafe {
	///   // We can now make changes to the components, such
	///   // as casting the pointer to a compatible type.
	///   let ptr = ptr.cast::<Cell<usize>>();
	///   BitVec::from_raw_parts(ptr, len, cap)
	/// };
	/// assert_eq!(rebuilt, bits![0, 1, 0, 0, 1]);
	/// ```
	///
	/// [`BitPtr::pointer`]: crate::ptr::BitPtr::pointer
	/// [`from_raw_parts`]: Self::from_raw_parts
	#[inline]
	pub fn into_raw_parts(self) -> (BitPtr<Mut, O, T>, usize, usize) {
		let (bitspan, capacity) = (self.bitspan, self.capacity());
		mem::forget(self);
		(bitspan.as_bitptr(), bitspan.len(), capacity)
	}

	/// Creates a `BitVec<O, T>` directly from the raw components of another
	/// bit-vector.
	///
	/// # Original
	///
	/// [`Vec::from_raw_parts`](alloc::vec::Vec::from_raw_parts)
	///
	/// # API Differences
	///
	/// This takes a `BitPtr`, rather than a `*mut T`. If you only have a
	/// pointer, you can construct a `BitPtr` to its zeroth bit before calling
	/// this.
	///
	/// # Safety
	///
	/// This is highly unsafe, due to the number of invariants that aren’t
	/// checked:
	///
	/// - `bitptr` needs to have been previously allocated by `BitVec<O, T>`, or
	///   constructed from a pointer allocated by [`Vec<T>`].
	/// - `T` needs to have the same size and alignment as what `bitptr` was
	///   allocated with. (`T` having a less strict alignment is not sufficient;
	///   the alignment really needs to be equal to satisf the [`dealloc`]
	///   requirement that memory must be allocated and deällocated with the
	///   same layout.) However, you can safely cast between bare integers,
	///   `BitSafe` integers, `Cell` wrappers, and atomic integers, as long as
	///   they all have the same width.
	/// - `length` needs to be less than or equal to capacity.
	/// - `capacity` needs to be the capacity (in bits) that the bit-pointer was
	///   allocated with (less any head offset in `bitptr`).
	///
	/// Violating these **will** cause problems. For example, it is **not** safe
	/// to build a `BitVec<_, u8>` from a pointer to a `u16` sequence and twice
	/// its original length, because the allocator cares about the alignment,
	/// and these two types have different alignments. The buffer was allocated
	/// with alignment 2 (for `u16`), but after turning it into a `BitVec<_,
	/// u8>`, it’ll be deällocated with alignment 1.
	///
	/// The ownership of `bitptr`is effectively transferred to the `BitVec<O,
	/// T>` which may then deällocate, reällocate, or change the contents of
	/// memory pointed to by the bit-pointer at will. Ensure that nothing else
	/// uses the pointer after calling this function.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	/// use bitvec::ptr as bv_ptr;
	/// use core::mem::ManuallyDrop;
	///
	/// let bv = bitvec![0, 1, 0, 0, 1];
	/// let mut bv = ManuallyDrop::new(bv);
	/// let bp = bv.as_mut_bitptr();
	/// let len = bv.len();
	/// let cap = bv.capacity();
	///
	/// unsafe {
	///   // Overwrite memory with the inverse bits.
	///   for i in 0 .. len {
	///     let bp = bp.add(i);
	///     bv_ptr::write(bp, !bv_ptr::read(bp.immut()));
	///   }
	///
	///   // Put everything back together into a `BitVec`.
	///   let rebuilt = BitVec::from_raw_parts(bp, len, cap);
	///   assert_eq!(rebuilt, bits![1, 0, 1, 1, 0]);
	/// }
	/// ```
	///
	/// [`Vec<T>`]: alloc::vec::Vec
	/// [`dealloc`]: alloc::alloc::GlobalAlloc::dealloc
	#[inline]
	pub unsafe fn from_raw_parts(
		bitptr: BitPtr<Mut, O, T>,
		length: usize,
		capacity: usize,
	) -> Self {
		Self {
			bitspan: bitptr.span_unchecked(length),
			capacity: crate::mem::elts::<T>(
				//  The capacity counts from `head`, not from 0.
				capacity.saturating_add(bitptr.head().into_inner() as usize),
			),
		}
	}

	/// Returns the number of bits the bit-vector can hold without reällocating.
	///
	/// # Original
	///
	/// [`Vec::capacity`](alloc::vec::Vec::capacity)
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bv: BitVec = BitVec::with_capacity(100);
	/// assert!(bv.capacity() >= 100);
	/// ```
	#[inline]
	pub fn capacity(&self) -> usize {
		self.capacity
			.checked_mul(T::Mem::BITS as usize)
			.expect("Bit-Vector capacity exceeded")
			//  Don’t forget to subtract any dead bits in the front of the base!
			//  This has to be saturating, becase a non-zero head on a zero
			//  capacity underflows.
			.saturating_sub(self.bitspan.head().into_inner() as usize)
	}

	/// Reserves capacity for at least `additional` more bits to be inserted in
	/// the given `BitVec<O, T>`. The collection may reserve more space to avoid
	/// frequent reällocations. After calling `reserve`, capacity will be
	/// greater than or equal to `self.len() + additional`. Does nothing if
	/// capacity is already sufficient.
	///
	/// # Original
	///
	/// [`Vec::reserve`](alloc::vec::Vec::reserve)
	///
	/// # Panics
	///
	/// Panics if the new capacity exceeds the bit-vector’s limits.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv = bitvec![1];
	/// bv.reserve(100);
	/// assert!(bv.capacity() >= 101);
	/// ```
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn reserve(&mut self, additional: usize) {
		self.do_reservation(additional, Vec::<T>::reserve);
	}

	/// Reserves the minimum capacity for exactly `additional` more bits to be
	/// inserted in the given `BitVec<O, T>`. After calling `reserve_exact`,
	/// capacity will be greater than or equal to `self.len() + additional`.
	/// Does nothing if the capacity is already sufficient.
	///
	/// Note that the allocator may give the collection more space than it
	/// requests. Therefore, capacity can not be relied upon to be precisely
	/// minimal. Prefer `reserve` if future insertions are expected.
	///
	/// # Original
	///
	/// [`Vec::reserve_exact`](alloc::vec::Vec::reserve_exact)
	///
	/// # Panics
	///
	/// Panics if the new capacity exceeds the vector’s limits.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv = bitvec![1];
	/// bv.reserve_exact(100);
	/// assert!(bv.capacity() >= 101);
	/// ```
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn reserve_exact(&mut self, additional: usize) {
		self.do_reservation(additional, Vec::<T>::reserve_exact);
	}

	/// Shrinks the capacity of the bit-vector as much as possible.
	///
	/// It will drop down as close as possible to the length but the allocator
	/// may still inform the bit-vector that there is space for a few more bits.
	///
	/// # Original
	///
	/// [`Vec::shrink_to_fit`](alloc::vec::Vec::shrink_to_fit)
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv: BitVec = BitVec::with_capacity(100);
	/// bv.extend([false, true, false].iter().copied());
	/// assert!(bv.capacity() >= 100);
	/// bv.shrink_to_fit();
	/// assert!(bv.capacity() >= 3);
	/// ```
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn shrink_to_fit(&mut self) {
		self.with_vec(|vec| vec.shrink_to_fit());
	}

	#[doc(hidden)]
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	#[deprecated = "Prefer `into_boxed_bitslice`"]
	pub fn into_boxed_slice(self) -> BitBox<O, T> {
		self.into_boxed_bitslice()
	}

	/// Shortens the bit-vector, keeping the first `len` bits and dropping the
	/// rest.
	///
	/// If `len` is greater than the bit-vector’s current length, this has no
	/// effect.
	///
	/// The [`drain`] method can emulate `truncate`, but causes the excess bits
	/// to be returned instead of dropped.
	///
	/// Note that this method has no effect on the allocated capacity of the
	/// bit-vector, **nor does it erase truncated memory**. Bits in the
	/// allocated memory that are outside of the [`as_bitslice`] view always
	/// have **unspecified** values, and cannot be relied upon to be zero.
	///
	/// # Original
	///
	/// [`Vec::truncate`](alloc::vec::Vec::truncate)
	///
	/// # Examples
	///
	/// Truncating a five-bit vector to two bits:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv = bitvec![1; 5];
	/// bv.truncate(2);
	/// assert_eq!(bv.len(), 2);
	/// assert!(bv.as_raw_slice()[0].count_ones() >= 5);
	/// ```
	///
	/// No truncation occurs when `len` is greater than the vector’s current
	/// length:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv = bitvec![1; 3];
	/// bv.truncate(8);
	/// assert_eq!(bv.len(), 3);
	/// ```
	///
	/// Truncating when `len == 0` is equivalent to calling the [`clear`]
	/// method.
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv = bitvec![0; 3];
	/// bv.truncate(0);
	/// assert!(bv.is_empty());
	/// ```
	///
	/// [`as_bitslice`]: Self::as_bitslice
	/// [`clear`]: Self::clear
	/// [`drain`]: Self::drain
	#[inline]
	pub fn truncate(&mut self, len: usize) {
		if len < self.len() {
			unsafe { self.set_len_unchecked(len) }
		}
	}

	#[doc(hidden)]
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	#[deprecated = "Prefer `as_bitslice`, or `as_raw_slice` to view the \
	                underlying memory"]
	pub fn as_slice(&self) -> &BitSlice<O, T> {
		self.as_bitslice()
	}

	#[doc(hidden)]
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	#[deprecated = "Prefer `as_mut_bitslice`, or `as_mut_raw_slice` to view the \
	                underlying memory"]
	pub fn as_mut_slice(&mut self) -> &mut BitSlice<O, T> {
		self.as_mut_bitslice()
	}

	#[doc(hidden)]
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	#[deprecated = "Prefer `as_bitptr`, or `as_raw_ptr` to take the address of \
	                the underlying memory"]
	pub fn as_ptr(&self) -> BitPtr<Const, O, T> {
		self.as_bitptr()
	}

	#[doc(hidden)]
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	#[deprecated = "Prefer `as_mut_bitptr`, or `as_mut_raw_ptr` to take the \
	                address of the underlying memory"]
	pub fn as_mut_ptr(&mut self) -> BitPtr<Mut, O, T> {
		self.as_mut_bitptr()
	}

	/// Forces the length of the bit-vector to `new_len`.
	///
	/// This is a low-level operation that maintains none of the normal
	/// invariants of the type. Normall changing the length of a bit-vector is
	/// done using one of the safe operations instead, such as [`truncate`],
	/// [`resize`], [`extend`], or [`clear`].
	///
	/// # Original
	///
	/// [`Vec::set_len`](alloc::vec::Vec::set_len)
	///
	/// # Safety
	///
	/// - `new_len` must be less than or equal to [`self.capacity()`].
	/// - The memory elements underlying `old_len .. new_len` must be
	///   initialized.
	///
	/// # Examples
	///
	/// This method can be useful for situations in which the bit-vector is
	/// serving as a buffer for other code, particularly over FFI:
	///
	/// ```rust
	/// # #![allow(dead_code)]
	/// # #![allow(improper_ctypes)]
	/// # const ERL_OK: i32 = 0;
	/// # extern "C" {
	/// #   fn erl_read_bits(
	/// #     bv: *mut BitVec<Msb0, u8>,
	/// #     bits_reqd: usize,
	/// #     bits_read: *mut usize,
	/// #   ) -> i32;
	/// # }
	/// use bitvec::prelude::*;
	///
	/// // `bitvec` could pair with `rustler` for a better bitstream
	/// type ErlBitstring = BitVec<Msb0, u8>;
	/// # pub fn _test() {
	/// let mut bits_read = 0;
	/// // An imaginary Erlang function wants a large bit buffer.
	/// let mut buf = ErlBitstring::with_capacity(32_768);
	/// // SAFETY: When `erl_read_bits` returns `ERL_OK`, it holds that:
	/// // 1. `bits_read` bits were initialized.
	/// // 2. `bits_read` <= the capacity (32_768)
	/// // which makes `set_len` safe to call.
	/// unsafe {
	///   // Make the FFI call…
	///   let status = erl_read_bits(&mut buf, 10, &mut bits_read);
	///   if status == ERL_OK {
	///     // …and update the length to what was read in.
	///     buf.set_len(bits_read);
	///   }
	/// }
	/// # }
	/// ```
	///
	/// [`clear`]: Self::clear
	/// [`extend`]: Self::extend
	/// [`resize`]: Self::resize
	/// [`self.capacity()`]: Self::capacity
	/// [`truncate`]: Self::truncate
	#[inline]
	pub unsafe fn set_len(&mut self, new_len: usize) {
		assert!(
			new_len <= BitSlice::<O, T>::MAX_BITS,
			"Bit-Vector capacity exceeded: {} > {}",
			new_len,
			BitSlice::<O, T>::MAX_BITS,
		);
		let cap = self.capacity();
		assert!(
			new_len <= cap,
			"Bit-Vector capacity exceeded: {} > {}",
			new_len,
			cap,
		);
		self.set_len_unchecked(new_len);
	}

	/// Removes a bit from the bit-vector and returns it.
	///
	/// The removed bit is replaced by the last bit of the bit-vector.
	///
	/// This does not preserve ordering, but is O(1).
	///
	/// # Original
	///
	/// [`Vec::swap_remove`](alloc::vec::Vec::swap_remove)
	///
	/// # Panics
	///
	/// Panics if `index` is out of bounds.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv = bitvec![0, 0, 1, 0, 1];
	/// assert!(!bv.swap_remove(1));
	/// assert_eq!(bv, bits![0, 1, 1, 0]);
	///
	/// assert!(!bv.swap_remove(0));
	/// assert_eq!(bv, bits![0, 1, 1]);
	/// ```
	#[inline]
	pub fn swap_remove(&mut self, index: usize) -> bool {
		self.assert_in_bounds(index, 0 .. self.len());
		let last = self.len() - 1;
		unsafe {
			self.swap_unchecked(index, last);
			self.set_len(last);
			*self.get_unchecked(last)
		}
	}

	/// Inserts a bit at position `index` within the bit-vector, shifting all
	/// bits after it to the right.
	///
	/// # Original
	///
	/// [`Vec::insert`](alloc::vec::Vec::insert)
	///
	/// # Panics
	///
	/// Panics if `index > len`.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv = bitvec![0; 5];
	/// bv.insert(5, true);
	/// assert_eq!(bv, bits![0, 0, 0, 0, 0, 1]);
	/// bv.insert(2, true);
	/// assert_eq!(bv, bits![0, 0, 1, 0, 0, 0, 1]);
	/// ```
	#[inline]
	pub fn insert(&mut self, index: usize, value: bool) {
		self.assert_in_bounds(index, 0 ..= self.len());
		self.push(value);
		unsafe { self.get_unchecked_mut(index ..) }.rotate_right(1);
	}

	/// Removes and returns the bit at position `index` within the bit-vector,
	/// shifting all bits after it to the left.
	///
	/// # Original
	///
	/// [`Vec::remove`](alloc::vec::Vec::remove)
	///
	/// # Panics
	///
	/// Panics if `index` is out of bounds.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv = bitvec![0, 1, 0];
	/// assert!(bv.remove(1));
	/// assert_eq!(bv, bits![0, 0]);
	/// ```
	#[inline]
	pub fn remove(&mut self, index: usize) -> bool {
		self.assert_in_bounds(index, 0 .. self.len());
		let last = self.len() - 1;
		unsafe {
			self.get_unchecked_mut(index ..).rotate_left(1);
			self.set_len(last);
			*self.get_unchecked(last)
		}
	}

	/// Retains only the bits specified by the predicate.
	///
	/// In other words, remove all bits `b` such that `func(idx(b), &b)` returns
	/// `false`. This method operates in place, visiting each bit exactly once
	/// in the original order, and preserves the order of the retained bits.
	///
	/// # Original
	///
	/// [`Vec::retain`](alloc::vec::Vec::retain)
	///
	/// # API Differences
	///
	/// In order to allow more than one bit of information for the retention
	/// decision, the predicate receives the index of each bit, as well as its
	/// value.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv = bitvec![0, 1, 1, 0, 0, 1];
	/// bv.retain(|i, b| (i % 2 == 0) ^ b);
	/// assert_eq!(bv, bits![0, 1, 0, 1]);
	/// ```
	#[inline]
	pub fn retain<F>(&mut self, mut func: F)
	where F: FnMut(usize, &bool) -> bool {
		let len = self.len();
		let mut del = 0;
		/* Walk the vector, testing each bit and its index. This loop sorts the
		vector in-place, partitioning it with consecutive retained bits at the
		front and consecutive discarded bits at the back.
		*/
		for (idx, bitptr) in self.as_bitslice().as_bitptr_range().enumerate() {
			//  If the bit/index fails the test, bump the deletion counter.
			if !func(idx, &unsafe { bitptr.read() }) {
				del += 1
			}
			//  If the test passes, swap the bit with the first failed bit.
			else if del > 0 {
				self.swap(idx - del, idx);
			}
		}
		// Drop discarded bits.
		if del > 0 {
			self.truncate(len - del);
		}
	}

	/// Appends a bit to the back of a collection.
	///
	/// # Original
	///
	/// [`Vec::push`](alloc::vec::Vec::push)
	///
	/// # Panics
	///
	/// Panics if the number of bits in the bit-vector exceeds the maximum
	/// bit-vector capacity.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv = bitvec![0, 0];
	/// bv.push(true);
	/// assert_eq!(bv.count_ones(), 1);
	/// ```
	#[inline]
	pub fn push(&mut self, value: bool) {
		let len = self.len();
		assert!(
			len <= BitSlice::<O, T>::MAX_BITS,
			"Bit-Vector capacity exceeded: {} > {}",
			len,
			BitSlice::<O, T>::MAX_BITS,
		);
		//  Push a new `T` into the underlying buffer if needed
		if self.is_empty() || self.bitspan.tail() == BitTail::LAST {
			self.with_vec(|vec| vec.push(unsafe { mem::zeroed() }))
		}
		//  Write `value` into the now-safely-allocated `len` slot.
		unsafe {
			self.set_len_unchecked(len + 1);
			self.set_unchecked(len, value);
		}
	}

	/// Removes the last bit from a bit-vector and returns it, or [`None`] if it
	/// is empty.
	///
	/// # Original
	///
	/// [`Vec::pop`](alloc::vec::Vec::pop)
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv = bitvec![0, 0, 1];
	/// assert_eq!(bv.pop(), Some(true));
	/// assert_eq!(bv, bits![0, 0]);
	/// ```
	///
	/// [`None`]: core::option::Option::None
	#[inline]
	pub fn pop(&mut self) -> Option<bool> {
		match self.len() {
			0 => None,
			n => unsafe {
				let new_len = n - 1;
				self.set_len_unchecked(new_len);
				Some(*self.get_unchecked(new_len))
			},
		}
	}

	/// Moves all the bits of `other` into `self`, leaving `other` empty.
	///
	/// # Original
	///
	/// [`Vec::append`](alloc::vec::Vec::append)
	///
	/// # API Differences
	///
	/// This permits `other` to have different type parameters than `self`, and
	/// does not require that it be of literally `Self`.
	///
	/// # Panics
	///
	/// Panics if the number of bits overflows the maximum bit-vector capacity.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv1 = bitvec![Msb0, u16; 0; 10];
	/// let mut bv2 = bitvec![Lsb0, u32; 1; 10];
	///
	/// bv1.append(&mut bv2);
	///
	/// assert_eq!(bv1.count_ones(), 10);
	/// assert!(bv2.is_empty());
	/// ```
	#[inline]
	pub fn append<O2, T2>(&mut self, other: &mut BitVec<O2, T2>)
	where
		O2: BitOrder,
		T2: BitStore,
	{
		let this_len = self.len();
		let new_len = this_len + other.len();
		self.resize(new_len, false);
		unsafe { self.get_unchecked_mut(this_len .. new_len) }
			.clone_from_bitslice(other.as_bitslice());
		other.clear();
	}

	/// Creates a draining iterator that removes the specified range in the
	/// bit-vector and yields the removed bits.
	///
	/// When the iterator **is** dropped, all bits in the range are removed from
	/// the bit-vector, even if the iterator was not fully consumed. If the
	/// iterator **is not** dropped (with [`mem::forget`] for example), it is
	/// unspecified how many bits are removed.
	///
	/// # Original
	///
	/// [`Vec::drain`](alloc::vec::Vec::drain)
	///
	/// # Panics
	///
	/// Panics if the starting point is greater than the end point or if the end
	/// point is greater than the length of the bit-vector.
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv = bitvec![0, 1, 1];
	/// let bv2: BitVec = bv.drain(1 ..).collect();
	/// assert_eq!(bv, bits![0]);
	/// assert_eq!(bv2, bits![1, 1]);
	///
	/// // A full range clears the vector
	/// bv.drain(..);
	/// assert_eq!(bv, bits![]);
	/// ```
	///
	/// [`mem::forget`]: core::mem::forget
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn drain<R>(&mut self, range: R) -> Drain<O, T>
	where R: RangeBounds<usize> {
		Drain::new(self, range)
	}

	/// Clears the bit-vector, removing all values.
	///
	/// Note that this method has no effect on the allocated capacity of the
	/// bit-vector.
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv = bitvec![0, 1, 0, 1];
	/// bv.clear();
	/// assert!(bv.is_empty());
	/// ```
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn clear(&mut self) {
		self.truncate(0);
	}

	/// Returns the number of bits in the bit-vector, also referred to as its
	/// ‘length’.
	///
	/// # Original
	///
	/// [`Vec::len`](alloc::vec::Vec::len)
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bv = bitvec![0, 0, 1];
	/// assert_eq!(bv.len(), 3);
	/// ```
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn len(&self) -> usize {
		self.bitspan.len()
	}

	/// Returns `true` if the bit-vector contains no bits.
	///
	/// # Original
	///
	/// [`Vec::is_empty`](alloc::vec::Vec::is_empty)
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv: BitVec = BitVec::new();
	/// assert!(bv.is_empty());
	///
	/// bv.push(true);
	/// assert!(!bv.is_empty());
	/// ```
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn is_empty(&self) -> bool {
		self.bitspan.len() == 0
	}

	/// Splits the collection into two at the given index.
	///
	/// Returns a newly allocated bit-vector containing the bits in range `[at,
	/// len)`. After the call, the original bit-vector will be left containing
	/// the bits `[0, at)` with its previous capacity unchanged.
	///
	/// # Original
	///
	/// [`Vec::split_off`](alloc::vec::Vec::split_off)
	///
	/// # Panics
	///
	/// Panics if `at > len`.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv = bitvec![0, 0, 1];
	/// let bv2 = bv.split_off(1);
	/// assert_eq!(bv, bits![0]);
	/// assert_eq!(bv2, bits![0, 1]);
	/// ```
	#[inline]
	#[must_use = "use `.truncate()` if you don’t need the other half"]
	pub fn split_off(&mut self, at: usize) -> Self {
		let len = self.len();
		assert!(at <= len, "Index {} out of bounds: {}", at, len);
		match at {
			0 => mem::replace(self, Self::new()),
			n if n == len => Self::new(),
			_ => unsafe {
				self.set_len(at);
				self.get_unchecked(at .. len)
					.to_bitvec()
					.pipe(Self::strip_unalias)
			},
		}
	}

	/// Resizes the `BitVec` in-place so that `len` is equal to `new_len`.
	///
	/// If `new_len` is greater than `len`, the `BitVec` is extended by the
	/// difference, with each additional slot filled with the result of calling
	/// the closure `func`. The return values from `func` will end up in the
	/// `BitVec` in the order they have been generated.
	///
	/// If `new_len` is less than `len`, the `BitVec` is simply truncated.
	///
	/// This method uses a closure to create new values on every push. If you’d
	/// rather [`Clone`] a given value, use [`resize`]. If you want to use the
	/// [`Default`] trait to generate values, you can pass
	/// [`Default::default()`] as the second argument.
	///
	/// # Original
	///
	/// [`Vec::resize_with`](alloc::vec::Vec::resize_with)
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv = bitvec![1; 3];
	/// bv.resize_with(5, Default::default);
	/// assert_eq!(bv, bits![1, 1, 1, 0, 0]);
	///
	/// let mut bv = bitvec![];
	/// let mut p = 0;
	/// bv.resize_with(4, || { p += 1; p % 2 == 0 });
	/// assert_eq!(bv, bits![0, 1, 0, 1]);
	/// ```
	///
	/// [`Clone`]: core::clone::Clone
	/// [`Default`]: core::default::Default
	/// [`Default::default()`]: core::default::Default::default
	/// [`resize`]: Self::resize
	#[inline]
	pub fn resize_with<F>(&mut self, new_len: usize, func: F)
	where F: FnMut() -> bool {
		let len = self.len();
		if new_len > len {
			self.extend_with(len, new_len, func);
		}
		else {
			self.truncate(new_len);
		}
	}

	/// Consumes and leaks the `BitVec`, returning a mutable reference to the
	/// contents, `&'a mut BitSlice<O, T>`. This lifetime may be chosen to be
	/// `'static`.
	///
	/// This function is similar to the [`leak`] function on [`BitBox`].
	///
	/// This function is mainly useful for data that lives for the remainder of
	/// the program’s life. Dropping the returned reference will cause a memory
	/// leak.
	///
	/// # Original
	///
	/// [`Vec::leak`](alloc::vec::Vec::leak)
	///
	/// # Examples
	///
	/// Simple usage:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let x = bitvec![0, 0, 1];
	/// let static_ref: &'static mut BitSlice = x.leak();
	/// static_ref.set(0, true);
	/// assert_eq!(static_ref, bits![1, 0, 1]);
	/// ```
	///
	/// [`BitBox`]: crate::boxed::BitBox
	/// [`leak`]: crate::boxed::BitBox::leak
	#[inline]
	pub fn leak<'a>(self) -> &'a mut BitSlice<O, T> {
		self.into_boxed_bitslice().pipe(BitBox::leak)
	}

	/// Resizes the `BitVec` in-place so that `len` is equal to `new_len`.
	///
	/// If `new_len` is greater than `len`, the `BitVec` is extended by the
	/// difference, with each additional slot filled with `value`. If `new_len`
	/// is less than `len`, the `BitVec` is simply truncated.
	///
	/// This method requires a single `bool` value. If you need more
	/// flexibility, use [`resize_with`].
	///
	/// # Original
	///
	/// [`Vec::resize`](alloc::vec::Vec::resize)
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv = bitvec![1];
	/// bv.resize(3, false);
	/// assert_eq!(bv, bits![1, 0, 0]);
	///
	/// let mut bv = bitvec![1; 4];
	/// bv.resize(2, false);
	/// assert_eq!(bv, bits![1; 2]);
	/// ```
	///
	/// [`resize_with`]: Self::resize_with
	#[inline]
	pub fn resize(&mut self, new_len: usize, value: bool) {
		let len = self.len();
		if new_len > len {
			self.extend_with(len, new_len, || value);
		}
		else {
			self.truncate(new_len);
		}
	}

	#[doc(hidden)]
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	#[deprecated = "Prefer `extend_from_bitslice`. If you need to extend from a \
	                slice of `T` elements, use `extend_from_raw_slice`"]
	pub fn extend_from_slice<O2, T2>(&mut self, other: &BitSlice<O2, T2>)
	where
		O2: BitOrder,
		T2: BitStore,
	{
		self.extend_from_bitslice(other);
	}

	/// Resizes the `BitVec` in-place so that `len` is equal to `new_len`.
	#[inline]
	#[deprecated = "`Vec::resize_default` is deprecated"]
	pub fn resize_default(&mut self, new_len: usize) {
		let len = self.len();
		if new_len > len {
			self.extend_with(len, new_len, Default::default);
		}
		else {
			self.truncate(new_len);
		}
	}

	/// Creates a splicing iterator that replaces the specified range in the
	/// bit-vector with the given `replace_with` iterator and yields the removed
	/// items. `replace_with` does not need to be the same length as `range`.
	///
	/// `range` is removed even if the iterator is not consumed until the end.
	///
	/// It is unspecified how many bits are removed from the vector if the
	/// [`Splice`] value is leaked.
	///
	/// The input iterator `replace_with` is only consumed when the [`Splice`]
	/// value is dropped.
	///
	/// This is optimal if:
	///
	/// - the tail (bits in the vector after `range`) is empty
	/// - or `replace_with` yields fewer bits than `range`’s length
	/// - or the lower bound of its [`size_hint`] is exact.
	///
	/// Otherwise, a temporary bit-vector is allocated and the tail is moved
	/// twice.
	///
	/// # Original
	///
	/// [`Vec::splice`](alloc::vec::Vec::splice)
	///
	/// # Panics
	///
	/// Panics if the starting point is greater than the end point or if the end
	/// point is greater than the length of the bit-vector.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv = bitvec![0, 1, 0];
	/// let new = bits![1, 0];
	/// let old: BitVec = bv.splice(.. 2, new.iter().by_val()).collect();
	/// assert_eq!(bv, bits![1, 0, 0]);
	/// assert_eq!(old, bits![0, 1]);
	/// ```
	///
	/// [`Splice`]: crate::vec::Splice
	/// [`size_hint`]: core::iter::Iterator::size_hint
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	pub fn splice<R, I>(
		&mut self,
		range: R,
		replace_with: I,
	) -> Splice<O, T, I::IntoIter>
	where
		R: RangeBounds<usize>,
		I: IntoIterator<Item = bool>,
	{
		Splice::new(self.drain(range), replace_with)
	}

	fn extend_with<F>(&mut self, len: usize, new_len: usize, mut func: F)
	where F: FnMut() -> bool {
		self.reserve(new_len - len);

		unsafe {
			for bitptr in
				self.get_unchecked_mut(len .. new_len).as_mut_bitptr_range()
			{
				bitptr.write(func());
			}
			self.set_len_unchecked(new_len);
		}
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/vec/api.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/vec/iter.rs =====
//! Iterators over `Vec<T>`.

use alloc::vec::Vec;
use core::{
	fmt::{
		self,
		Debug,
		Formatter,
	},
	iter::{
		FromIterator,
		FusedIterator,
	},
	mem::{
		self,
		ManuallyDrop,
	},
	ops::{
		Range,
		RangeBounds,
	},
};

use tap::{
	Pipe,
	Tap,
	TapOptional,
};

use super::BitVec;
use crate::{
	boxed::BitBox,
	devel as dvl,
	order::BitOrder,
	ptr::{
		BitPtrRange,
		BitRef,
		Mut,
		Mutability,
	},
	slice::BitSlice,
	store::BitStore,
	view::BitView,
};

/** Extends a `BitVec` from a `bool` producer.

# Notes

This is the second-slowest possible way to append bits to a bit-vector, second
only to `for bit in bits { bitvec.push(bit); }`. **Do not** use this if you have
any other choice.

If you are extending a bit-vector from the contents of a bit-slice, use
[`BitVec::extend_from_bitslice`] instead. That method will never be *slower*
than this. When the source bit-slice does not match the destination bit-vector’s
type parameters, it will still be faster by virtue of knowing the bit-slice
length upfront; when the type parameters match, it will optimize to `memcpy`
with some bookkeeping.
**/
impl<O, T> Extend<bool> for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn extend<I>(&mut self, iter: I)
	where I: IntoIterator<Item = bool> {
		let mut iter = iter.into_iter();
		#[allow(irrefutable_let_patterns)] // Removing the `if` is unstable.
		if let (_, Some(n)) | (n, None) = iter.size_hint() {
			self.reserve(n);
			let len = self.len();
			let new_len = len + n;
			let new = unsafe { self.get_unchecked_mut(len .. new_len) };

			let mut pulled = 0;
			//  In theory, using direct pointer writes ought to be the fastest
			//  general condition.
			for (ptr, bit) in new.as_mut_bitptr_range().zip(iter.by_ref()) {
				unsafe {
					ptr.write(bit);
				}
				pulled += 1;
			}
			unsafe {
				self.set_len(len + pulled);
			}
		}

		//  Well-behaved iterators will reduce this to a single branch.
		iter.for_each(|bit| self.push(bit));
	}
}

impl<'a, O, T> Extend<&'a bool> for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn extend<I>(&mut self, iter: I)
	where I: IntoIterator<Item = &'a bool> {
		self.extend(iter.into_iter().copied());
	}
}

/// ***DO NOT*** use this. You clearly have a [`BitSlice`]. Use
/// [`BitVec::extend_from_bitslice`].
impl<'a, M, O1, O2, T1, T2> Extend<BitRef<'a, M, O2, T2>> for BitVec<O1, T1>
where
	M: Mutability,
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn extend<I>(&mut self, iter: I)
	where I: IntoIterator<Item = BitRef<'a, M, O2, T2>> {
		self.extend(iter.into_iter().map(|bit| *bit));
	}
}

impl<O, T> Extend<T> for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn extend<I>(&mut self, iter: I)
	where I: IntoIterator<Item = T> {
		for elem in iter.into_iter() {
			self.extend_from_bitslice(elem.view_bits::<O>());
		}
	}
}

impl<'a, O, T> Extend<&'a T> for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn extend<I>(&mut self, iter: I)
	where I: IntoIterator<Item = &'a T> {
		for elem in iter.into_iter() {
			self.extend_from_bitslice(elem.view_bits::<O>());
		}
	}
}

impl<O, T> FromIterator<bool> for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn from_iter<I>(iter: I) -> Self
	where I: IntoIterator<Item = bool> {
		Self::new().tap_mut(|bv| bv.extend(iter.into_iter()))
	}
}

/// ***DO NOT*** use this. You clearly have a [`BitSlice`]. Use
/// [`BitVec::from_bitslice`] instead.
impl<'a, M, O1, O2, T1, T2> FromIterator<BitRef<'a, M, O2, T2>>
	for BitVec<O1, T1>
where
	M: Mutability,
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn from_iter<I>(iter: I) -> Self
	where I: IntoIterator<Item = BitRef<'a, M, O2, T2>> {
		Self::new().tap_mut(|bv| bv.extend(iter.into_iter()))
	}
}

impl<'a, O, T> FromIterator<&'a bool> for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn from_iter<I>(iter: I) -> Self
	where I: IntoIterator<Item = &'a bool> {
		iter.into_iter().copied().pipe(Self::from_iter)
	}
}

/** Collect a sequence of memory elements into a bit-vector.

This is a short-hand for, and implemented as, `iter.collect::<Vec<_>>().into()`.

This is not a standard-library API, and was added for [Issue #83].

[Issue #83]: https://github.com/bitvecto-rs/bitvec/issues/83
**/
impl<O, T> FromIterator<T> for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn from_iter<I>(iter: I) -> Self
	where I: IntoIterator<Item = T> {
		iter.into_iter().collect::<Vec<_>>().pipe(Self::from_vec)
	}
}

impl<'a, O, T> FromIterator<&'a T> for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn from_iter<I>(iter: I) -> Self
	where I: IntoIterator<Item = &'a T> {
		let mut vec = iter
			.into_iter()
			.map(BitStore::load_value)
			.collect::<Vec<T::Mem>>()
			.pipe(ManuallyDrop::new);
		let (ptr, len, capa) = (vec.as_mut_ptr(), vec.len(), vec.capacity());
		unsafe { Vec::from_raw_parts(ptr as *mut T, len, capa) }
			.pipe(Self::from_vec)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> IntoIterator for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	type IntoIter = <BitBox<O, T> as IntoIterator>::IntoIter;
	type Item = <BitBox<O, T> as IntoIterator>::Item;

	#[inline(always)]
	fn into_iter(self) -> Self::IntoIter {
		self.into_boxed_bitslice().into_iter()
	}
}

#[cfg(not(tarpaulin_include))]
impl<'a, O, T> IntoIterator for &'a BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	type IntoIter = <&'a BitSlice<O, T> as IntoIterator>::IntoIter;
	type Item = <&'a BitSlice<O, T> as IntoIterator>::Item;

	#[inline(always)]
	fn into_iter(self) -> Self::IntoIter {
		self.as_bitslice().into_iter()
	}
}

#[cfg(not(tarpaulin_include))]
impl<'a, O, T> IntoIterator for &'a mut BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	type IntoIter = <&'a mut BitSlice<O, T> as IntoIterator>::IntoIter;
	type Item = <&'a mut BitSlice<O, T> as IntoIterator>::Item;

	#[inline(always)]
	fn into_iter(self) -> Self::IntoIter {
		self.as_mut_bitslice().into_iter()
	}
}

/** A draining iterator for [`BitVec`].

This `struct` is created by the [`.drain()`] method on [`BitVec`].

# Original

[`vec::Drain`](alloc::vec::Drain)

[`BitVec`]: crate::vec::BitVec
[`.drain()`]: crate::vec::BitVec::drain
**/
pub struct Drain<'a, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// Exclusive reference to the vector this drains.
	source: &'a mut BitVec<O, T>,
	/// The range of the source vector’s buffer being drained.
	drain: BitPtrRange<Mut, O, T>,
	/// The range of the source vector’s preserved tail. This runs from the back
	/// edge of the drained region to the vector’s original length.
	tail: Range<usize>,
}

impl<'a, O, T> Drain<'a, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	pub(super) fn new<R>(source: &'a mut BitVec<O, T>, range: R) -> Self
	where R: RangeBounds<usize> {
		//  Hold the current vector size for bounds comparison.
		let len = source.len();
		//  Normalize the input range and assert that it is within bounds.
		let drain = dvl::normalize_range(range, len);
		dvl::assert_range(drain.clone(), len);

		//  The tail region is everything after the drain, before the real end.
		let tail = drain.end .. len;
		//  The drain span is an iterator over the provided range.
		let drain = unsafe {
			//  Set the source vector to end before the drain.
			source.set_len(drain.start);
			//  Grab the drain range and produce an iterator over it.
			source
				.as_mut_bitslice()
				.get_unchecked_mut(drain)
				//  Detach the region from the `source` borrow.
				.as_mut_bitptr_range()
		};
		Self {
			source,
			drain,
			tail,
		}
	}

	/// Returns the remaining bits of this iterator as a [`BitSlice`].
	///
	/// # Original
	///
	/// [`Drain::as_slice`](alloc::vec::Drain::as_slice)
	///
	/// # API Differences
	///
	/// This method is renamed, as it operates on a [`BitSlice`] rather than an
	/// element slice.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	#[inline]
	pub fn as_bitslice(&self) -> &'a BitSlice<O, T> {
		self.drain.clone().into_bitspan().to_bitslice_ref()
	}

	#[doc(hidden)]
	#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	#[deprecated = "Use `as_bitslice` to view the underlying slice"]
	pub fn as_slice(&self) -> &BitSlice<O, T> {
		self.as_bitslice()
	}

	/// Attempts to overwrite the drained region with another iterator.
	///
	/// # Type Parameters
	///
	/// - `I`: Some source of `bool`s.
	///
	/// # Parameters
	///
	/// - `&mut self`
	/// - `iter`: A source of `bool`s with which to overwrite the drained span.
	///
	/// # Returns
	///
	/// Whether the drained span was completely filled, or if the replacement
	/// source `iter`ator was exhausted first.
	///
	/// # Effects
	///
	/// The source vector is extended to include all bits filled in from the
	/// replacement `iter`ator, but is *not* extended to include the tail, even
	/// if drained region is completely filled. This work is done in the
	/// destructor.
	fn fill<I>(&mut self, iter: &mut I) -> FillStatus
	where I: Iterator<Item = bool> {
		let bitvec = &mut *self.source;
		//  Get the length of the source vector. This will be grown as `iter`
		//  writes into the drain span.
		let mut len = bitvec.len();
		//  Get the drain span as a bit-pointer range.
		let span = unsafe { bitvec.get_unchecked_mut(len .. self.tail.start) }
			.as_mut_bitptr_range();

		//  Set the exit flag to assume completion.
		let mut out = FillStatus::FullSpan;
		//  Write the `iter` bits into the drain `span`.
		for ptr in span {
			//  While the `iter` is not exhausted, write it into the span and
			//  increase the vector length counter.
			if let Some(bit) = iter.next() {
				unsafe {
					ptr.write(bit);
				}
				len += 1;
			}
			//  If the `iter` exhausts before the drain `span` is filled, set
			//  the exit flag accordingly.
			else {
				out = FillStatus::EmptyInput;
				break;
			}
		}
		//  Update the vector length counter to include the bits written by
		//  `iter`.
		unsafe {
			bitvec.set_len(len);
		}
		out
	}

	/// Inserts `additional` capacity between the vector and the tail.
	///
	/// # Parameters
	///
	/// - `&mut self`
	/// - `additional`: The amount of new bits to reserve between the head and
	///   tail sections of the vector.
	///
	/// # Effects
	///
	/// This is permitted to reällocate the buffer in order to grow capacity.
	/// After completion, the tail segment will be relocated to begin
	/// `additional` bits after the head segment ends. The drain iteration
	/// cursor will not be modified.
	unsafe fn move_tail(&mut self, additional: usize) {
		if additional == 0 {
			return;
		}

		let bitvec = &mut *self.source;
		let tail_len = self.tail.end - self.tail.start;

		//  Reserve allocation capacity for `additional` and the tail.
		//  `.reserve()` begins from the `bitvec.len()`, so the tail length must
		//  still be included.
		let full_len = additional + tail_len;
		bitvec.reserve(full_len);
		let new_tail_start = additional + self.tail.start;
		let orig_tail = mem::replace(
			&mut self.tail,
			new_tail_start .. new_tail_start + tail_len,
		);
		//  Temporarily resize the vector to include the full buffer. This is
		//  necessary until `copy_within_unchecked` stops using `.len()`
		//  internally.
		let len = bitvec.len();
		bitvec.set_len(full_len);
		bitvec.copy_within_unchecked(orig_tail, new_tail_start);
		bitvec.set_len(len);
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> AsRef<BitSlice<O, T>> for Drain<'_, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn as_ref(&self) -> &BitSlice<O, T> {
		self.as_bitslice()
	}
}

#[cfg(not(tarpaulin_include))]
impl<'a, O, T> Debug for Drain<'a, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		fmt.debug_tuple("Drain").field(&self.as_bitslice()).finish()
	}
}

impl<O, T> Iterator for Drain<'_, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	type Item = bool;

	#[inline]
	fn next(&mut self) -> Option<Self::Item> {
		self.drain.next().map(crate::ptr::range::read_raw)
	}

	#[inline(always)]
	fn size_hint(&self) -> (usize, Option<usize>) {
		self.drain.size_hint()
	}

	#[inline(always)]
	fn count(self) -> usize {
		self.len()
	}

	#[inline]
	fn nth(&mut self, n: usize) -> Option<Self::Item> {
		self.drain.nth(n).map(crate::ptr::range::read_raw)
	}

	#[inline(always)]
	fn last(mut self) -> Option<Self::Item> {
		self.next_back()
	}
}

impl<O, T> DoubleEndedIterator for Drain<'_, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn next_back(&mut self) -> Option<Self::Item> {
		self.drain.next_back().map(crate::ptr::range::read_raw)
	}

	#[inline]
	fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
		self.drain.nth_back(n).map(crate::ptr::range::read_raw)
	}
}

impl<O, T> ExactSizeIterator for Drain<'_, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn len(&self) -> usize {
		self.drain.len()
	}
}

impl<O, T> FusedIterator for Drain<'_, O, T>
where
	O: BitOrder,
	T: BitStore,
{
}

unsafe impl<O, T> Send for Drain<'_, O, T>
where
	O: BitOrder,
	T: BitStore,
{
}

unsafe impl<O, T> Sync for Drain<'_, O, T>
where
	O: BitOrder,
	T: BitStore,
{
}

impl<O, T> Drop for Drain<'_, O, T>
where
	O: BitOrder,
	T: BitStore,
{
	fn drop(&mut self) {
		//  Grab the tail range descriptor
		let tail = self.tail.clone();
		//  And compute its length.
		let tail_len = tail.end - tail.start;
		//  If the tail region is empty, then there is no cleanup work to do.
		if tail_len == 0 {
			return;
		}
		//  Otherwise, access the source vector,
		let bitvec = &mut *self.source;
		//  And grab its current end.
		let old_len = bitvec.len();
		let new_len = old_len + tail_len;
		unsafe {
			//  Expand the vector to include where the tail bits will be.
			bitvec.set_len(new_len);
			//  Then move the tail bits into the new location.
			bitvec.copy_within_unchecked(tail, old_len);
			//  This ordering is important! `copy_within_unchecked` uses the
			//  `len` boundary.
		}
	}
}

/** `std` uses a `bool` flag for done/not done, which is less clear about what
it signals.

See <https://github.com/rust-lang/rust/blob/5779815/library/alloc/src/vec.rs#L3327-L3348>.
**/
#[repr(u8)]
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
enum FillStatus {
	/// The drain span is completely filled.
	FullSpan   = 0,
	/// The replacement source is completely emptied.
	EmptyInput = 1,
}

/** A splicing iterator for [`BitVec`].

This struct is created by the [`.splice()`] method on [`BitVec`]. See its
documentation for more.

# Original

[`vec::Splice`](alloc::vec::Splice)

[`BitVec`]: crate::vec::BitVec
[`.splice()`]: crate::vec::BitVec::splice
**/
#[derive(Debug)]
pub struct Splice<'a, O, T, I>
where
	O: BitOrder,
	T: BitStore,
	I: Iterator<Item = bool>,
{
	/// The region of the vector being spliced.
	drain: Drain<'a, O, T>,
	/// The bitstream to be written into the drain.
	splice: I,
}

impl<'a, O, T, I> Splice<'a, O, T, I>
where
	O: BitOrder,
	T: BitStore,
	I: Iterator<Item = bool>,
{
	/// Constructs a splice out of a drain and a replacement.
	#[inline]
	pub(super) fn new<IntoIter>(
		drain: Drain<'a, O, T>,
		splice: IntoIter,
	) -> Self
	where
		IntoIter: IntoIterator<IntoIter = I, Item = bool>,
	{
		let splice = splice.into_iter();
		Self { drain, splice }
	}
}

impl<O, T, I> Iterator for Splice<'_, O, T, I>
where
	O: BitOrder,
	T: BitStore,
	I: Iterator<Item = bool>,
{
	type Item = bool;

	#[inline]
	fn next(&mut self) -> Option<Self::Item> {
		self.drain.next().tap_some(|_| {
			/* Attempt to write a bit into the now-vacated slot at the front of
			the `Drain`. If the `splice` stream produces a bit, then it is
			written into the end of the `Drain`’s buffer, extending it by one.
			This works because `Drain` always truncates its vector to the front
			edge of the drain region, so `bv.len()` is always the first bit of
			the `Drain` region if the `Drain` is willing to yield a bit.
			*/
			if let Some(bit) = self.splice.next() {
				unsafe {
					let bv = &mut *self.drain.source;
					let len = bv.len();
					bv.set_len_unchecked(len + 1);
					bv.set_unchecked(len, bit);
				}
			}
		})
	}

	#[inline(always)]
	fn size_hint(&self) -> (usize, Option<usize>) {
		self.drain.size_hint()
	}

	#[inline(always)]
	fn count(self) -> usize {
		self.len()
	}

	#[inline(always)]
	fn last(mut self) -> Option<Self::Item> {
		self.next_back()
	}
}

impl<O, T, I> DoubleEndedIterator for Splice<'_, O, T, I>
where
	O: BitOrder,
	T: BitStore,
	I: Iterator<Item = bool>,
{
	#[inline(always)]
	fn next_back(&mut self) -> Option<Self::Item> {
		self.drain.next_back()
	}

	#[inline(always)]
	fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
		self.drain.nth_back(n)
	}
}

impl<O, T, I> ExactSizeIterator for Splice<'_, O, T, I>
where
	O: BitOrder,
	T: BitStore,
	I: Iterator<Item = bool>,
{
	#[inline(always)]
	fn len(&self) -> usize {
		self.drain.len()
	}
}

impl<O, T, I> FusedIterator for Splice<'_, O, T, I>
where
	O: BitOrder,
	T: BitStore,
	I: Iterator<Item = bool>,
{
}

impl<O, T, I> Drop for Splice<'_, O, T, I>
where
	O: BitOrder,
	T: BitStore,
	I: Iterator<Item = bool>,
{
	fn drop(&mut self) {
		let tail = self.drain.tail.clone();
		let tail_len = tail.end - tail.start;
		let bitvec = &mut *self.drain.source;

		//  If the `drain` has no tail span, then extend the vector with the
		//  splice and exit.
		if tail_len == 0 {
			bitvec.extend(self.splice.by_ref());
			return;
		}

		//  Fill the drained range first. If the `splice` exhausts, then the
		//  `Drain` destructor will handle relocating the vector tail segment.
		if let FillStatus::EmptyInput = self.drain.fill(&mut self.splice) {
			return;
		}

		//  If the `splice` has not yet exhausted, then the `Drain` needs to
		//  adjust to receive its contents.
		let len = match self.splice.size_hint() {
			(n, None) | (_, Some(n)) => n,
		};
		unsafe {
			self.drain.move_tail(len);
		}
		//  Now that the tail has been relocated, fill the `splice` into it. If
		//  this exhausts the `splice`, exit.
		if let FillStatus::EmptyInput = self.drain.fill(&mut self.splice) {
			return;
		}

		/* If the `splice` *still* has bits to provide, then its `.size_hint()`
		is untrustworthy. Collect the `splice` into a vector, then insert the
		vector into the spliced region.
		*/
		let mut collected = self.splice.by_ref().collect::<BitVec>().into_iter();
		let len = collected.len();
		if len > 0 {
			unsafe {
				self.drain.move_tail(len);
			}
			let filled = self.drain.fill(&mut collected);
			debug_assert_eq!(filled, FillStatus::EmptyInput);
			debug_assert_eq!(collected.len(), 0);
		}
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/vec/iter.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/vec/ops.rs =====
//! Port of the `Vec<T>` operator implementations.

use core::{
	mem::ManuallyDrop,
	ops::{
		BitAnd,
		BitAndAssign,
		BitOr,
		BitOrAssign,
		BitXor,
		BitXorAssign,
		Deref,
		DerefMut,
		Index,
		IndexMut,
		Not,
	},
};

use super::BitVec;
use crate::{
	order::BitOrder,
	slice::BitSlice,
	store::BitStore,
};

#[cfg(not(tarpaulin_include))]
impl<O, T, Rhs> BitAnd<Rhs> for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
	BitSlice<O, T>: BitAndAssign<Rhs>,
{
	type Output = Self;

	#[inline(always)]
	fn bitand(mut self, rhs: Rhs) -> Self::Output {
		self &= rhs;
		self
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T, Rhs> BitAndAssign<Rhs> for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
	BitSlice<O, T>: BitAndAssign<Rhs>,
{
	#[inline(always)]
	fn bitand_assign(&mut self, rhs: Rhs) {
		*self.as_mut_bitslice() &= rhs;
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T, Rhs> BitOr<Rhs> for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
	BitSlice<O, T>: BitOrAssign<Rhs>,
{
	type Output = Self;

	#[inline(always)]
	fn bitor(mut self, rhs: Rhs) -> Self::Output {
		self |= rhs;
		self
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T, Rhs> BitOrAssign<Rhs> for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
	BitSlice<O, T>: BitOrAssign<Rhs>,
{
	#[inline(always)]
	fn bitor_assign(&mut self, rhs: Rhs) {
		*self.as_mut_bitslice() |= rhs;
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T, Rhs> BitXor<Rhs> for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
	BitSlice<O, T>: BitXorAssign<Rhs>,
{
	type Output = Self;

	#[inline(always)]
	fn bitxor(mut self, rhs: Rhs) -> Self::Output {
		self ^= rhs;
		self
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T, Rhs> BitXorAssign<Rhs> for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
	BitSlice<O, T>: BitXorAssign<Rhs>,
{
	#[inline(always)]
	fn bitxor_assign(&mut self, rhs: Rhs) {
		*self.as_mut_bitslice() ^= rhs;
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Deref for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	type Target = BitSlice<O, T>;

	#[inline(always)]
	fn deref(&self) -> &Self::Target {
		self.as_bitslice()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> DerefMut for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn deref_mut(&mut self) -> &mut Self::Target {
		self.as_mut_bitslice()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Drop for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn drop(&mut self) {
		//  Run the `Vec` destructor to deällocate the buffer.
		self.with_vec(|slot| unsafe { ManuallyDrop::drop(slot) });
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T, Idx> Index<Idx> for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
	BitSlice<O, T>: Index<Idx>,
{
	type Output = <BitSlice<O, T> as Index<Idx>>::Output;

	#[inline(always)]
	fn index(&self, index: Idx) -> &Self::Output {
		self.as_bitslice().index(index)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T, Idx> IndexMut<Idx> for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
	BitSlice<O, T>: IndexMut<Idx>,
{
	#[inline(always)]
	fn index_mut(&mut self, index: Idx) -> &mut Self::Output {
		self.as_mut_bitslice().index_mut(index)
	}
}

/** This implementation inverts all elements in the live buffer. You cannot rely
on the value of bits in the buffer that are outside the domain of
[`BitVec::as_mut_bitslice`].
**/
#[cfg(not(tarpaulin_include))]
impl<O, T> Not for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	type Output = Self;

	#[inline]
	fn not(mut self) -> Self::Output {
		for elem in self.as_mut_raw_slice() {
			elem.store_value(!elem.load_value())
		}
		self
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/vec/ops.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/vec/tests.rs =====
#![cfg(test)]

#[cfg(not(feature = "std"))]
use alloc::{
	format,
	vec,
	vec::Vec,
};
use core::{
	borrow::{
		Borrow,
		BorrowMut,
	},
	cmp::Ordering,
	convert::TryInto,
	iter,
};
#[cfg(feature = "std")]
use std::panic::catch_unwind;

use crate::prelude::*;

#[test]
fn from_vec() {
	let mut bv = BitVec::<Msb0, u8>::from_vec(vec![0, 1, 2, 3]);
	let bp_mut = bv.as_mut_bitslice() as *mut _;
	assert_eq!(bv.len(), 32);
	assert_eq!(bv.count_ones(), 4);

	let capacity = bv.capacity();
	let bits = bv.leak();
	assert_eq!(bits as *mut _, bp_mut);
	let (ptr, length) = (bits.as_mut_bitptr(), bits.len());
	let bv = unsafe { BitVec::from_raw_parts(ptr, length, capacity) };
	assert_eq!(bv.as_raw_slice(), &[0, 1, 2, 3]);
}

#[test]
fn push() {
	let mut bvm08 = BitVec::<Msb0, u8>::new();
	assert!(bvm08.is_empty());

	bvm08.push(false);
	assert_eq!(bvm08.len(), 1);
	assert!(!bvm08[0]);

	bvm08.push(true);
	assert_eq!(bvm08.len(), 2);
	assert!(bvm08[1]);

	bvm08.extend(&[true; 3]);
	bvm08.extend(&[false; 3]);
	assert_eq!(bvm08, bits![0, 1, 1, 1, 1, 0, 0, 0]);
}

#[test]
fn check_buffers() {
	let mut bv = bitvec![LocalBits, u16; 0; 40];
	assert_eq!(bv.elements(), 3);

	assert_eq!(bv.as_raw_ptr(), bv.as_raw_slice().as_ptr());
	assert_eq!(bv.as_mut_raw_ptr(), bv.as_mut_raw_slice().as_mut_ptr());
}

#[test]
fn buffer_control() {
	let data = 0xA5u8;
	let bits = data.view_bits::<Msb0>();

	let mut bv = bits[2 ..].to_bitvec();
	assert_eq!(bv.as_raw_slice(), &[0xA5u8]);
	bv.force_align();
	assert_eq!(bv.as_raw_slice(), &[0b1001_0101]);
	bv.force_align();
	assert_eq!(bv.as_raw_slice(), &[0b1001_0101]);

	bv.truncate(6);
	bv.set_uninitialized(false);
	assert_eq!(bv.as_raw_slice(), &[0b1001_0100]);
	bv.set_uninitialized(true);
	assert_eq!(bv.as_raw_slice(), &[0b1001_0111]);
	assert_eq!(bv, bits![1, 0, 0, 1, 0, 1]);
}

#[test]
#[cfg(not(target_arch = "riscv64"))]
#[should_panic(expected = "Vector capacity exceeded")]
fn overcommit() {
	BitVec::<LocalBits, usize>::with_capacity(
		BitSlice::<LocalBits, usize>::MAX_BITS + 1,
	);
}

#[test]
#[cfg(feature = "std")]
fn reservations() {
	let mut bv = bitvec![1; 40];
	assert!(bv.capacity() >= 40);
	bv.reserve(100);
	assert!(bv.capacity() >= 140, "{}", bv.capacity());
	bv.shrink_to_fit();
	assert!(bv.capacity() >= 40);

	//  Trip the first assertion by wrapping around the `usize` boundary.
	assert!(
		catch_unwind(|| {
			let mut bv = bitvec![1; 100];
			bv.reserve(!0 - 50);
		})
		.is_err()
	);

	//  Trip the second assertion by exceeding `MAX_BITS` without wrapping.
	assert!(
		catch_unwind(|| {
			let mut bv = bitvec![1; 100];
			bv.reserve(BitSlice::<LocalBits, usize>::MAX_BITS - 50);
		})
		.is_err()
	);

	let mut bv = bitvec![1; 40];
	assert!(bv.capacity() >= 40);
	bv.reserve_exact(100);
	assert!(bv.capacity() >= 140, "{}", bv.capacity());

	//  Trip the first assertion by wrapping around the `usize` boundary.
	assert!(
		catch_unwind(|| {
			let mut bv = bitvec![1; 100];
			bv.reserve_exact(!0 - 50);
		})
		.is_err()
	);

	//  Trip the second assertion by exceeding `MAX_BITS` without wrapping.
	assert!(
		catch_unwind(|| {
			let mut bv = bitvec![1; 100];
			bv.reserve_exact(BitSlice::<LocalBits, usize>::MAX_BITS - 50);
		})
		.is_err()
	);
}

#[test]
#[allow(deprecated)]
fn iterators() {
	let bv: BitVec<Msb0, u8> = [0xC3, 0x96].iter().collect();
	assert_eq!(bv.count_ones(), 8);
	assert_eq!(bv, bits![1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0]);

	let data = 0x35u8.view_bits::<Msb0>();
	let bv: BitVec<Msb0, u8> = data.iter().collect();
	assert_eq!(bv.count_ones(), 4);

	for (l, r) in (&bv).into_iter().zip(bits![0, 0, 1, 1, 0, 1, 0, 1]) {
		assert_eq!(*l, *r);
	}

	let mut bv = bv;
	*(&mut bv).into_iter().next().unwrap() = true;

	let mut iter = bv.into_iter();
	assert!(iter.next().unwrap());
	assert_eq!(iter.as_bitslice(), data[1 ..]);
	assert_eq!(iter.as_mut_bitslice(), data[1 ..]);

	assert_eq!(iter.size_hint(), (7, Some(7)));
	assert_eq!(bitvec![0; 10].into_iter().count(), 10);
	assert!(bitvec![0, 0, 1, 0].into_iter().nth(2).unwrap());
	assert!(bitvec![0, 1].into_iter().last().unwrap());
	assert!(bitvec![0, 0, 1].into_iter().next_back().unwrap());
	assert!(bitvec![0, 1, 0, 0].into_iter().nth_back(2).unwrap());

	let mut bv = bitvec![0, 0, 0, 1, 1, 1, 0, 0, 0];
	let mut drain = bv.drain(3 .. 6);
	let mid = bits![1; 3];
	assert_eq!(drain.as_bitslice(), mid);
	let drain_span: &BitSlice = drain.as_ref();
	assert_eq!(drain_span, mid);

	assert!(drain.nth(1).unwrap());
	assert!(drain.last().unwrap());
	assert_eq!(bitvec![0, 0, 1, 1, 0, 0,].drain(2 .. 4).count(), 2);

	let mut bv = bitvec![0, 0, 1, 0, 1, 1, 0, 1, 0, 0];
	let mut splice = bv.splice(2 .. 8, iter::repeat(false).take(4));
	assert!(splice.next().unwrap());
	assert!(splice.next_back().unwrap());
	assert!(splice.nth(1).unwrap());
	assert!(splice.nth_back(1).unwrap());
	drop(splice);
	assert_eq!(bv, bits![0; 8]);

	let mut bv = bitvec![0, 1, 1, 1, 1, 0];
	let splice = bv.splice(1 .. 5, Some(false));
	assert_eq!(splice.count(), 4);
	assert_eq!(bv, bits![0; 3]);

	//  Attempt to hit branches in the Splice destructor.

	let mut bv = bitvec![0, 0, 0, 1, 1, 1];
	drop(bv.splice(3 .., Some(false)));
	assert_eq!(bv, bits![0; 4]);

	let mut bv = bitvec![0, 0, 0, 1, 1, 1];
	let mut splice = bv.splice(3 .., [false; 2].iter().copied());
	assert!(splice.next().unwrap());
	assert!(splice.last().unwrap());
	assert_eq!(bv, bits![0; 5]);
}

#[test]
fn misc() {
	let mut bv = bitvec![0; 0];
	bv.insert(0, true);
	assert_eq!(bv, bits![1]);

	let mut bv = bitvec![1; 10];
	bv.truncate(20);
	assert_eq!(bv, bits![1; 10]);
	bv.truncate(5);
	assert_eq!(bv, bits![1; 5]);

	let mut bv = bitvec![0, 0, 1, 0, 0];
	assert!(bv.swap_remove(2));
	assert!(bv.not_any());

	bv.insert(2, true);
	assert_eq!(bv, bits![0, 0, 1, 0, 0]);

	bv.remove(2);
	assert!(bv.not_any());

	let mut bv = bitvec![0, 0, 1, 1, 0, 1, 0, 1, 0, 0];
	bv.retain(|idx, bit| !(idx & 1 == 0 && *bit));
	//                                         ^^^ even ^^^    prime
	assert_eq!(bv, bits![0, 0, 1, 0, 1, 0, 1, 0, 0]);
	//                        ^ 2 is the only even prime

	let mut bv_1 = bitvec![Lsb0, u8; 0; 5];
	let mut bv_2 = bitvec![Msb0, u16; 1; 5];
	let mut bv_3 = bv_1.clone();

	bv_1.append(&mut bv_2);
	assert_eq!(bv_1, bits![0, 0, 0, 0, 0, 1, 1, 1, 1, 1]);
	assert!(bv_2.is_empty());

	bv_1.append(&mut bv_3);
	assert_eq!(bv_1, bits![0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]);
	assert!(bv_3.is_empty());

	let bv_4 = bv_1.split_off(5);
	assert!(bv_1.not_any());
	assert!(bv_4.some());

	let mut last = false;
	bv_1.resize_with(10, || {
		last = !last;
		last
	});
	assert_eq!(bv_1, bits![0, 0, 0, 0, 0, 1, 0, 1, 0, 1]);
}

#[test]
fn cloning() {
	let mut a = bitvec![0];
	let b = bitvec![1; 20];

	assert_ne!(a, b);
	a.clone_from(&b);
	assert_eq!(a, b);
}

#[test]
fn vec_splice() {
	let mut bv = bitvec![0, 1, 0];
	let new = bits![1, 0];
	let old: BitVec = bv.splice(.. 2, new.iter().by_val()).collect();
	assert_eq!(bv, bits![1, 0, 0]);
	assert_eq!(old, bits![0, 1]);

	let mut bv = bitvec![0, 1, 0];
	let new = bits![1, 1, 0, 0, 1, 1];
	let old: BitVec = bv.splice(1 .. 2, new.iter().by_val()).collect();
	assert_eq!(bv, bits![0, 1, 1, 0, 0, 1, 1, 0]);
	assert_eq!(old, bits![1]);
}

#[test]
fn ops() {
	let a = bitvec![0, 0, 1, 1];
	let b = bitvec![0, 1, 0, 1];

	let c = a.clone() & b.clone();
	assert_eq!(c, bits![0, 0, 0, 1]);
	let d = a.clone() | b.clone();
	assert_eq!(d, bits![0, 1, 1, 1]);
	let e = a.clone() ^ b.clone();
	assert_eq!(e, bits![0, 1, 1, 0]);
	let f = !e;
	assert_eq!(f, bits![1, 0, 0, 1]);
}

#[test]
fn traits() {
	let mut bv = bitvec![0, 0, 1, 1];
	let bits: &BitSlice = bv.borrow();
	assert_eq!(bv, bits);
	let bits: &mut BitSlice = bv.borrow_mut();
	assert_eq!(bits, bits![0, 0, 1, 1]);
	assert!(bv.as_bitslice().eq(&bv));

	let bv2 = bitvec![0, 1, 0, 1];
	assert_eq!(bv.cmp(&bv2), Ordering::Less);
	assert!(!bv.eq(&bv2));
	assert_eq!((&bv.as_bitslice()).partial_cmp(&bv2), Some(Ordering::Less));

	let _: &BitSlice = bv.as_ref();
	let _: &mut BitSlice = bv.as_mut();

	let bv: BitVec = bits![mut 0, 1, 0, 1].into();
	assert_eq!(bv, bits![0, 1, 0, 1]);
	let bv: BitVec = bitbox![0, 1, 0, 1].into();
	assert_eq!(bv, bits![0, 1, 0, 1]);
	let vec: Vec<usize> = bv.into();
	assert_eq!(vec.len(), 1);
	let bv: Result<BitVec, Vec<usize>> = vec.try_into();
	assert!(bv.is_ok());
}

#[test]
fn format() {
	let bv = bitvec![0, 0, 1, 1, 0, 1, 0, 1];
	assert_eq!(format!("{}", bv), format!("{}", bv.as_bitslice()));
	assert_eq!(format!("{:b}", bv), format!("{:b}", bv.as_bitslice()));
	assert_eq!(format!("{:o}", bv), format!("{:o}", bv.as_bitslice()));
	assert_eq!(format!("{:x}", bv), format!("{:x}", bv.as_bitslice()));
	assert_eq!(format!("{:X}", bv), format!("{:X}", bv.as_bitslice()));

	let text = format!("{:?}", bitvec![Msb0, u8; 0, 1, 0, 0]);
	assert!(
		text.starts_with("BitVec<bitvec::order::Msb0, u8> { addr: 0x"),
		"{}",
		text
	);
	assert!(
		text.contains(", head: 000, bits: 4, capacity: "),
		"{}",
		text
	);
	assert!(text.ends_with(" } [0100]"), "{}", text);
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/vec/tests.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/vec/traits.rs =====
//! Non-operator trait implementations.

use alloc::vec::Vec;
use core::{
	borrow::{
		Borrow,
		BorrowMut,
	},
	cmp,
	convert::TryFrom,
	fmt::{
		self,
		Binary,
		Debug,
		Display,
		Formatter,
		LowerHex,
		Octal,
		UpperHex,
	},
	hash::{
		Hash,
		Hasher,
	},
};

use tap::Tap;

use super::BitVec;
use crate::{
	boxed::BitBox,
	order::BitOrder,
	slice::BitSlice,
	store::BitStore,
};

#[cfg(not(tarpaulin_include))]
impl<O, T> Borrow<BitSlice<O, T>> for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn borrow(&self) -> &BitSlice<O, T> {
		self.as_bitslice()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> BorrowMut<BitSlice<O, T>> for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn borrow_mut(&mut self) -> &mut BitSlice<O, T> {
		self.as_mut_bitslice()
	}
}

impl<O, T> Clone for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	fn clone(&self) -> Self {
		Self::new().tap_mut(|bv| bv.clone_from(self))
	}

	fn clone_from(&mut self, source: &Self) {
		self.clear();
		self.resize(source.len(), false);
		self.copy_from_bitslice(source.as_bitslice());
	}
}

impl<O, T> Eq for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Ord for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn cmp(&self, other: &Self) -> cmp::Ordering {
		self.as_bitslice().cmp(other.as_bitslice())
	}
}

#[cfg(not(tarpaulin_include))]
impl<O1, O2, T1, T2> PartialEq<BitVec<O2, T2>> for BitSlice<O1, T1>
where
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn eq(&self, other: &BitVec<O2, T2>) -> bool {
		self == other.as_bitslice()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O1, O2, T1, T2> PartialEq<BitVec<O2, T2>> for &BitSlice<O1, T1>
where
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn eq(&self, other: &BitVec<O2, T2>) -> bool {
		*self == other.as_bitslice()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O1, O2, T1, T2> PartialEq<BitVec<O2, T2>> for &mut BitSlice<O1, T1>
where
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn eq(&self, other: &BitVec<O2, T2>) -> bool {
		**self == other.as_bitslice()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T, Rhs> PartialEq<Rhs> for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
	Rhs: ?Sized + PartialEq<BitSlice<O, T>>,
{
	#[inline]
	fn eq(&self, other: &Rhs) -> bool {
		other == self.as_bitslice()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O1, O2, T1, T2> PartialOrd<BitVec<O2, T2>> for BitSlice<O1, T1>
where
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn partial_cmp(&self, other: &BitVec<O2, T2>) -> Option<cmp::Ordering> {
		self.partial_cmp(other.as_bitslice())
	}
}

#[cfg(not(tarpaulin_include))]
impl<'a, O1, O2, T1, T2> PartialOrd<BitVec<O2, T2>> for &'a BitSlice<O1, T1>
where
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn partial_cmp(&self, other: &BitVec<O2, T2>) -> Option<cmp::Ordering> {
		self.partial_cmp(other.as_bitslice())
	}
}

#[cfg(not(tarpaulin_include))]
impl<'a, O1, O2, T1, T2> PartialOrd<BitVec<O2, T2>> for &'a mut BitSlice<O1, T1>
where
	O1: BitOrder,
	O2: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	#[inline]
	fn partial_cmp(&self, other: &BitVec<O2, T2>) -> Option<cmp::Ordering> {
		self.partial_cmp(other.as_bitslice())
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T, Rhs> PartialOrd<Rhs> for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
	Rhs: ?Sized + PartialOrd<BitSlice<O, T>>,
{
	#[inline]
	fn partial_cmp(&self, other: &Rhs) -> Option<cmp::Ordering> {
		other.partial_cmp(self.as_bitslice())
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> AsRef<BitSlice<O, T>> for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn as_ref(&self) -> &BitSlice<O, T> {
		self.as_bitslice()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> AsMut<BitSlice<O, T>> for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn as_mut(&mut self) -> &mut BitSlice<O, T> {
		self.as_mut_bitslice()
	}
}

#[cfg(not(tarpaulin_include))]
impl<'a, O, T> From<&'a BitSlice<O, T>> for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn from(slice: &'a BitSlice<O, T>) -> Self {
		Self::from_bitslice(slice)
	}
}

#[cfg(not(tarpaulin_include))]
impl<'a, O, T> From<&'a mut BitSlice<O, T>> for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn from(slice: &'a mut BitSlice<O, T>) -> Self {
		Self::from_bitslice(slice)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> From<BitBox<O, T>> for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn from(boxed: BitBox<O, T>) -> Self {
		boxed.into_bitvec()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> From<BitVec<O, T>> for Vec<T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn from(bv: BitVec<O, T>) -> Self {
		bv.into_vec()
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> TryFrom<Vec<T>> for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	type Error = Vec<T>;

	#[inline(always)]
	fn try_from(vec: Vec<T>) -> Result<Self, Self::Error> {
		Self::try_from_vec(vec)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Default for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn default() -> Self {
		Self::new()
	}
}

impl<O, T> Debug for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		self.as_bitspan().render(fmt, "Vec", &[(
			"capacity",
			&self.capacity() as &dyn Debug,
		)])?;
		fmt.write_str(" ")?;
		Display::fmt(self, fmt)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Display for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		Display::fmt(self.as_bitslice(), fmt)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Binary for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		Binary::fmt(self.as_bitslice(), fmt)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> LowerHex for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		LowerHex::fmt(self.as_bitslice(), fmt)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Octal for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		Octal::fmt(self.as_bitslice(), fmt)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> UpperHex for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
		UpperHex::fmt(self.as_bitslice(), fmt)
	}
}

#[cfg(not(tarpaulin_include))]
impl<O, T> Hash for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	#[inline(always)]
	fn hash<H>(&self, state: &mut H)
	where H: Hasher {
		self.as_bitslice().hash(state)
	}
}

unsafe impl<O, T> Send for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
}

unsafe impl<O, T> Sync for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
}

impl<O, T> Unpin for BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/vec/traits.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/vec.rs =====
/*! A dynamically-allocated buffer containing a [`BitSlice`] region.

You can read the standard library’s [`alloc::vec` module documentation][std]
here.

This module defines the [`BitVec`] buffer, and all of its associated support
code.

[`BitVec`] is equivalent to [`Vec<bool>`], in its operation and in its
relationship to the [`BitSlice`] type. Most of the interesting work to be done
on a bit-sequence is implemented in `BitSlice`, to which `BitVec` dereferences,
and the vector container itself only exists to maintain ownership, implement
dynamic resizing, and provide some specializations that cannot safely be done on
`BitSlice` alone.

[`BitSlice`]: crate::slice::BitSlice
[`BitVec`]: crate::vec::BitVec
[`Vec<bool>`]: alloc::vec::Vec
[std]: mod@alloc::vec
!*/

#![cfg(feature = "alloc")]

#[cfg(not(feature = "std"))]
use alloc::vec;
use alloc::vec::Vec;
use core::{
	convert::TryInto,
	mem::{
		self,
		ManuallyDrop,
	},
	slice,
};

use funty::{
	IsInteger,
	IsNumber,
};
use tap::{
	pipe::Pipe,
	tap::Tap,
};

pub use self::iter::{
	Drain,
	Splice,
};
pub use crate::boxed::IntoIter;
use crate::{
	boxed::BitBox,
	domain::Domain,
	index::BitIdx,
	mem::BitRegister,
	order::{
		BitOrder,
		Lsb0,
	},
	ptr::{
		BitPtr,
		BitSpan,
		BitSpanError,
		Const,
		Mut,
	},
	slice::BitSlice,
	store::BitStore,
};

mod api;
mod iter;
mod ops;
mod traits;

/** A contiguous growable array of bits.

This is a managed, heap-allocated, buffer that contains a [`BitSlice`] region.
It is analagous to [`Vec<bool>`], and is written to be very nearly a drop-in
replacement for it. This type contains little interesting behavior in its own
right; most of its behavior is provided by dereferencing to its managed
[`BitSlice`] buffer. It instead serves primarily as an interface to the
allocator, and has some specialized behaviors for its fully-owned memory buffer.

# Documentation

All APIs that mirror something in the standard library will have an `Original`
section linking to the corresponding item. All APIs that have a different
signature or behavior than the original will have an `API Differences` section
explaining what has changed, and how to adapt your existing code to the change.

These sections look like this:

# Original

[`Vec<T>`](alloc::vec::Vec)

# API Differences

The buffer type [`Vec<bool>`] has no type parameters. `BitVec<O, T>` has the
same two type parameters as [`BitSlice<O, T>`][`BitSlice`]. Otherwise, `BitVec`
is able to implement the full API surface of `Vec<bool>`.

# Examples

Because `BitVec` takes type parameters, but has default type arguments for them,
you will need to specify its type parameters when using its associated
functions. The easiest way to do this is to declare bindings type as `: BitVec`,
which uses the default type arguments.

```rust
use bitvec::prelude::*;

let mut bv: BitVec = BitVec::new();
bv.push(false);
bv.push(true);

assert_eq!(bv.len(), 2);
assert_eq!(bv[0], false);

assert_eq!(bv.pop(), Some(true));
assert_eq!(bv.len(), 1);

// `BitVec` cannot yet support `[]=` write indexing.
*bv.get_mut(0).unwrap() = true;
assert_eq!(bv[0], true);

bv.extend(bits![0, 1, 0]);

for bit in &bv {
  println!("{}", bit);
}
assert_eq!(bv, bits![1, 0, 1, 0]);
```

The [`bitvec!`] macro is provided to make initialization more convenient:

```rust
use bitvec::prelude::*;

let mut bv = bitvec![0, 0, 1];
bv.push(true);
assert_eq!(bv, bits![0, 0, 1, 1]);
```

It has the same argument syntax as [`vec!`]. In addition, it can take type
arguments for ordering and storage:

```rust
use bitvec::prelude::*;

let bv = bitvec![Msb0, u16; 1; 30];
assert!(bv.all());
assert_eq!(bv.len(), 30);
```

# Indexing

The `BitVec` type allows you to access bits by index, because it implements the
[`Index`] trait. However, because [`IndexMut`] requires producing an `&mut bool`
reference, it cannot implement `[]=` index assignment syntax. Instead, you must
use [`get_mut`] or [`get_unchecked_mut`] to produce proxy types that can serve
the same purpose.

# Slicing

A `BitVec` is resizable, while [`BitSlice`] is a fixed-size view of a buffer.
Just as with ordinary [`Vec`]s and slices, you can get a `BitSlice` from a
`BitVec` by borrowing it:

```rust
use bitvec::prelude::*;

fn read_bitslice(slice: &BitSlice) {
  // …
}

let bv = bitvec![0; 30];
read_bitslice(&bv);

// … and that’s all!
// you can also do it like this:
let x: &BitSlice = &bv;
```

As with ordinary Rust types, you should prefer passing bit-slices rather than
buffers when you just want to inspect the data, and not manage the underlying
memory region.

# Behavior

Because `BitVec` is a fully-owned buffer, it is able to operate on its memory
without concern for any other views that may alias. This enables it to
specialize some [`BitSlice`] behavior to be faster or more efficient. However,
`BitVec` is *not* restricted to only using unaliased integer storage, and
technically permits the construction of `BitVec<_, AtomicType>`.

This restriction is extremely awkward and constraining to write in the library,
and clients will probably never attempt to construct them, but the possibility
is still present. Be aware of this possibility when using generic code to
convert from `BitSlice` to `BitVec`. Fully-typed code does not need to be
concerned with this possibility.

# Capacity and Reällocation

The capacity of a bit-vector is the amount of space allocated for any future
bits that will be added onto the vector. This is not to be confused with the
*length* of a vector, which specifies the number of actual bits within the
vector. If a vector’s length exceeds its capacity, its capacity will
automatically be increased, but its buffer will have to be reällocated

For example, a bit-vector with capacity 64 and length 0 would be an empty vector
with space for 64 more bits. Pushing 64 or fewer bits onto the vector will not
change its capacity or cause reällocation to occur. However, if the vector’s
length is increased to 65, it *may* have to reällocate, which can be slow. For
this reason, it is recommended to use [`BitVec::with_capacity`] whenever
possible to specify how big the vector is expected to get.

# Safety

Like [`BitSlice`], `BitVec` is exactly equal in size to [`Vec`], and is also
absolutely representation-incompatible with it. You must never attempt to
type-cast between `Vec<T>` and `BitVec` in any way, nor attempt to modify the
memory value of a `BitVec` handle. Doing so will cause allocator and memory
errors in your program, likely inducing a panic.

Everything in the `BitVec` public API, even the `unsafe` parts, are guaranteed
to have no more unsafety than their equivalent items in the standard library.
All `unsafe` APIs will have documentation explicitly detailing what the API
requires you to uphold in order for it to function safely and correctly. All
safe APIs will do so themselves.

# Performance

The choice of [`BitStore`] type parameter can impact your vector’s performance,
as the allocator operates in units of `T` rather than in bits. This means that
larger register types will increase the amount of memory reserved in each call
to the allocator, meaning fewer calls to [`push`] will actually cause a
reällocation. In addition, iteration over the vector is governed by the
[`BitSlice`] characteristics on the type parameter. You are generally better off
using larger types when your vector is a data collection rather than a specific
I/O protocol buffer.

# Macro Construction

Heap allocation can only occur at runtime, but the [`bitvec!`] macro will
construct an appropriate [`BitSlice`] buffer at compile-time, and at run-time,
only copy the buffer into a heap allocation.

[`BitStore`]: crate::store::BitStore
[`BitSlice`]: crate::slice::BitSlice
[`BitVec::with_capacity`]: Self::with_capacity
[`Index`]: core::ops::Index
[`IndexMut`]: core::ops::IndexMut
[`Vec`]: alloc::vec::Vec
[`Vec<bool>`]: alloc::vec::Vec
[`bitvec!`]: macro@crate::bitvec
[`vec!`]: macro@alloc::vec
[`get_mut`]: crate::slice::BitSlice::get_mut
[`get_unchecked_mut`]: crate::slice::BitSlice::get_unchecked_mut
[`push`]: Self::push
**/
#[repr(C)]
pub struct BitVec<O = Lsb0, T = usize>
where
	O: BitOrder,
	T: BitStore,
{
	/// Region pointer describing the live portion of the owned buffer.
	bitspan: BitSpan<Mut, O, T>,
	/// Allocated capacity, in elements `T`, of the owned buffer.
	capacity: usize,
}

/// General-purpose functions not present on `Vec<T>`.
impl<O, T> BitVec<O, T>
where
	O: BitOrder,
	T: BitStore,
{
	/// Constructs a `BitVec` from a value repeated many times.
	///
	/// This function is equivalent to the `bitvec![O, T; bit; len]` [macro]
	/// call, and is in fact the implementation of that macro syntax.
	///
	/// # Parameters
	///
	/// - `bit`: The bit value to which all `len` allocated bits will be set.
	/// - `len`: The number of live bits in the constructed `BitVec`.
	///
	/// # Returns
	///
	/// A `BitVec` with `len` live bits, all set to `bit`.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bv = BitVec::<Msb0, u8>::repeat(true, 20);
	/// assert_eq!(bv, bits![1; 20]);
	/// ```
	///
	/// [macro]: macro@crate::bitvec
	#[inline]
	pub fn repeat(bit: bool, len: usize) -> Self {
		let mut out = Self::with_capacity(len);
		unsafe {
			out.set_len(len);
		}
		out.set_elements(if bit { T::Mem::ALL } else { T::Mem::ZERO });
		out
	}

	/// Copies the contents of a [`BitSlice`] into a new allocation.
	///
	/// This is an exact copy: the newly-created bit-vector is initialized with
	/// a direct copy of the `slice`’s underlying contents, and its handle is
	/// set to use `slice`’s head index. Slices that do not begin at the zeroth
	/// bit of the base element will thus create misaligned vectors.
	///
	/// You can move the bit-vector contents down to begin at the zero index of
	/// the bit-vector’s buffer with [`force_align`].
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bits = bits![0, 1, 0, 1, 1, 0, 1, 1];
	/// let bv = BitVec::from_bitslice(&bits[2 ..]);
	/// assert_eq!(bv, bits[2 ..]);
	/// assert_eq!(bits.as_raw_slice(), bv.as_raw_slice());
	/// ```
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	/// [`force_align`]: Self::force_align
	#[inline]
	pub fn from_bitslice(slice: &BitSlice<O, T>) -> Self {
		let bitspan = slice.as_bitspan();

		let mut vec = bitspan
			.elements()
			.pipe(Vec::with_capacity)
			.pipe(ManuallyDrop::new);

		match slice.domain() {
			Domain::Enclave { elem, .. } => vec.push(elem.load_value()),
			Domain::Region { head, body, tail } => {
				if let Some((_, elem)) = head {
					vec.push(elem.load_value());
				}
				vec.extend(body.iter().map(BitStore::load_value));
				if let Some((elem, _)) = tail {
					vec.push(elem.load_value());
				}
			},
		}

		let bitspan = unsafe {
			BitSpan::new_unchecked(
				vec.as_mut_ptr()
					.cast::<T>()
					.try_into()
					.unwrap_or_else(|err| {
						unreachable!(
							"The allocator produced an improper address: {}",
							err
						)
					}),
				bitspan.head(),
				bitspan.len(),
			)
		};

		let capacity = vec.capacity();
		Self { bitspan, capacity }
	}

	/// Constructs a new `BitVec` from the bit-pattern of a single element.
	///
	/// This function copies `elem` into a new vector, then views that vector as
	/// bits.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// assert_eq!(BitVec::<Msb0, _>::from_element(0xABBAu16).count_ones(), 10);
	/// ```
	#[inline]
	pub fn from_element(elem: T) -> Self {
		vec![elem].pipe(Self::from_vec)
	}

	/// Constructs a new `BitVec` from the bit-pattern of an element slice.
	///
	/// This function copies `slice` into a new vector, then views that vector
	/// as bits.
	///
	/// # Parameters
	///
	/// - `slice`: A slice of elements. It should not exceed [`BitSlice::<O,
	///   T>::MAX_ELTS`].
	///
	/// # Returns
	///
	/// This returns an error if [`BitSlice::<O, T>::from_slice`] fails;
	/// otherwise, it returns the newly allocated and initialized bit-vector.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let slice = &[0u8, 1, 2, 3];
	/// let bv = BitVec::<Lsb0, _>::from_slice(slice);
	/// assert!(bv.is_ok());
	/// assert_eq!(bv.unwrap().len(), 32);
	/// ```
	///
	/// [`BitSlice::<O, T>::MAX_ELTS`]: crate::slice::BitSlice::MAX_ELTS
	/// [`BitSlice::<O, T>::from_slice`]: crate::slice::BitSlice::from_slice
	#[inline]
	pub fn from_slice(slice: &[T]) -> Result<Self, BitSpanError<T>> {
		slice.pipe(BitSlice::from_slice).map(Self::from_bitslice)
	}

	/// Converts a [`Vec<T>`] into a `BitVec<O, T>` without copying its buffer.
	///
	/// # Parameters
	///
	/// - `vec`: A vector to view as bits.
	///
	/// # Returns
	///
	/// A `BitVec` over the `vec` buffer.
	///
	/// # Panics
	///
	/// This panics if `vec` is too long to convert into a `BitVec`. See
	/// [`BitSlice::MAX_ELTS`].
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let vec = vec![0u8; 4];
	/// let bv = BitVec::<LocalBits, _>::from_vec(vec);
	/// assert_eq!(bv, bits![0; 32]);
	/// ```
	///
	/// [`BitSlice::MAX_ELTS`]: crate::slice::BitSlice::MAX_ELTS
	/// [`Vec<T>`]: alloc::vec::Vec
	#[inline]
	pub fn from_vec(vec: Vec<T>) -> Self {
		Self::try_from_vec(vec)
			.expect("Vector was too long to be converted into a `BitVec`")
	}

	/// Converts a [`Vec<T>`] into a `BitVec<O, T>` without copying its buffer.
	///
	/// This method takes ownership of a memory buffer and enables it to be used
	/// as a bit-vector. Because [`Vec`] can be longer than `BitVec`s, this is a
	/// fallible method, and the original vector will be returned if it cannot
	/// be converted.
	///
	/// # Parameters
	///
	/// - `vec`: Some vector of memory, to be viewed as bits.
	///
	/// # Returns
	///
	/// If `vec` is short enough to be viewed as a `BitVec`, then this returns
	/// a `BitVec` over the `vec` buffer. If `vec` is too long, then this
	/// returns `vec` unmodified.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let vec = vec![0u8; 4];
	/// let bv = BitVec::<LocalBits, _>::try_from_vec(vec).unwrap();
	/// assert_eq!(bv, bits![0; 32]);
	/// ```
	///
	/// An example showing this function failing would require an allocation
	/// exceeding `!0usize >> 3` bytes in size, which is infeasible to produce.
	///
	/// [`Vec`]: alloc::vec::Vec
	/// [`Vec<T>`]: alloc::vec::Vec
	#[inline]
	pub fn try_from_vec(vec: Vec<T>) -> Result<Self, Vec<T>> {
		let mut vec = ManuallyDrop::new(vec);
		let capacity = vec.capacity();

		BitPtr::from_mut_slice(vec.as_mut_slice())
			.span(vec.len() * T::Mem::BITS as usize)
			.map(|bitspan| Self { bitspan, capacity })
			.map_err(|_| ManuallyDrop::into_inner(vec))
	}

	/// Copies all bits in a [`BitSlice`] into the `BitVec`.
	///
	/// # Original
	///
	/// [`Vec::extend_from_slice`](alloc::vec::Vec::extend_from_slice)
	///
	/// # Type Parameters
	///
	/// This can extend from a [`BitSlice`] of any type arguments. Where the
	/// source `&BitSlice` matches `self`’s type parameters, the implementation
	/// is able to attempt to accelerate the copy; however, if the type
	/// parameters do not match, then the implementation falls back to a
	/// bit-by-bit iteration and is equivalent to the `Extend` implementation.
	///
	/// You should only use this method when the type parameters match and there
	/// is a possibility of copy acceleration. Otherwise, `.extend()` is the
	/// correct API.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv = bitvec![0, 1];
	/// bv.extend_from_bitslice(bits![1, 1, 0, 1]);
	///
	/// assert_eq!(bv, bits![0, 1, 1, 1, 0, 1]);
	/// ```
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	//  Implementation note: per #85, users want this method to stay generic.
	#[inline]
	pub fn extend_from_bitslice<O2, T2>(&mut self, other: &BitSlice<O2, T2>)
	where
		O2: BitOrder,
		T2: BitStore,
	{
		let len = self.len();
		let olen = other.len();
		self.resize(len + olen, false);
		unsafe { self.get_unchecked_mut(len ..) }.clone_from_bitslice(other);
	}

	/// Appends a slice of elements `T` to the `BitVec`.
	///
	/// The `slice` is interpreted as a `BitSlice<O, T>`, then appended directly
	/// to the bit-vector.
	///
	/// # Original
	///
	/// [`Vec::extend_from_slice`](alloc::vec::Vec::extend_from_slice)
	#[inline]
	pub fn extend_from_raw_slice(&mut self, slice: &[T]) {
		self.extend_from_bitslice(
			BitSlice::<O, T>::from_slice(slice)
				.expect("Slice is too long to encode as a BitSlice"),
		);
	}

	/// Gets the number of elements `T` that contain live bits of the
	/// bit-vector.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bv = bitvec![LocalBits, u16; 1; 50];
	/// assert_eq!(bv.elements(), 4);
	/// ```
	#[inline]
	pub fn elements(&self) -> usize {
		self.as_bitspan().elements()
	}

	/// Converts the bit-vector into [`BitBox<O, T>`].
	///
	/// Note that this will drop any excess capacity.
	///
	/// # Original
	///
	/// [`Vec::into_boxed_slice`](alloc::vec::Vec::into_boxed_slice)
	///
	/// # API Differences
	///
	/// This returns a `bitvec` boxed bit-slice, not a standard boxed slice. To
	/// convert the underlying buffer into a boxed element slice, use
	/// `.into_boxed_bitslice().into_boxed_slice()`.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bv = bitvec![0, 1, 0, 0, 1];
	/// let bitslice = bv.into_boxed_slice();
	/// ```
	///
	/// Any excess capacity is removed:
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv: BitVec = BitVec::with_capacity(100);
	/// bv.extend([0, 1, 0, 0, 1].iter().copied());
	///
	/// assert!(bv.capacity() >= 100);
	/// let bs = bv.into_boxed_bitslice();
	/// assert!(bs.into_bitvec().capacity() >= 5);
	/// ```
	///
	/// [`BitBox<O, T>`]: crate::boxed::BitBox
	#[inline]
	pub fn into_boxed_bitslice(mut self) -> BitBox<O, T> {
		let mut bitspan = self.as_mut_bitspan();
		let mut boxed =
			self.into_vec().into_boxed_slice().pipe(ManuallyDrop::new);
		unsafe {
			bitspan.set_address(boxed.as_mut_ptr());
			BitBox::from_raw(bitspan.to_bitslice_ptr_mut())
		}
	}

	/// Removes the bit-precision view, returning the underlying [`Vec`].
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bv = bitvec![Lsb0, u8; 0, 1, 0, 0, 1];
	/// let vec = bv.into_vec();
	/// assert_eq!(vec, &[18]);
	/// ```
	///
	/// [`Vec`]: alloc::vec::Vec
	#[inline]
	pub fn into_vec(self) -> Vec<T> {
		let (bitspan, capacity) = (self.bitspan, self.capacity);
		mem::forget(self);
		unsafe {
			Vec::from_raw_parts(
				bitspan.address().to_mut(),
				bitspan.elements(),
				capacity,
			)
		}
	}

	/// Writes a value into every element that the bit-vector considers live.
	///
	/// This unconditionally writes `element` into each live location in the
	/// backing buffer, without altering the `BitVec`’s length or capacity.
	///
	/// It is unspecified what effects this has on the allocated but dead
	/// elements in the buffer. You may not rely on them being zeroed *or* being
	/// set to the `value` integer.
	///
	/// # Parameters
	///
	/// - `&mut self`
	/// - `element`: The value which will be written to each live location in
	///   the bit-vector’s buffer.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv = bitvec![LocalBits, u8; 0; 10];
	/// assert_eq!(bv.as_raw_slice(), [0, 0]);
	/// bv.set_elements(0xA5);
	/// assert_eq!(bv.as_raw_slice(), [0xA5, 0xA5]);
	/// ```
	#[inline]
	pub fn set_elements(&mut self, element: T::Mem) {
		self.as_mut_raw_slice()
			.iter_mut()
			.for_each(|elt| elt.store_value(element));
	}

	/// Sets the uninitialized bits of the bit-vector to a fixed value.
	///
	/// This method modifies all bits in the allocated buffer that are outside
	/// the [`as_bitslice`] view so that they have a consistent value. This can
	/// be used to zero the uninitialized memory so that when viewed as a raw
	/// memory slice, bits outside the live region have a predictable value.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv = 220u8.view_bits::<Lsb0>().to_bitvec();
	/// assert_eq!(bv.as_raw_slice(), &[220u8]);
	///
	/// bv.truncate(4);
	/// assert_eq!(bv.count_ones(), 2);
	/// assert_eq!(bv.as_raw_slice(), &[220u8]);
	///
	/// bv.set_uninitialized(false);
	/// assert_eq!(bv.as_raw_slice(), &[12u8]);
	///
	/// bv.set_uninitialized(true);
	/// assert_eq!(bv.as_raw_slice(), &[!3u8]);
	/// ```
	///
	/// [`as_bitslice`]: Self::as_bitslice
	#[inline]
	pub fn set_uninitialized(&mut self, value: bool) {
		let head = self.as_bitspan().head().into_inner() as usize;
		let tail = head + self.len();
		let capa = self.capacity();
		let mut bp = self.as_mut_bitspan();
		unsafe {
			bp.set_head(BitIdx::ZERO);
			bp.set_len(capa);
			let bits = bp.to_bitslice_mut();
			bits.get_unchecked_mut(.. head).set_all(value);
			bits.get_unchecked_mut(tail ..).set_all(value);
		}
	}

	/// Ensures that the live region of the bit-vector’s contents begins at the
	/// leading edge of the buffer.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let data = 0x3Cu8;
	/// let bits = data.view_bits::<Msb0>();
	///
	/// let mut bv = bits[2 .. 6].to_bitvec();
	/// assert_eq!(bv, bits[2 .. 6]);
	/// assert_eq!(bv.as_raw_slice()[0], data);
	///
	/// bv.force_align();
	/// assert_eq!(bv, bits[2 .. 6]);
	/// // It is not specified what happens
	/// // to bits that are no longer used.
	/// assert_eq!(bv.as_raw_slice()[0] & 0xF0, 0xF0);
	/// ```
	#[inline]
	pub fn force_align(&mut self) {
		let bitspan = self.as_mut_bitspan();
		let head = bitspan.head().into_inner() as usize;
		if head == 0 {
			return;
		}
		let last = bitspan.len() + head;
		unsafe {
			self.bitspan = bitspan.tap_mut(|bp| bp.set_head(BitIdx::ZERO));
			self.copy_within_unchecked(head .. last, 0);
		}
	}

	/// Writes a new length value into the pointer without any checks.
	///
	/// # Safety
	///
	/// `new_len` must not exceed `self.capacity() - self.bitspan.head()`.
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub(crate) unsafe fn set_len_unchecked(&mut self, new_len: usize) {
		self.bitspan.set_len(new_len);
	}

	/// Extracts a bit-slice containing the entire bit-vector.
	///
	/// Equivalent to `&bv[..]`.
	///
	/// # Original
	///
	/// [`Vec::as_slice`](alloc::vec::Vec::as_slice)
	///
	/// # API Differences
	///
	/// This returns a `bitvec` bit-slice, not a standard slice. To view the
	/// underlying element buffer, use [`as_raw_slice`].
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bv = bitvec![0, 1, 0, 0, 1];
	/// let bits = bv.as_bitslice();
	/// ```
	///
	/// [`as_raw_slice`]: Self::as_raw_slice
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn as_bitslice(&self) -> &BitSlice<O, T> {
		self.bitspan.to_bitslice_ref()
	}

	/// Extracts a mutable bit-slice of the entire bit-vector.
	///
	/// Equivalent to `&mut bv[..]`.
	///
	/// # Original
	///
	/// [`Vec::as_mut_slice`](alloc::vec::Vec::as_mut_slice)
	///
	/// # API Differences
	///
	/// This returns a `bitvec` bit-slice, not a standard slice. To view the
	/// underlying element buffer, use [`as_mut_raw_slice`].
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv = bitvec![0, 1, 0, 0, 1];
	/// let bits = bv.as_mut_bitslice();
	/// ```
	///
	/// [`as_mut_raw_slice`]: Self::as_mut_raw_slice
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn as_mut_bitslice(&mut self) -> &mut BitSlice<O, T> {
		self.bitspan.to_bitslice_mut()
	}

	/// Returns a raw pointer to the bit-vector’s buffer.
	///
	/// The caller must ensure that the bit-vector outlives the bit-pointer this
	/// function returns, or else it will end up pointing to garbage. Modifying
	/// the bit-vector may cause its buffer to be reällocated, which would also
	/// make any bit-pointers to it invalid.
	///
	/// The caller must also ensure that the memory the bit-pointer
	/// (non-transitively) points to is never written to (except inside an
	/// [`UnsafeCell`]) using this bit-pointer or any bit-pointer derived from
	/// it. If you need to mutate the contents of the buffer, use
	/// [`as_mut_bitptr`].
	///
	/// # Original
	///
	/// [`Vec::as_ptr`](alloc::vec::Vec::as_ptr)
	///
	/// # API Differences
	///
	/// This returns a `bitvec` bit-pointer, not a standard pointer. To take the
	/// address of the underlying element buffer, use [`as_raw_ptr`].
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bv = bitvec![0, 1, 0, 0, 1];
	/// let bp = bv.as_bitptr();
	///
	/// unsafe {
	///   for i in 0 .. bv.len() {
	///     assert_eq!(bp.add(i).read(), bv[i]);
	///   }
	/// }
	/// ```
	///
	/// [`UnsafeCell`]: core::cell::UnsafeCell
	/// [`as_raw_ptr`]: Self::as_raw_ptr
	/// [`as_mut_bitptr`]: Self::as_mut_bitptr
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn as_bitptr(&self) -> BitPtr<Const, O, T> {
		self.bitspan.as_bitptr().immut()
	}

	/// Returns an unsafe mutable bit-pointer to the bit-vector’s region.
	///
	/// The caller must ensure that the bit-vector outlives the bit-pointer this
	/// function returns, or else it will end up pointing to garbage. Modifying
	/// the bit-vector may cause its buffer to be reällocated, which would also
	/// make any bit-pointers to it invalid.
	///
	/// # Original
	///
	/// [`Vec::as_mut_ptr`](alloc::vec::Vec::as_mut_ptr)
	///
	/// # API Differences
	///
	/// This returns a `bitvec` bit-pointer, not a standard pointer. To take the
	/// address of the underlying element buffer, use [`as_mut_raw_ptr`].
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv = BitVec::<Msb0, u8>::with_capacity(4);
	/// let bp = bv.as_mut_bitptr();
	/// unsafe {
	///   for i in 0 .. 4 {
	///     bp.add(i).write(true);
	///   }
	///   bv.set_len(4);
	/// }
	/// assert_eq!(bv, bits![1; 4]);
	/// ```
	///
	/// [`as_mut_raw_ptr`]: Self::as_mut_raw_ptr
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub fn as_mut_bitptr(&mut self) -> BitPtr<Mut, O, T> {
		self.bitspan.as_bitptr()
	}

	/// Views the underlying buffer as a shared element slice.
	///
	/// # Original
	///
	/// [`Vec::as_slice`](alloc::vec::Vec::as_slice)
	///
	/// # API Differences
	///
	/// This method is renamed in order to emphasize the semantic distinction
	/// between borrowing the bit-vector contents, and borrowing the memory that
	/// implements the collection contents.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bv = bitvec![Msb0, u8; 0, 1, 0, 0, 1, 1, 0, 1];
	/// let raw = bv.as_raw_slice();
	/// assert_eq!(raw, &[0x4D]);
	/// ```
	#[inline]
	pub fn as_raw_slice(&self) -> &[T] {
		unsafe {
			slice::from_raw_parts(
				self.bitspan.address().to_const(),
				self.bitspan.elements(),
			)
		}
	}

	/// Views the underlying buffer as an exclusive element slice.
	///
	/// # Original
	///
	/// [`Vec::as_mut_slice`](alloc::vec::Vec::as_mut_slice)
	///
	/// # API Differences
	///
	/// This method is renamed in order to emphasize the semantic distinction
	/// between borrowing the bit-vector contents, and borrowing the memory that
	/// implements the collection contents.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv = bitvec![Msb0, u8; 0, 1, 0, 0, 1, 1, 0, 1];
	/// let raw = bv.as_mut_raw_slice();
	/// assert_eq!(raw, &[0x4D]);
	/// raw[0] = 0xD4;
	/// assert_eq!(bv, bits![1, 1, 0, 1, 0, 1, 0, 0]);
	/// ```
	#[inline]
	pub fn as_mut_raw_slice(&mut self) -> &mut [T] {
		unsafe {
			slice::from_raw_parts_mut(
				self.bitspan.address().to_mut(),
				self.bitspan.elements(),
			)
		}
	}

	/// Returns a raw pointer to the bit-vector’s buffer.
	///
	/// # Original
	///
	/// [`Vec::as_ptr`](alloc::vec::Vec::as_ptr)
	///
	/// # API Differences
	///
	/// This method is renamed in order to emphasize the semantic distinction
	/// between taking a pointer to the start of the bit-vector contents, and
	/// taking a pointer to the underlying memory that implements the collection
	/// contents.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let bv = bitvec![Msb0, u8; 0, 1, 0, 0, 1];
	/// let addr = bv.as_raw_ptr();
	/// ```
	#[inline]
	pub fn as_raw_ptr(&self) -> *const T {
		self.bitspan.address().to_const()
	}

	/// Returns an unsafe mutable pointer to the bit-vector’s buffer.
	///
	/// # Original
	///
	/// [`Vec::as_mut_ptr`](alloc::vec::Vec::as_mut_ptr)
	///
	/// # API Differences
	///
	/// This method is renamed in order to emphasize the semantic distinction
	/// between taking a pointer to the start of the bit-vector contents, and
	/// taking a pointer to the underlying memory that implements the collection
	/// contents.
	///
	/// # Examples
	///
	/// ```rust
	/// use bitvec::prelude::*;
	///
	/// let mut bv = bitvec![0, 1, 0, 0, 1];
	/// let addr = bv.as_mut_raw_ptr();
	/// ```
	#[inline]
	pub fn as_mut_raw_ptr(&mut self) -> *mut T {
		self.bitspan.address().to_mut()
	}

	/// Construct a `BitVec` from its exact fields, rather than using a formal
	/// constructor.
	///
	/// This is used for handle construction elsewhere in the crate, where a
	/// vector allocation and `BitSpan` descriptor exist, and need to be bundled
	/// into a `BitVec` without going through the ordinary construction process.
	///
	/// # Parameters
	///
	/// - `bitspan`: A span descriptor.
	/// - `capacity`: An allocation capacity, measured in `T` elements rather
	///   than in bits.
	///
	/// # Returns
	///
	/// `BitVec { bitspan, capacity }`
	///
	/// # Safety
	///
	/// The arguments must be derived from a known-good buffer allocation and
	/// span description. They will be directly used to construct the returned
	/// bit-vector, and drive all future memory access and allocation control.
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	pub(crate) unsafe fn from_fields(
		bitspan: BitSpan<Mut, O, T>,
		capacity: usize,
	) -> Self {
		Self { bitspan, capacity }
	}

	/// Removes the `::Unalias` marker from a bit-vector’s type signature.
	#[cfg_attr(not(tarpaulin_include), inline(always))]
	fn strip_unalias(this: BitVec<O, T::Unalias>) -> Self {
		let (bitspan, capacity) = (this.bitspan.cast::<T>(), this.capacity);
		mem::forget(this);
		Self { bitspan, capacity }
	}

	/// Combines the logic for `BitVec::reserve` and `BitVec::reserve_exact`.
	#[inline]
	fn do_reservation(
		&mut self,
		additional: usize,
		func: impl FnOnce(&mut Vec<T>, usize),
	) {
		let len = self.len();
		let new_len = len
			.checked_add(additional)
			.expect("Bit-Vector capacity exceeded");
		assert!(
			new_len <= BitSlice::<O, T>::MAX_BITS,
			"Bit-Vector capacity exceeded: {} > {}",
			new_len,
			BitSlice::<O, T>::MAX_BITS,
		);
		let bitspan = self.bitspan;
		let head = bitspan.head();
		let elts = bitspan.elements();
		let new_elts =
			crate::mem::elts::<T>(head.into_inner() as usize + new_len);
		let extra = new_elts - elts;
		self.with_vec(|vec| {
			func(&mut **vec, extra);
			//  Initialize any newly-allocated elements to zero, without
			//  initializing leftover dead capacity.
			vec.resize_with(new_elts, || unsafe { mem::zeroed() });
		});
	}

	/// Permits manipulation of the underlying vector allocation.
	///
	/// The caller receives a mutable borrow of a `Vec<T>` with its destructor
	/// disarmed. The caller may modify the buffer controls, including its
	/// location and its capacity, and these changes will be committed back into
	/// `self`. Modifications to the referent `[T]` handle, such as length
	/// changes, will not be preserved.
	fn with_vec<F, R>(&mut self, func: F) -> R
	where F: FnOnce(&mut ManuallyDrop<Vec<T>>) -> R {
		let capacity = self.capacity;
		let (ptr, length) =
			(self.bitspan.address().to_mut(), self.bitspan.elements());

		let mut vec = unsafe { Vec::from_raw_parts(ptr, length, capacity) }
			.pipe(ManuallyDrop::new);
		let out = func(&mut vec);

		unsafe {
			self.bitspan.set_address(vec.as_mut_ptr());
		}
		self.capacity = vec.capacity();
		out
	}
}

#[cfg(test)]
mod tests;
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/vec.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/src/view.rs =====
/*! [`BitSlice`] view adapters for memory regions.

The [`&BitSlice`][`BitSlice`] type is a referential view over existing memory.
The inherent constructor functions are awkward to call, as they require function
syntax rather than method syntax, and must provide a token for the memory type
argument even though this is informed by the already-existing reference being
used.

This module provides an extension trait, [`BitView`], which provides methods on
many memory types (all [`BitRegister`] integers, and slices and arrays of them)
to construct [`BitSlice`] over those values.

In addition, the traits [`AsBits`] and [`AsBitsMut`] are analogues of [`AsRef`]
and [`AsMut`], respectively. These traits have a blanket implementation for all
`A: As{Ref,Mut}<[T: BitRegister]>`, so that any type that implements a view to a
suitable memory region automatically implements a view to that region’s bits.

These traits are distinct because [`BitView`] combines the im/mutable view
functions into one trait, and can provide specialized implementations with a
slight performance increase over the generic, but `AsBits{,Mut}` can fit in the
generic type system of any library without undue effort.

[`AsBits`]: crate::view::AsBits
[`AsBitsMut`]: crate::view::AsBitsMut
[`AsMut`]: core::convert::AsMut
[`AsRef`]: core::convert::AsRef
[`BitRegister`]: crate::mem::BitRegister
[`BitSlice`]: crate::slice::BitSlice
[`BitView`]: crate::view::BitView
!*/

use funty::IsNumber;

use crate::{
	order::BitOrder,
	slice::BitSlice,
	store::BitStore,
};

/** Creates a [`BitSlice`] view over some type that supports it.

This trait is implemented on all [`BitRegister`] types, and the arrays and slices
of them that are supported by the standard library.

This means that until type-level integers are stabilized, only arrays in
`[T: BitRegister; 0 ..= 64]` will implement the trait; wider arrays will need to
reborrow as slices `[T]` in order to use the slice implementation.

If you have a type that contains a [`BitRegister`] type that can be viewed with
this trait, then you can implement this trait by forwarding to the interior
view.

[`BitSlice`]: crate::slice::BitSlice
[`BitRegister`]: crate::mem::BitRegister
**/
pub trait BitView {
	/// The region’s storage type.
	type Store: BitStore;

	/// Views a memory region as a [`BitSlice`].
	///
	/// # Type Parameters
	///
	/// - `O`: The bit ordering used for the region.
	///
	/// # Parameters
	///
	/// - `&self`: The region to view as individual bits.
	///
	/// # Returns
	///
	/// A `&BitSlice` view over the region at `*self`.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	fn view_bits<O>(&self) -> &BitSlice<O, Self::Store>
	where O: BitOrder;

	/// Views a memory region as a mutable [`BitSlice`].
	///
	/// # Type Parameters
	///
	/// - `O`: The bit ordering used for the region.
	///
	/// # Parameters
	///
	/// - `&mut self`: The region to view as individual mutable bits.
	///
	/// # Returns
	///
	/// A `&mut BitSlice` view over the region at `*self`.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	fn view_bits_mut<O>(&mut self) -> &mut BitSlice<O, Self::Store>
	where O: BitOrder;
}

#[cfg(not(tarpaulin_include))]
impl<T> BitView for T
where T: BitStore
{
	type Store = T;

	#[inline(always)]
	fn view_bits<O>(&self) -> &BitSlice<O, T>
	where O: BitOrder {
		BitSlice::from_element(self)
	}

	#[inline(always)]
	fn view_bits_mut<O>(&mut self) -> &mut BitSlice<O, T>
	where O: BitOrder {
		BitSlice::from_element_mut(self)
	}
}

impl<T> BitView for [T]
where T: BitStore
{
	type Store = T;

	#[inline]
	fn view_bits<O>(&self) -> &BitSlice<O, T>
	where O: BitOrder {
		BitSlice::from_slice(self).expect("slice was too long to view as bits")
	}

	#[inline]
	fn view_bits_mut<O>(&mut self) -> &mut BitSlice<O, T>
	where O: BitOrder {
		BitSlice::from_slice_mut(self)
			.expect("slice was too long to view as bits")
	}
}

impl<T, const N: usize> BitView for [T; N]
where T: BitStore
{
	type Store = T;

	#[inline]
	fn view_bits<O>(&self) -> &BitSlice<O, T>
	where O: BitOrder {
		BitSlice::from_slice(&self[..])
			.expect("array was too long to view as bits")
	}

	#[inline]
	fn view_bits_mut<O>(&mut self) -> &mut BitSlice<O, T>
	where O: BitOrder {
		BitSlice::from_slice_mut(&mut self[..])
			.expect("array was too long to view as bits")
	}
}

/// Helper for size awareness on `Sized` storage regions.
pub trait BitViewSized: BitView + Sized {
	/// Counts the number of elements `T` contained in the type.
	const ELTS: usize;
	/// Counts the number of bits contained in the type.
	const BITS: usize =
		Self::ELTS * <<Self::Store as BitStore>::Mem as IsNumber>::BITS as usize;
}

/// Elements are equivalent to `[T; 1]`.
impl<T> BitViewSized for T
where T: BitStore
{
	const ELTS: usize = 1;
}

impl<T, const N: usize> BitViewSized for [T; N]
where T: BitStore
{
	const ELTS: usize = N;
}

/** Views a region as an immutable [`BitSlice`] only.

This trait is an analogue to the [`AsRef`] trait, in that it enables any type to
provide an immutable-only view of a bit slice.

It does not require an `AsRef<[T: BitStore]>` implementation, and a blanket
implementation for all such types is provided. This allows you to choose whether
to implement only one of `AsBits<T>` or `AsRef<[T]>`, and gain a [`BitSlice`]
view with either choice.

# Type Parameters

- `T`: The underlying storage region.

# Notes

You are not *forbidden* from creating multiple views with different element
types to the same region, but doing so is likely to cause inconsistent and
surprising behavior.

Refrain from implementing this trait with more than one storage argument unless
you are sure that you can uphold the memory region requirements of all of them,
and are aware of the behavior conflicts that may arise.

[`AsRef`]: core::convert::AsRef
[`BitSlice`]: crate::slice::BitSlice
**/
pub trait AsBits<T>
where T: BitStore
{
	/// Views memory as a slice of immutable bits.
	///
	/// # Type Parameters
	///
	/// - `O`: The bit ordering used for the region.
	///
	/// # Parameters
	///
	/// - `&self`: The value that is providing a [`BitSlice`] view.
	///
	/// # Returns
	///
	/// An immutable view into some bits.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	fn as_bits<O>(&self) -> &BitSlice<O, T>
	where O: BitOrder;
}

/** Views a region as a mutable [`BitSlice`].

This trait is an analogue to the [`AsMut`] trait, in that it enables any type to
provide a mutable view of a bit slice.

It does not require an `AsMut<[T: BitStore]>` implementation, and a blanket
implementation for all such types is provided. This allows you to choose whether
to implement only one of `AsBitsMut<T>` or `AsMut<[T]>`, and gain a [`BitSlice`]
view with either choice.

# Type Parameters

- `T`: The underlying storage region.

# Notes

You are not *forbidden* from creating multiple views with different element
types to the same region, but doing so is likely to cause inconsistent and
surprising behavior.

Refrain from implementing this trait with more than one storage argument unless
you are sure that you can uphold the memory region requirements of all of them,
and are aware of the behavior conflicts that may arise.

[`AsMut`]: core::convert::AsMut
[`BitSlice`]: crate::slice::BitSlice
**/
pub trait AsBitsMut<T>
where T: BitStore
{
	/// Views memory as a slice of mutable bits.
	///
	/// # Type Parameters
	///
	/// - `O`: The bit ordering used for the region.
	///
	/// # Parameters
	///
	/// - `&mut self`: The value that is providing a [`BitSlice`] view.
	///
	/// # Returns
	///
	/// A mutable view into some bits.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	fn as_bits_mut<O>(&mut self) -> &mut BitSlice<O, T>
	where O: BitOrder;
}

#[cfg(not(tarpaulin_include))]
impl<A, T> AsBits<T> for A
where
	A: AsRef<[T]>,
	T: BitStore,
{
	#[inline]
	fn as_bits<O>(&self) -> &BitSlice<O, T>
	where O: BitOrder {
		self.as_ref().view_bits::<O>()
	}
}

#[cfg(not(tarpaulin_include))]
impl<A, T> AsBitsMut<T> for A
where
	A: AsMut<[T]>,
	T: BitStore,
{
	#[inline]
	fn as_bits_mut<O>(&mut self) -> &mut BitSlice<O, T>
	where O: BitOrder {
		self.as_mut().view_bits_mut::<O>()
	}
}

#[cfg(test)]
mod tests {
	use crate::{
		prelude::*,
		view::BitViewSized,
	};

	#[test]
	fn impls() {
		let mut byte = 0u8;
		let mut bytes = [0u8; 2];
		assert!(byte.view_bits::<LocalBits>().not_any());
		assert!(byte.view_bits_mut::<LocalBits>().not_any());
		assert!(bytes.view_bits::<LocalBits>().not_any());
		assert!(bytes.view_bits_mut::<LocalBits>().not_any());
		assert!(bytes[..].view_bits::<LocalBits>().not_any());
		assert!(bytes[..].view_bits_mut::<LocalBits>().not_any());

		let mut blank: [u8; 0] = [];
		assert!(blank.view_bits::<LocalBits>().is_empty());
		assert!(blank.view_bits_mut::<LocalBits>().is_empty());

		assert_eq!(<u8 as BitViewSized>::BITS, 8);
		assert_eq!(<u16 as BitViewSized>::BITS, 16);
		assert_eq!(<u32 as BitViewSized>::BITS, 32);

		#[cfg(target_pointer_width = "64")]
		{
			assert_eq!(<u64 as BitViewSized>::BITS, 64);
		}
	}
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/src/view.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/tarpaulin.toml =====
################################################################################
#                            Coverage Configuration                            #
#                                                                              #
# This file controls the behavior of `cargo-tarpaulin`, used to produce        #
# coverage reports for the project.
################################################################################

[coverage]
all-features = true
count = true
ignore-panics = true
ignore-tests = true
run-types = [
	"Tests",
]

[report]
out = [
	"Html",
	"Lcov",
	"Xml",
]
output-dir = "target/tarpaulin"
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/tarpaulin.toml =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/tests/bincode.rs =====
/*! [Issue #96] describes a failure to roundtrip through `bincode` de/ser.

This defect was caused by the use of the `[T]` slice implementation when
serializing a `BitArray`, but the `[T; N]` array implementation when
deserializing. The bincode format uses a dynamic length-aware encoding for
slice references, but can permit arrays to be self-describing, without any
excess data in the transport format.

This discrepancy caused `BitArray` to fail to roundtrip through bincode, and has
been resolved by committing to using only the `[T; N]` de/ser implementation on
both sides of the `serde` interface.

In the future, the implementation *may* change to use the `BitSlice` transport
format. The exact implementation of the transport format is not guaranteed
between major revisions of the crate; however, as it does technically constitute
an ABI, it will only be modified in `0.X` or `X.0` releases.

[Issue #96]: https://github.com/myrrlyn/bitvec/issues/96
!*/

#![cfg(feature = "serde")]

use bitvec::prelude::*;

#[test]
fn serialize_bitarr_bincode() {
	let ba = bitarr![Msb0, u8; 1, 1, 1, 1, 1, 0, 0, 0];

	let bytes = bincode::serialize::<BitArray<_, [u8; 1]>>(&ba)
		.expect("bincode serialization failed");

	let deser = bincode::deserialize::<BitArray<Msb0, [u8; 1]>>(bytes.as_ref())
		.expect("bincode deserialization failed");

	assert_eq!(deser, ba);
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/tests/bincode.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/tests/equality.rs =====
/*! The `PartialEq` and `PartialOrd` trait implementations are *surprisingly*
hard to correctly implement. This test suite is built to ensure that all
combinations of equality and comparison are correctly present.
!*/

use core::cmp::Ordering;

use bitvec::prelude::*;

#[test]
fn slice_only() {
	let a = bits![mut Msb0, u8; 0, 1];
	let b = bits![mut Lsb0, u16; 0, 1];
	let c = bits![mut 1, 0];

	//  BitSlice as PartialEq<BitSlice>
	assert!(<BitSlice<_, _> as PartialEq<BitSlice<_, _>>>::eq(&*a, &*b));
	//  BitSlice as PartialEq<&mut BitSlice>
	assert!(<BitSlice<_, _> as PartialEq<&mut BitSlice<_, _>>>::eq(
		&*a, &b
	));
	//  &mut BitSlice as PartialEq<BitSlice>
	assert!(<&mut BitSlice<_, _> as PartialEq<BitSlice<_, _>>>::eq(
		&a, &*b
	));
	//  &mut BitSlice as PartialEq<&mut BitSlice>
	assert!(<&mut BitSlice<_, _> as PartialEq<&mut BitSlice<_, _>>>::eq(
		&a, &b
	));

	//  &BitSlice as PartialEq<&BitSlice>
	assert!(<&BitSlice<_, _> as PartialEq<&BitSlice<_, _>>>::eq(
		&&*a, &&*b
	));
	//  &BitSlice as PartialEq<BitSlice>
	assert!(<&BitSlice<_, _> as PartialEq<BitSlice<_, _>>>::eq(
		&&*a, &*b
	));
	//  BitSlice as PartialEq<&BitSlice>
	assert!(<BitSlice<_, _> as PartialEq<&BitSlice<_, _>>>::eq(
		&*a, &&*b
	));

	//  &mut BitSlice as PartialEq<&BitSlice>
	assert!(<&mut BitSlice<_, _> as PartialEq<&BitSlice<_, _>>>::eq(
		&a, &&*b
	));
	//  &BitSlice as PartialEq<&mut BitSlice>
	assert!(<&BitSlice<_, _> as PartialEq<&mut BitSlice<_, _>>>::eq(
		&&*a, &b
	));

	//  BitSlice as PartialOrd<BitSlice>
	assert_eq!(
		<BitSlice<_, _> as PartialOrd<BitSlice<_, _>>>::partial_cmp(&*b, &*c),
		Some(Ordering::Less)
	);
	//  BitSlice as PartialOrd<&mut BitSlice>
	assert_eq!(
		<BitSlice<_, _> as PartialOrd<&mut BitSlice<_, _>>>::partial_cmp(
			&*b, &c
		),
		Some(Ordering::Less)
	);
	//  &mut BitSlice as PartialOrd<BitSlice>
	assert_eq!(
		<&mut BitSlice<_, _> as PartialOrd<BitSlice<_, _>>>::partial_cmp(
			&b, &*c
		),
		Some(Ordering::Less)
	);
	//  &mut BitSlice as PartialOrd<&mut BitSlice>
	assert_eq!(
		<&mut BitSlice<_, _> as PartialOrd<&mut BitSlice<_, _>>>::partial_cmp(
			&b, &c
		),
		Some(Ordering::Less)
	);

	//  &BitSlice as PartialOrd<&BitSlice>
	assert_eq!(
		<&BitSlice<_, _> as PartialOrd<&BitSlice<_, _>>>::partial_cmp(
			&&*b, &&*c
		),
		Some(Ordering::Less)
	);
	//  &BitSlice as PartialOrd<&mut BitSlice>
	assert_eq!(
		<&BitSlice<_, _> as PartialOrd<&mut BitSlice<_, _>>>::partial_cmp(
			&&*b, &c
		),
		Some(Ordering::Less)
	);
	//  &mut BitSlice as PartialOrd<&BitSlice>
	assert_eq!(
		<&mut BitSlice<_, _> as PartialOrd<&BitSlice<_, _>>>::partial_cmp(
			&b, &&*c
		),
		Some(Ordering::Less)
	);
}

#[test]
#[rustfmt::skip]
#[cfg(feature = "alloc")]
#[allow(clippy::eq_op)] // The matrix diagonal is a deliberate style choice.
fn with_alloc() {
	let a = bits![Msb0, u8; 0, 1];
	let b = bits![mut Lsb0, u16; 0, 1];
	let c = bitbox![Lsb0, u32; 0, 1];
	let d = bitvec![Msb0, usize; 0, 1];

	assert_eq!(a, a); assert_eq!(a, b); assert_eq!(a, c); assert_eq!(a, d);
	assert_eq!(b, a); assert_eq!(b, b); assert_eq!(b, c); assert_eq!(b, d);
	assert_eq!(c, a); assert_eq!(c, b); assert_eq!(c, c); assert_eq!(c, d);
	assert_eq!(d, a); assert_eq!(d, b); assert_eq!(d, c); assert_eq!(d, d);

	assert_eq!(a.partial_cmp(&a), Some(Ordering::Equal));
	assert_eq!(a.partial_cmp(&b), Some(Ordering::Equal));
	assert_eq!(a.partial_cmp(&c), Some(Ordering::Equal));
	assert_eq!(a.partial_cmp(&d), Some(Ordering::Equal));

	assert_eq!(b.partial_cmp(&a), Some(Ordering::Equal));
	assert_eq!(b.partial_cmp(&b), Some(Ordering::Equal));
	assert_eq!(b.partial_cmp(&c), Some(Ordering::Equal));
	assert_eq!(b.partial_cmp(&d), Some(Ordering::Equal));

	assert_eq!(c.partial_cmp(&a), Some(Ordering::Equal));
	assert_eq!(c.partial_cmp(&b), Some(Ordering::Equal));
	assert_eq!(c.partial_cmp(&c), Some(Ordering::Equal));
	assert_eq!(c.partial_cmp(&d), Some(Ordering::Equal));

	assert_eq!(d.partial_cmp(&a), Some(Ordering::Equal));
	assert_eq!(d.partial_cmp(&b), Some(Ordering::Equal));
	assert_eq!(d.partial_cmp(&c), Some(Ordering::Equal));
	assert_eq!(d.partial_cmp(&d), Some(Ordering::Equal));

}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/tests/equality.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/tests/foreign_order.rs =====
/*! Third-party crates should be able to implement [`BitOrder`] usefully.

This test ensures that [`bitvec`] provides a sufficient API to implement
[`BitOrder`] in foreign crates and have these orderings work in the `bitvec`
system as peers of the provided orderings.
!*/

extern crate bitvec;

use bitvec::{
	index::{
		BitIdx,
		BitPos,
	},
	mem::BitRegister,
	prelude::*,
};

pub struct Swizzle;

unsafe impl BitOrder for Swizzle {
	fn at<R>(index: BitIdx<R>) -> BitPos<R>
	where R: BitRegister {
		match R::BITS {
			8 => BitPos::new(index.into_inner() ^ 0b100).unwrap(),
			16 => BitPos::new(index.into_inner() ^ 0b1100).unwrap(),
			32 => BitPos::new(index.into_inner() ^ 0b11100).unwrap(),
			64 => BitPos::new(index.into_inner() ^ 0b111100).unwrap(),
			_ => unreachable!("No other integers are supported"),
		}
	}
}

#[test]
#[cfg(not(miri))]
fn check_impl() {
	bitvec::order::verify::<Swizzle>(cfg!(feature = "testing"));
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/tests/foreign_order.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/tests/issues.rs =====
//! Test cases for defect reports.

#![allow(clippy::unusual_byte_groupings)]

#[cfg(feature = "alloc")]
use bitvec::prelude::*;

/** Test case for [Issue #10], opened by [@overminder].

Issue #10 is a bug in the implementation of `<BitSlice as ToOwned>::to_owned`.
That trait implementation used `BitVec::from_bitslice`, which had the incorrect
behavior of cloning the underlying `&[T]` slice into a vector. Bit slices are
capable of partial-element heads, while bit vectors are not (at time of issue).
This meant that cloning an intermediate span copied from the start of the first
element, rather than from the first bit.

The fix was to use `<BitVec as FromIterator<bool>>::from_iter` to power both
`BitVec::from_bitslice` and `<BitSlice as ToOwned>::to_owned`.

In the future, it may be possible to revert to the original
`<[T] as ToOwned>::to_owned` implementation, if `BitVec` becomes capable of
partial heads without loss of pointer information.

[Issue #10]: https://github.com/myrrlyn/bitvec/issues/10
[@overminder]: https://github.com/overminder
**/
#[test]
#[cfg(feature = "alloc")]
fn issue_10() {
	let bv = bitvec![LocalBits, u8;
		0, 0, 0, 0,
		0, 0, 0, 1,
		1, 0, 0, 0,
		0, 0, 0, 1,
	];

	let slice = &bv[4 .. 12];
	assert_eq!(slice.len(), 8);
	assert!(!slice[0]);
	assert!(slice[3]);
	assert!(slice[4]);
	assert!(!slice[7]);

	let mut bv2 = slice.to_owned();
	assert_eq!(bv2, slice);
	assert!(!bv2[0]);
	assert!(bv2[3]);
	assert!(bv2[4]);
	assert!(!bv2[7]);

	bv2.force_align();
	//  These may be removed in the future.
	assert_eq!(bv2.as_raw_slice().len(), 1);
	assert_eq!(bv2.as_raw_slice()[0], 0x18);
}

/** Test case for [Issue #33], opened by [@jonas-schievink].

This report discovered an error in the implementation of `BitVec::reserve`,
which caused it to fail to reällocate in certain conditions.

The error was that the `reserve` method was testing the reservation amount
passed in to `Vec::reserve` against the currently-allocated *capacity*, not the
currently-occupied *element length*. `Vec::reserve` expects the difference to be
against the element length, so `BitVec::reserve` was estimating too few elements
and `Vec::reserve` did not see the request amount as requiring a reällocation.

`BitVec::reserve` now tests the reservation amount against the current element
length, which produces the correct reservation request for `Vec::reserve`,
fixing the error.

[Issue #33]: https://github.com/myrrlyn/bitvec/issues/33
[@jonas-schievink]: https://github.com/jonas-schievink
**/
#[test]
#[cfg(feature = "alloc")]
fn issue_33() {
	let mut swdio = BitVec::<Lsb0, u8>::new();

	swdio.resize(64, true);

	let mut seq = 0xE79E; // LSb first
	for _ in 0 .. 16 {
		swdio.push(seq & 0b1 != 0);
		seq >>= 1;
	}

	swdio.reserve(64);
	swdio.resize(swdio.len() + 64, true);

	swdio.resize(swdio.len() + 10, false);
}

/** Test case for [Issue #62], reported by GitHub user [@sharksforarms].

They reported thread-safety violations under TSan. This occurred when running
tests using `BitVec::extend_from_bitslice` to combine buffers.

Removing all code within the tests still causes TSan failures, as of 2020-08-06.
Given that the test code in question does not perform any threading work of its
own, this indicates misbehavior of the test harness, outside of library scope.

However, the memory assertion failures they encountered *do* represent a bug
class in `bitvec`. This is the same bug class that occurred in #65, and has the
same solution: uninitialized memory in the `BitVec` buffer is not required to be
zeroed.

[Issue #62]: https://github.com/myrrlyn/bitvec/issues/62
[@sharksforarms]: https://github.com/sharksforarms
**/
#[test]
#[cfg(feature = "alloc")]
fn issue_62() {
	trait Writer {
		fn write(
			&self,
			output_is_le: bool,
			bit_size: Option<usize>,
		) -> BitVec<Msb0, u8>;
	}

	impl Writer for u32 {
		fn write(
			&self,
			output_is_le: bool,
			bit_size: Option<usize>,
		) -> BitVec<Msb0, u8> {
			let input = if output_is_le {
				self.to_le_bytes()
			}
			else {
				self.to_be_bytes()
			};
			let input_bits: BitVec<Msb0, u8> =
				BitSlice::from_slice(&input).unwrap().into();

			let res_bits: BitVec<Msb0, u8> = {
				if let Some(bit_size) = bit_size {
					if bit_size > input_bits.len() {
						todo!() // TODO: return err
					}

					if output_is_le {
						// Example read 10 bits u32 [0xAB, 0b11_000000]
						// => [10101011, 00000011, 00000000, 00000000]
						let mut res_bits = BitVec::<Msb0, u8>::new();
						let mut remaining_bits = bit_size;
						// println!("input_bits: {}", input_bits);
						for chunk in input_bits.chunks(8) {
							println!("chunk: {}", chunk);
							if chunk.len() > remaining_bits {
								res_bits.extend_from_bitslice(
									&chunk[chunk.len() - remaining_bits ..],
								);
								break;
							}
							else {
								res_bits.extend_from_bitslice(chunk)
							}
							remaining_bits -= chunk.len();
						}

						res_bits
					}
					else {
						// Example read 10 bits u32 [0xAB, 0b11_000000]
						// => [00000000, 00000000, 00000010, 10101111]
						input_bits[input_bits.len() - bit_size ..].into()
					}
				}
				else {
					input_bits
				}
			};

			res_bits
		}
	}

	let data = 0x03ABu32;
	let data_bits = data.write(true, Some(10));
	assert_eq!(bitvec![Msb0, u8; 1,0,1,0,1,0,1,1, 1,1], data_bits);
	let data_vec = data_bits.into_vec();
	assert_eq!(vec![0xAB, 0b11_000000], data_vec);

	let data = 0x03ABu32;
	let data_bits = data.write(false, Some(10)).into_vec();
	assert_eq!(vec![0b11, 0xAB], data_bits);

	let data = 0xDDCCBBAA;
	let data_bits = data.write(true, None).into_vec();
	assert_eq!(vec![0xAA, 0xBB, 0xCC, 0xDD], data_bits);

	let data = 0xDDCCBBAA;
	let data_bits = data.write(false, None).into_vec();
	assert_eq!(vec![0xDD, 0xCC, 0xBB, 0xAA], data_bits);
}

/** Test case for [Issue #65], opened by [@inikulin].

This issue found the use of uninitialized memory in
`BitVec::extend_from_bitslice` causing non-deterministic behavior.

[Issue #65]: https://github.com/myrrlyn/bitvec/issues/65
[@inikulin]: https://github.com/inikulin
**/
#[test]
#[cfg(feature = "alloc")]
fn issue_65() {
	let mut v = BitVec::<Msb0, u8>::default();
	v.extend_from_bitslice(bits![Msb0, u8; 0, 1]);
	assert_eq!(v.into_vec(), [0b0100_0000u8]);
}

/** Test case for [Issue #69], opened by [@YoshikiTakashima].

This report shows a dereference after deällocation. This is not *strictly* true:
the destructor only used the value of the pointer, and did not issue a load or
store instruction through it, but even that use was sufficient to trip Miri’s
alarms.

This test is only useful when run under `cargo +nightly miri test`. It asserts
that the allocation pointer is correctly managed during drop.

[Issue #10]: https://github.com/myrrlyn/bitvec/issues/69
[@YoshikiTakashima]: https://github.com/YoshikiTakashima
**/
#[test]
#[cfg(feature = "alloc")]
fn issue_69() {
	let _ = bitbox![0];
}

/** Test case for [Issue #77], opened by [@Cryptjar].

This report describes a segmentation fault found when using the `.rev()`
iterator adaptor. The fault was traced to an incorrect behavior in the
`ExactSizeIterator::len` implementation of `src/slice/iter.rs:iter!`. The
difference between the first and one-past-the-last pointers was incorrectly
scaled by the bit width of the `T` storage parameter, while pointers are
*always* byte-stepped, and should only be scaled by the bit width of a byte, not
the bit width of `T`.

Embarassingly, I made the same mistake in the `ptr_diff` implementation used in
the `nom` compatibility branch. At least I’m consistent.

The overly-large scaling in computation of `.len()` caused `Rev<>`, which relies
on a correct implementation of `.len()`, to attempt to access memory out of
bounds inside `Iter::nth`.

[Issue #77]: https://github.com/myrrlyn/bitvec/issues/77
[@Cryptjar]: https://github.com/Cryptjar
**/
#[test]
#[cfg(feature = "alloc")]
fn issue_77() {
	// The argument of `take`. If above "SOME" threshold, it will panic!
	// If below "the" threshold, the assert will fail instead.
	//
	// It appears that the threshold for normal execution is 4,
	// but when executing the binary via `gdb` it is 6.
	const N: usize = 6;

	let mut bv: BitVec = BitVec::new();
	// Must be at least the 'register size', but may be much larger
	bv.resize(64, true);

	// Here the complete iter-rev-take-rev-sequence is mandatory to reproduce the
	// error, just the `collect` is here for convenience.
	let last_few: Vec<_> = bv.iter().by_ref().rev().take(N).rev().collect();

	// Also notice, `bv` only contains `true`, but with `N` < 4, the `last_few`
	// are all `false`!!!
	assert_eq!(&[&true; N], last_few.as_slice());
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/tests/issues.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/tests/readme.rs =====
//! Copy of the example snippet in the README

#![allow(unused_variables, array_into_iter)]

#[cfg(feature = "alloc")]
use core::iter::repeat;

#[cfg(feature = "alloc")]
use bitvec::prelude::*;

#[test]
#[cfg(feature = "alloc")]
fn main() {
	// You can build a static array,
	let arr = bitarr![Lsb0, u32; 0; 64];
	// a hidden static slice,
	let slice = bits![mut LocalBits, u16; 0; 10];
	// or a boxed slice,
	let boxed = bitbox![0; 20];
	// or a vector, using macros that extend the `vec!` syntax
	let mut bv = bitvec![Msb0, u8; 0, 1, 0, 1];

	// You can also explicitly borrow existing scalars,
	let data = 0u32;
	let bits = BitSlice::<Lsb0, _>::from_element(&data);
	// or arrays,
	let mut data = [0u8; 3];
	let bits = BitSlice::<Msb0, _>::from_slice_mut(&mut data[..]);
	// and these are available as shortcut methods:
	let bits = 0u32.view_bits::<Lsb0>();
	let bits = [0u8; 3].view_bits_mut::<Msb0>();

	// `BitVec` implements the entire `Vec` API
	bv.reserve(8);

	// Like `Vec<bool>`, it can be extended by any iterator of `bool` or `&bool`
	bv.extend([false; 4].iter());
	bv.extend([true; 4].iter().copied());

	// `BitSlice`-owning buffers can be viewed as their raw memory
	assert_eq!(
		bv.as_raw_slice(),
		&[0b0101_0000, 0b1111_0000],
		//  ^ index 0       ^ index 11
	);
	assert_eq!(bv.len(), 12);
	assert!(bv.capacity() >= 16);

	bv.push(true);
	bv.push(false);
	bv.push(true);

	// `BitSlice` implements indexing
	assert!(bv[12]);
	assert!(!bv[13]);
	assert!(bv[14]);
	assert!(bv.get(15).is_none());

	// but not in place position
	// bv[12] = false;
	// because it cannot produce `&mut bool`.
	// instead, use `.get_mut()`:
	*bv.get_mut(12).unwrap() = false;
	// or `.set()`:
	bv.set(12, false);

	// range indexing produces subslices
	let last = &bv[12 ..];
	assert_eq!(last.len(), 3);
	assert!(last.any());

	for _ in 0 .. 3 {
		assert!(bv.pop().is_some());
	}

	//  `BitSlice` implements set arithmetic against any `bool` iterator
	bv &= repeat(true);
	bv |= repeat(false);
	bv ^= repeat(true);
	bv = !bv;
	// the crate no longer implements integer arithmetic, but `BitSlice`
	// can be used to represent varints in a downstream library.

	// `BitSlice`s are iterators:
	assert_eq!(bv.iter().filter(|b| **b).count(), 6,);

	// including mutable iteration, though this requires explicit binding:
	for (idx, mut bit) in bv.iter_mut().enumerate() {
		//      ^^^ not optional
		*bit ^= idx % 2 == 0;
	}

	// `BitSlice` can also implement bitfield memory behavior:
	bv[1 .. 7].store(0x2Eu8);
	assert_eq!(bv[1 .. 7].load::<u8>(), 0x2E);
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/tests/readme.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/bitvec/tests/serdes.rs =====
/*! This example shows off de/serializing a bit sequence using serde.

The example uses JSON for simplicity of demonstration; it should work with all
serde-compatible de/ser protocols.
!*/

#[cfg(all(feature = "alloc", feature = "serde"))]
use bitvec::prelude::*;

#[test]
#[cfg(all(feature = "alloc", feature = "serde"))]
fn serdes_array() {
	let ba = bitarr![Msb0, u8; 1, 0, 1, 1, 0, 0, 1, 0];
	let json = serde_json::to_string(&ba).expect("cannot fail to serialize");
	assert_eq!(json.trim(), r#"[178]"#);

	let ba: BitArray<Msb0, [u8; 1]> =
		serde_json::from_str(&json).expect("cannot fail to deserialize");
	assert!(ba[0]);
	assert_eq!(ba.as_raw_slice()[0], 178);

	//  Note: Scalar arrays do not (yet) serialize as a sequence of one element.
	let ba_bare: BitArray<Msb0, u8> =
		serde_json::from_str(&"178").expect("cannot fail to deserialize");
	assert_eq!(ba.as_bitslice(), ba_bare.as_bitslice());
}

#[test]
#[cfg(all(feature = "alloc", feature = "serde"))]
fn serdes_vector() {
	let bv = bitvec![Msb0, u8; 1, 0, 1, 1, 0, 0, 1, 0];
	let json = serde_json::to_string(&bv).expect("cannot fail to serialize");
	assert_eq!(json.trim(), r#"{"head":0,"bits":8,"data":[178]}"#);

	let bb: BitBox<Msb0, u8> =
		serde_json::from_str(&json).expect("cannot fail to deserialize");

	assert!(bb[0]);
	assert_eq!(bb.as_slice()[0], 178);
}
===== END OF /home/matt/InterCooperative-Network/vendor/bitvec/tests/serdes.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/funty/Cargo.toml =====
[package]
name = "funty"
version = "1.0.0"
authors = [
	"myrrlyn <self@myrrlyn.dev>",
]
categories = [
	"no-std",
	"rust-patterns",
]
description = "Trait generalization over the primitive types"
documentation = "https://docs.rs/funty"
edition = "2018"
include = [
	"Cargo.toml",
	"src/lib.rs",
]
keywords = [
	"numerics",
	"primitives",
	"traits",
]
license = "MIT"
readme = "README.md"
repository = "https://github.com/myrrlyn/funty"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[features]
default = [
	"std",
]
std = []

[dev-dependencies]
static_assertions = "1"
===== END OF /home/matt/InterCooperative-Network/vendor/funty/Cargo.toml =====

===== START OF /home/matt/InterCooperative-Network/vendor/funty/rustfmt-nightly.toml =====
################################################################################
#                           Rust Style Configuration                           #
#                                                                              #
# This file controls the operation of `rustfmt` and `cargo fmt`. As the        #
# `rustfmt` tool is still unstable, this file is only usable by the nightly    #
# release of Rust at least as of the date this file was last touched.          #
#                                                                              #
# See https://github.com/rust-lang/rustfmt/blob/master/Configurations.md for a #
# list of all configuration options.                                           #
################################################################################

# Stable as of current nightly
edition = "2018"
fn_args_layout = "Tall"
force_explicit_abi = true
hard_tabs = true
max_width = 81
merge_derives = true
newline_style = "Unix"
print_misformatted_file_names = false
remove_nested_parens = true
reorder_imports = true
reorder_modules = true
tab_spaces = 4
use_field_init_shorthand = true
use_small_heuristics = "Default"
use_try_shorthand = true

# Still unstable
binop_separator = "Front"
blank_lines_lower_bound = 0
blank_lines_upper_bound = 1
brace_style = "SameLineWhere"
color = "Auto"
combine_control_expr = true
comment_width = 80
condense_wildcard_suffixes = true
control_brace_style = "ClosingNextLine"
disable_all_formatting = false
empty_item_single_line = false
enum_discrim_align_threshold = 40
error_on_line_overflow = false
error_on_unformatted = false
fn_single_line = false
force_multiline_blocks = false
format_code_in_doc_comments = false
format_macro_matchers = true
format_macro_bodies = true
format_strings = true
hide_parse_errors = false
ignore = []
imports_indent = "Block"
imports_layout = "Vertical"
indent_style = "Block"
inline_attribute_width = 0
license_template_path = ""
match_arm_blocks = true
match_block_trailing_comma = true
merge_imports = true
normalize_comments = false
normalize_doc_attributes = true
overflow_delimited_expr = true
reorder_impl_items = true
report_fixme = "Unnumbered"
report_todo = "Unnumbered"
space_after_colon = true
space_before_colon = false
spaces_around_ranges = true
struct_field_align_threshold = 0
struct_lit_single_line = true
trailing_comma = "Vertical"
trailing_semicolon = true
type_punctuation_density = "Wide"
unstable_features = true
version = "Two"
where_single_line = true
wrap_comments = true
===== END OF /home/matt/InterCooperative-Network/vendor/funty/rustfmt-nightly.toml =====

===== START OF /home/matt/InterCooperative-Network/vendor/funty/rustfmt.toml =====
################################################################################
#                           Rust Style Configuration                           #
#                                                                              #
# This file controls the operation of `rustfmt` and `cargo fmt`. As the        #
# `rustfmt` tool is still unstable, this file only contains the configurations #
# that are stable as of the pinned Rust version in `rust-toolchain`. The file  #
# `rustfmt-nightly.toml` contains the configurations that are available as of  #
# the nightly Rust release when that file was last touched.                    #
################################################################################

edition = "2018"
hard_tabs = true
force_explicit_abi = true
max_width = 81
merge_derives = true
newline_style = "Unix"
remove_nested_parens = true
reorder_imports = true
reorder_modules = true
tab_spaces = 4
use_field_init_shorthand = true
use_small_heuristics = "Default"
use_try_shorthand = true
===== END OF /home/matt/InterCooperative-Network/vendor/funty/rustfmt.toml =====

===== START OF /home/matt/InterCooperative-Network/vendor/funty/src/lib.rs =====
/*! `fun`damental `ty`pes

This crate provides trait unification of the Rust fundamental numbers, allowing
users to declare the behavior they want from a number without committing to a
single particular numeric type.

The number types can be categorized along two axes: behavior and width. Traits
for each axis and group on that axis are provided:

## Numeric Categories

The most general category is represented by the trait [`IsNumber`]. It is
implemented by all the numeric fundamentals, and includes only the traits that
they all implement. This is an already-large amount: basic memory management,
comparison, rendering, and numeric arithmetic.

The numbers are then split into [`IsInteger`] and [`IsFloat`]. The former fills
out the API of `f32` and `f64`, while the latter covers all of the `iN` and `uN`
numbers.

Lastly, [`IsInteger`] splits further, into [`IsSigned`] and [`IsUnsigned`].
These provide the last specializations unique to the differences between `iN`
and `uN`.

## Width Categories

Every number implements the trait `IsN` for the `N` of its bit width. `isize`
and `usize` implement the trait that matches their width on the target platform.

In addition, the trait groups `AtLeastN` and `AtMostN` enable clamping the range
of acceptable widths to lower or upper bounds. These traits are equivalent to
`mem::size_of::<T>() >= N` and `mem::size_of::<T>() <= N`, respectively.

[`IsFloat`]: trait.IsFloat.html
[`IsInteger`]: trait.IsInteger.html
[`IsNumber`]: trait.IsNumber.html
[`IsSigned`]: trait.IsSigned.html
[`IsUnsigned`]: trait.IsUnsigned.html
!*/

#![cfg_attr(not(feature = "std"), no_std)]
#![deny(unconditional_recursion)]

use core::{
	convert::TryFrom,
	fmt::{
		Binary,
		Debug,
		Display,
		LowerExp,
		LowerHex,
		Octal,
		UpperExp,
		UpperHex,
	},
	hash::Hash,
	iter::{
		Product,
		Sum,
	},
	num::{
		FpCategory,
		ParseIntError,
	},
	ops::{
		Add,
		AddAssign,
		BitAnd,
		BitAndAssign,
		BitOr,
		BitOrAssign,
		BitXor,
		BitXorAssign,
		Div,
		DivAssign,
		Mul,
		MulAssign,
		Neg,
		Not,
		Rem,
		RemAssign,
		Shl,
		ShlAssign,
		Shr,
		ShrAssign,
		Sub,
		SubAssign,
	},
	str::FromStr,
};

/// Declare that a type is an abstract number.
///
/// This unifies all of the signed-integer, unsigned-integer, and floating-point
/// types.
pub trait IsNumber: Sized
	+ Send
	+ Sync
	+ Unpin
	+ Clone
	+ Copy
	+ Default
	+ FromStr
	//  cmp
	+ PartialEq<Self>
	+ PartialOrd<Self>
	//  fmt
	+ Debug
	+ Display
	//  iter
	+ Product<Self>
	+ for<'a> Product<&'a Self>
	+ Sum<Self>
	+ for<'a> Sum<&'a Self>
	//  numeric ops
	+ Add<Self, Output = Self>
	+ for<'a> Add<&'a Self, Output = Self>
	+ AddAssign<Self>
	+ for<'a> AddAssign<&'a Self>
	+ Sub<Self, Output = Self>
	+ for<'a> Sub<&'a Self, Output = Self>
	+ SubAssign<Self>
	+ for<'a> SubAssign<&'a Self>
	+ Mul<Self, Output = Self>
	+ for<'a> Mul<&'a Self, Output = Self>
	+ MulAssign<Self>
	+ for<'a> MulAssign<&'a Self>
	+ Div<Self, Output = Self>
	+ for<'a> Div<&'a Self, Output = Self>
	+ DivAssign<Self>
	+ for<'a> DivAssign<&'a Self>
	+ Rem<Self, Output = Self>
	+ for<'a> Rem<&'a Self, Output = Self>
	+ RemAssign<Self>
	+ for<'a> RemAssign<&'a Self>
{
	type Bytes;

	/// Return the memory representation of this number as a byte array in
	/// big-endian (network) byte order.
	fn to_be_bytes(self) -> Self::Bytes;

	/// Return the memory representation of this number as a byte array in
	/// little-endian byte order.
	fn to_le_bytes(self) -> Self::Bytes;

	/// Return the memory representation of this number as a byte array in
	/// native byte order.
	fn to_ne_bytes(self) -> Self::Bytes;

	/// Create a numeric value from its representation as a byte array in big
	/// endian.
	fn from_be_bytes(bytes: Self::Bytes) -> Self;

	/// Create a numeric value from its representation as a byte array in little
	/// endian.
	fn from_le_bytes(bytes: Self::Bytes) -> Self;

	/// Create a numeric value from its memory representation as a byte array in
	/// native endianness.
	fn from_ne_bytes(bytes: Self::Bytes) -> Self;
}

/// Declare that a type is a fixed-point integer.
///
/// This unifies all of the signed and unsigned integral types.
pub trait IsInteger: IsNumber
	+ Hash
	//  cmp
	+ Eq
	+ Ord
	//  fmt
	+ Binary
	+ LowerHex
	+ UpperHex
	+ Octal
	//  boolean ops
	+ BitAnd<Self, Output=Self>
	+ for<'a> BitAnd<&'a Self, Output=Self>
	+ BitAndAssign<Self>
	+ for<'a> BitAndAssign<&'a Self>
	+ BitOr<Self, Output=Self>
	+ for<'a> BitOr<&'a Self, Output=Self>
	+ BitOrAssign<Self>
	+ for<'a> BitOrAssign<&'a Self>
	+ BitXor<Self, Output=Self>
	+ for<'a> BitXor<&'a Self, Output=Self>
	+ BitXorAssign<Self>
	+ for<'a> BitXorAssign<&'a Self>
	+ Not<Output=Self>
	//  conversions
	+ TryFrom<i8>
	+ TryFrom<u8>
	+ TryFrom<i16>
	+ TryFrom<u16>
	+ TryFrom<i32>
	+ TryFrom<u32>
	+ TryFrom<i64>
	+ TryFrom<u64>
	+ TryFrom<i128>
	+ TryFrom<u128>
	+ TryFrom<isize>
	+ TryFrom<usize>
	//  shifts
	+ Shl<i8, Output=Self>
	+ for<'a> Shl<&'a i8, Output=Self>
	+ ShlAssign<i8>
	+ for<'a> ShlAssign<&'a i8>
	+ Shr<i8, Output=Self>
	+ for<'a> Shr<&'a i8, Output=Self>
	+ ShrAssign<i8>
	+ for<'a> ShrAssign<&'a i8>
	+ Shl<u8, Output=Self>
	+ for<'a> Shl<&'a u8, Output=Self>
	+ ShlAssign<u8>
	+ for<'a> ShlAssign<&'a u8>
	+ Shr<u8, Output=Self>
	+ for<'a> Shr<&'a u8, Output=Self>
	+ ShrAssign<u8>
	+ for<'a> ShrAssign<&'a u8>
	+ Shl<i16, Output=Self>
	+ for<'a> Shl<&'a i16, Output=Self>
	+ ShlAssign<i16>
	+ for<'a> ShlAssign<&'a i16>
	+ Shr<i16, Output=Self>
	+ for<'a> Shr<&'a i16, Output=Self>
	+ ShrAssign<i16>
	+ for<'a> ShrAssign<&'a i16>
	+ Shl<u16, Output=Self>
	+ for<'a> Shl<&'a u16, Output=Self>
	+ ShlAssign<u16>
	+ for<'a> ShlAssign<&'a u16>
	+ Shr<u16, Output=Self>
	+ for<'a> Shr<&'a u16, Output=Self>
	+ ShrAssign<u16>
	+ for<'a> ShrAssign<&'a u16>
	+ Shl<i32, Output=Self>
	+ for<'a> Shl<&'a i32, Output=Self>
	+ ShlAssign<i32>
	+ for<'a> ShlAssign<&'a i32>
	+ Shr<i32, Output=Self>
	+ for<'a> Shr<&'a i32, Output=Self>
	+ ShrAssign<i32>
	+ for<'a> ShrAssign<&'a i32>
	+ Shl<u32, Output=Self>
	+ for<'a> Shl<&'a u32, Output=Self>
	+ ShlAssign<u32>
	+ for<'a> ShlAssign<&'a u32>
	+ Shr<u32, Output=Self>
	+ for<'a> Shr<&'a u32, Output=Self>
	+ ShrAssign<u32>
	+ for<'a> ShrAssign<&'a u32>
	+ Shl<i64, Output=Self>
	+ for<'a> Shl<&'a i64, Output=Self>
	+ ShlAssign<i64>
	+ for<'a> ShlAssign<&'a i64>
	+ Shr<i64, Output=Self>
	+ for<'a> Shr<&'a i64, Output=Self>
	+ ShrAssign<i64>
	+ for<'a> ShrAssign<&'a i64>
	+ Shl<u64, Output=Self>
	+ for<'a> Shl<&'a u64, Output=Self>
	+ ShlAssign<u64>
	+ for<'a> ShlAssign<&'a u64>
	+ Shr<u64, Output=Self>
	+ for<'a> Shr<&'a u64, Output=Self>
	+ ShrAssign<u64>
	+ for<'a> ShrAssign<&'a u64>
	+ Shl<i128, Output=Self>
	+ for<'a> Shl<&'a i128, Output=Self>
	+ ShlAssign<i128>
	+ for<'a> ShlAssign<&'a i128>
	+ Shr<i128, Output=Self>
	+ for<'a> Shr<&'a i128, Output=Self>
	+ ShrAssign<i128>
	+ for<'a> ShrAssign<&'a i128>
	+ Shl<u128, Output=Self>
	+ for<'a> Shl<&'a u128, Output=Self>
	+ ShlAssign<u128>
	+ for<'a> ShlAssign<&'a u128>
	+ Shr<u128, Output=Self>
	+ for<'a> Shr<&'a u128, Output=Self>
	+ ShrAssign<u128>
	+ for<'a> ShrAssign<&'a u128>
	+ Shl<isize, Output=Self>
	+ for<'a> Shl<&'a isize, Output=Self>
	+ ShlAssign<isize>
	+ for<'a> ShlAssign<&'a isize>
	+ Shr<isize, Output=Self>
	+ for<'a> Shr<&'a isize, Output=Self>
	+ ShrAssign<isize>
	+ for<'a> ShrAssign<&'a isize>
	+ Shl<usize, Output=Self>
	+ for<'a> Shl<&'a usize, Output=Self>
	+ ShlAssign<usize>
	+ for<'a> ShlAssign<&'a usize>
	+ Shr<usize, Output=Self>
	+ for<'a> Shr<&'a usize, Output=Self>
	+ ShrAssign<usize>
	+ for<'a> ShrAssign<&'a usize>
{
	/// The type’s zero value.
	const ZERO: Self;

	/// The type’s minimum value. This is zero for unsigned integers.
	const MIN: Self;

	/// The type’s maximum value.
	const MAX: Self;

	/// Returns the smallest value that can be represented by this integer type.
	fn min_value() -> Self;

	/// Returns the largest value that can be represented by this integer type.
	fn max_value() -> Self;

	/// Converts a string slice in a given base to an integer.
	///
	/// The string is expected to be an optional `+` or `-` sign followed by
	/// digits. Leading and trailing whitespace represent an error. Digits are a
	/// subset of these characters, depending on `radix`:
	///
	/// - `0-9`
	/// - `a-z`
	/// - `A-Z`
	///
	/// # Panics
	///
	/// This function panics if `radix` is not in the range from 2 to 36.
	fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError>;

	/// Returns the number of ones in the binary representation of `self`.
	fn count_ones(self) -> u32;

	/// Returns the number of zeros in the binary representation of `self`.
	fn count_zeros(self) -> u32;

	/// Returns the number of leading zeros in the binary representation of
	/// `self`.
	fn leading_zeros(self) -> u32;

	/// Returns the number of trailing zeros in the binary representation of
	/// `self`.
	fn trailing_zeros(self) -> u32;

	/// Shifts the bits to the left by a specified amount, `n`, wrapping the
	/// truncated bits to the end of the resulting integer.
	///
	/// Please note this isn’t the same operation as the `<<` shifting operator!
	fn rotate_left(self, n: u32) -> Self;

	/// Shifts the bits to the right by a specified amount, `n`, wrapping the
	/// truncated bits to the beginning of the resulting integer.
	///
	/// Please note this isn’t the same operation as the `>>` shifting operator!
	fn rotate_right(self, n: u32) -> Self;

	/// Reverses the byte order of the integer.
	fn swap_bytes(self) -> Self;

	/// Reverses the bit pattern of the integer.
	fn reverse_bits(self) -> Self;

	/// Converts an integer from big endian to the target’s endianness.
	///
	/// On big endian this is a no-op. On little endian the bytes are swapped.
	fn from_be(self) -> Self;

	/// Converts an integer frm little endian to the target’s endianness.
	///
	/// On little endian this is a no-op. On big endian the bytes are swapped.
	fn from_le(self) -> Self;

	/// Converts `self` to big endian from the target’s endianness.
	///
	/// On big endian this is a no-op. On little endian the bytes are swapped.
	fn to_be(self) -> Self;

	/// Converts `self` to little endian from the target’s endianness.
	///
	/// On little endian this is a no-op. On big endian the bytes are swapped.
	fn to_le(self) -> Self;

	/// Checked integer addition. Computes `self + rhs`, returning `None` if
	/// overflow occurred.
	fn checked_add(self, rhs: Self) -> Option<Self>;

	/// Checked integer subtraction. Computes `self - rhs`, returning `None` if
	/// overflow occurred.
	fn checked_sub(self, rhs: Self) -> Option<Self>;

	/// Checked integer multiplication. Computes `self * rhs`, returning `None`
	/// if overflow occurred.
	fn checked_mul(self, rhs: Self) -> Option<Self>;

	/// Checked integer division. Computes `self / rhs`, returning `None` if
	/// `rhs == 0` or the division results in overflow.
	fn checked_div(self, rhs: Self) -> Option<Self>;

	/// Checked Euclidean division. Computes `self.div_euclid(rhs)`, returning
	/// `None` if `rhs == 0` or the division results in overflow.
	fn checked_div_euclid(self, rhs: Self) -> Option<Self>;

	/// Checked integer remainder. Computes `self % rhs`, returning `None` if
	/// `rhs == 0` or the division results in overflow.
	fn checked_rem(self, rhs: Self) -> Option<Self>;

	/// Checked Euclidean remainder. Computes `self.rem_euclid(rhs)`, returning
	/// `None` if `rhs == 0` or the division results in overflow.
	fn checked_rem_euclid(self, rhs: Self) -> Option<Self>;

	/// Checked negation. Computes `-self`, returning `None` if `self == MIN`.
	///
	/// Note that negating any positive integer will overflow.
	fn checked_neg(self) -> Option<Self>;

	/// Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is
	/// larger than or equal to the number of bits in `self`.
	fn checked_shl(self, rhs: u32) -> Option<Self>;

	/// Checked shift right. Computes `self >> rhs`, returning `None` if `rhs`
	/// is larger than or equal to the number of bits in `self`.
	fn checked_shr(self, rhs: u32) -> Option<Self>;

	/// Checked exponentiation. Computes `self.pow(exp)`, returning `None` if
	/// overflow occurred.
	fn checked_pow(self, rhs: u32) -> Option<Self>;

	/// Saturating integer addition. Computes `self + rhs`, saturating at the
	/// numeric bounds instead of overflowing.
	fn saturating_add(self, rhs: Self) -> Self;

	/// Saturating integer subtraction. Computes `self - rhs`, saturating at the
	/// numeric bounds instead of overflowing.
	fn saturating_sub(self, rhs: Self) -> Self;

	/// Saturating integer multiplication. Computes `self * rhs`, saturating at
	/// the numeric bounds instead of overflowing.
	fn saturating_mul(self, rhs: Self) -> Self;

	/// Saturating integer exponentiation. Computes `self.pow(exp)`, saturating
	/// at the numeric bounds instead of overflowing.
	fn saturating_pow(self, rhs: u32) -> Self;

	/// Wrapping (modular) addition. Computes `self + rhs`, wrapping around at
	/// the boundary of the type.
	fn wrapping_add(self, rhs: Self) -> Self;

	/// Wrapping (modular) subtraction. Computes `self - rhs`, wrapping around
	/// at the boundary of the type.
	fn wrapping_sub(self, rhs: Self) -> Self;

	/// Wrapping (modular) multiplication. Computes `self * rhs`, wrapping
	/// around at the boundary of the type.
	fn wrapping_mul(self, rhs: Self) -> Self;

	/// Wrapping (modular) division. Computes `self / rhs`, wrapping around at
	/// the boundary of the type.
	///
	/// # Signed Integers
	///
	/// The only case where such wrapping can occur is when one divides
	/// `MIN / -1` on a signed type (where `MIN` is the negative minimal value
	/// for the type); this is equivalent to `-MIN`, a positive value that is
	/// too large to represent in the type. In such a case, this function
	/// returns `MIN` itself.
	///
	/// # Unsigned Integers
	///
	/// Wrapping (modular) division. Computes `self / rhs`. Wrapped division on
	/// unsigned types is just normal division. There’s no way wrapping could
	/// ever happen. This function exists, so that all operations are accounted
	/// for in the wrapping operations.
	///
	/// # Panics
	///
	/// This function will panic if `rhs` is 0.
	fn wrapping_div(self, rhs: Self) -> Self;

	/// Wrapping Eulidean division. Computes `self.div_euclid(rhs)`, wrapping
	/// around at the boundary of the type.
	///
	/// # Signed Types
	///
	/// Wrapping will only occur in `MIN / -1` on a signed type (where `MIN` is
	/// the negative minimal value for the type). This is equivalent to `-MIN`,
	/// a positive value that is too large to represent in the type. In this
	/// case, this method returns `MIN` itself.
	///
	/// # Unsigned Types
	///
	/// Wrapped division on unsigned types is just normal division. There’s no
	/// way wrapping could ever happen. This function exists, so that all
	/// operations are accounted for in the wrapping operations. Since, for the
	/// positive integers, all common definitions of division are equal, this is
	/// exactly equal to `self.wrapping_div(rhs)`.
	///
	/// # Panics
	///
	/// This function will panic if `rhs` is 0.
	fn wrapping_div_euclid(self, rhs: Self) -> Self;

	/// Wrapping (modular) remainder. Computes `self % rhs`, wrapping around at
	/// the boundary of the type.
	///
	/// # Signed Integers
	///
	/// Such wrap-around never actually occurs mathematically; implementation
	/// artifacts make `x % y` invalid for `MIN / -1` on a signed type (where
	/// `MIN` is the negative minimal value). In such a case, this function
	/// returns `0`.
	///
	/// # Unsigned Integers
	///
	/// Wrapped remainder calculation on unsigned types is just the regular
	/// remainder calculation. There’s no way wrapping could ever happen. This
	/// function exists, so that all operations are accounted for in the
	/// wrapping operations.
	///
	/// # Panics
	///
	/// This function will panic if `rhs` is 0.
	fn wrapping_rem(self, rhs: Self) -> Self;

	/// Wrapping Euclidean remainder. Computes `self.rem_euclid(rhs)`, wrapping
	/// around at the boundary of the type.
	///
	/// # Signed Integers
	///
	/// Wrapping will only occur in `MIN % -1` on a signed type (where `MIN` is
	/// the negative minimal value for the type). In this case, this method
	/// returns 0.
	///
	/// # Unsigned Integers
	///
	/// Wrapped modulo calculation on unsigned types is just the regular
	/// remainder calculation. There’s no way wrapping could ever happen. This
	/// function exists, so that all operations are accounted for in the
	/// wrapping operations. Since, for the positive integers, all common
	/// definitions of division are equal, this is exactly equal to
	/// `self.wrapping_rem(rhs)`.
	///
	/// # Panics
	///
	/// This function will panic if `rhs` is 0.
	fn wrapping_rem_euclid(self, rhs: Self) -> Self;

	/// Wrapping (modular) negation. Computes `-self`, wrapping around at the
	/// boundary of the type.
	///
	/// # Signed Integers
	///
	/// The  only case where such wrapping can occur is when one negates `MIN`
	/// on a signed type (where `MIN` is the negative minimal value for the
	/// type); this is a positive value that is too large to represent in the
	/// type. In such a case, this function returns `MIN` itself.
	///
	/// # Unsigned Integers
	///
	/// Since unsigned types do not have negative equivalents all applications
	/// of this function will wrap (except for `-0`). For values smaller than
	/// the corresponding signed type’s maximum the result is the same as
	/// casting the corresponding signed value. Any larger values are equivalent
	/// to `MAX + 1 - (val - MAX - 1)` where `MAX` is the corresponding signed
	/// type’s maximum.
	fn wrapping_neg(self) -> Self;

	/// Panic-free bitwise shift-left; yields `self << mask(rhs)`, where `mask`
	/// removes any high-order bits of `rhs` that would cause the shift to
	/// exceed the bitwidth of the type.
	///
	/// Note that this is not the same as a rotate-left; the RHS of a wrapping
	/// shift-left is restricted to the range of the type, rather than the bits
	/// shifted out of the LHS being returned to the other end. The primitive
	/// integer types all implement a `rotate_left` function, which may be what
	/// you want instead.
	fn wrapping_shl(self, rhs: u32) -> Self;

	/// Panic-free bitwise shift-right; yields `self >> mask(rhs)`, where `mask`
	/// removes any high-order bits of `rhs` that would cause the shift to
	/// exceed the bitwidth of the type.
	///
	/// Note that this is not the same as a rotate-right; the RHS of a wrapping
	/// shift-right is restricted to the range of the type, rather than the bits
	/// shifted out of the LHS being returned to the other end. The primitive
	/// integer types all implement a `rotate_right` function, which may be what
	/// you want instead.
	fn wrapping_shr(self, rhs: u32) -> Self;

	/// Wrapping (modular) exponentiation. Computes `self.pow(exp)`, wrapping
	/// around at the boundary of the type.
	fn wrapping_pow(self, rhs: u32) -> Self;

	/// Calculates `self + rhs`
	///
	/// Returns a tuple of the addition along with a boolean indicating whether
	/// an arithmetic overflow would occur. If an overflow would have occurred
	/// then the wrapped value is returned.
	fn overflowing_add(self, rhs: Self) -> (Self, bool);

	/// Calculates `self - rhs`
	///
	/// Returns a tuple of the subtraction along with a boolean indicating
	/// whether an arithmetic overflow would occur. If an overflow would have
	/// occurred then the wrapped value is returned.
	fn overflowing_sub(self, rhs: Self) -> (Self, bool);

	/// Calculates the multiplication of `self` and `rhs`.
	///
	/// Returns a tuple of the multiplication along with a boolean indicating
	/// whether an arithmetic overflow would occur. If an overflow would have
	/// occurred then the wrapped value is returned.
	fn overflowing_mul(self, rhs: Self) -> (Self, bool);

	/// Calculates the divisor when `self` is divided by `rhs`.
	///
	/// Returns a tuple of the divisor along with a boolean indicating whether
	/// an arithmetic overflow would occur. If an overflow would occur then self
	/// is returned.
	///
	/// # Panics
	///
	/// This function will panic if `rhs` is 0.
	fn overflowing_div(self, rhs: Self) -> (Self, bool);

	/// Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.
	///
	/// Returns a tuple of the divisor along with a boolean indicating whether
	/// an arithmetic overflow would occur. If an overflow would occur then self
	/// is returned.
	///
	/// # Panics
	///
	/// This function will panic if `rhs` is 0.
	fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool);

	/// Calculates the remainder when `self` is divided by `rhs`.
	///
	/// Returns a tuple of the remainder after dividing along with a boolean
	/// indicating whether an arithmetic overflow would occur. If an overflow
	/// would occur then 0 is returned.
	///
	/// # Panics
	///
	/// This function will panic if `rhs` is 0.
	fn overflowing_rem(self, rhs: Self) -> (Self, bool);

	/// Overflowing Euclidean remainder. Calculates `self.rem_euclid(rhs)`.
	///
	/// Returns a tuple of the remainder after dividing along with a boolean
	/// indicating whether an arithmetic overflow would occur. If an overflow
	/// would occur then 0 is returned.
	///
	/// # Panics
	///
	/// This function will panic if rhs is 0.
	fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool);

	/// Negates self, overflowing if this is equal to the minimum value.
	///
	/// Returns a tuple of the negated version of self along with a boolean
	/// indicating whether an overflow happened. If `self` is the minimum value
	/// (e.g., `i32::MIN` for values of type `i32`), then the minimum value will
	/// be returned again and `true` will be returned for an overflow happening.
	fn overflowing_neg(self) -> (Self, bool);

	/// Shifts self left by `rhs` bits.
	///
	/// Returns a tuple of the shifted version of self along with a boolean
	/// indicating whether the shift value was larger than or equal to the
	/// number of bits. If the shift value is too large, then value is masked
	/// (N-1) where N is the number of bits, and this value is then used to
	/// perform the shift.
	fn overflowing_shl(self, rhs: u32) -> (Self, bool);

	/// Shifts self right by `rhs` bits.
	///
	/// Returns a tuple of the shifted version of self along with a boolean
	/// indicating whether the shift value was larger than or equal to the
	/// number of bits. If the shift value is too large, then value is masked
	/// (N-1) where N is the number of bits, and this value is then used to
	/// perform the shift.
	fn overflowing_shr(self, rhs: u32) -> (Self, bool);


	/// Raises self to the power of `exp`, using exponentiation by squaring.
	///
	/// Returns a tuple of the exponentiation along with a bool indicating
	/// whether an overflow happened.
	fn overflowing_pow(self, rhs: u32) -> (Self, bool);

	/// Raises self to the power of `exp`, using exponentiation by squaring.
	fn pow(self, rhs: u32) -> Self;

	/// Calculates the quotient of Euclidean division of self by rhs.
	///
	/// This computes the integer `n` such that
	/// `self = n * rhs + self.rem_euclid(rhs)`, with
	/// `0 <= self.rem_euclid(rhs) < rhs`.
	///
	/// In other words, the result is `self / rhs` rounded to the integer `n`
	/// such that `self >= n * rhs`. If `self > 0`, this is equal to round
	/// towards zero (the default in Rust); if `self < 0`, this is equal to
	/// round towards +/- infinity.
	///
	/// # Panics
	///
	/// This function will panic if `rhs` is 0 or the division results in
	/// overflow.
	fn div_euclid(self, rhs: Self) -> Self;

	/// Calculates the least nonnegative remainder of `self (mod rhs)`.
	///
	/// This is done as if by the Euclidean division algorithm -- given
	/// `r = self.rem_euclid(rhs)`, `self = rhs * self.div_euclid(rhs) + r`, and
	/// `0 <= r < abs(rhs)`.
	///
	/// # Panics
	///
	/// This function will panic if `rhs` is 0 or the division results in
	/// overflow.
	fn rem_euclid(self, rhs: Self) -> Self;
}

/// Declare that a type is a signed integer.
pub trait IsSigned: IsInteger + Neg {
	/// Checked absolute value. Computes `self.abs()`, returning `None` if
	/// `self == MIN`.
	fn checked_abs(self) -> Option<Self>;

	/// Wrapping (modular) absolute value. Computes `self.abs()`, wrapping
	/// around at the boundary of the type.
	///
	/// The only case where such wrapping can occur is when one takes the
	/// absolute value of the negative minimal value for the type this is a
	/// positive value that is too large to represent in the type. In such a
	/// case, this function returns `MIN` itself.
	fn wrapping_abs(self) -> Self;

	/// Computes the absolute value of `self`.
	///
	/// Returns a tuple of the absolute version of self along with a boolean
	/// indicating whether an overflow happened. If self is the minimum value
	/// (e.g., iN::MIN for values of type iN), then the minimum value will be
	/// returned again and true will be returned for an overflow happening.
	fn overflowing_abs(self) -> (Self, bool);

	//// Computes the absolute value of self.
	///
	/// # Overflow behavior
	///
	/// The absolute value of `iN::min_value()` cannot be represented as an
	/// `iN`, and attempting to calculate it will cause an overflow. This means
	/// that code in debug mode will trigger a panic on this case and optimized
	/// code will return `iN::min_value()` without a panic.
	fn abs(self) -> Self;

	/// Returns a number representing sign of `self`.
	///
	/// - `0` if the number is zero
	/// - `1` if the number is positive
	/// - `-1` if the number is negative
	fn signum(self) -> Self;

	/// Returns `true` if `self` is positive and `false` if the number is zero
	/// or negative.
	fn is_positive(self) -> bool;

	/// Returns `true` if `self` is negative and `false` if the number is zero
	/// or positive.
	fn is_negative(self) -> bool;
}

/// Declare that a type is an unsigned integer.
pub trait IsUnsigned: IsInteger {
	/// Returns `true` if and only if `self == 2^k` for some `k`.
	fn is_power_of_two(self) -> bool;

	/// Returns the smallest power of two greater than or equal to `self`.
	///
	/// When return value overflows (i.e., `self > (1 << (N-1))` for type `uN`),
	/// it panics in debug mode and return value is wrapped to 0 in release mode
	/// (the only situation in which method can return 0).
	fn next_power_of_two(self) -> Self;

	/// Returns the smallest power of two greater than or equal to `n`. If the
	/// next power of two is greater than the type’s maximum value, `None` is
	/// returned, otherwise the power of two is wrapped in `Some`.
	fn checked_next_power_of_two(self) -> Option<Self>;
}

/// Declare that a type is a floating-point number.
pub trait IsFloat:
	IsNumber
	+ LowerExp
	+ UpperExp
	+ Neg
	+ From<f32>
	+ From<i8>
	+ From<i16>
	+ From<u8>
	+ From<u16>
{
	type Raw;

	/// The radix or base of the internal representation of `f32`.
	const RADIX: u32;

	/// Number of significant digits in base 2.
	const MANTISSA_DIGITS: u32;

	/// Approximate number of significant digits in base 10.
	const DIGITS: u32;

	/// [Machine epsilon] value for `f32`.
	///
	/// This is the difference between `1.0` and the next larger representable
	/// number.
	///
	/// [Machine epsilon]: https://en.wikipedia.org/wiki/Machine_epsilon
	const EPSILON: Self;

	/// Smallest finite `f32` value.
	const MIN: Self;

	/// Smallest positive normal `f32` value.
	const MIN_POSITIVE: Self;

	/// Largest finite `f32` value.
	const MAX: Self;

	/// One greater than the minimum possible normal power of 2 exponent.
	const MIN_EXP: i32;

	/// Maximum possible power of 2 exponent.
	const MAX_EXP: i32;

	/// Minimum possible normal power of 10 exponent.
	const MIN_10_EXP: i32;

	/// Maximum possible power of 10 exponent.
	const MAX_10_EXP: i32;

	/// Not a Number (NaN).
	const NAN: Self;

	/// Infinity (∞).
	const INFINITY: Self;

	/// Negative infinity (−∞).
	const NEG_INFINITY: Self;

	/// Archimedes' constant (π)
	const PI: Self;

	/// π/2
	const FRAC_PI_2: Self;

	/// π/3
	const FRAC_PI_3: Self;

	/// π/4
	const FRAC_PI_4: Self;

	/// π/6
	const FRAC_PI_6: Self;

	/// π/8
	const FRAC_PI_8: Self;

	/// 1/π
	const FRAC_1_PI: Self;

	/// 2/π
	const FRAC_2_PI: Self;

	/// 2/sqrt(π)
	const FRAC_2_SQRT_PI: Self;

	/// sqrt(2)
	const SQRT_2: Self;

	/// 1/sqrt(2)
	const FRAC_1_SQRT_2: Self;

	/// Euler’s number (e)
	const E: Self;

	/// log<sub>2</sub>(e)
	const LOG2_E: Self;

	/// log<sub>10</sub>(e)
	const LOG10_E: Self;

	/// ln(2)
	const LN_2: Self;

	/// ln(10)
	const LN_10: Self;

	//  These functions are only available in `libstd`, because they rely on the
	//  system math library `libm` which is not provided by `libcore`.

	/// Returns the largest integer less than or equal to a number.
	#[cfg(feature = "std")]
	fn floor(self) -> Self;

	/// Returns the smallest integer greater than or equal to a number.
	#[cfg(feature = "std")]
	fn ceil(self) -> Self;

	/// Returns the nearest integer to a number. Round half-way cases away from
	/// `0.0`.
	#[cfg(feature = "std")]
	fn round(self) -> Self;

	/// Returns the integer part of a number.
	#[cfg(feature = "std")]
	fn trunc(self) -> Self;

	/// Returns the fractional part of a number.
	#[cfg(feature = "std")]
	fn fract(self) -> Self;

	/// Computes the absolute value of `self`. Returns `NAN` if the
	/// number is `NAN`.
	#[cfg(feature = "std")]
	fn abs(self) -> Self;

	/// Returns a number that represents the sign of `self`.
	///
	/// - `1.0` if the number is positive, `+0.0` or `INFINITY`
	/// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
	/// - `NAN` if the number is `NAN`
	#[cfg(feature = "std")]
	fn signum(self) -> Self;

	/// Returns a number composed of the magnitude of `self` and the sign of
	/// `sign`.
	///
	/// Equal to `self` if the sign of `self` and `sign` are the same, otherwise
	/// equal to `-self`. If `self` is a `NAN`, then a `NAN` with the sign of
	/// `sign` is returned.
	#[cfg(feature = "std")]
	fn copysign(self, sign: Self) -> Self;

	/// Fused multiply-add. Computes `(self * a) + b` with only one rounding
	/// error, yielding a more accurate result than an unfused multiply-add.
	///
	/// Using `mul_add` can be more performant than an unfused multiply-add if
	/// the target architecture has a dedicated `fma` CPU instruction.
	#[cfg(feature = "std")]
	fn mul_add(self, a: Self, b: Self) -> Self;

	/// Calculates Euclidean division, the matching method for `rem_euclid`.
	///
	/// This computes the integer `n` such that
	/// `self = n * rhs + self.rem_euclid(rhs)`.
	/// In other words, the result is `self / rhs` rounded to the integer `n`
	/// such that `self >= n * rhs`.
	#[cfg(feature = "std")]
	fn div_euclid(self, rhs: Self) -> Self;

	/// Calculates the least nonnegative remainder of `self (mod rhs)`.
	///
	/// In particular, the return value `r` satisfies `0.0 <= r < rhs.abs()` in
	/// most cases. However, due to a floating point round-off error it can
	/// result in `r == rhs.abs()`, violating the mathematical definition, if
	/// `self` is much smaller than `rhs.abs()` in magnitude and `self < 0.0`.
	/// This result is not an element of the function's codomain, but it is the
	/// closest floating point number in the real numbers and thus fulfills the
	/// property `self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)`
	/// approximatively.
	#[cfg(feature = "std")]
	fn rem_euclid(self, rhs: Self) -> Self;

	/// Raises a number to an integer power.
	///
	/// Using this function is generally faster than using `powf`
	#[cfg(feature = "std")]
	fn powi(self, n: i32) -> Self;

	/// Raises a number to a floating point power.
	#[cfg(feature = "std")]
	fn powf(self, n: Self) -> Self;

	/// Returns the square root of a number.
	///
	/// Returns NaN if `self` is a negative number.
	#[cfg(feature = "std")]
	fn sqrt(self) -> Self;

	/// Returns `e^(self)`, (the exponential function).
	#[cfg(feature = "std")]
	fn exp(self) -> Self;

	/// Returns `2^(self)`.
	#[cfg(feature = "std")]
	fn exp2(self) -> Self;

	/// Returns the natural logarithm of the number.
	#[cfg(feature = "std")]
	fn ln(self) -> Self;

	/// Returns the logarithm of the number with respect to an arbitrary base.
	///
	/// The result may not be correctly rounded owing to implementation details;
	/// `self.log2()` can produce more accurate results for base 2, and
	/// `self.log10()` can produce more accurate results for base 10.
	#[cfg(feature = "std")]
	fn log(self, base: Self) -> Self;

	/// Returns the base 2 logarithm of the number.
	#[cfg(feature = "std")]
	fn log2(self) -> Self;

	/// Returns the base 10 logarithm of the number.
	#[cfg(feature = "std")]
	fn log10(self) -> Self;

	/// Returns the cubic root of a number.
	#[cfg(feature = "std")]
	fn cbrt(self) -> Self;

	/// Computes the sine of a number (in radians).
	#[cfg(feature = "std")]
	fn hypot(self, other: Self) -> Self;

	/// Computes the sine of a number (in radians).
	#[cfg(feature = "std")]
	fn sin(self) -> Self;

	/// Computes the cosine of a number (in radians).
	#[cfg(feature = "std")]
	fn cos(self) -> Self;

	/// Computes the tangent of a number (in radians).
	#[cfg(feature = "std")]
	fn tan(self) -> Self;

	/// Computes the arcsine of a number. Return value is in radians in the
	/// range [-pi/2, pi/2] or NaN if the number is outside the range [-1, 1].
	#[cfg(feature = "std")]
	fn asin(self) -> Self;

	/// Computes the arccosine of a number. Return value is in radians in the
	/// range [0, pi] or NaN if the number is outside the range [-1, 1].
	#[cfg(feature = "std")]
	fn acos(self) -> Self;

	/// Computes the arctangent of a number. Return value is in radians in the
	/// range [-pi/2, pi/2];
	#[cfg(feature = "std")]
	fn atan(self) -> Self;

	/// Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`)
	/// in radians.
	///
	/// - `x = 0`, `y = 0`: `0`
	/// - `x >= 0`: `arctan(y/x)` -> `[-pi/2, pi/2]`
	/// - `y >= 0`: `arctan(y/x) + pi` -> `(pi/2, pi]`
	/// - `y < 0`: `arctan(y/x) - pi` -> `(-pi, -pi/2)`
	#[cfg(feature = "std")]
	fn atan2(self, other: Self) -> Self;

	/// Simultaneously computes the sine and cosine of the number, `x`. Returns
	/// `(sin(x), cos(x))`.
	#[cfg(feature = "std")]
	fn sin_cos(self) -> (Self, Self);

	/// Returns `e^(self) - 1` in a way that is accurate even if the number is
	/// close to zero.
	#[cfg(feature = "std")]
	fn exp_m1(self) -> Self;

	/// Returns `ln(1+n)` (natural logarithm) more accurately than if the
	/// operations were performed separately.
	#[cfg(feature = "std")]
	fn ln_1p(self) -> Self;

	/// Hyperbolic sine function.
	#[cfg(feature = "std")]
	fn sinh(self) -> Self;

	/// Hyperbolic cosine function.
	#[cfg(feature = "std")]
	fn cosh(self) -> Self;

	/// Hyperbolic tangent function.
	#[cfg(feature = "std")]
	fn tanh(self) -> Self;

	/// Inverse hyperbolic sine function.
	#[cfg(feature = "std")]
	fn asinh(self) -> Self;

	/// Inverse hyperbolic cosine function.
	#[cfg(feature = "std")]
	fn acosh(self) -> Self;

	/// Inverse hyperbolic tangent function.
	#[cfg(feature = "std")]
	fn atanh(self) -> Self;

	/// Returns `true` if this value is `NaN`.
	fn is_nan(self) -> bool;

	/// Returns `true` if this value is positive infinity or negative infinity,
	/// and `false` otherwise.
	fn is_infinite(self) -> bool;

	/// Returns `true` if this number is neither infinite nor `NaN`.
	fn is_finite(self) -> bool;

	/// Returns `true` if the number is neither zero, infinite, [subnormal], or
	/// `NaN`.
	///
	/// [subnormal]: https://en.wixipedia.org/wiki/Denormal_number
	fn is_normal(self) -> bool;

	/// Returns the floating point category of the number. If only one property
	/// is going to be tested, it is generally faster to use the specific
	/// predicate instead.
	fn classify(self) -> FpCategory;

	/// Returns `true` if `self` has a positive sign, including `+0.0`, `NaN`s
	/// with positive sign bit and positive infinity.
	fn is_sign_positive(self) -> bool;

	/// Returns `true` if `self` has a negative sign, including `-0.0`, `NaN`s
	/// with negative sign bit and negative infinity.
	fn is_sign_negative(self) -> bool;

	/// Takes the reciprocal (inverse) of a number, `1/x`.
	fn recip(self) -> Self;

	/// Converts radians to degrees.
	fn to_degrees(self) -> Self;

	/// Converts degrees to radians.
	fn to_radians(self) -> Self;

	/// Returns the maximum of the two numbers.
	fn max(self, other: Self) -> Self;

	/// Returns the minimum of the two numbers.
	fn min(self, other: Self) -> Self;

	/// Raw transmutation to `u32`.
	///
	/// This is currently identical to `transmute::<f32, u32>(self)` on all
	/// platforms.
	///
	/// See `from_bits` for some discussion of the portability of this operation
	/// (there are almost no issues).
	///
	/// Note that this function is distinct from `as` casting, which attempts to
	/// preserve the *numeric* value, and not the bitwise value.
	fn to_bits(self) -> Self::Raw;

	/// Raw transmutation from `u32`.
	///
	/// This is currently identical to `transmute::<u32, f32>(v)` on all
	/// platforms. It turns out this is incredibly portable, for two reasons:
	///
	/// - Floats and Ints have the same endianness on all supported platforms.
	/// - IEEE-754 very precisely specifies the bit layout of floats.
	///
	/// However there is one caveat: prior to the 2008 version of IEEE-754, how
	/// to interpret the NaN signaling bit wasn't actually specified. Most
	/// platforms (notably x86 and ARM) picked the interpretation that was
	/// ultimately standardized in 2008, but some didn't (notably MIPS). As a
	/// result, all signaling NaNs on MIPS are quiet NaNs on x86, and
	/// vice-versa.
	///
	/// Rather than trying to preserve signaling-ness cross-platform, this
	/// implementation favors preserving the exact bits. This means that
	/// any payloads encoded in NaNs will be preserved even if the result of
	/// this method is sent over the network from an x86 machine to a MIPS one.
	///
	/// If the results of this method are only manipulated by the same
	/// architecture that produced them, then there is no portability concern.
	///
	/// If the input isn't NaN, then there is no portability concern.
	///
	/// If you don't care about signalingness (very likely), then there is no
	/// portability concern.
	///
	/// Note that this function is distinct from `as` casting, which attempts to
	/// preserve the *numeric* value, and not the bitwise value.
	fn from_bits(bits: Self::Raw) -> Self;
}

/// Declare that a type is exactly eight bits wide.
pub trait Is8: IsNumber {}

/// Declare that a type is exactly sixteen bits wide.
pub trait Is16: IsNumber {}

/// Declare that a type is exactly thirty-two bits wide.
pub trait Is32: IsNumber {}

/// Declare that a type is exactly sixty-four bits wide.
pub trait Is64: IsNumber {}

/// Declare that a type is exactly one hundred twenty-eight bits wide.
pub trait Is128: IsNumber {}

/// Declare that a type is eight or more bits wide.
pub trait AtLeast8: IsNumber {}

/// Declare that a type is sixteen or more bits wide.
pub trait AtLeast16: IsNumber {}

/// Declare that a type is thirty-two or more bits wide.
pub trait AtLeast32: IsNumber {}

/// Declare that a type is sixty-four or more bits wide.
pub trait AtLeast64: IsNumber {}

/// Declare that a type is one hundred twenty-eight or more bits wide.
pub trait AtLeast128: IsNumber {}

/// Declare that a type is eight or fewer bits wide.
pub trait AtMost8: IsNumber {}

/// Declare that a type is sixteen or fewer bits wide.
pub trait AtMost16: IsNumber {}

/// Declare that a type is thirty-two or fewer bits wide.
pub trait AtMost32: IsNumber {}

/// Declare that a type is sixty-four or fewer bits wide.
pub trait AtMost64: IsNumber {}

/// Declare that a type is one hundred twenty-eight or fewer bits wide.
pub trait AtMost128: IsNumber {}

macro_rules! func {
	( $name:ident ( self $(, $arg:ident : $t:ty)* ) $( -> $ret:ty )? ) => {
		fn $name ( self $(, $arg : $t )* ) $( -> $ret )? { <Self>:: $name ( self $(, $arg )* )}
	};
	( $name:ident ( &self $(, $arg:ident : $t:ty)* ) $( -> $ret:ty )? ) => {
		fn $name ( &self $(, $arg : $t )* ) $( -> $ret )? { <Self>:: $name ( &self $(, $arg )* )}
	};
	( $name:ident ( &mut self $(, $arg:ident : $t:ty)* ) $( -> $ret:ty )? ) => {
		fn $name ( &mut self $(, $arg : $t )* ) $( -> $ret )? { <Self>:: $name ( &mut self $(, $arg )* )}
	};
	( $name:ident ( $($arg:ident : $t:ty),* ) $( -> $ret:ty )? ) => {
		fn $name ( $($arg : $t ),* ) $( -> $ret )? { <Self>:: $name ( $( $arg ),* )}
	};
}

macro_rules! stdfunc {
	( $name:ident ( self $(, $arg:ident : $t:ty)* ) $( -> $ret:ty )? ) => {
		#[cfg(feature = "std")]
		fn $name ( self $(, $arg : $t )* ) $( -> $ret )? { <Self>:: $name ( self $(, $arg )* )}
	};
	( $name:ident ( &self $(, $arg:ident : $t:ty)* ) $( -> $ret:ty )? ) => {
		#[cfg(feature = "std")]
		fn $name ( &self $(, $arg : $t )* ) $( -> $ret )? { <Self>:: $name ( &self $(, $arg )* )}
	};
	( $name:ident ( &mut self $(, $arg:ident : $t:ty)* ) $( -> $ret:ty )? ) => {
		#[cfg(feature = "std")]
		fn $name ( &mut self $(, $arg : $t )* ) $( -> $ret )? { <Self>:: $name ( &mut self $(, $arg )* )}
	};
	( $name:ident ( $($arg:ident : $t:ty),* ) $( -> $ret:ty )? ) => {
		#[cfg(feature = "std")]
		fn $name ( $($arg : $t ),* ) $( -> $ret )? { <Self>:: $name ( $( $arg ),* )}
	};
}

macro_rules! impl_for {
	( IsNumber => $($t:ty),+ $(,)? ) => { $(
		impl IsNumber for $t {
			type Bytes = [u8; core::mem::size_of::<Self>()];

			func!(to_be_bytes(self) -> Self::Bytes);
			func!(to_le_bytes(self) -> Self::Bytes);
			func!(to_ne_bytes(self) -> Self::Bytes);
			func!(from_be_bytes(bytes: Self::Bytes) -> Self);
			func!(from_le_bytes(bytes: Self::Bytes) -> Self);
			func!(from_ne_bytes(bytes: Self::Bytes) -> Self);
		}
	)+ };
	( IsInteger => $($t:ty),+ $(,)? ) => { $(
		impl IsInteger for $t {
			const ZERO: Self = 0;
			const MIN: Self = <Self>::min_value();
			const MAX: Self = <Self>::max_value();

			func!(min_value() -> Self);
			func!(max_value() -> Self);
			func!(from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError>);
			func!(count_ones(self) -> u32);
			func!(count_zeros(self) -> u32);
			func!(leading_zeros(self) -> u32);
			func!(trailing_zeros(self) -> u32);
			func!(rotate_left(self, n: u32) -> Self);
			func!(rotate_right(self, n: u32) -> Self);
			func!(swap_bytes(self) -> Self);
			func!(reverse_bits(self) -> Self);
			func!(from_be(self) -> Self);
			func!(from_le(self) -> Self);
			func!(to_be(self) -> Self);
			func!(to_le(self) -> Self);
			func!(checked_add(self, rhs: Self) -> Option<Self>);
			func!(checked_sub(self, rhs: Self) -> Option<Self>);
			func!(checked_mul(self, rhs: Self) -> Option<Self>);
			func!(checked_div(self, rhs: Self) -> Option<Self>);
			func!(checked_div_euclid(self, rhs: Self) -> Option<Self>);
			func!(checked_rem(self, rhs: Self) -> Option<Self>);
			func!(checked_rem_euclid(self, rhs: Self) -> Option<Self>);
			func!(checked_neg(self) -> Option<Self>);
			func!(checked_shl(self, rhs: u32) -> Option<Self>);
			func!(checked_shr(self, rhs: u32) -> Option<Self>);
			func!(checked_pow(self, rhs: u32) -> Option<Self>);
			func!(saturating_add(self, rhs: Self) -> Self);
			func!(saturating_sub(self, rhs: Self) -> Self);
			func!(saturating_mul(self, rhs: Self) -> Self);
			func!(saturating_pow(self, rhs: u32) -> Self);
			func!(wrapping_add(self, rhs: Self) -> Self);
			func!(wrapping_sub(self, rhs: Self) -> Self);
			func!(wrapping_mul(self, rhs: Self) -> Self);
			func!(wrapping_div(self, rhs: Self) -> Self);
			func!(wrapping_div_euclid(self, rhs: Self) -> Self);
			func!(wrapping_rem(self, rhs: Self) -> Self);
			func!(wrapping_rem_euclid(self, rhs: Self) -> Self);
			func!(wrapping_neg(self) -> Self);
			func!(wrapping_shl(self, rhs: u32) -> Self);
			func!(wrapping_shr(self, rhs: u32) -> Self);
			func!(wrapping_pow(self, rhs: u32) -> Self);
			func!(overflowing_add(self, rhs: Self) -> (Self, bool));
			func!(overflowing_sub(self, rhs: Self) -> (Self, bool));
			func!(overflowing_mul(self, rhs: Self) -> (Self, bool));
			func!(overflowing_div(self, rhs: Self) -> (Self, bool));
			func!(overflowing_div_euclid(self, rhs: Self) -> (Self, bool));
			func!(overflowing_rem(self, rhs: Self) -> (Self, bool));
			func!(overflowing_rem_euclid(self, rhs: Self) -> (Self, bool));
			func!(overflowing_neg(self) -> (Self, bool));
			func!(overflowing_shl(self, rhs: u32) -> (Self, bool));
			func!(overflowing_shr(self, rhs: u32) -> (Self, bool));
			func!(overflowing_pow(self, rhs: u32) -> (Self, bool));
			func!(pow(self, rhs: u32) -> Self);
			func!(div_euclid(self, rhs: Self) -> Self);
			func!(rem_euclid(self, rhs: Self) -> Self);
		}
	)+ };
	( IsSigned => $($t:ty),+ $(,)? ) => { $(
		impl IsSigned for $t {
			func!(checked_abs(self) -> Option<Self>);
			func!(wrapping_abs(self) -> Self);
			func!(overflowing_abs(self) -> (Self, bool));
			func!(abs(self) -> Self);
			func!(signum(self) -> Self);
			func!(is_positive(self) -> bool);
			func!(is_negative(self) -> bool);
		}
	)+ };
	( IsUnsigned => $($t:ty),+ $(,)? ) => { $(
		impl IsUnsigned for $t {
			func!(is_power_of_two(self) -> bool);
			func!(next_power_of_two(self) -> Self);
			func!(checked_next_power_of_two(self) -> Option<Self>);
		}
	)+ };
	( IsFloat => $($t:ident | $u:ty),+ $(,)? ) => { $(
		impl IsFloat for $t {
			type Raw = $u;

			const RADIX: u32 = core::$t::RADIX;
			const MANTISSA_DIGITS: u32 = core::$t::MANTISSA_DIGITS;
			const DIGITS: u32 = core::$t::DIGITS;
			const EPSILON: Self = core::$t::EPSILON;
			const MIN: Self = core::$t::MIN;
			const MIN_POSITIVE: Self = core::$t::MIN_POSITIVE;
			const MAX: Self = core::$t::MAX;
			const MIN_EXP: i32 = core::$t::MIN_EXP;
			const MAX_EXP: i32 = core::$t::MAX_EXP;
			const MIN_10_EXP: i32 = core::$t::MIN_10_EXP;
			const MAX_10_EXP: i32 = core::$t::MAX_10_EXP;
			const NAN: Self = core::$t::NAN;
			const INFINITY: Self = core::$t::INFINITY;
			const NEG_INFINITY: Self = core::$t::NEG_INFINITY;

			const PI: Self = core::$t::consts::PI;
			const FRAC_PI_2: Self = core::$t::consts::FRAC_PI_2;
			const FRAC_PI_3: Self = core::$t::consts::FRAC_PI_3;
			const FRAC_PI_4: Self = core::$t::consts::FRAC_PI_4;
			const FRAC_PI_6: Self = core::$t::consts::FRAC_PI_6;
			const FRAC_PI_8: Self = core::$t::consts::FRAC_PI_8;
			const FRAC_1_PI: Self = core::$t::consts::FRAC_1_PI;
			const FRAC_2_PI: Self = core::$t::consts::FRAC_2_PI;
			const FRAC_2_SQRT_PI: Self = core::$t::consts::FRAC_2_SQRT_PI;
			const SQRT_2: Self = core::$t::consts::SQRT_2;
			const FRAC_1_SQRT_2: Self = core::$t::consts::FRAC_1_SQRT_2;
			const E: Self = core::$t::consts::E;
			const LOG2_E: Self = core::$t::consts::LOG2_E;
			const LOG10_E: Self = core::$t::consts::LOG10_E;
			const LN_2: Self = core::$t::consts::LN_2;
			const LN_10: Self = core::$t::consts::LN_10;

			stdfunc!(floor(self) -> Self);
			stdfunc!(ceil(self) -> Self);
			stdfunc!(round(self) -> Self);
			stdfunc!(trunc(self) -> Self);
			stdfunc!(fract(self) -> Self);
			stdfunc!(abs(self) -> Self);
			stdfunc!(signum(self) -> Self);
			stdfunc!(copysign(self, sign: Self) -> Self);
			stdfunc!(mul_add(self, a: Self, b: Self) -> Self);
			stdfunc!(div_euclid(self, rhs: Self) -> Self);
			stdfunc!(rem_euclid(self, rhs: Self) -> Self);
			stdfunc!(powi(self, n: i32) -> Self);
			stdfunc!(powf(self, n: Self) -> Self);
			stdfunc!(sqrt(self) -> Self);
			stdfunc!(exp(self) -> Self);
			stdfunc!(exp2(self) -> Self);
			stdfunc!(ln(self) -> Self);
			stdfunc!(log(self, base: Self) -> Self);
			stdfunc!(log2(self) -> Self);
			stdfunc!(log10(self) -> Self);
			stdfunc!(cbrt(self) -> Self);
			stdfunc!(hypot(self, other: Self) -> Self);
			stdfunc!(sin(self) -> Self);
			stdfunc!(cos(self) -> Self);
			stdfunc!(tan(self) -> Self);
			stdfunc!(asin(self) -> Self);
			stdfunc!(acos(self) -> Self);
			stdfunc!(atan(self) -> Self);
			stdfunc!(atan2(self, other: Self) -> Self);
			stdfunc!(sin_cos(self) -> (Self, Self));
			stdfunc!(exp_m1(self) -> Self);
			stdfunc!(ln_1p(self) -> Self);
			stdfunc!(sinh(self) -> Self);
			stdfunc!(cosh(self) -> Self);
			stdfunc!(tanh(self) -> Self);
			stdfunc!(asinh(self) -> Self);
			stdfunc!(acosh(self) -> Self);
			stdfunc!(atanh(self) -> Self);

			func!(is_nan(self) -> bool);
			func!(is_infinite(self) -> bool);
			func!(is_finite(self) -> bool);
			func!(is_normal(self) -> bool);
			func!(classify(self) -> FpCategory);
			func!(is_sign_positive(self) -> bool);
			func!(is_sign_negative(self) -> bool);
			func!(recip(self) -> Self);
			func!(to_degrees(self) -> Self);
			func!(to_radians(self) -> Self);
			func!(max(self, other: Self) -> Self);
			func!(min(self, other: Self) -> Self);
			func!(to_bits(self) -> Self::Raw);
			func!(from_bits(bits: Self::Raw) -> Self);
		}
	)+ };
	( $which:ty => $($t:ty),+ $(,)? ) => { $(
		impl $which for $t {}
	)+ };
}

impl_for!(IsNumber => i8, i16, i32, i64, i128, isize, u8, u16, u32, u64, u128, usize, f32, f64);
impl_for!(IsInteger => i8, i16, i32, i64, i128, isize, u8, u16, u32, u64, u128, usize);
impl_for!(IsSigned => i8, i16, i32, i64, i128, isize);
impl_for!(IsUnsigned => u8, u16, u32, u64, u128, usize);
impl_for!(IsFloat => f32 | u32, f64 | u64);

impl_for!(Is8 => i8, u8);
impl_for!(Is16 => i16, u16);
impl_for!(Is32 => i32, u32, f32);
impl_for!(Is64 => i64, u64, f64);
impl_for!(Is128 => i128, u128);

#[cfg(target_pointer_width = "16")]
impl_for!(Is16 => isize, usize);

#[cfg(target_pointer_width = "32")]
impl_for!(Is32 => isize, usize);

#[cfg(target_pointer_width = "64")]
impl_for!(Is64 => isize, usize);

impl_for!(AtLeast8 => i8, i16, i32, i64, i128, isize, u8, u16, u32, u64, u128, usize, f32, f64);
impl_for!(AtLeast16 => i16, i32, i64, i128, u16, u32, u64, u128, f32, f64);
impl_for!(AtLeast32 => i32, i64, i128, u32, u64, u128, f32, f64);
impl_for!(AtLeast64 => i64, i128, u64, u128, f64);
impl_for!(AtLeast128 => i128, u128);

#[cfg(any(
	target_pointer_width = "16",
	target_pointer_width = "32",
	target_pointer_width = "64"
))]
impl_for!(AtLeast16 => isize, usize);

#[cfg(any(target_pointer_width = "32", target_pointer_width = "64"))]
impl_for!(AtLeast32 => isize, usize);

#[cfg(target_pointer_width = "64")]
impl_for!(AtLeast64 => isize, usize);

impl_for!(AtMost8 => i8, u8);
impl_for!(AtMost16 => i8, i16, u8, u16);
impl_for!(AtMost32 => i8, i16, i32, u8, u16, u32, f32);
impl_for!(AtMost64 => i8, i16, i32, i64, isize, u8, u16, u32, u64, usize, f32, f64);
impl_for!(AtMost128 => i8, i16, i32, i64, i128, isize, u8, u16, u32, u64, u128, usize, f32, f64);

#[cfg(target_pointer_width = "16")]
impl_for!(AtMost16 => isize, usize);

#[cfg(any(target_pointer_width = "16", target_pointer_width = "32"))]
impl_for!(AtMost32 => isize, usize);

#[cfg(test)]
mod tests {
	use super::*;
	use static_assertions::*;

	assert_impl_all!(i8: IsInteger, IsSigned, Is8);
	assert_impl_all!(i16: IsInteger, IsSigned, Is16);
	assert_impl_all!(i32: IsInteger, IsSigned, Is32);
	assert_impl_all!(i64: IsInteger, IsSigned, Is64);
	assert_impl_all!(i128: IsInteger, IsSigned, Is128);
	assert_impl_all!(isize: IsInteger, IsSigned);

	assert_impl_all!(u8: IsInteger, IsUnsigned, Is8);
	assert_impl_all!(u16: IsInteger, IsUnsigned, Is16);
	assert_impl_all!(u32: IsInteger, IsUnsigned, Is32);
	assert_impl_all!(u64: IsInteger, IsUnsigned, Is64);
	assert_impl_all!(u128: IsInteger, IsUnsigned, Is128);
	assert_impl_all!(usize: IsInteger, IsUnsigned);

	assert_impl_all!(f32: IsFloat, Is32);
	assert_impl_all!(f64: IsFloat, Is64);
}
===== END OF /home/matt/InterCooperative-Network/vendor/funty/src/lib.rs =====

===== START OF /home/matt/InterCooperative-Network/vendor/funty/tests/readme.rs =====
use funty::IsUnsigned;

#[test]
fn readme() {
	fn invert_some_bits<T: IsUnsigned>(num: T) -> T {
		let mask = (!T::ZERO).wrapping_shl(2).wrapping_shr(4).wrapping_shl(2);
		num ^ mask
	}
	assert_eq!(invert_some_bits(!0u8), 0b1100_0011u8);
}
===== END OF /home/matt/InterCooperative-Network/vendor/funty/tests/readme.rs =====

===== START OF /home/matt/InterCooperative-Network/Cargo.toml =====
[workspace]
members = [
    "crates/icn_common",
    "crates/icn_blockchain",
    "crates/icn_consensus",
    "crates/icn_currency",
    "crates/icn_governance",
    "crates/icn_identity",
    "crates/icn_network",
    "crates/icn_sharding",
    "crates/icn_storage",
    "crates/icn_vm",
    "crates/icn_api",
    "crates/icn_testnet",
    "crates/icn_core",
    "crates/icn_zkp",
    "crates/icn_smart_contracts",
    "crates/icn_reputation",
    "crates/icn_market",
    "crates/icn_incentives",
    "crates/icn_language"
]

resolver = "2"

[workspace.dependencies]
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
chrono = { version = "0.4", features = ["serde"] }
thiserror = "1.0"
log = "0.4"
env_logger = "0.9"

[patch.crates-io]
bitvec = { version = "0.19.5" }
funty = { version = "1.1.0" }===== END OF /home/matt/InterCooperative-Network/Cargo.toml =====

